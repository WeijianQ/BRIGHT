[
    "Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.\n\n**Example 1:**\n\n**Input:** height = \\[0,1,0,2,1,0,1,3,2,1,2,1\\]\n**Output:** 6\n**Explanation:** The above elevation map (black section) is represented by array \\[0,1,0,2,1,0,1,3,2,1,2,1\\]. In this case, 6 units of rain water (blue section) are being trapped.\n\n**Example 2:**\n\n**Input:** height = \\[4,2,0,3,2,5\\]\n**Output:** 9\n\n**Constraints:**\n\n*   `n == height.length`\n*   `1 <= n <= 2 * 104`\n*   `0 <= height[i] <= 105`",
    "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _all distinct solutions to the **n-queens puzzle**_. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** \\[\\[ \".Q.. \", \"...Q \", \"Q... \", \"..Q. \"\\],\\[ \"..Q. \", \"Q... \", \"...Q \", \".Q.. \"\\]\\]\n**Explanation:** There exist two distinct solutions to the 4-queens puzzle as shown above\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** \\[\\[ \"Q \"\\]\\]\n\n**Constraints:**\n\n*   `1 <= n <= 9`",
    "The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return _the number of distinct solutions to the **n-queens puzzle**_.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** There are two distinct solutions to the 4-queens puzzle as shown.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 9`",
    "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is `1`, return _the area of the largest rectangle in the histogram_.\n\n**Example 1:**\n\n**Input:** heights = \\[2,1,5,6,2,3\\]\n**Output:** 10\n**Explanation:** The above is a histogram where width of each bar is 1.\nThe largest rectangle is shown in the red area, which has an area = 10 units.\n\n**Example 2:**\n\n**Input:** heights = \\[2,4\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= heights.length <= 105`\n*   `0 <= heights[i] <= 104`",
    "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane, return _the maximum number of points that lie on the same straight line_.\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\]\n**Output:** 3\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,1\\],\\[3,2\\],\\[5,3\\],\\[4,1\\],\\[2,3\\],\\[1,4\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `1 <= points.length <= 300`\n*   `points[i].length == 2`\n*   `-104 <= xi, yi <= 104`\n*   All the `points` are **unique**.",
    "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** true\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\n\n**Example 2:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\],\\[0,1\\]\\]\n**Output:** false\n**Explanation:** There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= 5000`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   All the pairs prerequisites\\[i\\] are **unique**.",
    "There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you **must** take course `bi` first if you want to take course `ai`.\n\n*   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn _the ordering of courses you should take to finish all courses_. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array**.\n\n**Example 1:**\n\n**Input:** numCourses = 2, prerequisites = \\[\\[1,0\\]\\]\n**Output:** \\[0,1\\]\n**Explanation:** There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \\[0,1\\].\n\n**Example 2:**\n\n**Input:** numCourses = 4, prerequisites = \\[\\[1,0\\],\\[2,0\\],\\[3,1\\],\\[3,2\\]\\]\n**Output:** \\[0,2,1,3\\]\n**Explanation:** There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is \\[0,1,2,3\\]. Another correct ordering is \\[0,2,1,3\\].\n\n**Example 3:**\n\n**Input:** numCourses = 1, prerequisites = \\[\\]\n**Output:** \\[0\\]\n\n**Constraints:**\n\n*   `1 <= numCourses <= 2000`\n*   `0 <= prerequisites.length <= numCourses * (numCourses - 1)`\n*   `prerequisites[i].length == 2`\n*   `0 <= ai, bi < numCourses`\n*   `ai != bi`\n*   All the pairs `[ai, bi]` are **distinct**.",
    "A city's **skyline** is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return _the **skyline** formed by these buildings collectively_.\n\nThe geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:\n\n*   `lefti` is the x coordinate of the left edge of the `ith` building.\n*   `righti` is the x coordinate of the right edge of the `ith` building.\n*   `heighti` is the height of the `ith` building.\n\nYou may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.\n\nThe **skyline** should be represented as a list of \"key points \" **sorted by their x-coordinate** in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.\n\n**Note:** There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`\n\n**Example 1:**\n\n**Input:** buildings = \\[\\[2,9,10\\],\\[3,7,15\\],\\[5,12,12\\],\\[15,20,10\\],\\[19,24,8\\]\\]\n**Output:** \\[\\[2,10\\],\\[3,15\\],\\[7,12\\],\\[12,0\\],\\[15,10\\],\\[20,8\\],\\[24,0\\]\\]\n**Explanation:**\nFigure A shows the buildings of the input.\nFigure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.\n\n**Example 2:**\n\n**Input:** buildings = \\[\\[0,2,3\\],\\[2,5,3\\]\\]\n**Output:** \\[\\[0,3\\],\\[5,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= buildings.length <= 104`\n*   `0 <= lefti < righti <= 231 - 1`\n*   `1 <= heighti <= 231 - 1`\n*   `buildings` is sorted by `lefti` in non-decreasing order.",
    "Convert a non-negative integer `num` to its English words representation.\n\n**Example 1:**\n\n**Input:** num = 123\n**Output:**  \"One Hundred Twenty Three \"\n\n**Example 2:**\n\n**Input:** num = 12345\n**Output:**  \"Twelve Thousand Three Hundred Forty Five \"\n\n**Example 3:**\n\n**Input:** num = 1234567\n**Output:**  \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven \"\n\n**Constraints:**\n\n*   `0 <= num <= 231 - 1`",
    "Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `ith` paper, return _the researcher's h-index_.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): The h-index is defined as the maximum value of `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.\n\n**Example 1:**\n\n**Input:** citations = \\[3,0,6,1,5\\]\n**Output:** 3\n**Explanation:** \\[3,0,6,1,5\\] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\n\n**Example 2:**\n\n**Input:** citations = \\[1,3,1\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `n == citations.length`\n*   `1 <= n <= 5000`\n*   `0 <= citations[i] <= 1000`",
    "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n\n**Example 1:**\n\n**Input:** n = 5, bad = 4\n**Output:** 4\n**Explanation:**\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\n\n**Example 2:**\n\n**Input:** n = 1, bad = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= bad <= n <= 231 - 1`",
    "According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): \"The **Game of Life**, also known simply as **Life**, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. \"\n\nThe board is made up of an `m x n` grid of cells, where each cell has an initial state: **live** (represented by a `1`) or **dead** (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):\n\n1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.\n2.  Any live cell with two or three live neighbors lives on to the next generation.\n3.  Any live cell with more than three live neighbors dies, as if by over-population.\n4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nThe next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.\n\n**Example 1:**\n\n**Input:** board = \\[\\[0,1,0\\],\\[0,0,1\\],\\[1,1,1\\],\\[0,0,0\\]\\]\n**Output:** \\[\\[0,0,0\\],\\[1,0,1\\],\\[0,1,1\\],\\[0,1,0\\]\\]\n\n**Example 2:**\n\n**Input:** board = \\[\\[1,1\\],\\[1,0\\]\\]\n**Output:** \\[\\[1,1\\],\\[1,1\\]\\]\n\n**Constraints:**\n\n*   `m == board.length`\n*   `n == board[i].length`\n*   `1 <= m, n <= 25`\n*   `board[i][j]` is `0` or `1`.\n\n**Follow up:**\n\n*   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.\n*   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?",
    "You are playing the **[Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows)** game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\n*   The number of \"bulls \", which are digits in the guess that are in the correct position.\n*   The number of \"cows \", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\n\nGiven the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.\n\nThe hint should be formatted as `\"xAyB \"`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.\n\n**Example 1:**\n\n**Input:** secret =  \"1807 \", guess =  \"7810 \"\n**Output:**  \"1A3B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1807 \"\n  |\n \"7810 \"\n\n**Example 2:**\n\n**Input:** secret =  \"1123 \", guess =  \"0111 \"\n**Output:**  \"1A1B \"\n**Explanation:** Bulls are connected with a '|' and cows are underlined:\n \"1123 \"         \"1123 \"\n  |      or     |\n \"0111 \"         \"0111 \"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n\n**Constraints:**\n\n*   `1 <= secret.length, guess.length <= 1000`\n*   `secret.length == guess.length`\n*   `secret` and `guess` consist of digits only.",
    "A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.\n\nGiven a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called **minimum height trees** (MHTs).\n\nReturn _a list of all **MHTs'** root labels_. You can return the answer in **any order**.\n\nThe **height** of a rooted tree is the number of edges on the longest downward path between the root and a leaf.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[1,0\\],\\[1,2\\],\\[1,3\\]\\]\n**Output:** \\[1\\]\n**Explanation:** As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.\n\n**Example 2:**\n\n**Input:** n = 6, edges = \\[\\[3,0\\],\\[3,1\\],\\[3,2\\],\\[3,4\\],\\[5,4\\]\\]\n**Output:** \\[3,4\\]\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `edges.length == n - 1`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   All the pairs `(ai, bi)` are distinct.\n*   The given input is **guaranteed** to be a tree and there will be **no repeated** edges.",
    "There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.\n\nReturn _the number of bulbs that are on after `n` rounds_.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 1\n**Explanation:** At first, the three bulbs are \\[off, off, off\\].\nAfter the first round, the three bulbs are \\[on, on, on\\].\nAfter the second round, the three bulbs are \\[on, off, on\\].\nAfter the third round, the three bulbs are \\[on, off, off\\]. \nSo you should return 1 because there is only one bulb is on.\n\n**Example 2:**\n\n**Input:** n = 0\n**Output:** 0\n\n**Example 3:**\n\n**Input:** n = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `0 <= n <= 109`",
    "Given an `m x n` integers `matrix`, return _the length of the longest increasing path in_ `matrix`.\n\nFrom each cell, you can either move in four directions: left, right, up, or down. You **may not** move **diagonally** or move **outside the boundary** (i.e., wrap-around is not allowed).\n\n**Example 1:**\n\n**Input:** matrix = \\[\\[9,9,4\\],\\[6,6,8\\],\\[2,1,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[1, 2, 6, 9]`.\n\n**Example 2:**\n\n**Input:** matrix = \\[\\[3,4,5\\],\\[3,2,6\\],\\[2,2,1\\]\\]\n**Output:** 4\n**Explanation:** The longest increasing path is `[3, 4, 5, 6]`. Moving diagonally is not allowed.\n\n**Example 3:**\n\n**Input:** matrix = \\[\\[1\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `m == matrix.length`\n*   `n == matrix[i].length`\n*   `1 <= m, n <= 200`\n*   `0 <= matrix[i][j] <= 231 - 1`",
    "You are given a list of airline `tickets` where `tickets[i] = [fromi, toi]` represent the departure and the arrival airports of one flight. Reconstruct the itinerary in order and return it.\n\nAll of the tickets belong to a man who departs from `\"JFK \"`, thus, the itinerary must begin with `\"JFK \"`. If there are multiple valid itineraries, you should return the itinerary that has the smallest lexical order when read as a single string.\n\n*   For example, the itinerary `[ \"JFK \", \"LGA \"]` has a smaller lexical order than `[ \"JFK \", \"LGB \"]`.\n\nYou may assume all tickets form at least one valid itinerary. You must use all the tickets once and only once.\n\n**Example 1:**\n\n**Input:** tickets = \\[\\[ \"MUC \", \"LHR \"\\],\\[ \"JFK \", \"MUC \"\\],\\[ \"SFO \", \"SJC \"\\],\\[ \"LHR \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"MUC \", \"LHR \", \"SFO \", \"SJC \"\\]\n\n**Example 2:**\n\n**Input:** tickets = \\[\\[ \"JFK \", \"SFO \"\\],\\[ \"JFK \", \"ATL \"\\],\\[ \"SFO \", \"ATL \"\\],\\[ \"ATL \", \"JFK \"\\],\\[ \"ATL \", \"SFO \"\\]\\]\n**Output:** \\[ \"JFK \", \"ATL \", \"JFK \", \"SFO \", \"ATL \", \"SFO \"\\]\n**Explanation:** Another possible reconstruction is \\[ \"JFK \", \"SFO \", \"ATL \", \"JFK \", \"ATL \", \"SFO \"\\] but it is larger in lexical order.\n\n**Constraints:**\n\n*   `1 <= tickets.length <= 300`\n*   `tickets[i].length == 2`\n*   `fromi.length == 3`\n*   `toi.length == 3`\n*   `fromi` and `toi` consist of uppercase English letters.\n*   `fromi != toi`",
    "We are playing the Guess Game. The game is as follows:\n\nI pick a number from `1` to `n`. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API `int guess(int num)`, which returns three possible results:\n\n*   `-1`: Your guess is higher than the number I picked (i.e. `num > pick`).\n*   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).\n*   `0`: your guess is equal to the number I picked (i.e. `num == pick`).\n\nReturn _the number that I picked_.\n\n**Example 1:**\n\n**Input:** n = 10, pick = 6\n**Output:** 6\n\n**Example 2:**\n\n**Input:** n = 1, pick = 1\n**Output:** 1\n\n**Example 3:**\n\n**Input:** n = 2, pick = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= n <= 231 - 1`\n*   `1 <= pick <= n`",
    "We are playing the Guessing Game. The game will work as follows:\n\n1.  I pick a number between `1` and `n`.\n2.  You guess a number.\n3.  If you guess the right number, **you win the game**.\n4.  If you guess the wrong number, then I will tell you whether the number I picked is **higher or lower**, and you will continue guessing.\n5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, **you lose the game**.\n\nGiven a particular `n`, return _the minimum amount of money you need to **guarantee a win regardless of what number I pick**_.\n\n**Example 1:**\n\n**Input:** n = 10\n**Output:** 16\n**Explanation:** The winning strategy is as follows:\n- The range is \\[1,10\\]. Guess 7.\n    - If this is my number, your total is $0. Otherwise, you pay $7.\n    - If my number is higher, the range is \\[8,10\\]. Guess 9.\n        - If this is my number, your total is $7. Otherwise, you pay $9.\n        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.\n        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.\n    - If my number is lower, the range is \\[1,6\\]. Guess 3.\n        - If this is my number, your total is $7. Otherwise, you pay $3.\n        - If my number is higher, the range is \\[4,6\\]. Guess 5.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.\n            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.\n            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.\n        - If my number is lower, the range is \\[1,2\\]. Guess 1.\n            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.\n            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.\nThe worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.\n\n**Example 2:**\n\n**Input:** n = 1\n**Output:** 0\n**Explanation:** There is only one possible number, so you can guess 1 and not have to pay anything.\n\n**Example 3:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** There are two possible numbers, 1 and 2.\n- Guess 1.\n    - If this is my number, your total is $0. Otherwise, you pay $1.\n    - If my number is higher, it must be 2. Guess 2. Your total is $1.\nThe worst case is that you pay $1.\n\n**Constraints:**\n\n*   `1 <= n <= 200`",
    "A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.\n\n*   For example, the below binary watch reads `\"4:51 \"`.\n\nGiven an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in **any order**.\n\nThe hour must not contain a leading zero.\n\n*   For example, `\"01:00 \"` is not valid. It should be `\"1:00 \"`.\n\nThe minute must be consist of two digits and may contain a leading zero.\n\n*   For example, `\"10:2 \"` is not valid. It should be `\"10:02 \"`.\n\n**Example 1:**\n\n**Input:** turnedOn = 1\n**Output:** \\[\"0:01\",\"0:02\",\"0:04\",\"0:08\",\"0:16\",\"0:32\",\"1:00\",\"2:00\",\"4:00\",\"8:00\"\\]\n\n**Example 2:**\n\n**Input:** turnedOn = 9\n**Output:** \\[\\]\n\n**Constraints:**\n\n*   `0 <= turnedOn <= 10`",
    "You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with **exactly** `ki` other people in front who have a height greater than or equal to `hi`.\n\nReconstruct and return _the queue that is represented by the input array_ `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).\n\n**Example 1:**\n\n**Input:** people = \\[\\[7,0\\],\\[4,4\\],\\[7,1\\],\\[5,0\\],\\[6,1\\],\\[5,2\\]\\]\n**Output:** \\[\\[5,0\\],\\[7,0\\],\\[5,2\\],\\[6,1\\],\\[4,4\\],\\[7,1\\]\\]\n**Explanation:**\nPerson 0 has height 5 with no other people taller or the same height in front.\nPerson 1 has height 7 with no other people taller or the same height in front.\nPerson 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.\nPerson 3 has height 6 with one person taller or the same height in front, which is person 1.\nPerson 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.\nPerson 5 has height 7 with one person taller or the same height in front, which is person 1.\nHence \\[\\[5,0\\],\\[7,0\\],\\[5,2\\],\\[6,1\\],\\[4,4\\],\\[7,1\\]\\] is the reconstructed queue.\n\n**Example 2:**\n\n**Input:** people = \\[\\[6,0\\],\\[5,0\\],\\[4,0\\],\\[3,2\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** \\[\\[4,0\\],\\[5,0\\],\\[2,2\\],\\[3,2\\],\\[1,4\\],\\[6,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= people.length <= 2000`\n*   `0 <= hi <= 106`\n*   `0 <= ki < people.length`\n*   It is guaranteed that the queue can be reconstructed.",
    "You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes \", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,0,0\\],\\[1,1,1,0\\],\\[0,1,0,0\\],\\[1,1,0,0\\]\\]\n**Output:** 16\n**Explanation:** The perimeter is the 16 yellow stripes in the image above.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\]\\]\n**Output:** 4\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,0\\]\\]\n**Output:** 4\n\n**Constraints:**\n\n*   `row == grid.length`\n*   `col == grid[i].length`\n*   `1 <= row, col <= 100`\n*   `grid[i][j]` is `0` or `1`.\n*   There is exactly one island in `grid`.",
    "In the \"100 game \" two players take turns adding, to a running total, any integer from `1` to `10`. The player who first causes the running total to **reach or exceed** 100 wins.\n\nWhat if we change the game so that players **cannot** re-use integers?\n\nFor example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n\nGiven two integers `maxChoosableInteger` and `desiredTotal`, return `true` if the first player to move can force a win, otherwise, return `false`. Assume both players play **optimally**.\n\n**Example 1:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 11\n**Output:** false\n**Explanation:**\nNo matter which integer the first player choose, the first player will lose.\nThe first player can choose an integer from 1 up to 10.\nIf the first player choose 1, the second player can only choose integers from 2 up to 10.\nThe second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\nSame with other integers chosen by the first player, the second player will always win.\n\n**Example 2:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 0\n**Output:** true\n\n**Example 3:**\n\n**Input:** maxChoosableInteger = 10, desiredTotal = 1\n**Output:** true\n\n**Constraints:**\n\n*   `1 <= maxChoosableInteger <= 20`\n*   `0 <= desiredTotal <= 300`",
    "You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use **all the matchsticks** to make one square. You **should not break** any stick, but you can link them up, and each matchstick must be used **exactly one time**.\n\nReturn `true` if you can make this square and `false` otherwise.\n\n**Example 1:**\n\n**Input:** matchsticks = \\[1,1,2,2,2\\]\n**Output:** true\n**Explanation:** You can form a square with length 2, one side of the square came two sticks with length 1.\n\n**Example 2:**\n\n**Input:** matchsticks = \\[3,3,3,3,4\\]\n**Output:** false\n**Explanation:** You cannot find a way to form a square with all the matchsticks.\n\n**Constraints:**\n\n*   `1 <= matchsticks.length <= 15`\n*   `1 <= matchsticks[i] <= 108`",
    "You are given an integer array `nums`. Two players are playing a game with this array: player 1 and player 2.\n\nPlayer 1 and player 2 take turns, with player 1 starting first. Both players start the game with a score of `0`. At each turn, the player takes one of the numbers from either end of the array (i.e., `nums[0]` or `nums[nums.length - 1]`) which reduces the size of the array by `1`. The player adds the chosen number to their score. The game ends when there are no more elements in the array.\n\nReturn `true` if Player 1 can win the game. If the scores of both players are equal, then player 1 is still the winner, and you should also return `true`. You may assume that both players are playing optimally.\n\n**Example 1:**\n\n**Input:** nums = \\[1,5,2\\]\n**Output:** false\n**Explanation:** Initially, player 1 can choose between 1 and 2. \nIf he chooses 2 (or 1), then player 2 can choose from 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). \nSo, final score of player 1 is 1 + 2 = 3, and player 2 is 5. \nHence, player 1 will never be the winner and you need to return false.\n\n**Example 2:**\n\n**Input:** nums = \\[1,5,233,7\\]\n**Output:** true\n**Explanation:** Player 1 first chooses 1. Then player 2 has to choose between 5 and 7. No matter which number player 2 choose, player 1 can choose 233.\nFinally, player 1 has more score (234) than player 2 (12), so you need to return True representing player1 can win.\n\n**Constraints:**\n\n*   `1 <= nums.length <= 20`\n*   `0 <= nums[i] <= 107`",
    "Suppose LeetCode will start its **IPO** soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the **IPO**. Since it has limited resources, it can only finish at most `k` distinct projects before the **IPO**. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.\n\nYou are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.\n\nInitially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.\n\nPick a list of **at most** `k` distinct projects from given projects to **maximize your final capital**, and return _the final maximized capital_.\n\nThe answer is guaranteed to fit in a 32-bit signed integer.\n\n**Example 1:**\n\n**Input:** k = 2, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,1\\]\n**Output:** 4\n**Explanation:** Since your initial capital is 0, you can only start the project indexed 0.\nAfter finishing it you will obtain profit 1 and your capital becomes 1.\nWith capital 1, you can either start the project indexed 1 or the project indexed 2.\nSince you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.\nTherefore, output the final maximized capital, which is 0 + 1 + 3 = 4.\n\n**Example 2:**\n\n**Input:** k = 3, w = 0, profits = \\[1,2,3\\], capital = \\[0,1,2\\]\n**Output:** 6\n\n**Constraints:**\n\n*   `1 <= k <= 105`\n*   `0 <= w <= 109`\n*   `n == profits.length`\n*   `n == capital.length`\n*   `1 <= n <= 105`\n*   `0 <= profits[i] <= 104`\n*   `0 <= capital[i] <= 109`",
    "The **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is,\n\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.\n\nGiven `n`, calculate `F(n)`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** 1\n**Explanation:** F(2) = F(1) + F(0) = 1 + 0 = 1.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 2\n**Explanation:** F(3) = F(2) + F(1) = 1 + 1 = 2.\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** 3\n**Explanation:** F(4) = F(3) + F(2) = 2 + 1 = 3.\n\n**Constraints:**\n\n*   `0 <= n <= 30`",
    "You are given an array of `n` pairs `pairs` where `pairs[i] = [lefti, righti]` and `lefti < righti`.\n\nA pair `p2 = [c, d]` **follows** a pair `p1 = [a, b]` if `b < c`. A **chain** of pairs can be formed in this fashion.\n\nReturn _the length longest chain which can be formed_.\n\nYou do not need to use up all the given intervals. You can select pairs in any order.\n\n**Example 1:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\]\\]\n**Output:** 2\n**Explanation:** The longest chain is \\[1,2\\] -> \\[3,4\\].\n\n**Example 2:**\n\n**Input:** pairs = \\[\\[1,2\\],\\[7,8\\],\\[4,5\\]\\]\n**Output:** 3\n**Explanation:** The longest chain is \\[1,2\\] -> \\[4,5\\] -> \\[7,8\\].\n\n**Constraints:**\n\n*   `n == pairs.length`\n*   `1 <= n <= 1000`\n*   `-1000 <= lefti < righti <= 1000`",
    "In the world of Dota2, there are two parties: the Radiant and the Dire.\n\nThe Dota2 senate consists of senators coming from two parties. Now the Senate wants to decide on a change in the Dota2 game. The voting for this change is a round-based procedure. In each round, each senator can exercise **one** of the two rights:\n\n*   **Ban one senator's right:** A senator can make another senator lose all his rights in this and all the following rounds.\n*   **Announce the victory:** If this senator found the senators who still have rights to vote are all from the same party, he can announce the victory and decide on the change in the game.\n\nGiven a string `senate` representing each senator's party belonging. The character `'R'` and `'D'` represent the Radiant party and the Dire party. Then if there are `n` senators, the size of the given string will be `n`.\n\nThe round-based procedure starts from the first senator to the last senator in the given order. This procedure will last until the end of voting. All the senators who have lost their rights will be skipped during the procedure.\n\nSuppose every senator is smart enough and will play the best strategy for his own party. Predict which party will finally announce the victory and change the Dota2 game. The output should be `\"Radiant \"` or `\"Dire \"`.\n\n**Example 1:**\n\n**Input:** senate =  \"RD \"\n**Output:**  \"Radiant \"\n**Explanation:** \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd in round 2, the first senator can just announce the victory since he is the only guy in the senate who can vote.\n\n**Example 2:**\n\n**Input:** senate =  \"RDD \"\n**Output:**  \"Dire \"\n**Explanation:** \nThe first senator comes from Radiant and he can just ban the next senator's right in round 1. \nAnd the second senator can't exercise any rights anymore since his right has been banned. \nAnd the third senator comes from Dire and he can ban the first senator's right in round 1. \nAnd in round 2, the third senator can just announce the victory since he is the only guy in the senate who can vote.\n\n**Constraints:**\n\n*   `n == senate.length`\n*   `1 <= n <= 104`\n*   `senate[i]` is either `'R'` or `'D'`.",
    "There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot **ends up at** `(0, 0)` after it completes its moves.\n\nYou are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).\n\nReturn `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.\n\n**Note**: The way that the robot is \"facing \" is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n\n**Example 1:**\n\n**Input:** moves =  \"UD \"\n**Output:** true\n**Explanation**: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n**Example 2:**\n\n**Input:** moves =  \"LL \"\n**Output:** false\n**Explanation**: The robot moves left twice. It ends up two  \"moves \" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n\n**Constraints:**\n\n*   `1 <= moves.length <= 2 * 104`\n*   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.",
    "Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i * j` (**1-indexed**).\n\nGiven three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_.\n\n**Example 1:**\n\n**Input:** m = 3, n = 3, k = 5\n**Output:** 3\n**Explanation:** The 5th smallest number is 3.\n\n**Example 2:**\n\n**Input:** m = 2, n = 3, k = 6\n**Output:** 6\n**Explanation:** The 6th smallest number is 6.\n\n**Constraints:**\n\n*   `1 <= m, n <= 3 * 104`\n*   `1 <= k <= m * n`",
    "There is a room with `n` bulbs labeled from `1` to `n` that all are turned on initially, and **four buttons** on the wall. Each of the four buttons has a different functionality where:\n\n*   **Button 1:** Flips the status of all the bulbs.\n*   **Button 2:** Flips the status of all the bulbs with even labels (i.e., `2, 4, ...`).\n*   **Button 3:** Flips the status of all the bulbs with odd labels (i.e., `1, 3, ...`).\n*   **Button 4:** Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...` (i.e., `1, 4, 7, 10, ...`).\n\nYou must make **exactly** `presses` button presses in total. For each press, you may pick **any** of the four buttons to press.\n\nGiven the two integers `n` and `presses`, return _the number of **different possible statuses** after performing all_ `presses` _button presses_.\n\n**Example 1:**\n\n**Input:** n = 1, presses = 1\n**Output:** 2\n**Explanation:** Status can be:\n- \\[off\\] by pressing button 1\n- \\[on\\] by pressing button 2\n\n**Example 2:**\n\n**Input:** n = 2, presses = 1\n**Output:** 3\n**Explanation:** Status can be:\n- \\[off, off\\] by pressing button 1\n- \\[on, off\\] by pressing button 2\n- \\[off, on\\] by pressing button 3\n\n**Example 3:**\n\n**Input:** n = 3, presses = 1\n**Output:** 4\n**Explanation:** Status can be:\n- \\[off, off, off\\] by pressing button 1\n- \\[off, on, off\\] by pressing button 2\n- \\[on, off, on\\] by pressing button 3\n- \\[off, on, on\\] by pressing button 4\n\n**Constraints:**\n\n*   `1 <= n <= 1000`\n*   `0 <= presses <= 1000`",
    "You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings `operations`, where `operations[i]` is the `ith` operation you must apply to the record and is one of the following:\n\n*   An integer `x`.\n    *   Record a new score of `x`.\n*   `'+'`.\n    *   Record a new score that is the sum of the previous two scores.\n*   `'D'`.\n    *   Record a new score that is the double of the previous score.\n*   `'C'`.\n    *   Invalidate the previous score, removing it from the record.\n\nReturn _the sum of all the scores on the record after applying all the operations_.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a **32-bit** integer and that all operations are valid.\n\n**Example 1:**\n\n**Input:** ops = \\[ \"5 \", \"2 \", \"C \", \"D \", \"+ \"\\]\n**Output:** 30\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"2 \" - Add 2 to the record, record is now \\[5, 2\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5\\].\n \"D \" - Add 2 \\* 5 = 10 to the record, record is now \\[5, 10\\].\n \"+ \" - Add 5 + 10 = 15 to the record, record is now \\[5, 10, 15\\].\nThe total sum is 5 + 10 + 15 = 30.\n\n**Example 2:**\n\n**Input:** ops = \\[ \"5 \", \"-2 \", \"4 \", \"C \", \"D \", \"9 \", \"+ \", \"+ \"\\]\n**Output:** 27\n**Explanation:**\n \"5 \" - Add 5 to the record, record is now \\[5\\].\n \"-2 \" - Add -2 to the record, record is now \\[5, -2\\].\n \"4 \" - Add 4 to the record, record is now \\[5, -2, 4\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[5, -2\\].\n \"D \" - Add 2 \\* -2 = -4 to the record, record is now \\[5, -2, -4\\].\n \"9 \" - Add 9 to the record, record is now \\[5, -2, -4, 9\\].\n \"+ \" - Add -4 + 9 = 5 to the record, record is now \\[5, -2, -4, 9, 5\\].\n \"+ \" - Add 9 + 5 = 14 to the record, record is now \\[5, -2, -4, 9, 5, 14\\].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n**Example 3:**\n\n**Input:** ops = \\[ \"1 \", \"C \"\\]\n**Output:** 0\n**Explanation:**\n \"1 \" - Add 1 to the record, record is now \\[1\\].\n \"C \" - Invalidate and remove the previous score, record is now \\[\\].\nSince the record is empty, the total sum is 0.\n\n**Constraints:**\n\n*   `1 <= operations.length <= 1000`\n*   `operations[i]` is `\"C \"`, `\"D \"`, `\"+ \"`, or a string representing an integer in the range `[-3 * 104, 3 * 104]`.\n*   For operation `\"+ \"`, there will always be at least two previous scores on the record.\n*   For operations `\"C \"` and `\"D \"`, there will always be at least one previous score on the record.",
    "In this problem, a tree is an **undirected graph** that is connected and has no cycles.\n\nYou are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two **different** vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.\n\nReturn _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[1,2\\],\\[1,3\\],\\[2,3\\]\\]\n**Output:** \\[2,3\\]\n\n**Example 2:**\n\n**Input:** edges = \\[\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[1,4\\],\\[1,5\\]\\]\n**Output:** \\[1,4\\]\n\n**Constraints:**\n\n*   `n == edges.length`\n*   `3 <= n <= 1000`\n*   `edges[i].length == 2`\n*   `1 <= ai < bi <= edges.length`\n*   `ai != bi`\n*   There are no repeated edges.\n*   The given graph is connected.",
    "You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected **4-directionally** (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is the number of cells with a value `1` in the island.\n\nReturn _the maximum **area** of an island in_ `grid`. If there is no island, return `0`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,0,1,0,0,0,0,1,0,0,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,1,1,0,1,0,0,0,0,0,0,0,0\\],\\[0,1,0,0,1,1,0,0,1,0,1,0,0\\],\\[0,1,0,0,1,1,0,0,1,1,1,0,0\\],\\[0,0,0,0,0,0,0,0,0,0,1,0,0\\],\\[0,0,0,0,0,0,0,1,1,1,0,0,0\\],\\[0,0,0,0,0,0,0,1,1,0,0,0,0\\]\\]\n**Output:** 6\n**Explanation:** The answer is not 11, because the island must be connected 4-directionally.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,0,0,0,0,0,0,0\\]\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 50`\n*   `grid[i][j]` is either `0` or `1`.",
    "There are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands **on the top side of another square** or **on the X-axis**. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\nAfter each square is dropped, you must record the **height of the current tallest stack of squares**.\n\nReturn _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.\n\n**Example 1:**\n\n**Input:** positions = \\[\\[1,2\\],\\[2,3\\],\\[6,1\\]\\]\n**Output:** \\[2,5,5\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of \\[2, 5, 5\\].\n\n**Example 2:**\n\n**Input:** positions = \\[\\[100,100\\],\\[200,100\\]\\]\n**Output:** \\[100,100\\]\n**Explanation:**\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of \\[100, 100\\].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.\n\n**Constraints:**\n\n*   `1 <= positions.length <= 1000`\n*   `1 <= lefti <= 108`\n*   `1 <= sideLengthi <= 106`",
    "Given an array of integers `temperatures` represents the daily temperatures, return _an array_ `answer` _such that_ `answer[i]` _is the number of days you have to wait after the_ `ith` _day to get a warmer temperature_. If there is no future day for which this is possible, keep `answer[i] == 0` instead.\n\n**Example 1:**\n\n**Input:** temperatures = \\[73,74,75,71,69,72,76,73\\]\n**Output:** \\[1,1,4,2,1,1,0,0\\]\n\n**Example 2:**\n\n**Input:** temperatures = \\[30,40,50,60\\]\n**Output:** \\[1,1,1,0\\]\n\n**Example 3:**\n\n**Input:** temperatures = \\[30,60,90\\]\n**Output:** \\[1,1,0\\]\n\n**Constraints:**\n\n*   `1 <= temperatures.length <= 105`\n*   `30 <= temperatures[i] <= 100`",
    "You are standing at position `0` on an infinite number line. There is a destination at position `target`.\n\nYou can make some number of moves `numMoves` so that:\n\n*   On each move, you can either go left or right.\n*   During the `ith` move (starting from `i == 1` to `i == numMoves`), you take `i` steps in the chosen direction.\n\nGiven the integer `target`, return _the **minimum** number of moves required (i.e., the minimum_ `numMoves`_) to reach the destination_.\n\n**Example 1:**\n\n**Input:** target = 2\n**Output:** 3\n**Explanation:**\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\n\n**Example 2:**\n\n**Input:** target = 3\n**Output:** 2\n**Explanation:**\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n\n**Constraints:**\n\n*   `-109 <= target <= 109`\n*   `target != 0`",
    "There are `n` couples sitting in `2n` seats arranged in a row and want to hold hands.\n\nThe people and seats are represented by an integer array `row` where `row[i]` is the ID of the person sitting in the `ith` seat. The couples are numbered in order, the first couple being `(0, 1)`, the second couple being `(2, 3)`, and so on with the last couple being `(2n - 2, 2n - 1)`.\n\nReturn _the minimum number of swaps so that every couple is sitting side by side_. A swap consists of choosing any two people, then they stand up and switch seats.\n\n**Example 1:**\n\n**Input:** row = \\[0,2,1,3\\]\n**Output:** 1\n**Explanation:** We only need to swap the second (row\\[1\\]) and third (row\\[2\\]) person.\n\n**Example 2:**\n\n**Input:** row = \\[3,2,0,1\\]\n**Output:** 0\n**Explanation:** All couples are already seated side by side.\n\n**Constraints:**\n\n*   `2n == row.length`\n*   `2 <= n <= 30`\n*   `n` is even.\n*   `0 <= row[i] < 2n`\n*   All the elements of `row` are **unique**.",
    "You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.\n\nThe rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.\n\nReturn _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,2\\],\\[1,3\\]\\]\n**Output:** 3\nExplanation:\nAt time 0, you are in grid location (0, 0).\nYou cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.\nYou cannot reach point (1, 1) until time 3.\nWhen the depth of water is 3, we can swim anywhere inside the grid.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,2,3,4\\],\\[24,23,22,21,5\\],\\[12,13,14,15,16\\],\\[11,17,18,19,20\\],\\[10,9,8,7,6\\]\\]\n**Output:** 16\n**Explanation:** The final route is shown.\nWe need to wait until time 16 so that (0, 0) and (4, 4) are connected.\n\n**Constraints:**\n\n*   `n == grid.length`\n*   `n == grid[i].length`\n*   `1 <= n <= 50`\n*   `0 <= grid[i][j] < n2`\n*   Each value `grid[i][j]` is **unique**.",
    "Given an array of points on the **X-Y** plane `points` where `points[i] = [xi, yi]`, return _the area of the largest triangle that can be formed by any three different points_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** points = \\[\\[0,0\\],\\[0,1\\],\\[1,0\\],\\[0,2\\],\\[2,0\\]\\]\n**Output:** 2.00000\n**Explanation:** The five points are shown in the above figure. The red triangle is the largest.\n\n**Example 2:**\n\n**Input:** points = \\[\\[1,0\\],\\[0,0\\],\\[0,1\\]\\]\n**Output:** 0.50000\n\n**Constraints:**\n\n*   `3 <= points.length <= 50`\n*   `-50 <= xi, yi <= 50`\n*   All the given points are **unique**.",
    "There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.\n\nYou are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nReturn an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.\n\n**Example 1:**\n\n**Input:** n = 6, edges = \\[\\[0,1\\],\\[0,2\\],\\[2,3\\],\\[2,4\\],\\[2,5\\]\\]\n**Output:** \\[8,12,6,10,10,10\\]\n**Explanation:** The tree is shown above.\nWe can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)\nequals 1 + 1 + 2 + 2 + 2 = 8.\nHence, answer\\[0\\] = 8, and so on.\n\n**Example 2:**\n\n**Input:** n = 1, edges = \\[\\]\n**Output:** \\[0\\]\n\n**Example 3:**\n\n**Input:** n = 2, edges = \\[\\[1,0\\]\\]\n**Output:** \\[1,1\\]\n\n**Constraints:**\n\n*   `1 <= n <= 3 * 104`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   The given input represents a valid tree.",
    "You may recall that an array `arr` is a **mountain array** if and only if:\n\n*   `arr.length >= 3`\n*   There exists some index `i` (**0-indexed**) with `0 < i < arr.length - 1` such that:\n    *   `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`\n    *   `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`\n\nGiven an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.\n\n**Example 1:**\n\n**Input:** arr = \\[2,1,4,7,3,2,5\\]\n**Output:** 5\n**Explanation:** The largest mountain is \\[1,4,7,3,2\\] which has length 5.\n\n**Example 2:**\n\n**Input:** arr = \\[2,2,2\\]\n**Output:** 0\n**Explanation:** There is no mountain.\n\n**Constraints:**\n\n*   `1 <= arr.length <= 104`\n*   `0 <= arr[i] <= 104`\n\n**Follow up:**\n\n*   Can you solve it using only one pass?\n*   Can you solve it in `O(1)` space?",
    "There are `n` cars going to the same destination along a one-lane road. The destination is `target` miles away.\n\nYou are given two integer array `position` and `speed`, both of length `n`, where `position[i]` is the position of the `ith` car and `speed[i]` is the speed of the `ith` car (in miles per hour).\n\nA car can never pass another car ahead of it, but it can catch up to it and drive bumper to bumper **at the same speed**. The faster car will **slow down** to match the slower car's speed. The distance between these two cars is ignored (i.e., they are assumed to have the same position).\n\nA **car fleet** is some non-empty set of cars driving at the same position and same speed. Note that a single car is also a car fleet.\n\nIf a car catches up to a car fleet right at the destination point, it will still be considered as one car fleet.\n\nReturn _the **number of car fleets** that will arrive at the destination_.\n\n**Example 1:**\n\n**Input:** target = 12, position = \\[10,8,0,5,3\\], speed = \\[2,4,1,1,3\\]\n**Output:** 3\n**Explanation:**\nThe cars starting at 10 (speed 2) and 8 (speed 4) become a fleet, meeting each other at 12.\nThe car starting at 0 does not catch up to any other car, so it is a fleet by itself.\nThe cars starting at 5 (speed 1) and 3 (speed 3) become a fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\nNote that no other cars meet these fleets before the destination, so the answer is 3.\n\n**Example 2:**\n\n**Input:** target = 10, position = \\[3\\], speed = \\[3\\]\n**Output:** 1\n**Explanation:** There is only one car, hence there is only one fleet.\n\n**Example 3:**\n\n**Input:** target = 100, position = \\[0,2,4\\], speed = \\[4,2,1\\]\n**Output:** 1\n**Explanation:**\nThe cars starting at 0 (speed 4) and 2 (speed 2) become a fleet, meeting each other at 4. The fleet moves at speed 2.\nThen, the fleet (speed 2) and the car starting at 4 (speed 1) become one fleet, meeting each other at 6. The fleet moves at speed 1 until it reaches target.\n\n**Constraints:**\n\n*   `n == position.length == speed.length`\n*   `1 <= n <= 105`\n*   `0 < target <= 106`\n*   `0 <= position[i] < target`\n*   All the values of `position` are **unique**.\n*   `0 < speed[i] <= 106`",
    "There are `n` workers. You are given two integer arrays `quality` and `wage` where `quality[i]` is the quality of the `ith` worker and `wage[i]` is the minimum wage expectation for the `ith` worker.\n\nWe want to hire exactly `k` workers to form a paid group. To hire a group of `k` workers, we must pay them according to the following rules:\n\n1.  Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n2.  Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer `k`, return _the least amount of money needed to form a paid group satisfying the above conditions_. Answers within `10-5` of the actual answer will be accepted.\n\n**Example 1:**\n\n**Input:** quality = \\[10,20,5\\], wage = \\[70,50,30\\], k = 2\n**Output:** 105.00000\n**Explanation:** We pay 70 to 0th worker and 35 to 2nd worker.\n\n**Example 2:**\n\n**Input:** quality = \\[3,1,10,10,1\\], wage = \\[4,8,2,2,7\\], k = 3\n**Output:** 30.66667\n**Explanation:** We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n\n**Constraints:**\n\n*   `n == quality.length == wage.length`\n*   `1 <= k <= n <= 104`\n*   `1 <= quality[i], wage[i] <= 104`",
    "You are given an undirected graph (the **\"original graph \"**) with `n` nodes labeled from `0` to `n - 1`. You decide to **subdivide** each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will **subdivide** the edge into. Note that `cnti == 0` means you will not subdivide the edge.\n\nTo **subdivide** the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`, `[xcnti, vi]`.\n\nIn this **new graph**, you want to know how many nodes are **reachable** from the node `0`, where a node is **reachable** if the distance is `maxMoves` or less.\n\nGiven the original graph and `maxMoves`, return _the number of nodes that are **reachable** from node_ `0` _in the new graph_.\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1,10\\],\\[0,2,1\\],\\[1,2,2\\]\\], maxMoves = 6, n = 3\n**Output:** 13\n**Explanation:** The edge subdivisions are shown in the image above.\nThe nodes that are reachable are highlighted in yellow.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1,4\\],\\[1,2,6\\],\\[0,2,8\\],\\[1,3,1\\]\\], maxMoves = 10, n = 4\n**Output:** 23\n\n**Example 3:**\n\n**Input:** edges = \\[\\[1,2,4\\],\\[1,4,5\\],\\[1,3,1\\],\\[2,3,4\\],\\[3,4,5\\]\\], maxMoves = 17, n = 5\n**Output:** 1\n**Explanation:** Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.\n\n**Constraints:**\n\n*   `0 <= edges.length <= min(n * (n - 1) / 2, 104)`\n*   `edges[i].length == 3`\n*   `0 <= ui < vi < n`\n*   There are **no multiple edges** in the graph.\n*   `0 <= cnti <= 104`\n*   `0 <= maxMoves <= 109`\n*   `1 <= n <= 3000`",
    "You start at the cell `(rStart, cStart)` of an `rows x cols` grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\n\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all `rows * cols` spaces of the grid.\n\nReturn _an array of coordinates representing the positions of the grid in the order you visited them_.\n\n**Example 1:**\n\n**Input:** rows = 1, cols = 4, rStart = 0, cStart = 0\n**Output:** \\[\\[0,0\\],\\[0,1\\],\\[0,2\\],\\[0,3\\]\\]\n\n**Example 2:**\n\n**Input:** rows = 5, cols = 6, rStart = 1, cStart = 4\n**Output:** \\[\\[1,4\\],\\[1,5\\],\\[2,5\\],\\[2,4\\],\\[2,3\\],\\[1,3\\],\\[0,3\\],\\[0,4\\],\\[0,5\\],\\[3,5\\],\\[3,4\\],\\[3,3\\],\\[3,2\\],\\[2,2\\],\\[1,2\\],\\[0,2\\],\\[4,5\\],\\[4,4\\],\\[4,3\\],\\[4,2\\],\\[4,1\\],\\[3,1\\],\\[2,1\\],\\[1,1\\],\\[0,1\\],\\[4,0\\],\\[3,0\\],\\[2,0\\],\\[1,0\\],\\[0,0\\]\\]\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 100`\n*   `0 <= rStart < rows`\n*   `0 <= cStart < cols`",
    "You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array `fruits` where `fruits[i]` is the **type** of fruit the `ith` tree produces.\n\nYou want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:\n\n*   You only have **two** baskets, and each basket can only hold a **single type** of fruit. There is no limit on the amount of fruit each basket can hold.\n*   Starting from any tree of your choice, you must pick **exactly one fruit** from **every** tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.\n*   Once you reach a tree with fruit that cannot fit in your baskets, you must stop.\n\nGiven the integer array `fruits`, return _the **maximum** number of fruits you can pick_.\n\n**Example 1:**\n\n**Input:** fruits = \\[1,2,1\\]\n**Output:** 3\n**Explanation:** We can pick from all 3 trees.\n\n**Example 2:**\n\n**Input:** fruits = \\[0,1,2,2\\]\n**Output:** 3\n**Explanation:** We can pick from trees \\[1,2,2\\].\nIf we had started at the first tree, we would only pick from trees \\[0,1\\].\n\n**Example 3:**\n\n**Input:** fruits = \\[1,2,3,2,2\\]\n**Output:** 4\n**Explanation:** We can pick from trees \\[2,3,2,2\\].\nIf we had started at the first tree, we would only pick from trees \\[1,2\\].\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `0 <= fruits[i] < fruits.length`",
    "A game on an **undirected** graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: `graph[a]` is a list of all nodes `b` such that `ab` is an edge of the graph.\n\nThe mouse starts at node `1` and goes first, the cat starts at node `2` and goes second, and there is a hole at node `0`.\n\nDuring each player's turn, they **must** travel along one edge of the graph that meets where they are. For example, if the Mouse is at node 1, it **must** travel to any node in `graph[1]`.\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n*   If ever the Cat occupies the same node as the Mouse, the Cat wins.\n*   If ever the Mouse reaches the Hole, the Mouse wins.\n*   If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a `graph`, and assuming both players play optimally, return\n\n*   `1` if the mouse wins the game,\n*   `2` if the cat wins the game, or\n*   `0` if the game is a draw.\n\n**Example 1:**\n\n**Input:** graph = \\[\\[2,5\\],\\[3\\],\\[0,4,5\\],\\[1,4,5\\],\\[2,3\\],\\[0,2,3\\]\\]\n**Output:** 0\n\n**Example 2:**\n\n**Input:** graph = \\[\\[1,3\\],\\[0\\],\\[3\\],\\[0,2\\]\\]\n**Output:** 1\n\n**Constraints:**\n\n*   `3 <= graph.length <= 50`\n*   `1 <= graph[i].length < graph.length`\n*   `0 <= graph[i][j] < graph.length`\n*   `graph[i][j] != i`\n*   `graph[i]` is unique.\n*   The mouse and the cat can always move.",
    "You are given an integer array of unique positive integers `nums`. Consider the following graph:\n\n*   There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,\n*   There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.\n\nReturn _the size of the largest connected component in the graph_.\n\n**Example 1:**\n\n**Input:** nums = \\[4,6,15,35\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** nums = \\[20,50,9,63\\]\n**Output:** 2\n\n**Example 3:**\n\n**Input:** nums = \\[2,3,6,7,4,12,21,39\\]\n**Output:** 8\n\n**Constraints:**\n\n*   `1 <= nums.length <= 2 * 104`\n*   `1 <= nums[i] <= 105`\n*   All the values of `nums` are **unique**.",
    "Given an array of `points` where `points[i] = [xi, yi]` represents a point on the **X-Y** plane and an integer `k`, return the `k` closest points to the origin `(0, 0)`.\n\nThe distance between two points on the **X-Y** plane is the Euclidean distance (i.e., `\u221a(x1 - x2)2 + (y1 - y2)2`).\n\nYou may return the answer in **any order**. The answer is **guaranteed** to be **unique** (except for the order that it is in).\n\n**Example 1:**\n\n**Input:** points = \\[\\[1,3\\],\\[-2,2\\]\\], k = 1\n**Output:** \\[\\[-2,2\\]\\]\n**Explanation:**\nThe distance between (1, 3) and the origin is sqrt(10).\nThe distance between (-2, 2) and the origin is sqrt(8).\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\nWe only want the closest k = 1 points from the origin, so the answer is just \\[\\[-2,2\\]\\].\n\n**Example 2:**\n\n**Input:** points = \\[\\[3,3\\],\\[5,-1\\],\\[-2,4\\]\\], k = 2\n**Output:** \\[\\[3,3\\],\\[-2,4\\]\\]\n**Explanation:** The answer \\[\\[-2,4\\],\\[3,3\\]\\] would also be accepted.\n\n**Constraints:**\n\n*   `1 <= k <= points.length <= 104`\n*   `-104 < xi, yi < 104`",
    "Given an integer array `nums`, return _the largest perimeter of a triangle with a non-zero area, formed from three of these lengths_. If it is impossible to form any triangle of a non-zero area, return `0`.\n\n**Example 1:**\n\n**Input:** nums = \\[2,1,2\\]\n**Output:** 5\n**Explanation:** You can form a triangle with three side lengths: 1, 2, and 2.\n\n**Example 2:**\n\n**Input:** nums = \\[1,2,1,10\\]\n**Output:** 0\n**Explanation:** \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n**Constraints:**\n\n*   `3 <= nums.length <= 104`\n*   `1 <= nums[i] <= 106`",
    "You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree.\n\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n\nReturn _the **minimum** number of moves required to make every node have **exactly** one coin_.\n\n**Example 1:**\n\n**Input:** root = \\[3,0,0\\]\n**Output:** 2\n**Explanation:** From the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n**Example 2:**\n\n**Input:** root = \\[0,3,0\\]\n**Output:** 3\n**Explanation:** From the left child of the root, we move two coins to the root \\[taking two moves\\]. Then, we move one coin from the root of the tree to the right child.\n\n**Constraints:**\n\n*   The number of nodes in the tree is `n`.\n*   `1 <= n <= 100`\n*   `0 <= Node.val <= n`\n*   The sum of all `Node.val` is `n`.",
    "You are given an `m x n` integer array `grid` where `grid[i][j]` could be:\n\n*   `1` representing the starting square. There is exactly one starting square.\n*   `2` representing the ending square. There is exactly one ending square.\n*   `0` representing empty squares we can walk over.\n*   `-1` representing obstacles that we cannot walk over.\n\nReturn _the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,2,-1\\]\\]\n**Output:** 2\n**Explanation:** We have the following two paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)\n2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,0,0,0\\],\\[0,0,0,0\\],\\[0,0,0,2\\]\\]\n**Output:** 4\n**Explanation:** We have the following four paths: \n1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)\n2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)\n3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)\n4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,1\\],\\[2,0\\]\\]\n**Output:** 0\n**Explanation:** There is no path that walks over every empty square exactly once.\nNote that the starting and ending square can be anywhere in the grid.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 20`\n*   `1 <= m * n <= 20`\n*   `-1 <= grid[i][j] <= 2`\n*   There is exactly one starting cell and one ending cell.",
    "You are given an `m x n` `grid` where each cell can have one of three values:\n\n*   `0` representing an empty cell,\n*   `1` representing a fresh orange, or\n*   `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.\n\nReturn _the minimum number of minutes that must elapse until no cell has a fresh orange_. If _this is impossible, return_ `-1`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,1,1\\],\\[1,1,0\\],\\[0,1,1\\]\\]\n**Output:** 4\n\n**Example 2:**\n\n**Input:** grid = \\[\\[2,1,1\\],\\[0,1,1\\],\\[1,0,1\\]\\]\n**Output:** -1\n**Explanation:** The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.\n\n**Example 3:**\n\n**Input:** grid = \\[\\[0,2\\]\\]\n**Output:** 0\n**Explanation:** Since there are already no fresh oranges at minute 0, the answer is just 0.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 10`\n*   `grid[i][j]` is `0`, `1`, or `2`.",
    "There are `n` piles of `stones` arranged in a row. The `ith` pile has `stones[i]` stones.\n\nA move consists of merging exactly `k` **consecutive** piles into one pile, and the cost of this move is equal to the total number of stones in these `k` piles.\n\nReturn _the minimum cost to merge all piles of stones into one pile_. If it is impossible, return `-1`.\n\n**Example 1:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 2\n**Output:** 20\n**Explanation:** We start with \\[3, 2, 4, 1\\].\nWe merge \\[3, 2\\] for a cost of 5, and we are left with \\[5, 4, 1\\].\nWe merge \\[4, 1\\] for a cost of 5, and we are left with \\[5, 5\\].\nWe merge \\[5, 5\\] for a cost of 10, and we are left with \\[10\\].\nThe total cost was 20, and this is the minimum possible.\n\n**Example 2:**\n\n**Input:** stones = \\[3,2,4,1\\], k = 3\n**Output:** -1\n**Explanation:** After any merge operation, there are 2 piles left, and we can't merge anymore.  So the task is impossible.\n\n**Example 3:**\n\n**Input:** stones = \\[3,5,1,2,6\\], k = 3\n**Output:** 25\n**Explanation:** We start with \\[3, 5, 1, 2, 6\\].\nWe merge \\[5, 1, 2\\] for a cost of 8, and we are left with \\[3, 8, 6\\].\nWe merge \\[3, 8, 6\\] for a cost of 17, and we are left with \\[17\\].\nThe total cost was 25, and this is the minimum possible.\n\n**Constraints:**\n\n*   `n == stones.length`\n*   `1 <= n <= 30`\n*   `1 <= stones[i] <= 100`\n*   `2 <= k <= 30`",
    "There are some stones in different positions on the X-axis. You are given an integer array `stones`, the positions of the stones.\n\nCall a stone an **endpoint stone** if it has the smallest or largest position. In one move, you pick up an **endpoint stone** and move it to an unoccupied position so that it is no longer an **endpoint stone**.\n\n*   In particular, if the stones are at say, `stones = [1,2,5]`, you cannot move the endpoint stone at position `5`, since moving it to any position (such as `0`, or `3`) will still keep that stone as an endpoint stone.\n\nThe game ends when you cannot make any more moves (i.e., the stones are in three consecutive positions).\n\nReturn _an integer array_ `answer` _of length_ `2` _where_:\n\n*   `answer[0]` _is the minimum number of moves you can play, and_\n*   `answer[1]` _is the maximum number of moves you can play_.\n\n**Example 1:**\n\n**Input:** stones = \\[7,4,9\\]\n**Output:** \\[1,2\\]\n**Explanation:** We can move 4 -> 8 for one move to finish the game.\nOr, we can move 9 -> 5, 4 -> 6 for two moves to finish the game.\n\n**Example 2:**\n\n**Input:** stones = \\[6,5,4,3,10\\]\n**Output:** \\[2,3\\]\n**Explanation:** We can move 3 -> 8 then 10 -> 7 to finish the game.\nOr, we can move 3 -> 7, 4 -> 8, 5 -> 9 to finish the game.\nNotice we cannot move 10 -> 2 to finish the game, because that would be an illegal move.\n\n**Constraints:**\n\n*   `3 <= stones.length <= 104`\n*   `1 <= stones[i] <= 109`\n*   All the values of `stones` are **unique**.",
    "In an infinite binary tree where every node has two children, the nodes are labelled in row order.\n\nIn the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.\n\nGiven the `label` of a node in this tree, return the labels in the path from the root of the tree to the node with that `label`.\n\n**Example 1:**\n\n**Input:** label = 14\n**Output:** \\[1,3,4,14\\]\n\n**Example 2:**\n\n**Input:** label = 26\n**Output:** \\[1,2,6,10,26\\]\n\n**Constraints:**\n\n*   `1 <= label <= 10^6`",
    "Alice and Bob continue their games with piles of stones. There are a number of piles **arranged in a row**, and each pile has a positive integer number of stones `piles[i]`. The objective of the game is to end with the most stones.\n\nAlice and Bob take turns, with Alice starting first. Initially, `M = 1`.\n\nOn each player's turn, that player can take **all the stones** in the **first** `X` remaining piles, where `1 <= X <= 2M`. Then, we set `M = max(M, X)`.\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n**Example 1:**\n\n**Input:** piles = \\[2,7,9,4,4\\]\n**Output:** 10\n**Explanation:**  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n**Example 2:**\n\n**Input:** piles = \\[1,2,3,4,5,100\\]\n**Output:** 104\n\n**Constraints:**\n\n*   `1 <= piles.length <= 100`\n*   `1 <= piles[i] <= 104`",
    "**Tic-tac-toe** is played by two players `A` and `B` on a `3 x 3` grid. The rules of Tic-Tac-Toe are:\n\n*   Players take turns placing characters into empty squares `' '`.\n*   The first player `A` always places `'X'` characters, while the second player `B` always places `'O'` characters.\n*   `'X'` and `'O'` characters are always placed into empty squares, never on filled ones.\n*   The game ends when there are **three** of the same (non-empty) character filling any row, column, or diagonal.\n*   The game also ends if all squares are non-empty.\n*   No more moves can be played if the game is over.\n\nGiven a 2D integer array `moves` where `moves[i] = [rowi, coli]` indicates that the `ith` move will be played on `grid[rowi][coli]`. return _the winner of the game if it exists_ (`A` or `B`). In case the game ends in a draw return `\"Draw \"`. If there are still movements to play return `\"Pending \"`.\n\nYou can assume that `moves` is valid (i.e., it follows the rules of **Tic-Tac-Toe**), the grid is initially empty, and `A` will play first.\n\n**Example 1:**\n\n**Input:** moves = \\[\\[0,0\\],\\[2,0\\],\\[1,1\\],\\[2,1\\],\\[2,2\\]\\]\n**Output:**  \"A \"\n**Explanation:** A wins, they always play first.\n\n**Example 2:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[0,1\\],\\[0,2\\],\\[1,0\\],\\[2,0\\]\\]\n**Output:**  \"B \"\n**Explanation:** B wins.\n\n**Example 3:**\n\n**Input:** moves = \\[\\[0,0\\],\\[1,1\\],\\[2,0\\],\\[1,0\\],\\[1,2\\],\\[2,1\\],\\[0,1\\],\\[0,2\\],\\[2,2\\]\\]\n**Output:**  \"Draw \"\n**Explanation:** The game ends in a draw since there are no moves to make.\n\n**Constraints:**\n\n*   `1 <= moves.length <= 9`\n*   `moves[i].length == 2`\n*   `0 <= rowi, coli <= 2`\n*   There are no repeated elements on `moves`.\n*   `moves` follow the rules of tic tac toe.",
    "There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.\n\nReturn the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.\n\nNotice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.\n\n**Example 1:**\n\n**Input:** n = 4, edges = \\[\\[0,1,3\\],\\[1,2,1\\],\\[1,3,4\\],\\[2,3,1\\]\\], distanceThreshold = 4\n**Output:** 3\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 4 for each city are:\nCity 0 -> \\[City 1, City 2\\] \nCity 1 -> \\[City 0, City 2, City 3\\] \nCity 2 -> \\[City 0, City 1, City 3\\] \nCity 3 -> \\[City 1, City 2\\] \nCities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.\n\n**Example 2:**\n\n**Input:** n = 5, edges = \\[\\[0,1,2\\],\\[0,4,8\\],\\[1,2,3\\],\\[1,4,2\\],\\[2,3,1\\],\\[3,4,1\\]\\], distanceThreshold = 2\n**Output:** 0\n**Explanation:** The figure above describes the graph. \nThe neighboring cities at a distanceThreshold = 2 for each city are:\nCity 0 -> \\[City 1\\] \nCity 1 -> \\[City 0, City 4\\] \nCity 2 -> \\[City 3, City 4\\] \nCity 3 -> \\[City 2, City 4\\]\nCity 4 -> \\[City 1, City 2, City 3\\] \nThe city 0 has 1 neighboring city at a distanceThreshold = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 100`\n*   `1 <= edges.length <= n * (n - 1) / 2`\n*   `edges[i].length == 3`\n*   `0 <= fromi < toi < n`\n*   `1 <= weighti, distanceThreshold <= 10^4`\n*   All pairs `(fromi, toi)` are distinct.",
    "You are given an `m x n` `grid`. Each cell of `grid` represents a street. The street of `grid[i][j]` can be:\n\n*   `1` which means a street connecting the left cell and the right cell.\n*   `2` which means a street connecting the upper cell and the lower cell.\n*   `3` which means a street connecting the left cell and the lower cell.\n*   `4` which means a street connecting the right cell and the lower cell.\n*   `5` which means a street connecting the left cell and the upper cell.\n*   `6` which means a street connecting the right cell and the upper cell.\n\nYou will initially start at the street of the upper-left cell `(0, 0)`. A valid path in the grid is a path that starts from the upper left cell `(0, 0)` and ends at the bottom-right cell `(m - 1, n - 1)`. **The path should only follow the streets**.\n\n**Notice** that you are **not allowed** to change any street.\n\nReturn `true` _if there is a valid path in the grid or_ `false` _otherwise_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[2,4,3\\],\\[6,5,2\\]\\]\n**Output:** true\n**Explanation:** As shown you can start at cell (0, 0) and visit all the cells of the grid to reach (m - 1, n - 1).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,1\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** As shown you the street at cell (0, 0) is not connected with any street of any other cell and you will get stuck at cell (0, 0)\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,2\\]\\]\n**Output:** false\n**Explanation:** You will get stuck at cell (0, 1) and you cannot reach cell (0, 2).\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 300`\n*   `1 <= grid[i][j] <= 6`",
    "Alice and Bob continue their games with piles of stones. There are several stones **arranged in a row**, and each stone has an associated value which is an integer given in the array `stoneValue`.\n\nAlice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the **first** remaining stones in the row.\n\nThe score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.\n\nThe objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.\n\nAssume Alice and Bob **play optimally**.\n\nReturn `\"Alice \"` _if Alice will win,_ `\"Bob \"` _if Bob will win, or_ `\"Tie \"` _if they will end the game with the same score_.\n\n**Example 1:**\n\n**Input:** values = \\[1,2,3,7\\]\n**Output:**  \"Bob \"\n**Explanation:** Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.\n\n**Example 2:**\n\n**Input:** values = \\[1,2,3,-9\\]\n**Output:**  \"Alice \"\n**Explanation:** Alice must choose all the three piles at the first move to win and leave Bob with negative score.\nIf Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.\nIf Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.\nRemember that both play optimally so here Alice will choose the scenario that makes her win.\n\n**Example 3:**\n\n**Input:** values = \\[1,2,3,6\\]\n**Output:**  \"Tie \"\n**Explanation:** Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.\n\n**Constraints:**\n\n*   `1 <= stoneValue.length <= 5 * 104`\n*   `-1000 <= stoneValue[i] <= 1000`",
    "You are given the string `croakOfFrogs`, which represents a combination of the string `\"croak \"` from different frogs, that is, multiple frogs can croak at the same time, so multiple `\"croak \"` are mixed.\n\n_Return the minimum number of_ different _frogs to finish all the croaks in the given string._\n\nA valid `\"croak \"` means a frog is printing five letters `'c'`, `'r'`, `'o'`, `'a'`, and `'k'` **sequentially**. The frogs have to print all five letters to finish a croak. If the given string is not a combination of a valid `\"croak \"` return `-1`.\n\n**Example 1:**\n\n**Input:** croakOfFrogs =  \"croakcroak \"\n**Output:** 1 \n**Explanation:** One frog yelling  \"croak **\"** twice.\n\n**Example 2:**\n\n**Input:** croakOfFrogs =  \"crcoakroak \"\n**Output:** 2 \n**Explanation:** The minimum number of frogs is two. \nThe first frog could yell  \"**cr**c**oak**roak \".\nThe second frog could yell later  \"cr**c**oak**roak** \".\n\n**Example 3:**\n\n**Input:** croakOfFrogs =  \"croakcrook \"\n**Output:** -1\n**Explanation:** The given string is an invalid combination of  \"croak **\"** from different frogs.\n\n**Constraints:**\n\n*   `1 <= croakOfFrogs.length <= 105`\n*   `croakOfFrogs` is either `'c'`, `'r'`, `'o'`, `'a'`, or `'k'`.",
    "Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.\n\nFor each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.\n\n_Return the number of ways of cutting the pizza such that each piece contains **at least** one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.\n\n**Example 1:**\n\n**Input:** pizza = \\[ \"A.. \", \"AAA \", \"... \"\\], k = 3\n**Output:** 3 \n**Explanation:** The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.\n\n**Example 2:**\n\n**Input:** pizza = \\[ \"A.. \", \"AA. \", \"... \"\\], k = 3\n**Output:** 1\n\n**Example 3:**\n\n**Input:** pizza = \\[ \"A.. \", \"A.. \", \"... \"\\], k = 1\n**Output:** 1\n\n**Constraints:**\n\n*   `1 <= rows, cols <= 50`\n*   `rows == pizza.length`\n*   `cols == pizza[i].length`\n*   `1 <= k <= 10`\n*   `pizza` consists of characters `'A'` and `'.'` only.",
    "You are given an integer array `bloomDay`, an integer `m` and an integer `k`.\n\nYou want to make `m` bouquets. To make a bouquet, you need to use `k` **adjacent flowers** from the garden.\n\nThe garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in **exactly one** bouquet.\n\nReturn _the minimum number of days you need to wait to be able to make_ `m` _bouquets from the garden_. If it is impossible to make m bouquets return `-1`.\n\n**Example 1:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 1\n**Output:** 3\n**Explanation:** Let us see what happened in the first three days. x means flower bloomed and \\_ means flower did not bloom in the garden.\nWe need 3 bouquets each should contain 1 flower.\nAfter day 1: \\[x, \\_, \\_, \\_, \\_\\]   // we can only make one bouquet.\nAfter day 2: \\[x, \\_, \\_, \\_, x\\]   // we can only make two bouquets.\nAfter day 3: \\[x, \\_, x, \\_, x\\]   // we can make 3 bouquets. The answer is 3.\n\n**Example 2:**\n\n**Input:** bloomDay = \\[1,10,3,10,2\\], m = 3, k = 2\n**Output:** -1\n**Explanation:** We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.\n\n**Example 3:**\n\n**Input:** bloomDay = \\[7,7,7,7,12,7,7\\], m = 2, k = 3\n**Output:** 12\n**Explanation:** We need 2 bouquets each should have 3 flowers.\nHere is the garden after the 7 and 12 days:\nAfter day 7: \\[x, x, x, x, \\_, x, x\\]\nWe can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.\nAfter day 12: \\[x, x, x, x, x, x, x\\]\nIt is obvious that we can make two bouquets in different ways.\n\n**Constraints:**\n\n*   `bloomDay.length == n`\n*   `1 <= n <= 105`\n*   `1 <= bloomDay[i] <= 109`\n*   `1 <= m <= 106`\n*   `1 <= k <= n`",
    "We have a wooden plank of the length `n` **units**. Some ants are walking on the plank, each ant moves with a speed of **1 unit per second**. Some of the ants move to the **left**, the other move to the **right**.\n\nWhen two ants moving in two **different** directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n\nWhen an ant reaches **one end** of the plank at a time `t`, it falls out of the plank immediately.\n\nGiven an integer `n` and two integer arrays `left` and `right`, the positions of the ants moving to the left and the right, return _the moment when the last ant(s) fall out of the plank_.\n\n**Example 1:**\n\n**Input:** n = 4, left = \\[4,3\\], right = \\[0,1\\]\n**Output:** 4\n**Explanation:** In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\n**Example 2:**\n\n**Input:** n = 7, left = \\[\\], right = \\[0,1,2,3,4,5,6,7\\]\n**Output:** 7\n**Explanation:** All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\n**Example 3:**\n\n**Input:** n = 7, left = \\[0,1,2,3,4,5,6,7\\], right = \\[\\]\n**Output:** 7\n**Explanation:** All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n**Constraints:**\n\n*   `1 <= n <= 104`\n*   `0 <= left.length <= n + 1`\n*   `0 <= left[i] <= n`\n*   `0 <= right.length <= n + 1`\n*   `0 <= right[i] <= n`\n*   `1 <= left.length + right.length <= n + 1`\n*   All values of `left` and `right` are unique, and each value can appear **only in one** of the two arrays.",
    "Alice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there are `n` stones in a pile. On each player's turn, that player makes a _move_ consisting of removing **any** non-zero **square number** of stones in the pile.\n\nAlso, if a player cannot make a move, he/she loses the game.\n\nGiven a positive integer `n`, return `true` if and only if Alice wins the game otherwise return `false`, assuming both players play optimally.\n\n**Example 1:**\n\n**Input:** n = 1\n**Output:** true\n**Explanation:** Alice can remove 1 stone winning the game because Bob doesn't have any moves.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** false\n**Explanation:** Alice can only remove 1 stone, after that Bob removes the last one winning the game (2 -> 1 -> 0).\n\n**Example 3:**\n\n**Input:** n = 4\n**Output:** true\n**Explanation:** n is already a perfect square, Alice can win with one move, removing 4 stones (4 -> 0).\n\n**Constraints:**\n\n*   `1 <= n <= 105`",
    "Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length **6** is labelled as follows:\n\nGiven an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn _the minimum total cost_ of the cuts.\n\n**Example 1:**\n\n**Input:** n = 7, cuts = \\[1,3,4,5\\]\n**Output:** 16\n**Explanation:** Using cuts order = \\[1, 3, 4, 5\\] as in the input leads to the following scenario:\n \nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be \\[3, 5, 1, 4\\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\n**Example 2:**\n\n**Input:** n = 9, cuts = \\[5,6,1,4,2\\]\n**Output:** 22\n**Explanation:** If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order \\[4, 6, 5, 2, 1\\] has total cost = 22 which is the minimum possible.\n\n**Constraints:**\n\n*   `2 <= n <= 106`\n*   `1 <= cuts.length <= min(n - 1, 100)`\n*   `1 <= cuts[i] <= n - 1`\n*   All the integers in `cuts` array are **distinct**.",
    "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has `n` empty baskets, the `ith` basket is at `position[i]`, Morty has `m` balls and needs to distribute the balls into the baskets such that the **minimum magnetic force** between any two balls is **maximum**.\n\nRick stated that magnetic force between two different balls at positions `x` and `y` is `|x - y|`.\n\nGiven the integer array `position` and the integer `m`. Return _the required force_.\n\n**Example 1:**\n\n**Input:** position = \\[1,2,3,4,7\\], m = 3\n**Output:** 3\n**Explanation:** Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs \\[3, 3, 6\\]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n**Example 2:**\n\n**Input:** position = \\[5,4,3,2,1,1000000000\\], m = 2\n**Output:** 999999999\n**Explanation:** We can use baskets 1 and 1000000000.\n\n**Constraints:**\n\n*   `n == position.length`\n*   `2 <= n <= 105`\n*   `1 <= position[i] <= 109`\n*   All integers in `position` are **distinct**.\n*   `2 <= m <= position.length`",
    "You are given an `m x n` binary grid `grid` where `1` represents land and `0` represents water. An **island** is a maximal **4-directionally** (horizontal or vertical) connected group of `1`'s.\n\nThe grid is said to be **connected** if we have **exactly one island**, otherwise is said **disconnected**.\n\nIn one day, we are allowed to change **any** single land cell `(1)` into a water cell `(0)`.\n\nReturn _the minimum number of days to disconnect the grid_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1,0\\],\\[0,1,1,0\\],\\[0,0,0,0\\]\\]\n\n**Output:** 2\n**Explanation:** We need at least 2 days to get a disconnected grid.\nChange land grid\\[1\\]\\[1\\] and grid\\[0\\]\\[2\\] to water and get 2 disconnected island.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,1\\]\\]\n**Output:** 2\n**Explanation:** Grid of full water is also disconnected (\\[\\[1,1\\]\\] -> \\[\\[0,0\\]\\]), 0 islands.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 30`\n*   `grid[i][j]` is either `0` or `1`.",
    "There is a strange printer with the following two special requirements:\n\n*   On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.\n*   Once the printer has used a color for the above operation, **the same color cannot be used again**.\n\nYou are given a `m x n` matrix `targetGrid`, where `targetGrid[row][col]` is the color in the position `(row, col)` of the grid.\n\nReturn `true` _if it is possible to print the matrix_ `targetGrid`_,_ _otherwise, return_ `false`.\n\n**Example 1:**\n\n**Input:** targetGrid = \\[\\[1,1,1,1\\],\\[1,2,2,1\\],\\[1,2,2,1\\],\\[1,1,1,1\\]\\]\n**Output:** true\n\n**Example 2:**\n\n**Input:** targetGrid = \\[\\[1,1,1,1\\],\\[1,1,3,3\\],\\[1,1,3,4\\],\\[5,5,1,4\\]\\]\n**Output:** true\n\n**Example 3:**\n\n**Input:** targetGrid = \\[\\[1,2,1\\],\\[2,1,2\\],\\[1,2,1\\]\\]\n**Output:** false\n**Explanation:** It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n\n**Constraints:**\n\n*   `m == targetGrid.length`\n*   `n == targetGrid[i].length`\n*   `1 <= m, n <= 60`\n*   `1 <= targetGrid[row][col] <= 60`",
    "The Leetcode file system keeps a log each time some user performs a _change folder_ operation.\n\nThe operations are described below:\n\n*   `\"../ \"` : Move to the parent folder of the current folder. (If you are already in the main folder, **remain in the same folder**).\n*   `\"./ \"` : Remain in the same folder.\n*   `\"x/ \"` : Move to the child folder named `x` (This folder is **guaranteed to always exist**).\n\nYou are given a list of strings `logs` where `logs[i]` is the operation performed by the user at the `ith` step.\n\nThe file system starts in the main folder, then the operations in `logs` are performed.\n\nReturn _the minimum number of operations needed to go back to the main folder after the change folder operations._\n\n**Example 1:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"../ \", \"d21/ \", \"./ \"\\]\n**Output:** 2\n**Explanation:** Use this change folder operation  \"../ \" 2 times and go back to the main folder.\n\n**Example 2:**\n\n**Input:** logs = \\[ \"d1/ \", \"d2/ \", \"./ \", \"d3/ \", \"../ \", \"d31/ \"\\]\n**Output:** 3\n\n**Example 3:**\n\n**Input:** logs = \\[ \"d1/ \", \"../ \", \"../ \", \"../ \"\\]\n**Output:** 0\n\n**Constraints:**\n\n*   `1 <= logs.length <= 103`\n*   `2 <= logs[i].length <= 10`\n*   `logs[i]` contains lowercase English letters, digits, `'.'`, and `'/'`.\n*   `logs[i]` follows the format described in the statement.\n*   Folder names consist of lowercase English letters and digits.",
    "You are a hiker preparing for an upcoming hike. You are given `heights`, a 2D array of size `rows x columns`, where `heights[row][col]` represents the height of cell `(row, col)`. You are situated in the top-left cell, `(0, 0)`, and you hope to travel to the bottom-right cell, `(rows-1, columns-1)` (i.e., **0-indexed**). You can move **up**, **down**, **left**, or **right**, and you wish to find a route that requires the minimum **effort**.\n\nA route's **effort** is the **maximum absolute difference** in heights between two consecutive cells of the route.\n\nReturn _the minimum **effort** required to travel from the top-left cell to the bottom-right cell._\n\n**Example 1:**\n\n**Input:** heights = \\[\\[1,2,2\\],\\[3,8,2\\],\\[5,3,5\\]\\]\n**Output:** 2\n**Explanation:** The route of \\[1,3,5,3,5\\] has a maximum absolute difference of 2 in consecutive cells.\nThis is better than the route of \\[1,2,2,2,5\\], where the maximum absolute difference is 3.\n\n**Example 2:**\n\n**Input:** heights = \\[\\[1,2,3\\],\\[3,8,4\\],\\[5,3,5\\]\\]\n**Output:** 1\n**Explanation:** The route of \\[1,2,3,4,5\\] has a maximum absolute difference of 1 in consecutive cells, which is better than route \\[1,3,5,3,5\\].\n\n**Example 3:**\n\n**Input:** heights = \\[\\[1,2,1,1,1\\],\\[1,2,1,2,1\\],\\[1,2,1,2,1\\],\\[1,2,1,2,1\\],\\[1,1,1,2,1\\]\\]\n**Output:** 0\n**Explanation:** This route does not require any effort.\n\n**Constraints:**\n\n*   `rows == heights.length`\n*   `columns == heights[i].length`\n*   `1 <= rows, columns <= 100`\n*   `1 <= heights[i][j] <= 106`",
    "You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of **any** color.\n\nThe customer weirdly values the colored balls. Each colored ball's value is the number of balls **of that color** you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).\n\nYou are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls **in any order**.\n\nReturn _the **maximum** total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** inventory = \\[2,5\\], orders = 4\n**Output:** 14\n**Explanation:** Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).\nThe maximum total value is 2 + 5 + 4 + 3 = 14.\n\n**Example 2:**\n\n**Input:** inventory = \\[3,5\\], orders = 6\n**Output:** 19\n**Explanation:** Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).\nThe maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.\n\n**Constraints:**\n\n*   `1 <= inventory.length <= 105`\n*   `1 <= inventory[i] <= 109`\n*   `1 <= orders <= min(sum(inventory[i]), 109)`",
    "You have a bomb to defuse, and your time is running out! Your informer will provide you with a **circular** array `code` of length of `n` and a key `k`.\n\nTo decrypt the code, you must replace every number. All the numbers are replaced **simultaneously**.\n\n*   If `k > 0`, replace the `ith` number with the sum of the **next** `k` numbers.\n*   If `k < 0`, replace the `ith` number with the sum of the **previous** `k` numbers.\n*   If `k == 0`, replace the `ith` number with `0`.\n\nAs `code` is circular, the next element of `code[n-1]` is `code[0]`, and the previous element of `code[0]` is `code[n-1]`.\n\nGiven the **circular** array `code` and an integer key `k`, return _the decrypted code to defuse the bomb_!\n\n**Example 1:**\n\n**Input:** code = \\[5,7,1,4\\], k = 3\n**Output:** \\[12,10,16,13\\]\n**Explanation:** Each number is replaced by the sum of the next 3 numbers. The decrypted code is \\[7+1+4, 1+4+5, 4+5+7, 5+7+1\\]. Notice that the numbers wrap around.\n\n**Example 2:**\n\n**Input:** code = \\[1,2,3,4\\], k = 0\n**Output:** \\[0,0,0,0\\]\n**Explanation:** When k is zero, the numbers are replaced by 0. \n\n**Example 3:**\n\n**Input:** code = \\[2,4,9,3\\], k = -2\n**Output:** \\[12,5,6,13\\]\n**Explanation:** The decrypted code is \\[3+9, 2+3, 4+2, 9+4\\]. Notice that the numbers wrap around again. If k is negative, the sum is of the **previous** numbers.\n\n**Constraints:**\n\n*   `n == code.length`\n*   `1 <= n <= 100`\n*   `1 <= code[i] <= 100`\n*   `-(n - 1) <= k <= n - 1`",
    "A certain bug's home is on the x-axis at position `x`. Help them get there from position `0`.\n\nThe bug jumps according to the following rules:\n\n*   It can jump exactly `a` positions **forward** (to the right).\n*   It can jump exactly `b` positions **backward** (to the left).\n*   It cannot jump backward twice in a row.\n*   It cannot jump to any `forbidden` positions.\n\nThe bug may jump forward **beyond** its home, but it **cannot jump** to positions numbered with **negative** integers.\n\nGiven an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `-1.`\n\n**Example 1:**\n\n**Input:** forbidden = \\[14,4,18,1,15\\], a = 3, b = 15, x = 9\n**Output:** 3\n**Explanation:** 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.\n\n**Example 2:**\n\n**Input:** forbidden = \\[8,3,16,6,12,20\\], a = 15, b = 13, x = 11\n**Output:** -1\n\n**Example 3:**\n\n**Input:** forbidden = \\[1,6,2,14,5,17,4\\], a = 16, b = 9, x = 7\n**Output:** 2\n**Explanation:** One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.\n\n**Constraints:**\n\n*   `1 <= forbidden.length <= 1000`\n*   `1 <= a, b, forbidden[i] <= 2000`\n*   `0 <= x <= 2000`\n*   All the elements in `forbidden` are distinct.\n*   Position `x` is not forbidden.",
    "You are assigned to put some amount of boxes onto **one truck**. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:\n\n*   `numberOfBoxesi` is the number of boxes of type `i`.\n*   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.\n\nYou are also given an integer `truckSize`, which is the **maximum** number of **boxes** that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.\n\nReturn _the **maximum** total number of **units** that can be put on the truck._\n\n**Example 1:**\n\n**Input:** boxTypes = \\[\\[1,3\\],\\[2,2\\],\\[3,1\\]\\], truckSize = 4\n**Output:** 8\n**Explanation:** There are:\n- 1 box of the first type that contains 3 units.\n- 2 boxes of the second type that contain 2 units each.\n- 3 boxes of the third type that contain 1 unit each.\nYou can take all the boxes of the first and second types, and one box of the third type.\nThe total number of units will be = (1 \\* 3) + (2 \\* 2) + (1 \\* 1) = 8.\n\n**Example 2:**\n\n**Input:** boxTypes = \\[\\[5,10\\],\\[2,5\\],\\[4,7\\],\\[3,9\\]\\], truckSize = 10\n**Output:** 91\n\n**Constraints:**\n\n*   `1 <= boxTypes.length <= 1000`\n*   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`\n*   `1 <= truckSize <= 106`",
    "You are given an integer array `jobs`, where `jobs[i]` is the amount of time it takes to complete the `ith` job.\n\nThere are `k` workers that you can assign jobs to. Each job should be assigned to **exactly** one worker. The **working time** of a worker is the sum of the time it takes to complete all jobs assigned to them. Your goal is to devise an optimal assignment such that the **maximum working time** of any worker is **minimized**.\n\n_Return the **minimum** possible **maximum working time** of any assignment._\n\n**Example 1:**\n\n**Input:** jobs = \\[3,2,3\\], k = 3\n**Output:** 3\n**Explanation:** By assigning each person one job, the maximum time is 3.\n\n**Example 2:**\n\n**Input:** jobs = \\[1,2,4,7,8\\], k = 2\n**Output:** 11\n**Explanation:** Assign the jobs the following way:\nWorker 1: 1, 2, 8 (working time = 1 + 2 + 8 = 11)\nWorker 2: 4, 7 (working time = 4 + 7 = 11)\nThe maximum working time is 11.\n\n**Constraints:**\n\n*   `1 <= k <= jobs.length <= 12`\n*   `1 <= jobs[i] <= 107`",
    "A game is played by a cat and a mouse named Cat and Mouse.\n\nThe environment is represented by a `grid` of size `rows x cols`, where each element is a wall, floor, player (Cat, Mouse), or food.\n\n*   Players are represented by the characters `'C'`(Cat)`,'M'`(Mouse).\n*   Floors are represented by the character `'.'` and can be walked on.\n*   Walls are represented by the character `'#'` and cannot be walked on.\n*   Food is represented by the character `'F'` and can be walked on.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n\nMouse and Cat play according to the following rules:\n\n*   Mouse **moves first**, then they take turns to move.\n*   During each turn, Cat and Mouse can jump in one of the four directions (left, right, up, down). They cannot jump over the wall nor outside of the `grid`.\n*   `catJump, mouseJump` are the maximum lengths Cat and Mouse can jump at a time, respectively. Cat and Mouse can jump less than the maximum length.\n*   Staying in the same position is allowed.\n*   Mouse can jump over Cat.\n\nThe game can end in 4 ways:\n\n*   If Cat occupies the same position as Mouse, Cat wins.\n*   If Cat reaches the food first, Cat wins.\n*   If Mouse reaches the food first, Mouse wins.\n*   If Mouse cannot get to the food within 1000 turns, Cat wins.\n\nGiven a `rows x cols` matrix `grid` and two integers `catJump` and `mouseJump`, return `true` _if Mouse can win the game if both Cat and Mouse play optimally, otherwise return_ `false`.\n\n**Example 1:**\n\n**Input:** grid = \\[ \"####F \", \"#C... \", \"M.... \"\\], catJump = 1, mouseJump = 2\n**Output:** true\n**Explanation:** Cat cannot catch Mouse on its turn nor can it get the food before Mouse.\n\n**Example 2:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 4\n**Output:** true\n\n**Example 3:**\n\n**Input:** grid = \\[ \"M.C...F \"\\], catJump = 1, mouseJump = 3\n**Output:** false\n\n**Constraints:**\n\n*   `rows == grid.length`\n*   `cols = grid[i].length`\n*   `1 <= rows, cols <= 8`\n*   `grid[i][j]` consist only of characters `'C'`, `'M'`, `'F'`, `'.'`, and `'#'`.\n*   There is only one of each character `'C'`, `'M'`, and `'F'` in `grid`.\n*   `1 <= catJump, mouseJump <= 8`",
    "You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the **entire** event. Note that the end day is **inclusive**: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn _the **maximum sum** of values that you can receive by attending events._\n\n**Example 1:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,1\\]\\], k = 2\n**Output:** 7\n**Explanation:** Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\n**Example 2:**\n\n**Input:** events = \\[\\[1,2,4\\],\\[3,4,3\\],\\[2,3,10\\]\\], k = 2\n**Output:** 10\n**Explanation:** Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do **not** have to attend k events.\n\n**Example 3:**\n\n**Input:** events = \\[\\[1,1,1\\],\\[2,2,2\\],\\[3,3,3\\],\\[4,4,4\\]\\], k = 3\n**Output:** 9\n**Explanation:** Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n**Constraints:**\n\n*   `1 <= k <= events.length`\n*   `1 <= k * events.length <= 106`\n*   `1 <= startDayi <= endDayi <= 109`\n*   `1 <= valuei <= 106`",
    "There are `n` cars traveling at different speeds in the same direction along a one-lane road. You are given an array `cars` of length `n`, where `cars[i] = [positioni, speedi]` represents:\n\n*   `positioni` is the distance between the `ith` car and the beginning of the road in meters. It is guaranteed that `positioni < positioni+1`.\n*   `speedi` is the initial speed of the `ith` car in meters per second.\n\nFor simplicity, cars can be considered as points moving along the number line. Two cars collide when they occupy the same position. Once a car collides with another car, they unite and form a single car fleet. The cars in the formed fleet will have the same position and the same speed, which is the initial speed of the **slowest** car in the fleet.\n\nReturn an array `answer`, where `answer[i]` is the time, in seconds, at which the `ith` car collides with the next car, or `-1` if the car does not collide with the next car. Answers within `10-5` of the actual answers are accepted.\n\n**Example 1:**\n\n**Input:** cars = \\[\\[1,2\\],\\[2,1\\],\\[4,3\\],\\[7,2\\]\\]\n**Output:** \\[1.00000,-1.00000,3.00000,-1.00000\\]\n**Explanation:** After exactly one second, the first car will collide with the second car, and form a car fleet with speed 1 m/s. After exactly 3 seconds, the third car will collide with the fourth car, and form a car fleet with speed 2 m/s.\n\n**Example 2:**\n\n**Input:** cars = \\[\\[3,4\\],\\[5,4\\],\\[6,3\\],\\[9,1\\]\\]\n**Output:** \\[2.00000,1.00000,1.50000,-1.00000\\]\n\n**Constraints:**\n\n*   `1 <= cars.length <= 105`\n*   `1 <= positioni, speedi <= 106`\n*   `positioni < positioni+1`",
    "There is an undirected weighted connected graph. You are given a positive integer `n` which denotes that the graph has `n` nodes labeled from `1` to `n`, and an array `edges` where each `edges[i] = [ui, vi, weighti]` denotes that there is an edge between nodes `ui` and `vi` with weight equal to `weighti`.\n\nA path from node `start` to node `end` is a sequence of nodes `[z0, z1, z2, ..., zk]` such that `z0 = start` and `zk = end` and there is an edge between `zi` and `zi+1` where `0 <= i <= k-1`.\n\nThe distance of a path is the sum of the weights on the edges of the path. Let `distanceToLastNode(x)` denote the shortest distance of a path between node `n` and node `x`. A **restricted path** is a path that also satisfies that `distanceToLastNode(zi) > distanceToLastNode(zi+1)` where `0 <= i <= k-1`.\n\nReturn _the number of restricted paths from node_ `1` _to node_ `n`. Since that number may be too large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 5, edges = \\[\\[1,2,3\\],\\[1,3,3\\],\\[2,3,1\\],\\[1,4,2\\],\\[5,2,2\\],\\[3,5,1\\],\\[5,4,10\\]\\]\n**Output:** 3\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The three restricted paths are:\n1) 1 --> 2 --> 5\n2) 1 --> 2 --> 3 --> 5\n3) 1 --> 3 --> 5\n\n**Example 2:**\n\n**Input:** n = 7, edges = \\[\\[1,3,1\\],\\[4,1,2\\],\\[7,3,4\\],\\[2,5,3\\],\\[5,6,1\\],\\[6,7,2\\],\\[7,5,3\\],\\[2,6,4\\]\\]\n**Output:** 1\n**Explanation:** Each circle contains the node number in black and its `distanceToLastNode value in blue.` The only restricted path is 1 --> 3 --> 7.\n\n**Constraints:**\n\n*   `1 <= n <= 2 * 104`\n*   `n - 1 <= edges.length <= 4 * 104`\n*   `edges[i].length == 3`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   `1 <= weighti <= 105`\n*   There is at most one edge between any two nodes.\n*   There is at least one path between any two nodes.",
    "You are given `n`\u200b\u200b\u200b\u200b\u200b\u200b tasks labeled from `0` to `n - 1` represented by a 2D integer array `tasks`, where `tasks[i] = [enqueueTimei, processingTimei]` means that the `i\u200b\u200b\u200b\u200b\u200b\u200bth`\u200b\u200b\u200b\u200b task will be available to process at `enqueueTimei` and will take `processingTimei` to finish processing.\n\nYou have a single-threaded CPU that can process **at most one** task at a time and will act in the following way:\n\n*   If the CPU is idle and there are no available tasks to process, the CPU remains idle.\n*   If the CPU is idle and there are available tasks, the CPU will choose the one with the **shortest processing time**. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.\n*   Once a task is started, the CPU will **process the entire task** without stopping.\n*   The CPU can finish a task then start a new one instantly.\n\nReturn _the order in which the CPU will process the tasks._\n\n**Example 1:**\n\n**Input:** tasks = \\[\\[1,2\\],\\[2,4\\],\\[3,2\\],\\[4,1\\]\\]\n**Output:** \\[0,2,3,1\\]\n**Explanation:** The events go as follows: \n- At time = 1, task 0 is available to process. Available tasks = {0}.\n- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.\n- At time = 2, task 1 is available to process. Available tasks = {1}.\n- At time = 3, task 2 is available to process. Available tasks = {1, 2}.\n- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.\n- At time = 4, task 3 is available to process. Available tasks = {1, 3}.\n- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.\n- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.\n- At time = 10, the CPU finishes task 1 and becomes idle.\n\n**Example 2:**\n\n**Input:** tasks = \\[\\[7,10\\],\\[7,12\\],\\[7,5\\],\\[7,4\\],\\[7,2\\]\\]\n**Output:** \\[4,3,2,0,1\\]\n**Explanation****:** The events go as follows:\n- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.\n- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.\n- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.\n- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.\n- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.\n- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.\n- At time = 40, the CPU finishes task 1 and becomes idle.\n\n**Constraints:**\n\n*   `tasks.length == n`\n*   `1 <= n <= 105`\n*   `1 <= enqueueTimei, processingTimei <= 109`",
    "You are given a 2D integer array `logs` where each `logs[i] = [birthi, deathi]` indicates the birth and death years of the `ith` person.\n\nThe **population** of some year `x` is the number of people alive during that year. The `ith` person is counted in year `x`'s population if `x` is in the **inclusive** range `[birthi, deathi - 1]`. Note that the person is **not** counted in the year that they die.\n\nReturn _the **earliest** year with the **maximum population**_.\n\n**Example 1:**\n\n**Input:** logs = \\[\\[1993,1999\\],\\[2000,2010\\]\\]\n**Output:** 1993\n**Explanation:** The maximum population is 1, and 1993 is the earliest year with this population.\n\n**Example 2:**\n\n**Input:** logs = \\[\\[1950,1961\\],\\[1960,1971\\],\\[1970,1981\\]\\]\n**Output:** 1960\n**Explanation:** \nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960.\n\n**Constraints:**\n\n*   `1 <= logs.length <= 100`\n*   `1950 <= birthi < deathi <= 2050`",
    "A **square triple** `(a,b,c)` is a triple where `a`, `b`, and `c` are **integers** and `a2 + b2 = c2`.\n\nGiven an integer `n`, return _the number of **square triples** such that_ `1 <= a, b, c <= n`.\n\n**Example 1:**\n\n**Input:** n = 5\n**Output:** 2\n**Explanation**: The square triples are (3,4,5) and (4,3,5).\n\n**Example 2:**\n\n**Input:** n = 10\n**Output:** 4\n**Explanation**: The square triples are (3,4,5), (4,3,5), (6,8,10), and (8,6,10).\n\n**Constraints:**\n\n*   `1 <= n <= 250`",
    "There is a long and thin painting that can be represented by a number line. The painting was painted with multiple overlapping segments where each segment was painted with a **unique** color. You are given a 2D integer array `segments`, where `segments[i] = [starti, endi, colori]` represents the **half-closed segment** `[starti, endi)` with `colori` as the color.\n\nThe colors in the overlapping segments of the painting were **mixed** when it was painted. When two or more colors mix, they form a new color that can be represented as a **set** of mixed colors.\n\n*   For example, if colors `2`, `4`, and `6` are mixed, then the resulting mixed color is `{2,4,6}`.\n\nFor the sake of simplicity, you should only output the **sum** of the elements in the set rather than the full set.\n\nYou want to **describe** the painting with the **minimum** number of non-overlapping **half-closed segments** of these mixed colors. These segments can be represented by the 2D array `painting` where `painting[j] = [leftj, rightj, mixj]` describes a **half-closed segment** `[leftj, rightj)` with the mixed color **sum** of `mixj`.\n\n*   For example, the painting created with `segments = [[1,4,5],[1,7,7]]` can be described by `painting = [[1,4,12],[4,7,7]]` because:\n    *   `[1,4)` is colored `{5,7}` (with a sum of `12`) from both the first and second segments.\n    *   `[4,7)` is colored `{7}` from only the second segment.\n\nReturn _the 2D array_ `painting` _describing the finished painting (excluding any parts that are **not** painted). You may return the segments in **any order**_.\n\nA **half-closed segment** `[a, b)` is the section of the number line between points `a` and `b` **including** point `a` and **not including** point `b`.\n\n**Example 1:**\n\n**Input:** segments = \\[\\[1,4,5\\],\\[4,7,7\\],\\[1,7,9\\]\\]\n**Output:** \\[\\[1,4,14\\],\\[4,7,16\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,4) is colored {5,9} (with a sum of 14) from the first and third segments.\n- \\[4,7) is colored {7,9} (with a sum of 16) from the second and third segments.\n\n**Example 2:**\n\n**Input:** segments = \\[\\[1,7,9\\],\\[6,8,15\\],\\[8,10,7\\]\\]\n**Output:** \\[\\[1,6,9\\],\\[6,7,24\\],\\[7,8,15\\],\\[8,10,7\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,6) is colored 9 from the first segment.\n- \\[6,7) is colored {9,15} (with a sum of 24) from the first and second segments.\n- \\[7,8) is colored 15 from the second segment.\n- \\[8,10) is colored 7 from the third segment.\n\n**Example 3:**\n\n**Input:** segments = \\[\\[1,4,5\\],\\[1,4,7\\],\\[4,7,1\\],\\[4,7,11\\]\\]\n**Output:** \\[\\[1,4,12\\],\\[4,7,12\\]\\]\n**Explanation:** The painting can be described as follows:\n- \\[1,4) is colored {5,7} (with a sum of 12) from the first and second segments.\n- \\[4,7) is colored {1,11} (with a sum of 12) from the third and fourth segments.\nNote that returning a single segment \\[1,7) is incorrect because the mixed color sets are different.\n\n**Constraints:**\n\n*   `1 <= segments.length <= 2 * 104`\n*   `segments[i].length == 3`\n*   `1 <= starti < endi <= 105`\n*   `1 <= colori <= 109`\n*   Each `colori` is distinct.",
    "There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in **left to right** order. You are given an array `heights` of **distinct** integers where `heights[i]` represents the height of the `ith` person.\n\nA person can **see** another person to their right in the queue if everybody in between is **shorter** than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`.\n\nReturn _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the **number of people** the_ `ith` _person can **see** to their right in the queue_.\n\n**Example 1:**\n\n**Input:** heights = \\[10,6,8,5,11,9\\]\n**Output:** \\[3,1,2,1,1,0\\]\n**Explanation:**\nPerson 0 can see person 1, 2, and 4.\nPerson 1 can see person 2.\nPerson 2 can see person 3 and 4.\nPerson 3 can see person 4.\nPerson 4 can see person 5.\nPerson 5 can see no one since nobody is to the right of them.\n\n**Example 2:**\n\n**Input:** heights = \\[5,1,2,3,10\\]\n**Output:** \\[4,1,1,1,0\\]\n\n**Constraints:**\n\n*   `n == heights.length`\n*   `1 <= n <= 105`\n*   `1 <= heights[i] <= 105`\n*   All the values of `heights` are **unique**.",
    "Given an integer `n`, return `true` _if_ `n` _has **exactly three positive divisors**. Otherwise, return_ `false`.\n\nAn integer `m` is a **divisor** of `n` if there exists an integer `k` such that `n = k * m`.\n\n**Example 1:**\n\n**Input:** n = 2\n**Output:** false\n**Explantion:** 2 has only two divisors: 1 and 2.\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:** true\n**Explantion:** 4 has three divisors: 1, 2, and 4.\n\n**Constraints:**\n\n*   `1 <= n <= 104`",
    "You want to build some obstacle courses. You are given a **0-indexed** integer array `obstacles` of length `n`, where `obstacles[i]` describes the height of the `ith` obstacle.\n\nFor every index `i` between `0` and `n - 1` (**inclusive**), find the length of the **longest obstacle course** in `obstacles` such that:\n\n*   You choose any number of obstacles between `0` and `i` **inclusive**.\n*   You must include the `ith` obstacle in the course.\n*   You must put the chosen obstacles in the **same order** as they appear in `obstacles`.\n*   Every obstacle (except the first) is **taller** than or the **same height** as the obstacle immediately before it.\n\nReturn _an array_ `ans` _of length_ `n`, _where_ `ans[i]` _is the length of the **longest obstacle course** for index_ `i` _as described above_.\n\n**Example 1:**\n\n**Input:** obstacles = \\[1,2,3,2\\]\n**Output:** \\[1,2,3,3\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[1\\], \\[1\\] has length 1.\n- i = 1: \\[1,2\\], \\[1,2\\] has length 2.\n- i = 2: \\[1,2,3\\], \\[1,2,3\\] has length 3.\n- i = 3: \\[1,2,3,2\\], \\[1,2,2\\] has length 3.\n\n**Example 2:**\n\n**Input:** obstacles = \\[2,2,1\\]\n**Output:** \\[1,2,1\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[2\\], \\[2\\] has length 1.\n- i = 1: \\[2,2\\], \\[2,2\\] has length 2.\n- i = 2: \\[2,2,1\\], \\[1\\] has length 1.\n\n**Example 3:**\n\n**Input:** obstacles = \\[3,1,5,6,4,2\\]\n**Output:** \\[1,1,2,3,2,2\\]\n**Explanation:** The longest valid obstacle course at each position is:\n- i = 0: \\[3\\], \\[3\\] has length 1.\n- i = 1: \\[3,1\\], \\[1\\] has length 1.\n- i = 2: \\[3,1,5\\], \\[3,5\\] has length 2. \\[1,5\\] is also valid.\n- i = 3: \\[3,1,5,6\\], \\[3,5,6\\] has length 3. \\[1,5,6\\] is also valid.\n- i = 4: \\[3,1,5,6,4\\], \\[3,4\\] has length 2. \\[1,4\\] is also valid.\n- i = 5: \\[3,1,5,6,4,2\\], \\[1,2\\] has length 2.\n\n**Constraints:**\n\n*   `n == obstacles.length`\n*   `1 <= n <= 105`\n*   `1 <= obstacles[i] <= 107`",
    "You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with **bi-directional** roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.\n\nYou are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the **shortest amount of time**.\n\nReturn _the **number of ways** you can arrive at your destination in the **shortest amount of time**_. Since the answer may be large, return it **modulo** `109 + 7`.\n\n**Example 1:**\n\n**Input:** n = 7, roads = \\[\\[0,6,7\\],\\[0,1,2\\],\\[1,2,3\\],\\[1,3,3\\],\\[6,3,3\\],\\[3,5,1\\],\\[6,5,1\\],\\[2,5,1\\],\\[0,4,5\\],\\[4,6,2\\]\\]\n**Output:** 4\n**Explanation:** The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.\nThe four ways to get there in 7 minutes are:\n- 0 \u279d 6\n- 0 \u279d 4 \u279d 6\n- 0 \u279d 1 \u279d 2 \u279d 5 \u279d 6\n- 0 \u279d 1 \u279d 3 \u279d 5 \u279d 6\n\n**Example 2:**\n\n**Input:** n = 2, roads = \\[\\[1,0,10\\]\\]\n**Output:** 1\n**Explanation:** There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.\n\n**Constraints:**\n\n*   `1 <= n <= 200`\n*   `n - 1 <= roads.length <= n * (n - 1) / 2`\n*   `roads[i].length == 3`\n*   `0 <= ui, vi <= n - 1`\n*   `1 <= timei <= 109`\n*   `ui != vi`\n*   There is at most one road connecting any two intersections.\n*   You can reach any intersection from any other intersection.",
    "You are given a **0-indexed** integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.\n\nPick the scores of any `k` students from the array so that the **difference** between the **highest** and the **lowest** of the `k` scores is **minimized**.\n\nReturn _the **minimum** possible difference_.\n\n**Example 1:**\n\n**Input:** nums = \\[90\\], k = 1\n**Output:** 0\n**Explanation:** There is one way to pick score(s) of one student:\n- \\[**90**\\]. The difference between the highest and lowest score is 90 - 90 = 0.\nThe minimum possible difference is 0.\n\n**Example 2:**\n\n**Input:** nums = \\[9,4,1,7\\], k = 2\n**Output:** 2\n**Explanation:** There are six ways to pick score(s) of two students:\n- \\[**9**,**4**,1,7\\]. The difference between the highest and lowest score is 9 - 4 = 5.\n- \\[**9**,4,**1**,7\\]. The difference between the highest and lowest score is 9 - 1 = 8.\n- \\[**9**,4,1,**7**\\]. The difference between the highest and lowest score is 9 - 7 = 2.\n- \\[9,**4**,**1**,7\\]. The difference between the highest and lowest score is 4 - 1 = 3.\n- \\[9,**4**,1,**7**\\]. The difference between the highest and lowest score is 7 - 4 = 3.\n- \\[9,4,**1**,**7**\\]. The difference between the highest and lowest score is 7 - 1 = 6.\nThe minimum possible difference is 2.\n\n**Constraints:**\n\n*   `1 <= k <= nums.length <= 1000`\n*   `0 <= nums[i] <= 105`",
    "There are `n` tasks assigned to you. The task times are represented as an integer array `tasks` of length `n`, where the `ith` task takes `tasks[i]` hours to finish. A **work session** is when you work for **at most** `sessionTime` consecutive hours and then take a break.\n\nYou should finish the given tasks in a way that satisfies the following conditions:\n\n*   If you start a task in a work session, you must complete it in the **same** work session.\n*   You can start a new task **immediately** after finishing the previous one.\n*   You may complete the tasks in **any order**.\n\nGiven `tasks` and `sessionTime`, return _the **minimum** number of **work sessions** needed to finish all the tasks following the conditions above._\n\nThe tests are generated such that `sessionTime` is **greater** than or **equal** to the **maximum** element in `tasks[i]`.\n\n**Example 1:**\n\n**Input:** tasks = \\[1,2,3\\], sessionTime = 3\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish the first and the second tasks in 1 + 2 = 3 hours.\n- Second work session: finish the third task in 3 hours.\n\n**Example 2:**\n\n**Input:** tasks = \\[3,1,3,1,1\\], sessionTime = 8\n**Output:** 2\n**Explanation:** You can finish the tasks in two work sessions.\n- First work session: finish all the tasks except the last one in 3 + 1 + 3 + 1 = 8 hours.\n- Second work session: finish the last task in 1 hour.\n\n**Example 3:**\n\n**Input:** tasks = \\[1,2,3,4,5\\], sessionTime = 15\n**Output:** 1\n**Explanation:** You can finish all the tasks in one work session.\n\n**Constraints:**\n\n*   `n == tasks.length`\n*   `1 <= n <= 14`\n*   `1 <= tasks[i] <= 10`\n*   `max(tasks[i]) <= sessionTime <= 15`",
    "You are playing a game that contains multiple characters, and each of the characters has **two** main properties: **attack** and **defense**. You are given a 2D integer array `properties` where `properties[i] = [attacki, defensei]` represents the properties of the `ith` character in the game.\n\nA character is said to be **weak** if any other character has **both** attack and defense levels **strictly greater** than this character's attack and defense levels. More formally, a character `i` is said to be **weak** if there exists another character `j` where `attackj > attacki` and `defensej > defensei`.\n\nReturn _the number of **weak** characters_.\n\n**Example 1:**\n\n**Input:** properties = \\[\\[5,5\\],\\[6,3\\],\\[3,6\\]\\]\n**Output:** 0\n**Explanation:** No character has strictly greater attack and defense than the other.\n\n**Example 2:**\n\n**Input:** properties = \\[\\[2,2\\],\\[3,3\\]\\]\n**Output:** 1\n**Explanation:** The first character is weak because the second character has a strictly greater attack and defense.\n\n**Example 3:**\n\n**Input:** properties = \\[\\[1,5\\],\\[10,4\\],\\[4,3\\]\\]\n**Output:** 1\n**Explanation:** The third character is weak because the second character has a strictly greater attack and defense.\n\n**Constraints:**\n\n*   `2 <= properties.length <= 105`\n*   `properties[i].length == 2`\n*   `1 <= attacki, defensei <= 105`",
    "There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi.\n\nThe passengers are represented by a **0-indexed** 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip.\n\nFor **each** passenger `i` you pick up, you **earn** `endi - starti + tipi` dollars. You may only drive **at most one** passenger at a time.\n\nGiven `n` and `rides`, return _the **maximum** number of dollars you can earn by picking up the passengers optimally._\n\n**Note:** You may drop off a passenger and pick up a different passenger at the same point.\n\n**Example 1:**\n\n**Input:** n = 5, rides = \\[\\[2,5,4\\],\\[1,5,1\\]\\]\n**Output:** 7\n**Explanation:** We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.\n\n**Example 2:**\n\n**Input:** n = 20, rides = \\[\\[1,6,1\\],\\[3,10,2\\],\\[10,12,3\\],\\[11,12,2\\],\\[12,15,2\\],\\[13,18,1\\]\\]\n**Output:** 20\n**Explanation:** We will pick up the following passengers:\n- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.\n- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.\n- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.\nWe earn 9 + 5 + 6 = 20 dollars in total.\n\n**Constraints:**\n\n*   `1 <= n <= 105`\n*   `1 <= rides.length <= 3 * 104`\n*   `rides[i].length == 3`\n*   `1 <= starti < endi <= n`\n*   `1 <= tipi <= 105`",
    "You have observations of `n + m` **6-sided** dice rolls with each face numbered from `1` to `6`. `n` of the observations went missing, and you only have the observations of `m` rolls. Fortunately, you have also calculated the **average value** of the `n + m` rolls.\n\nYou are given an integer array `rolls` of length `m` where `rolls[i]` is the value of the `ith` observation. You are also given the two integers `mean` and `n`.\n\nReturn _an array of length_ `n` _containing the missing observations such that the **average value** of the_ `n + m` _rolls is **exactly**_ `mean`. If there are multiple valid answers, return _any of them_. If no such array exists, return _an empty array_.\n\nThe **average value** of a set of `k` numbers is the sum of the numbers divided by `k`.\n\nNote that `mean` is an integer, so the sum of the `n + m` rolls should be divisible by `n + m`.\n\n**Example 1:**\n\n**Input:** rolls = \\[3,2,4,3\\], mean = 4, n = 2\n**Output:** \\[6,6\\]\n**Explanation:** The mean of all n + m rolls is (3 + 2 + 4 + 3 + 6 + 6) / 6 = 4.\n\n**Example 2:**\n\n**Input:** rolls = \\[1,5,6\\], mean = 3, n = 4\n**Output:** \\[2,3,2,2\\]\n**Explanation:** The mean of all n + m rolls is (1 + 5 + 6 + 2 + 3 + 2 + 2) / 7 = 3.\n\n**Example 3:**\n\n**Input:** rolls = \\[1,2,3,4\\], mean = 6, n = 4\n**Output:** \\[\\]\n**Explanation:** It is impossible for the mean to be 6 no matter what the 4 missing rolls are.\n\n**Constraints:**\n\n*   `m == rolls.length`\n*   `1 <= n, m <= 105`\n*   `1 <= rolls[i], mean <= 6`",
    "A city is represented as a **bi-directional connected** graph with `n` vertices where each vertex is labeled from `1` to `n` (**inclusive**). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.\n\nEach vertex has a traffic signal which changes its color from **green** to **red** and vice versa every `change` minutes. All signals change **at the same time**. You can enter a vertex at **any time**, but can leave a vertex **only when the signal is green**. You **cannot wait** at a vertex if the signal is **green**.\n\nThe **second minimum value** is defined as the smallest value **strictly larger** than the minimum value.\n\n*   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.\n\nGiven `n`, `edges`, `time`, and `change`, return _the **second minimum time** it will take to go from vertex_ `1` _to vertex_ `n`.\n\n**Notes:**\n\n*   You can go through any vertex **any** number of times, **including** `1` and `n`.\n*   You can assume that when the journey **starts**, all signals have just turned **green**.\n\n**Example 1:**\n\n\u2003 \u2003 \u2003 \u2003\n\n**Input:** n = 5, edges = \\[\\[1,2\\],\\[1,3\\],\\[1,4\\],\\[3,4\\],\\[4,5\\]\\], time = 3, change = 5\n**Output:** 13\n**Explanation:**\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n**Example 2:**\n\n**Input:** n = 2, edges = \\[\\[1,2\\]\\], time = 3, change = 2\n**Output:** 11\n**Explanation:**\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n**Constraints:**\n\n*   `2 <= n <= 104`\n*   `n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)`\n*   `edges[i].length == 2`\n*   `1 <= ui, vi <= n`\n*   `ui != vi`\n*   There are no duplicate edges.\n*   Each vertex can be reached directly or indirectly from every other vertex.\n*   `1 <= time, change <= 103`",
    "There is a **binary** tree rooted at `0` consisting of `n` nodes. The nodes are labeled from `0` to `n - 1`. You are given a **0-indexed** integer array `parents` representing the tree, where `parents[i]` is the parent of node `i`. Since node `0` is the root, `parents[0] == -1`.\n\nEach node has a **score**. To find the score of a node, consider if the node and the edges connected to it were **removed**. The tree would become one or more **non-empty** subtrees. The **size** of a subtree is the number of the nodes in it. The **score** of the node is the **product of the sizes** of all those subtrees.\n\nReturn _the **number** of nodes that have the **highest score**_.\n\n**Example 1:**\n\n**Input:** parents = \\[-1,2,0,2,0\\]\n**Output:** 3\n**Explanation:**\n- The score of node 0 is: 3 \\* 1 = 3\n- The score of node 1 is: 4 = 4\n- The score of node 2 is: 1 \\* 1 \\* 2 = 2\n- The score of node 3 is: 4 = 4\n- The score of node 4 is: 4 = 4\nThe highest score is 4, and three nodes (node 1, node 3, and node 4) have the highest score.\n\n**Example 2:**\n\n**Input:** parents = \\[-1,2,0\\]\n**Output:** 2\n**Explanation:**\n- The score of node 0 is: 2 = 2\n- The score of node 1 is: 2 = 2\n- The score of node 2 is: 1 \\* 1 = 1\nThe highest score is 2, and two nodes (node 0 and node 1) have the highest score.\n\n**Constraints:**\n\n*   `n == parents.length`\n*   `2 <= n <= 105`\n*   `parents[0] == -1`\n*   `0 <= parents[i] <= n - 1` for `i != 0`\n*   `parents` represents a valid binary tree.",
    "You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed **before** course `nextCoursej` (prerequisite relationship). Furthermore, you are given a **0-indexed** integer array `time` where `time[i]` denotes how many **months** it takes to complete the `(i+1)th` course.\n\nYou must find the **minimum** number of months needed to complete all the courses following these rules:\n\n*   You may start taking a course at **any time** if the prerequisites are met.\n*   **Any number of courses** can be taken at the **same time**.\n\nReturn _the **minimum** number of months needed to complete all the courses_.\n\n**Note:** The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n**Example 1:**\n\n**Input:** n = 3, relations = \\[\\[1,3\\],\\[2,3\\]\\], time = \\[3,2,5\\]\n**Output:** 8\n**Explanation:** The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n**Example 2:**\n\n**Input:** n = 5, relations = \\[\\[1,5\\],\\[2,5\\],\\[3,5\\],\\[3,4\\],\\[4,5\\]\\], time = \\[1,2,3,4,5\\]\n**Output:** 12\n**Explanation:** The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n**Constraints:**\n\n*   `1 <= n <= 5 * 104`\n*   `0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)`\n*   `relations[j].length == 2`\n*   `1 <= prevCoursej, nextCoursej <= n`\n*   `prevCoursej != nextCoursej`\n*   All the pairs `[prevCoursej, nextCoursej]` are **unique**.\n*   `time.length == n`\n*   `1 <= time[i] <= 104`\n*   The given graph is a directed acyclic graph.",
    "You want to water `n` plants in your garden with a watering can. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`. There is a river at `x = -1` that you can refill your watering can at.\n\nEach plant needs a specific amount of water. You will water the plants in the following way:\n\n*   Water the plants in order from left to right.\n*   After watering the current plant, if you do not have enough water to **completely** water the next plant, return to the river to fully refill the watering can.\n*   You **cannot** refill the watering can early.\n\nYou are initially at the river (i.e., `x = -1`). It takes **one step** to move **one unit** on the x-axis.\n\nGiven a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and an integer `capacity` representing the watering can capacity, return _the **number of steps** needed to water all the plants_.\n\n**Example 1:**\n\n**Input:** plants = \\[2,2,3,3\\], capacity = 5\n**Output:** 14\n**Explanation:** Start at the river with a full watering can:\n- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.\n- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.\n- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).\n- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.\n- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).\n- Walk to plant 3 (4 steps) and water it.\nSteps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.\n\n**Example 2:**\n\n**Input:** plants = \\[1,1,1,4,2,3\\], capacity = 4\n**Output:** 30\n**Explanation:** Start at the river with a full watering can:\n- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).\n- Water plant 3 (4 steps). Return to river (4 steps).\n- Water plant 4 (5 steps). Return to river (5 steps).\n- Water plant 5 (6 steps).\nSteps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.\n\n**Example 3:**\n\n**Input:** plants = \\[7,7,7,7,7,7,7\\], capacity = 8\n**Output:** 49\n**Explanation:** You have to refill before watering each plant.\nSteps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.\n\n**Constraints:**\n\n*   `n == plants.length`\n*   `1 <= n <= 1000`\n*   `1 <= plants[i] <= 106`\n*   `max(plants[i]) <= capacity <= 109`",
    "You and a gang of thieves are planning on robbing a bank. You are given a **0-indexed** integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`.\n\nThe `ith` day is a good day to rob the bank if:\n\n*   There are at least `time` days before and after the `ith` day,\n*   The number of guards at the bank for the `time` days **before** `i` are **non-increasing**, and\n*   The number of guards at the bank for the `time` days **after** `i` are **non-decreasing**.\n\nMore formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]`.\n\nReturn _a list of **all** days **(0-indexed)** that are good days to rob the bank_. _The order that the days are returned in does **not** matter._\n\n**Example 1:**\n\n**Input:** security = \\[5,3,3,3,5,6,2\\], time = 2\n**Output:** \\[2,3\\]\n**Explanation:**\nOn day 2, we have security\\[0\\] >= security\\[1\\] >= security\\[2\\] <= security\\[3\\] <= security\\[4\\].\nOn day 3, we have security\\[1\\] >= security\\[2\\] >= security\\[3\\] <= security\\[4\\] <= security\\[5\\].\nNo other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.\n\n**Example 2:**\n\n**Input:** security = \\[1,1,1,1,1\\], time = 0\n**Output:** \\[0,1,2,3,4\\]\n**Explanation:**\nSince time equals 0, every day is a good day to rob the bank, so return every day.\n\n**Example 3:**\n\n**Input:** security = \\[1,2,3,4,5,6\\], time = 2\n**Output:** \\[\\]\n**Explanation:**\nNo day has 2 days before it that have a non-increasing number of guards.\nThus, no day is a good day to rob the bank, so return an empty list.\n\n**Constraints:**\n\n*   `1 <= security.length <= 105`\n*   `0 <= security[i], time <= 105`",
    "You are given a list of bombs. The **range** of a bomb is defined as the area where its effect can be felt. This area is in the shape of a **circle** with the center as the location of the bomb.\n\nThe bombs are represented by a **0-indexed** 2D integer array `bombs` where `bombs[i] = [xi, yi, ri]`. `xi` and `yi` denote the X-coordinate and Y-coordinate of the location of the `ith` bomb, whereas `ri` denotes the **radius** of its range.\n\nYou may choose to detonate a **single** bomb. When a bomb is detonated, it will detonate **all bombs** that lie in its range. These bombs will further detonate the bombs that lie in their ranges.\n\nGiven the list of `bombs`, return _the **maximum** number of bombs that can be detonated if you are allowed to detonate **only one** bomb_.\n\n**Example 1:**\n\n**Input:** bombs = \\[\\[2,1,3\\],\\[6,1,4\\]\\]\n**Output:** 2\n**Explanation:**\nThe above figure shows the positions and ranges of the 2 bombs.\nIf we detonate the left bomb, the right bomb will not be affected.\nBut if we detonate the right bomb, both bombs will be detonated.\nSo the maximum bombs that can be detonated is max(1, 2) = 2.\n\n**Example 2:**\n\n**Input:** bombs = \\[\\[1,1,5\\],\\[10,10,5\\]\\]\n**Output:** 1\n**Explanation:**\nDetonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.\n\n**Example 3:**\n\n**Input:** bombs = \\[\\[1,2,3\\],\\[2,3,1\\],\\[3,4,2\\],\\[4,5,3\\],\\[5,6,4\\]\\]\n**Output:** 5\n**Explanation:**\nThe best bomb to detonate is bomb 0 because:\n- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.\n- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.\n- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.\nThus all 5 bombs are detonated.\n\n**Constraints:**\n\n*   `1 <= bombs.length <= 100`\n*   `bombs[i].length == 3`\n*   `1 <= xi, yi, ri <= 105`",
    "There are `n` rings and each ring is either red, green, or blue. The rings are distributed **across ten rods** labeled from `0` to `9`.\n\nYou are given a string `rings` of length `2n` that describes the `n` rings that are placed onto the rods. Every two characters in `rings` forms a **color-position pair** that is used to describe each ring where:\n\n*   The **first** character of the `ith` pair denotes the `ith` ring's **color** (`'R'`, `'G'`, `'B'`).\n*   The **second** character of the `ith` pair denotes the **rod** that the `ith` ring is placed on (`'0'` to `'9'`).\n\nFor example, `\"R3G2B1 \"` describes `n == 3` rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n\nReturn _the number of rods that have **all three colors** of rings on them._\n\n**Example 1:**\n\n**Input:** rings =  \"B0B6G0R6R0R6G9 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.\n- The rod labeled 6 holds 3 rings, but it only has red and blue.\n- The rod labeled 9 holds only a green ring.\nThus, the number of rods with all three colors is 1.\n\n**Example 2:**\n\n**Input:** rings =  \"B0R0G0R9R0B0G0 \"\n**Output:** 1\n**Explanation:** \n- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.\n- The rod labeled 9 holds only a red ring.\nThus, the number of rods with all three colors is 1.\n\n**Example 3:**\n\n**Input:** rings =  \"G4 \"\n**Output:** 0\n**Explanation:** \nOnly one ring is given. Thus, no rods have all three colors.\n\n**Constraints:**\n\n*   `rings.length == 2 * n`\n*   `1 <= n <= 100`\n*   `rings[i]` where `i` is **even** is either `'R'`, `'G'`, or `'B'` (**0-indexed**).\n*   `rings[i]` where `i` is **odd** is a digit from `'0'` to `'9'` (**0-indexed**).",
    "Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`.\n\nEach plant needs a specific amount of water. Alice and Bob have a watering can each, **initially full**. They water the plants in the following way:\n\n*   Alice waters the plants in order from **left to right**, starting from the `0th` plant. Bob waters the plants in order from **right to left**, starting from the `(n - 1)th` plant. They begin watering the plants **simultaneously**.\n*   It takes the same amount of time to water each plant regardless of how much water it needs.\n*   Alice/Bob **must** water the plant if they have enough in their can to **fully** water it. Otherwise, they **first** refill their can (instantaneously) then water the plant.\n*   In case both Alice and Bob reach the same plant, the one with **more** water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.\n\nGiven a **0-indexed** integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the **number of times** they have to refill to water all the plants_.\n\n**Example 1:**\n\n**Input:** plants = \\[2,2,3,3\\], capacityA = 5, capacityB = 5\n**Output:** 1\n**Explanation:**\n- Initially, Alice and Bob have 5 units of water each in their watering cans.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 3 units and 2 units of water respectively.\n- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.\nSo, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.\n\n**Example 2:**\n\n**Input:** plants = \\[2,2,3,3\\], capacityA = 3, capacityB = 4\n**Output:** 2\n**Explanation:**\n- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.\n- Alice waters plant 0, Bob waters plant 3.\n- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.\n- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.\nSo, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.\n\n**Example 3:**\n\n**Input:** plants = \\[5\\], capacityA = 10, capacityB = 8\n**Output:** 0\n**Explanation:**\n- There is only one plant.\n- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.\nSo, the total number of times they have to refill is 0.\n\n**Constraints:**\n\n*   `n == plants.length`\n*   `1 <= n <= 105`\n*   `1 <= plants[i] <= 106`\n*   `max(plants[i]) <= capacityA, capacityB <= 109`",
    "Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already **sorted** by `positioni` in **ascending order**, and each `positioni` is **unique**.\n\nYou are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the **left or right**. It takes **one step** to move **one unit** on the x-axis, and you can walk **at most** `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.\n\nReturn _the **maximum total number** of fruits you can harvest_.\n\n**Example 1:**\n\n**Input:** fruits = \\[\\[2,8\\],\\[6,3\\],\\[8,6\\]\\], startPos = 5, k = 4\n**Output:** 9\n**Explanation:** \nThe optimal way is to:\n- Move right to position 6 and harvest 3 fruits\n- Move right to position 8 and harvest 6 fruits\nYou moved 3 steps and harvested 3 + 6 = 9 fruits in total.\n\n**Example 2:**\n\n**Input:** fruits = \\[\\[0,9\\],\\[4,1\\],\\[5,7\\],\\[6,2\\],\\[7,4\\],\\[10,9\\]\\], startPos = 5, k = 4\n**Output:** 14\n**Explanation:** \nYou can move at most k = 4 steps, so you cannot reach position 0 nor 10.\nThe optimal way is to:\n- Harvest the 7 fruits at the starting position 5\n- Move left to position 4 and harvest 1 fruit\n- Move right to position 6 and harvest 2 fruits\n- Move right to position 7 and harvest 4 fruits\nYou moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.\n\n**Example 3:**\n\n**Input:** fruits = \\[\\[0,3\\],\\[6,4\\],\\[8,5\\]\\], startPos = 3, k = 2\n**Output:** 0\n**Explanation:**\nYou can move at most k = 2 steps and cannot reach any position with fruits.\n\n**Constraints:**\n\n*   `1 <= fruits.length <= 105`\n*   `fruits[i].length == 2`\n*   `0 <= startPos, positioni <= 2 * 105`\n*   `positioni-1 < positioni` for any `i > 0` (**0-indexed**)\n*   `1 <= amounti <= 104`\n*   `0 <= k <= 2 * 105`",
    "You are given an integer array `prices` representing the daily price history of a stock, where `prices[i]` is the stock price on the `ith` day.\n\nA **smooth descent period** of a stock consists of **one or more contiguous** days such that the price on each day is **lower** than the price on the **preceding day** by **exactly** `1`. The first day of the period is exempted from this rule.\n\nReturn _the number of **smooth descent periods**_.\n\n**Example 1:**\n\n**Input:** prices = \\[3,2,1,4\\]\n**Output:** 7\n**Explanation:** There are 7 smooth descent periods:\n\\[3\\], \\[2\\], \\[1\\], \\[4\\], \\[3,2\\], \\[2,1\\], and \\[3,2,1\\]\nNote that a period with one day is a smooth descent period by the definition.\n\n**Example 2:**\n\n**Input:** prices = \\[8,6,7,7\\]\n**Output:** 4\n**Explanation:** There are 4 smooth descent periods: \\[8\\], \\[6\\], \\[7\\], and \\[7\\]\nNote that \\[8,6\\] is not a smooth descent period as 8 - 6 \u2260 1.\n\n**Example 3:**\n\n**Input:** prices = \\[1\\]\n**Output:** 1\n**Explanation:** There is 1 smooth descent period: \\[1\\]\n\n**Constraints:**\n\n*   `1 <= prices.length <= 105`\n*   `1 <= prices[i] <= 105`",
    "Anti-theft security devices are activated inside a bank. You are given a **0-indexed** binary string array `bank` representing the floor plan of the bank, which is an `m x n` 2D matrix. `bank[i]` represents the `ith` row, consisting of `'0'`s and `'1'`s. `'0'` means the cell is empty, while`'1'` means the cell has a security device.\n\nThere is **one** laser beam between any **two** security devices **if both** conditions are met:\n\n*   The two devices are located on two **different rows**: `r1` and `r2`, where `r1 < r2`.\n*   For **each** row `i` where `r1 < i < r2`, there are **no security devices** in the `ith` row.\n\nLaser beams are independent, i.e., one beam does not interfere nor join with another.\n\nReturn _the total number of laser beams in the bank_.\n\n**Example 1:**\n\n**Input:** bank = \\[ \"011001 \", \"000000 \", \"010100 \", \"001000 \"\\]\n**Output:** 8\n**Explanation:** Between each of the following device pairs, there is one beam. In total, there are 8 beams:\n \\* bank\\[0\\]\\[1\\] -- bank\\[2\\]\\[1\\]\n \\* bank\\[0\\]\\[1\\] -- bank\\[2\\]\\[3\\]\n \\* bank\\[0\\]\\[2\\] -- bank\\[2\\]\\[1\\]\n \\* bank\\[0\\]\\[2\\] -- bank\\[2\\]\\[3\\]\n \\* bank\\[0\\]\\[5\\] -- bank\\[2\\]\\[1\\]\n \\* bank\\[0\\]\\[5\\] -- bank\\[2\\]\\[3\\]\n \\* bank\\[2\\]\\[1\\] -- bank\\[3\\]\\[2\\]\n \\* bank\\[2\\]\\[3\\] -- bank\\[3\\]\\[2\\]\nNote that there is no beam between any device on the 0th row with any on the 3rd row.\nThis is because the 2nd row contains security devices, which breaks the second condition.\n\n**Example 2:**\n\n**Input:** bank = \\[ \"000 \", \"111 \", \"000 \"\\]\n**Output:** 0\n**Explanation:** There does not exist two devices located on two different rows.\n\n**Constraints:**\n\n*   `m == bank.length`\n*   `n == bank[i].length`\n*   `1 <= m, n <= 500`\n*   `bank[i][j]` is either `'0'` or `'1'`.",
    "You are given a **0-indexed** 2D integer array `grid` of size `m x n` that represents a map of the items in a shop. The integers in the grid represent the following:\n\n*   `0` represents a wall that you cannot pass through.\n*   `1` represents an empty cell that you can freely move to and from.\n*   All other positive integers represent the price of an item in that cell. You may also freely move to and from these item cells.\n\nIt takes `1` step to travel between adjacent grid cells.\n\nYou are also given integer arrays `pricing` and `start` where `pricing = [low, high]` and `start = [row, col]` indicates that you start at the position `(row, col)` and are interested only in items with a price in the range of `[low, high]` (**inclusive**). You are further given an integer `k`.\n\nYou are interested in the **positions** of the `k` **highest-ranked** items whose prices are **within** the given price range. The rank is determined by the **first** of these criteria that is different:\n\n1.  Distance, defined as the length of the shortest path from the `start` (**shorter** distance has a higher rank).\n2.  Price (**lower** price has a higher rank, but it must be **in the price range**).\n3.  The row number (**smaller** row number has a higher rank).\n4.  The column number (**smaller** column number has a higher rank).\n\nReturn _the_ `k` _highest-ranked items within the price range **sorted** by their rank (highest to lowest)_. If there are fewer than `k` reachable items within the price range, return _**all** of them_.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,2,0,1\\],\\[1,3,0,1\\],\\[0,2,5,1\\]\\], pricing = \\[2,5\\], start = \\[0,0\\], k = 3\n**Output:** \\[\\[0,1\\],\\[1,1\\],\\[2,1\\]\\]\n**Explanation:** You start at (0,0).\nWith a price range of \\[2,5\\], we can take items from (0,1), (1,1), (2,1) and (2,2).\nThe ranks of these items are:\n- (0,1) with distance 1\n- (1,1) with distance 2\n- (2,1) with distance 3\n- (2,2) with distance 4\nThus, the 3 highest ranked items in the price range are (0,1), (1,1), and (2,1).\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1,2,0,1\\],\\[1,3,3,1\\],\\[0,2,5,1\\]\\], pricing = \\[2,3\\], start = \\[2,3\\], k = 2\n**Output:** \\[\\[2,1\\],\\[1,2\\]\\]\n**Explanation:** You start at (2,3).\nWith a price range of \\[2,3\\], we can take items from (0,1), (1,1), (1,2) and (2,1).\nThe ranks of these items are:\n- (2,1) with distance 2, price 2\n- (1,2) with distance 2, price 3\n- (1,1) with distance 3\n- (0,1) with distance 4\nThus, the 2 highest ranked items in the price range are (2,1) and (1,2).\n\n**Example 3:**\n\n**Input:** grid = \\[\\[1,1,1\\],\\[0,0,1\\],\\[2,3,4\\]\\], pricing = \\[2,3\\], start = \\[0,0\\], k = 3\n**Output:** \\[\\[2,1\\],\\[2,0\\]\\]\n**Explanation:** You start at (0,0).\nWith a price range of \\[2,3\\], we can take items from (2,0) and (2,1). \nThe ranks of these items are: \n- (2,1) with distance 5\n- (2,0) with distance 6\nThus, the 2 highest ranked items in the price range are (2,1) and (2,0). \nNote that k = 3 but there are only 2 reachable items within the price range.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `0 <= grid[i][j] <= 105`\n*   `pricing.length == 2`\n*   `2 <= low <= high <= 105`\n*   `start.length == 2`\n*   `0 <= row <= m - 1`\n*   `0 <= col <= n - 1`\n*   `grid[row][col] > 0`\n*   `1 <= k <= m * n`",
    "Along a long library corridor, there is a line of seats and decorative plants. You are given a **0-indexed** string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.\n\nOne room divider has **already** been installed to the left of index `0`, and **another** to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections, where each section has **exactly two seats** with any number of plants. There may be multiple ways to perform the division. Two ways are **different** if there is a position with a room divider installed in the first way but not in the second way.\n\nReturn _the number of ways to divide the corridor_. Since the answer may be very large, return it **modulo** `109 + 7`. If there is no way, return `0`.\n\n**Example 1:**\n\n**Input:** corridor =  \"SSPPSPS \"\n**Output:** 3\n**Explanation:** There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, **each** section has exactly **two** seats.\n\n**Example 2:**\n\n**Input:** corridor =  \"PPSPSP \"\n**Output:** 1\n**Explanation:** There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n**Example 3:**\n\n**Input:** corridor =  \"S \"\n**Output:** 0\n**Explanation:** There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n**Constraints:**\n\n*   `n == corridor.length`\n*   `1 <= n <= 105`\n*   `corridor[i]` is either `'S'` or `'P'`.",
    "A generic microwave supports cooking times for:\n\n*   at least `1` second.\n*   at most `99` minutes and `99` seconds.\n\nTo set the cooking time, you push **at most four digits**. The microwave normalizes what you push as four digits by **prepending zeroes**. It interprets the **first** two digits as the minutes and the **last** two digits as the seconds. It then **adds** them up as the cooking time. For example,\n\n*   You push `9` `5` `4` (three digits). It is normalized as `0954` and interpreted as `9` minutes and `54` seconds.\n*   You push `0` `0` `0` `8` (four digits). It is interpreted as `0` minutes and `8` seconds.\n*   You push `8` `0` `9` `0`. It is interpreted as `80` minutes and `90` seconds.\n*   You push `8` `1` `3` `0`. It is interpreted as `81` minutes and `30` seconds.\n\nYou are given integers `startAt`, `moveCost`, `pushCost`, and `targetSeconds`. **Initially**, your finger is on the digit `startAt`. Moving the finger above **any specific digit** costs `moveCost` units of fatigue. Pushing the digit below the finger **once** costs `pushCost` units of fatigue.\n\nThere can be multiple ways to set the microwave to cook for `targetSeconds` seconds but you are interested in the way with the minimum cost.\n\nReturn _the **minimum cost** to set_ `targetSeconds` _seconds of cooking time_.\n\nRemember that one minute consists of `60` seconds.\n\n**Example 1:**\n\n**Input:** startAt = 1, moveCost = 2, pushCost = 1, targetSeconds = 600\n**Output:** 6\n**Explanation:** The following are the possible ways to set the cooking time.\n- 1 0 0 0, interpreted as 10 minutes and 0 seconds.\n  The finger is already on digit 1, pushes 1 (with cost 1), moves to 0 (with cost 2), pushes 0 (with cost 1), pushes 0 (with cost 1), and pushes 0 (with cost 1).\n  The cost is: 1 + 2 + 1 + 1 + 1 = 6. This is the minimum cost.\n- 0 9 6 0, interpreted as 9 minutes and 60 seconds. That is also 600 seconds.\n  The finger moves to 0 (with cost 2), pushes 0 (with cost 1), moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n  The cost is: 2 + 1 + 2 + 1 + 2 + 1 + 2 + 1 = 12.\n- 9 6 0, normalized as 0960 and interpreted as 9 minutes and 60 seconds.\n  The finger moves to 9 (with cost 2), pushes 9 (with cost 1), moves to 6 (with cost 2), pushes 6 (with cost 1), moves to 0 (with cost 2), and pushes 0 (with cost 1).\n  The cost is: 2 + 1 + 2 + 1 + 2 + 1 = 9.\n\n**Example 2:**\n\n**Input:** startAt = 0, moveCost = 1, pushCost = 2, targetSeconds = 76\n**Output:** 6\n**Explanation:** The optimal way is to push two digits: 7 6, interpreted as 76 seconds.\nThe finger moves to 7 (with cost 1), pushes 7 (with cost 2), moves to 6 (with cost 1), and pushes 6 (with cost 2). The total cost is: 1 + 2 + 1 + 2 = 6\nNote other possible ways are 0076, 076, 0116, and 116, but none of them produces the minimum cost.\n\n**Constraints:**\n\n*   `0 <= startAt <= 9`\n*   `1 <= moveCost, pushCost <= 105`\n*   `1 <= targetSeconds <= 6039`",
    "You are given an array of **positive** integers `beans`, where each integer represents the number of magic beans found in a particular magic bag.\n\n**Remove** any number of beans (**possibly none**) from each bag such that the number of beans in each remaining **non-empty** bag (still containing **at least one** bean) is **equal**. Once a bean has been removed from a bag, you are **not** allowed to return it to any of the bags.\n\nReturn _the **minimum** number of magic beans that you have to remove_.\n\n**Example 1:**\n\n**Input:** beans = \\[4,**1**,6,5\\]\n**Output:** 4\n**Explanation:** \n- We remove 1 bean from the bag with only 1 bean.\n  This results in the remaining bags: \\[4,**0**,6,5\\]\n- Then we remove 2 beans from the bag with 6 beans.\n  This results in the remaining bags: \\[4,0,**4**,5\\]\n- Then we remove 1 bean from the bag with 5 beans.\n  This results in the remaining bags: \\[4,0,4,**4**\\]\nWe removed a total of 1 + 2 + 1 = 4 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that remove 4 beans or fewer.\n\n**Example 2:**\n\n**Input:** beans = \\[**2**,10,**3**,**2**\\]\n**Output:** 7\n**Explanation:**\n- We remove 2 beans from one of the bags with 2 beans.\n  This results in the remaining bags: \\[**0**,10,3,2\\]\n- Then we remove 2 beans from the other bag with 2 beans.\n  This results in the remaining bags: \\[0,10,3,**0**\\]\n- Then we remove 3 beans from the bag with 3 beans. \n  This results in the remaining bags: \\[0,10,**0**,0\\]\nWe removed a total of 2 + 2 + 3 = 7 beans to make the remaining non-empty bags have an equal number of beans.\nThere are no other solutions that removes 7 beans or fewer.\n\n**Constraints:**\n\n*   `1 <= beans.length <= 105`\n*   `1 <= beans[i] <= 105`",
    "Alice and Bob are opponents in an archery competition. The competition has set the following rules:\n\n1.  Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.\n2.  The points are then calculated as follows:\n    1.  The target has integer scoring sections ranging from `0` to `11` **inclusive**.\n    2.  For **each** section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak >= bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points.\n    3.  However, if `ak == bk == 0`, then **nobody** takes `k` points.\n\n*   For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points.\n    \n\nYou are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to **maximize** the total number of points he can obtain.\n\nReturn _the array_ `bobArrows` _which represents the number of arrows Bob shot on **each** scoring section from_ `0` _to_ `11`. The sum of the values in `bobArrows` should equal `numArrows`.\n\nIf there are multiple ways for Bob to earn the maximum total points, return **any** one of them.\n\n**Example 1:**\n\n**Input:** numArrows = 9, aliceArrows = \\[1,1,0,1,0,0,2,1,0,1,2,0\\]\n**Output:** \\[0,0,0,0,1,1,0,0,1,2,3,1\\]\n**Explanation:** The table above shows how the competition is scored. \nBob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.\nIt can be shown that Bob cannot obtain a score higher than 47 points.\n\n**Example 2:**\n\n**Input:** numArrows = 3, aliceArrows = \\[0,0,1,0,0,0,0,0,0,0,0,2\\]\n**Output:** \\[0,0,0,0,0,0,0,0,1,1,1,0\\]\n**Explanation:** The table above shows how the competition is scored.\nBob earns a total point of 8 + 9 + 10 = 27.\nIt can be shown that Bob cannot obtain a score higher than 27 points.\n\n**Constraints:**\n\n*   `1 <= numArrows <= 105`\n*   `aliceArrows.length == bobArrows.length == 12`\n*   `0 <= aliceArrows[i], bobArrows[i] <= numArrows`\n*   `sum(aliceArrows[i]) == numArrows`",
    "Alice is a caretaker of `n` gardens and she wants to plant flowers to maximize the total beauty of all her gardens.\n\nYou are given a **0-indexed** integer array `flowers` of size `n`, where `flowers[i]` is the number of flowers already planted in the `ith` garden. Flowers that are already planted **cannot** be removed. You are then given another integer `newFlowers`, which is the **maximum** number of flowers that Alice can additionally plant. You are also given the integers `target`, `full`, and `partial`.\n\nA garden is considered **complete** if it has **at least** `target` flowers. The **total beauty** of the gardens is then determined as the **sum** of the following:\n\n*   The number of **complete** gardens multiplied by `full`.\n*   The **minimum** number of flowers in any of the **incomplete** gardens multiplied by `partial`. If there are no incomplete gardens, then this value will be `0`.\n\nReturn _the **maximum** total beauty that Alice can obtain after planting at most_ `newFlowers` _flowers._\n\n**Example 1:**\n\n**Input:** flowers = \\[1,3,1,1\\], newFlowers = 7, target = 6, full = 12, partial = 1\n**Output:** 14\n**Explanation:** Alice can plant\n- 2 flowers in the 0th garden\n- 3 flowers in the 1st garden\n- 1 flower in the 2nd garden\n- 1 flower in the 3rd garden\nThe gardens will then be \\[3,6,2,2\\]. She planted a total of 2 + 3 + 1 + 1 = 7 flowers.\nThere is 1 garden that is complete.\nThe minimum number of flowers in the incomplete gardens is 2.\nThus, the total beauty is 1 \\* 12 + 2 \\* 1 = 12 + 2 = 14.\nNo other way of planting flowers can obtain a total beauty higher than 14.\n\n**Example 2:**\n\n**Input:** flowers = \\[2,4,5,3\\], newFlowers = 10, target = 5, full = 2, partial = 6\n**Output:** 30\n**Explanation:** Alice can plant\n- 3 flowers in the 0th garden\n- 0 flowers in the 1st garden\n- 0 flowers in the 2nd garden\n- 2 flowers in the 3rd garden\nThe gardens will then be \\[5,4,5,5\\]. She planted a total of 3 + 0 + 0 + 2 = 5 flowers.\nThere are 3 gardens that are complete.\nThe minimum number of flowers in the incomplete gardens is 4.\nThus, the total beauty is 3 \\* 2 + 4 \\* 6 = 6 + 24 = 30.\nNo other way of planting flowers can obtain a total beauty higher than 30.\nNote that Alice could make all the gardens complete but in this case, she would obtain a lower total beauty.\n\n**Constraints:**\n\n*   `1 <= flowers.length <= 105`\n*   `1 <= flowers[i], target <= 105`\n*   `1 <= newFlowers <= 1010`\n*   `1 <= full, partial <= 105`",
    "You are given an integer `total` indicating the amount of money you have. You are also given two integers `cost1` and `cost2` indicating the price of a pen and pencil respectively. You can spend **part or all** of your money to buy multiple quantities (or none) of each kind of writing utensil.\n\nReturn _the **number of distinct ways** you can buy some number of pens and pencils._\n\n**Example 1:**\n\n**Input:** total = 20, cost1 = 10, cost2 = 5\n**Output:** 9\n**Explanation:** The price of a pen is 10 and the price of a pencil is 5.\n- If you buy 0 pens, you can buy 0, 1, 2, 3, or 4 pencils.\n- If you buy 1 pen, you can buy 0, 1, or 2 pencils.\n- If you buy 2 pens, you cannot buy any pencils.\nThe total number of ways to buy pens and pencils is 5 + 3 + 1 = 9.\n\n**Example 2:**\n\n**Input:** total = 5, cost1 = 10, cost2 = 10\n**Output:** 1\n**Explanation:** The price of both pens and pencils are 10, which cost more than total, so you cannot buy any writing utensils. Therefore, there is only 1 way: buy 0 pens and 0 pencils.\n\n**Constraints:**\n\n*   `1 <= total, cost1, cost2 <= 106`",
    "You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer.\n\nA **cornered path** is defined as a set of adjacent cells with **at most** one turn. More specifically, the path should exclusively move either **horizontally** or **vertically** up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the **alternate** direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.\n\nThe **product** of a path is defined as the product of all the values in the path.\n\nReturn _the **maximum** number of **trailing zeros** in the product of a cornered path found in_ `grid`.\n\nNote:\n\n*   **Horizontal** movement means moving in either the left or right direction.\n*   **Vertical** movement means moving in either the up or down direction.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[23,17,15,3,20\\],\\[8,1,20,27,11\\],\\[9,4,6,2,21\\],\\[40,9,1,10,6\\],\\[22,7,4,5,3\\]\\]\n**Output:** 3\n**Explanation:** The grid on the left shows a valid cornered path.\nIt has a product of 15 \\* 20 \\* 6 \\* 1 \\* 10 = 18000 which has 3 trailing zeros.\nIt can be shown that this is the maximum trailing zeros in the product of a cornered path.\n\nThe grid in the middle is not a cornered path as it has more than one turn.\nThe grid on the right is not a cornered path as it requires a return to a previously visited cell.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[4,3,2\\],\\[7,6,1\\],\\[8,8,8\\]\\]\n**Output:** 0\n**Explanation:** The grid is shown in the figure above.\nThere are no cornered paths in the grid that result in a product with a trailing zero.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 1000`",
    "You are given a **tree** (i.e. a connected, undirected graph that has no cycles) **rooted** at node `0` consisting of `n` nodes numbered from `0` to `n - 1`. The tree is represented by a **0-indexed** array `parent` of size `n`, where `parent[i]` is the parent of node `i`. Since node `0` is the root, `parent[0] == -1`.\n\nYou are also given a string `s` of length `n`, where `s[i]` is the character assigned to node `i`.\n\nReturn _the length of the **longest path** in the tree such that no pair of **adjacent** nodes on the path have the same character assigned to them._\n\n**Example 1:**\n\n**Input:** parent = \\[-1,0,0,1,1,2\\], s =  \"abacbe \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters in the tree is the path: 0 -> 1 -> 3. The length of this path is 3, so 3 is returned.\nIt can be proven that there is no longer path that satisfies the conditions. \n\n**Example 2:**\n\n**Input:** parent = \\[-1,0,0,0\\], s =  \"aabc \"\n**Output:** 3\n**Explanation:** The longest path where each two adjacent nodes have different characters is the path: 2 -> 0 -> 3. The length of this path is 3, so 3 is returned.\n\n**Constraints:**\n\n*   `n == parent.length == s.length`\n*   `1 <= n <= 105`\n*   `0 <= parent[i] <= n - 1` for all `i >= 1`\n*   `parent[0] == -1`\n*   `parent` represents a valid tree.\n*   `s` consists of only lowercase English letters.",
    "Given a 2D integer array `circles` where `circles[i] = [xi, yi, ri]` represents the center `(xi, yi)` and radius `ri` of the `ith` circle drawn on a grid, return _the **number of lattice points**_ _that are present inside **at least one** circle_.\n\n**Note:**\n\n*   A **lattice point** is a point with integer coordinates.\n*   Points that lie **on the circumference of a circle** are also considered to be inside it.\n\n**Example 1:**\n\n**Input:** circles = \\[\\[2,2,1\\]\\]\n**Output:** 5\n**Explanation:**\nThe figure above shows the given circle.\nThe lattice points present inside the circle are (1, 2), (2, 1), (2, 2), (2, 3), and (3, 2) and are shown in green.\nOther points such as (1, 1) and (1, 3), which are shown in red, are not considered inside the circle.\nHence, the number of lattice points present inside at least one circle is 5.\n\n**Example 2:**\n\n**Input:** circles = \\[\\[2,2,2\\],\\[3,4,1\\]\\]\n**Output:** 16\n**Explanation:**\nThe figure above shows the given circles.\nThere are exactly 16 lattice points which are present inside at least one circle. \nSome of them are (0, 2), (2, 0), (2, 4), (3, 2), and (4, 4).\n\n**Constraints:**\n\n*   `1 <= circles.length <= 200`\n*   `circles[i].length == 3`\n*   `1 <= xi, yi <= 100`\n*   `1 <= ri <= min(xi, yi)`",
    "You are given a 2D integer array `rectangles` where `rectangles[i] = [li, hi]` indicates that `ith` rectangle has a length of `li` and a height of `hi`. You are also given a 2D integer array `points` where `points[j] = [xj, yj]` is a point with coordinates `(xj, yj)`.\n\nThe `ith` rectangle has its **bottom-left corner** point at the coordinates `(0, 0)` and its **top-right corner** point at `(li, hi)`.\n\nReturn _an integer array_ `count` _of length_ `points.length` _where_ `count[j]` _is the number of rectangles that **contain** the_ `jth` _point._\n\nThe `ith` rectangle **contains** the `jth` point if `0 <= xj <= li` and `0 <= yj <= hi`. Note that points that lie on the **edges** of a rectangle are also considered to be contained by that rectangle.\n\n**Example 1:**\n\n**Input:** rectangles = \\[\\[1,2\\],\\[2,3\\],\\[2,5\\]\\], points = \\[\\[2,1\\],\\[1,4\\]\\]\n**Output:** \\[2,1\\]\n**Explanation:** \nThe first rectangle contains no points.\nThe second rectangle contains only the point (2, 1).\nThe third rectangle contains the points (2, 1) and (1, 4).\nThe number of rectangles that contain the point (2, 1) is 2.\nThe number of rectangles that contain the point (1, 4) is 1.\nTherefore, we return \\[2, 1\\].\n\n**Example 2:**\n\n**Input:** rectangles = \\[\\[1,1\\],\\[2,2\\],\\[3,3\\]\\], points = \\[\\[1,3\\],\\[1,1\\]\\]\n**Output:** \\[1,3\\]\n**Explanation:**\nThe first rectangle contains only the point (1, 1).\nThe second rectangle contains only the point (1, 1).\nThe third rectangle contains the points (1, 3) and (1, 1).\nThe number of rectangles that contain the point (1, 3) is 1.\nThe number of rectangles that contain the point (1, 1) is 3.\nTherefore, we return \\[1, 3\\].\n\n**Constraints:**\n\n*   `1 <= rectangles.length, points.length <= 5 * 104`\n*   `rectangles[i].length == points[j].length == 2`\n*   `1 <= li, xj <= 109`\n*   `1 <= hi, yj <= 100`\n*   All the `rectangles` are **unique**.\n*   All the `points` are **unique**.",
    "You are given a **0-indexed** 2D integer array `flowers`, where `flowers[i] = [starti, endi]` means the `ith` flower will be in **full bloom** from `starti` to `endi` (**inclusive**). You are also given a **0-indexed** integer array `people` of size `n`, where `poeple[i]` is the time that the `ith` person will arrive to see the flowers.\n\nReturn _an integer array_ `answer` _of size_ `n`_, where_ `answer[i]` _is the **number** of flowers that are in full bloom when the_ `ith` _person arrives._\n\n**Example 1:**\n\n**Input:** flowers = \\[\\[1,6\\],\\[3,7\\],\\[9,12\\],\\[4,13\\]\\], poeple = \\[2,3,7,11\\]\n**Output:** \\[1,2,2,2\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n**Example 2:**\n\n**Input:** flowers = \\[\\[1,10\\],\\[3,3\\]\\], poeple = \\[3,3,2\\]\n**Output:** \\[2,2,1\\]\n**Explanation:** The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n**Constraints:**\n\n*   `1 <= flowers.length <= 5 * 104`\n*   `flowers[i].length == 2`\n*   `1 <= starti <= endi <= 109`\n*   `1 <= people.length <= 5 * 104`\n*   `1 <= people[i] <= 109`",
    "You are given two integers `m` and `n` representing a **0-indexed** `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively.\n\nA guard can see **every** cell in the four cardinal directions (north, east, south, or west) starting from their position unless **obstructed** by a wall or another guard. A cell is **guarded** if there is **at least** one guard that can see it.\n\nReturn _the number of unoccupied cells that are **not** **guarded**._\n\n**Example 1:**\n\n**Input:** m = 4, n = 6, guards = \\[\\[0,0\\],\\[1,1\\],\\[2,3\\]\\], walls = \\[\\[0,1\\],\\[2,2\\],\\[1,4\\]\\]\n**Output:** 7\n**Explanation:** The guarded and unguarded cells are shown in red and green respectively in the above diagram.\nThere are a total of 7 unguarded cells, so we return 7.\n\n**Example 2:**\n\n**Input:** m = 3, n = 3, guards = \\[\\[1,1\\]\\], walls = \\[\\[0,1\\],\\[1,0\\],\\[2,1\\],\\[1,2\\]\\]\n**Output:** 4\n**Explanation:** The unguarded cells are shown in green in the above diagram.\nThere are a total of 4 unguarded cells, so we return 4.\n\n**Constraints:**\n\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `1 <= guards.length, walls.length <= 5 * 104`\n*   `2 <= guards.length + walls.length <= m * n`\n*   `guards[i].length == walls[j].length == 2`\n*   `0 <= rowi, rowj < m`\n*   `0 <= coli, colj < n`\n*   All the positions in `guards` and `walls` are **unique**.",
    "You are given a 2D integer array `tiles` where `tiles[i] = [li, ri]` represents that every tile `j` in the range `li <= j <= ri` is colored white.\n\nYou are also given an integer `carpetLen`, the length of a single carpet that can be placed **anywhere**.\n\nReturn _the **maximum** number of white tiles that can be covered by the carpet_.\n\n**Example 1:**\n\n**Input:** tiles = \\[\\[1,5\\],\\[10,11\\],\\[12,18\\],\\[20,25\\],\\[30,32\\]\\], carpetLen = 10\n**Output:** 9\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 9 white tiles, so we return 9.\nNote that there may be other places where the carpet covers 9 white tiles.\nIt can be shown that the carpet cannot cover more than 9 white tiles.\n\n**Example 2:**\n\n**Input:** tiles = \\[\\[10,11\\],\\[1,1\\]\\], carpetLen = 2\n**Output:** 2\n**Explanation:** Place the carpet starting on tile 10. \nIt covers 2 white tiles, so we return 2.\n\n**Constraints:**\n\n*   `1 <= tiles.length <= 5 * 104`\n*   `tiles[i].length == 2`\n*   `1 <= li <= ri <= 109`\n*   `1 <= carpetLen <= 109`\n*   The `tiles` are **non-overlapping**.",
    "Alice manages a company and has rented some floors of a building as office space. Alice has decided some of these floors should be **special floors**, used for relaxation only.\n\nYou are given two integers `bottom` and `top`, which denote that Alice has rented all the floors from `bottom` to `top` (**inclusive**). You are also given the integer array `special`, where `special[i]` denotes a special floor that Alice has designated for relaxation.\n\nReturn _the **maximum** number of consecutive floors without a special floor_.\n\n**Example 1:**\n\n**Input:** bottom = 2, top = 9, special = \\[4,6\\]\n**Output:** 3\n**Explanation:** The following are the ranges (inclusive) of consecutive floors without a special floor:\n- (2, 3) with a total amount of 2 floors.\n- (5, 5) with a total amount of 1 floor.\n- (7, 9) with a total amount of 3 floors.\nTherefore, we return the maximum number which is 3 floors.\n\n**Example 2:**\n\n**Input:** bottom = 6, top = 8, special = \\[7,6,8\\]\n**Output:** 0\n**Explanation:** Every floor rented is a special floor, so we return 0.\n\n**Constraints:**\n\n*   `1 <= special.length <= 105`\n*   `1 <= bottom <= special[i] <= top <= 109`\n*   All the values of `special` are **unique**.",
    "You are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi, pricei]` indicates the price of the stock on day `dayi` is `pricei`. A **line chart** is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:\n\nReturn _the **minimum number of lines** needed to represent the line chart_.\n\n**Example 1:**\n\n**Input:** stockPrices = \\[\\[1,7\\],\\[2,6\\],\\[3,5\\],\\[4,4\\],\\[5,4\\],\\[6,3\\],\\[7,2\\],\\[8,1\\]\\]\n**Output:** 3\n**Explanation:**\nThe diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.\nThe following 3 lines can be drawn to represent the line chart:\n- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).\n- Line 2 (in blue) from (4,4) to (5,4).\n- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).\nIt can be shown that it is not possible to represent the line chart using less than 3 lines.\n\n**Example 2:**\n\n**Input:** stockPrices = \\[\\[3,4\\],\\[1,2\\],\\[7,8\\],\\[2,3\\]\\]\n**Output:** 1\n**Explanation:**\nAs shown in the diagram above, the line chart can be represented with a single line.\n\n**Constraints:**\n\n*   `1 <= stockPrices.length <= 105`\n*   `stockPrices[i].length == 2`\n*   `1 <= dayi, pricei <= 109`\n*   All `dayi` are **distinct**.",
    "You are given a **0-indexed** 2D integer array `grid` of size `m x n`. Each cell has one of two values:\n\n*   `0` represents an **empty** cell,\n*   `1` represents an **obstacle** that may be removed.\n\nYou can move up, down, left, or right from and to an empty cell.\n\nReturn _the **minimum** number of **obstacles** to **remove** so you can move from the upper left corner_ `(0, 0)` _to the lower right corner_ `(m - 1, n - 1)`.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[0,1,1\\],\\[1,1,0\\],\\[1,1,0\\]\\]\n**Output:** 2\n**Explanation:** We can remove the obstacles at (0, 1) and (0, 2) to create a path from (0, 0) to (2, 2).\nIt can be shown that we need to remove at least 2 obstacles, so we return 2.\nNote that there may be other ways to remove 2 obstacles to create a path.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[0,1,0,0,0\\],\\[0,1,0,1,0\\],\\[0,0,0,1,0\\]\\]\n**Output:** 0\n**Explanation:** We can move from (0, 0) to (2, 4) without removing any obstacles, so we return 0.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 105`\n*   `2 <= m * n <= 105`\n*   `grid[i][j]` is either `0` **or** `1`.\n*   `grid[0][0] == grid[m - 1][n - 1] == 0`",
    "You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.\n\nTo cut a piece of wood, you must make a vertical or horizontal cut across the **entire** height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you **cannot** rotate a piece to swap its height and width.\n\nReturn _the **maximum** money you can earn after cutting an_ `m x n` _piece of wood_.\n\nNote that you can cut the piece of wood as many times as you want.\n\n**Example 1:**\n\n**Input:** m = 3, n = 5, prices = \\[\\[1,4,2\\],\\[2,2,7\\],\\[2,1,3\\]\\]\n**Output:** 19\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \\* 7 = 14.\n- 1 piece of wood shaped 2 x 1, selling for a price of 1 \\* 3 = 3.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 14 + 3 + 2 = 19 money earned.\nIt can be shown that 19 is the maximum amount of money that can be earned.\n\n**Example 2:**\n\n**Input:** m = 4, n = 6, prices = \\[\\[3,2,10\\],\\[1,4,2\\],\\[4,1,3\\]\\]\n**Output:** 32\n**Explanation:** The diagram above shows a possible scenario. It consists of:\n- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \\* 10 = 30.\n- 1 piece of wood shaped 1 x 4, selling for a price of 1 \\* 2 = 2.\nThis obtains a total of 30 + 2 = 32 money earned.\nIt can be shown that 32 is the maximum amount of money that can be earned.\nNotice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.\n\n**Constraints:**\n\n*   `1 <= m, n <= 200`\n*   `1 <= prices.length <= 2 * 104`\n*   `prices[i].length == 3`\n*   `1 <= hi <= m`\n*   `1 <= wi <= n`\n*   `1 <= pricei <= 106`\n*   All the shapes of wood `(hi, wi)` are pairwise **distinct**.",
    "You are given an integer `n`. You roll a fair 6-sided dice `n` times. Determine the total number of **distinct** sequences of rolls possible such that the following conditions are satisfied:\n\n1.  The **greatest common divisor** of any **adjacent** values in the sequence is equal to `1`.\n2.  There is **at least** a gap of `2` rolls between **equal** valued rolls. More formally, if the value of the `ith` roll is **equal** to the value of the `jth` roll, then `abs(i - j) > 2`.\n\nReturn _the **total number** of distinct sequences possible_. Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo sequences are considered distinct if at least one element is different.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 184\n**Explanation:** Some of the possible sequences are (1, 2, 3, 4), (6, 1, 2, 3), (1, 2, 3, 1), etc.\nSome invalid sequences are (1, 2, 1, 3), (1, 2, 3, 6).\n(1, 2, 1, 3) is invalid since the first and third roll have an equal value and abs(1 - 3) = 2 (i and j are 1-indexed).\n(1, 2, 3, 6) is invalid since the greatest common divisor of 3 and 6 = 3.\nThere are a total of 184 distinct sequences possible, so we return 184.\n\n**Example 2:**\n\n**Input:** n = 2\n**Output:** 22\n**Explanation:** Some of the possible sequences are (1, 2), (2, 1), (3, 2).\nSome invalid sequences are (3, 6), (2, 4) since the greatest common divisor is not equal to 1.\nThere are a total of 22 distinct sequences possible, so we return 22.\n\n**Constraints:**\n\n*   `1 <= n <= 104`",
    "You are given an `m x n` integer matrix `grid`, where you can move from a cell to any adjacent cell in all `4` directions.\n\nReturn _the number of **strictly** **increasing** paths in the grid such that you can start from **any** cell and end at **any** cell._ Since the answer may be very large, return it **modulo** `109 + 7`.\n\nTwo paths are considered different if they do not have exactly the same sequence of visited cells.\n\n**Example 1:**\n\n**Input:** grid = \\[\\[1,1\\],\\[3,4\\]\\]\n**Output:** 8\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[1\\], \\[3\\], \\[4\\].\n- Paths with length 2: \\[1 -> 3\\], \\[1 -> 4\\], \\[3 -> 4\\].\n- Paths with length 3: \\[1 -> 3 -> 4\\].\nThe total number of paths is 4 + 3 + 1 = 8.\n\n**Example 2:**\n\n**Input:** grid = \\[\\[1\\],\\[2\\]\\]\n**Output:** 3\n**Explanation:** The strictly increasing paths are:\n- Paths with length 1: \\[1\\], \\[2\\].\n- Paths with length 2: \\[1 -> 2\\].\nThe total number of paths is 2 + 1 = 3.\n\n**Constraints:**\n\n*   `m == grid.length`\n*   `n == grid[i].length`\n*   `1 <= m, n <= 1000`\n*   `1 <= m * n <= 105`\n*   `1 <= grid[i][j] <= 105`",
    "You are given an integer array `ranks` and a character array `suits`. You have `5` cards where the `ith` card has a rank of `ranks[i]` and a suit of `suits[i]`.\n\nThe following are the types of **poker hands** you can make from best to worst:\n\n1.  `\"Flush \"`: Five cards of the same suit.\n2.  `\"Three of a Kind \"`: Three cards of the same rank.\n3.  `\"Pair \"`: Two cards of the same rank.\n4.  `\"High Card \"`: Any single card.\n\nReturn _a string representing the **best** type of **poker hand** you can make with the given cards._\n\n**Note** that the return values are **case-sensitive**.\n\n**Example 1:**\n\n**Input:** ranks = \\[13,2,3,1,9\\], suits = \\[ \"a \", \"a \", \"a \", \"a \", \"a \"\\]\n**Output:**  \"Flush \"\n**Explanation:** The hand with all the cards consists of 5 cards with the same suit, so we have a  \"Flush \".\n\n**Example 2:**\n\n**Input:** ranks = \\[4,4,2,4,4\\], suits = \\[ \"d \", \"a \", \"a \", \"b \", \"c \"\\]\n**Output:**  \"Three of a Kind \"\n**Explanation:** The hand with the first, second, and fourth card consists of 3 cards with the same rank, so we have a  \"Three of a Kind \".\nNote that we could also make a  \"Pair \" hand but  \"Three of a Kind \" is a better hand.\nAlso note that other cards could be used to make the  \"Three of a Kind \" hand.\n\n**Example 3:**\n\n**Input:** ranks = \\[10,10,2,12,9\\], suits = \\[ \"a \", \"b \", \"c \", \"a \", \"d \"\\]\n**Output:**  \"Pair \"\n**Explanation:** The hand with the first and second card consists of 2 cards with the same rank, so we have a  \"Pair \".\nNote that we cannot make a  \"Flush \" or a  \"Three of a Kind \".\n\n**Constraints:**\n\n*   `ranks.length == suits.length == 5`\n*   `1 <= ranks[i] <= 13`\n*   `'a' <= suits[i] <= 'd'`\n*   No two cards have the same rank and suit.",
    "You are given a 2D integer array `intervals` where `intervals[i] = [lefti, righti]` represents the **inclusive** interval `[lefti, righti]`.\n\nYou have to divide the intervals into one or more **groups** such that each interval is in **exactly** one group, and no two intervals that are in the same group **intersect** each other.\n\nReturn _the **minimum** number of groups you need to make_.\n\nTwo intervals **intersect** if there is at least one common number between them. For example, the intervals `[1, 5]` and `[5, 8]` intersect.\n\n**Example 1:**\n\n**Input:** intervals = \\[\\[5,10\\],\\[6,8\\],\\[1,5\\],\\[2,3\\],\\[1,10\\]\\]\n**Output:** 3\n**Explanation:** We can divide the intervals into the following groups:\n- Group 1: \\[1, 5\\], \\[6, 8\\].\n- Group 2: \\[2, 3\\], \\[5, 10\\].\n- Group 3: \\[1, 10\\].\nIt can be proven that it is not possible to divide the intervals into fewer than 3 groups.\n\n**Example 2:**\n\n**Input:** intervals = \\[\\[1,3\\],\\[5,6\\],\\[8,10\\],\\[11,13\\]\\]\n**Output:** 1\n**Explanation:** None of the intervals overlap, so we can put all of them in one group.\n\n**Constraints:**\n\n*   `1 <= intervals.length <= 105`\n*   `intervals[i].length == 2`\n*   `1 <= lefti <= righti <= 106`",
    "Alice and Bob are traveling to Rome for separate business meetings.\n\nYou are given 4 strings `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob`. Alice will be in the city from the dates `arriveAlice` to `leaveAlice` (**inclusive**), while Bob will be in the city from the dates `arriveBob` to `leaveBob` (**inclusive**). Each will be a 5-character string in the format `\"MM-DD \"`, corresponding to the month and day of the date.\n\nReturn _the total number of days that Alice and Bob are in Rome together._\n\nYou can assume that all dates occur in the **same** calendar year, which is **not** a leap year. Note that the number of days per month can be represented as: `[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`.\n\n**Example 1:**\n\n**Input:** arriveAlice =  \"08-15 \", leaveAlice =  \"08-18 \", arriveBob =  \"08-16 \", leaveBob =  \"08-19 \"\n**Output:** 3\n**Explanation:** Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.\n\n**Example 2:**\n\n**Input:** arriveAlice =  \"10-01 \", leaveAlice =  \"10-31 \", arriveBob =  \"11-01 \", leaveBob =  \"12-31 \"\n**Output:** 0\n**Explanation:** There is no day when Alice and Bob are in Rome together, so we return 0.\n\n**Constraints:**\n\n*   All dates are provided in the format `\"MM-DD \"`.\n*   Alice and Bob's arrival dates are **earlier than or equal to** their leaving dates.\n*   The given dates are valid dates of a **non-leap** year.",
    "You are given an array of strings `names`, and an array `heights` that consists of **distinct** positive integers. Both arrays are of length `n`.\n\nFor each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person.\n\nReturn `names` _sorted in **descending** order by the people's heights_.\n\n**Example 1:**\n\n**Input:** names = \\[ \"Mary \", \"John \", \"Emma \"\\], heights = \\[180,165,170\\]\n**Output:** \\[ \"Mary \", \"Emma \", \"John \"\\]\n**Explanation:** Mary is the tallest, followed by Emma and John.\n\n**Example 2:**\n\n**Input:** names = \\[ \"Alice \", \"Bob \", \"Bob \"\\], heights = \\[155,185,150\\]\n**Output:** \\[ \"Bob \", \"Alice \", \"Bob \"\\]\n**Explanation:** The first Bob is the tallest, followed by Alice and the second Bob.\n\n**Constraints:**\n\n*   `n == names.length == heights.length`\n*   `1 <= n <= 103`\n*   `1 <= names[i].length <= 20`\n*   `1 <= heights[i] <= 105`\n*   `names[i]` consists of lower and upper case English letters.\n*   All the values of `heights` are distinct.",
    "Given two positive integers `a` and `b`, return _the number of **common** factors of_ `a` _and_ `b`.\n\nAn integer `x` is a **common factor** of `a` and `b` if `x` divides both `a` and `b`.\n\n**Example 1:**\n\n**Input:** a = 12, b = 6\n**Output:** 4\n**Explanation:** The common factors of 12 and 6 are 1, 2, 3, 6.\n\n**Example 2:**\n\n**Input:** a = 25, b = 30\n**Output:** 2\n**Explanation:** The common factors of 25 and 30 are 1, 5.\n\n**Constraints:**\n\n*   `1 <= a, b <= 1000`",
    "You are given a string of length `5` called `time`, representing the current time on a digital clock in the format `\"hh:mm \"`. The **earliest** possible time is `\"00:00 \"` and the **latest** possible time is `\"23:59 \"`.\n\nIn the string `time`, the digits represented by the `?` symbol are **unknown**, and must be **replaced** with a digit from `0` to `9`.\n\nReturn _an integer_ `answer`_, the number of valid clock times that can be created by replacing every_ `?` _with a digit from_ `0` _to_ `9`.\n\n**Example 1:**\n\n**Input:** time =  \"?5:00 \"\n**Output:** 2\n**Explanation:** We can replace the ? with either a 0 or 1, producing  \"05:00 \" or  \"15:00 \". Note that we cannot replace it with a 2, since the time  \"25:00 \" is invalid. In total, we have two choices.\n\n**Example 2:**\n\n**Input:** time =  \"0?:0? \"\n**Output:** 100\n**Explanation:** Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.\n\n**Example 3:**\n\n**Input:** time =  \"??:?? \"\n**Output:** 1440\n**Explanation:** There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 \\* 60 = 1440 choices.\n\n**Constraints:**\n\n*   `time` is a valid string of length `5` in the format `\"hh:mm \"`.\n*   `\"00 \" <= hh <= \"23 \"`\n*   `\"00 \" <= mm <= \"59 \"`\n*   Some of the digits might be replaced with `'?'` and need to be replaced with digits from `0` to `9`.",
    "There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.\n\nAt every node `i`, there is a gate. You are also given an array of even integers `amount`, where `amount[i]` represents:\n\n*   the price needed to open the gate at node `i`, if `amount[i]` is negative, or,\n*   the cash reward obtained on opening the gate at node `i`, otherwise.\n\nThe game goes on as follows:\n\n*   Initially, Alice is at node `0` and Bob is at node `bob`.\n*   At every second, Alice and Bob **each** move to an adjacent node. Alice moves towards some **leaf node**, while Bob moves towards node `0`.\n*   For **every** node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:\n    *   If the gate is **already open**, no price will be required, nor will there be any cash reward.\n    *   If Alice and Bob reach the node **simultaneously**, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.\n*   If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are **independent** of each other.\n\nReturn _the **maximum** net income Alice can have if she travels towards the optimal leaf node._\n\n**Example 1:**\n\n**Input:** edges = \\[\\[0,1\\],\\[1,2\\],\\[1,3\\],\\[3,4\\]\\], bob = 3, amount = \\[-2,4,2,-4,6\\]\n**Output:** 6\n**Explanation:** \nThe above diagram represents the given tree. The game goes as follows:\n- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.\n  Alice's net income is now -2.\n- Both Alice and Bob move to node 1. \n  Since they reach here simultaneously, they open the gate together and share the reward.\n  Alice's net income becomes -2 + (4 / 2) = 0.\n- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.\n  Bob moves on to node 0, and stops moving.\n- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.\nNow, neither Alice nor Bob can make any further moves, and the game ends.\nIt is not possible for Alice to get a higher net income.\n\n**Example 2:**\n\n**Input:** edges = \\[\\[0,1\\]\\], bob = 1, amount = \\[-7280,2350\\]\n**Output:** -7280\n**Explanation:** \nAlice follows the path 0->1 whereas Bob follows the path 1->0.\nThus, Alice opens the gate at node 0 only. Hence, her net income is -7280. \n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.\n*   `1 <= bob < n`\n*   `amount.length == n`\n*   `amount[i]` is an **even** integer in the range `[-104, 104]`.",
    "A **valid cut** in a circle can be:\n\n*   A cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\n*   A cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n\nSome valid and invalid cuts are shown in the figures below.\n\nGiven the integer `n`, return _the **minimum** number of cuts needed to divide a circle into_ `n` _equal slices_.\n\n**Example 1:**\n\n**Input:** n = 4\n**Output:** 2\n**Explanation:** \nThe above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n\n**Example 2:**\n\n**Input:** n = 3\n**Output:** 3\n**Explanation:**\nAt least 3 cuts are needed to divide the circle into 3 equal slices. \nIt can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\nAlso note that the first cut will not divide the circle into distinct parts.\n\n**Constraints:**\n\n*   `1 <= n <= 100`",
    "You are given a positive integer `n` representing `n` cities numbered from `1` to `n`. You are also given a **2D** array `roads` where `roads[i] = [ai, bi, distancei]` indicates that there is a **bidirectional** road between cities `ai` and `bi` with a distance equal to `distancei`. The cities graph is not necessarily connected.\n\nThe **score** of a path between two cities is defined as the **minimum** distance of a road in this path.\n\nReturn _the **minimum** possible score of a path between cities_ `1` _and_ `n`.\n\n**Note**:\n\n*   A path is a sequence of roads between two cities.\n*   It is allowed for a path to contain the same road **multiple** times, and you can visit cities `1` and `n` multiple times along the path.\n*   The test cases are generated such that there is **at least** one path between `1` and `n`.\n\n**Example 1:**\n\n**Input:** n = 4, roads = \\[\\[1,2,9\\],\\[2,3,6\\],\\[2,4,5\\],\\[1,4,7\\]\\]\n**Output:** 5\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\n**Example 2:**\n\n**Input:** n = 4, roads = \\[\\[1,2,2\\],\\[1,3,4\\],\\[3,4,7\\]\\]\n**Output:** 2\n**Explanation:** The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n**Constraints:**\n\n*   `2 <= n <= 105`\n*   `1 <= roads.length <= 105`\n*   `roads[i].length == 3`\n*   `1 <= ai, bi <= n`\n*   `ai != bi`\n*   `1 <= distancei <= 104`\n*   There are no repeated edges.\n*   There is at least one path between `1` and `n`.",
    "You are given a **0-indexed** integer array `forts` of length `n` representing the positions of several forts. `forts[i]` can be `-1`, `0`, or `1` where:\n\n*   `-1` represents there is **no fort** at the `ith` position.\n*   `0` indicates there is an **enemy** fort at the `ith` position.\n*   `1` indicates the fort at the `ith` the position is under your command.\n\nNow you have decided to move your army from one of your forts at position `i` to an empty position `j` such that:\n\n*   `0 <= i, j <= n - 1`\n*   The army travels over enemy forts **only**. Formally, for all `k` where `min(i,j) < k < max(i,j)`, `forts[k] == 0.`\n\nWhile moving the army, all the enemy forts that come in the way are **captured**.\n\nReturn _the **maximum** number of enemy forts that can be captured_. In case it is **impossible** to move your army, or you do not have any fort under your command, return `0`_._\n\n**Example 1:**\n\n**Input:** forts = \\[1,0,0,-1,0,0,0,0,1\\]\n**Output:** 4\n**Explanation:**\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\n**Example 2:**\n\n**Input:** forts = \\[0,0,1,-1\\]\n**Output:** 0\n**Explanation:** Since no enemy fort can be captured, 0 is returned.\n\n**Constraints:**\n\n*   `1 <= forts.length <= 1000`\n*   `-1 <= forts[i] <= 1`",
    "There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`.\n\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (**0-indexed**) can :\n\n*   Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.\n*   Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.\n*   Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.\n*   Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.\n\nA worker `i` is **less efficient** than a worker `j` if either condition is met:\n\n*   `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`\n*   `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`\n\nThe following rules regulate the movement of the workers through the bridge :\n\n*   If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.\n*   If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with **the lowest efficiency** crosses first.\n*   If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with **the lowest efficiency** crosses first.\n\nReturn _the instance of time at which the last worker **reaches the left bank** of the river after all n boxes have been put in the new warehouse_.\n\n**Example 1:**\n\n**Input:** n = 1, k = 3, time = \\[\\[1,1,2,1\\],\\[1,1,3,1\\],\\[1,1,4,1\\]\\]\n**Output:** 6\n**Explanation:** \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n**Example 2:**\n\n**Input:** n = 3, k = 2, time = \\[\\[1,9,1,8\\],\\[10,10,10,10\\]\\]\n**Output:** 50\n**Explanation:** \nFrom 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n**Constraints:**\n\n*   `1 <= n, k <= 104`\n*   `time.length == k`\n*   `time[i].length == 4`\n*   `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`",
    "There is a regular convex polygon with `n` vertices. The vertices are labeled from `0` to `n - 1` in a clockwise direction, and each vertex has **exactly one monkey**. The following figure shows a convex polygon of `6` vertices.\n\nEach monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex `i` can be:\n\n*   the vertex `(i + 1) % n` in the clockwise direction, or\n*   the vertex `(i - 1 + n) % n` in the counter-clockwise direction.\n\nA **collision** happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.\n\nReturn _the number of ways the monkeys can move so that at least **one collision**_ _happens_. Since the answer may be very large, return it modulo `109 + 7`.\n\n**Note** that each monkey can only move once.\n\n**Example 1:**\n\n**Input:** n = 3\n**Output:** 6\n**Explanation:** There are 8 total possible movements.\nTwo ways such that they collide at some point are:\n- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\n- Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\nIt can be shown 6 total movements result in a collision.\n\n**Example 2:**\n\n**Input:** n = 4\n**Output:** 14\n**Explanation:** It can be shown that there are 14 ways for the monkeys to collide.\n\n**Constraints:**\n\n*   `3 <= n <= 109`",
    "There are some prizes on the **X-axis**. You are given an integer array `prizePositions` that is **sorted in non-decreasing order**, where `prizePositions[i]` is the position of the `ith` prize. There could be different prizes at the same position on the line. You are also given an integer `k`.\n\nYou are allowed to select two segments with integer endpoints. The length of each segment must be `k`. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\n*   For example if `k = 2`, you can choose segments `[1, 3]` and `[2, 4]`, and you will win any prize i that satisfies `1 <= prizePositions[i] <= 3` or `2 <= prizePositions[i] <= 4`.\n\nReturn _the **maximum** number of prizes you can win if you choose the two segments optimally_.\n\n**Example 1:**\n\n**Input:** prizePositions = \\[1,1,2,2,3,3,5\\], k = 2\n**Output:** 7\n**Explanation:** In this example, you can win all 7 prizes by selecting two segments \\[1, 3\\] and \\[3, 5\\].\n\n**Example 2:**\n\n**Input:** prizePositions = \\[1,2,3,4\\], k = 0\n**Output:** 2\n**Explanation:** For this example, **one choice** for the segments is `[3, 3]` and `[4, 4],` and you will be able to get `2` prizes. \n\n**Constraints:**\n\n*   `1 <= prizePositions.length <= 105`\n*   `1 <= prizePositions[i] <= 109`\n*   `0 <= k <= 109`\n*   `prizePositions` is sorted in non-decreasing order.\n\n.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\\[value=\"Show Message\"\\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\\[value=\"Hide Message\"\\] + .spoiler {padding:5px;}",
    "There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.\n\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:\n\n*   Collect all the coins that are at a distance of at most `2` from the current vertex, or\n*   Move to any adjacent vertex in the tree.\n\nFind _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.\n\nNote that if you pass an edge several times, you need to count it into the answer several times.\n\n**Example 1:**\n\n**Input:** coins = \\[1,0,0,0,0,1\\], edges = \\[\\[0,1\\],\\[1,2\\],\\[2,3\\],\\[3,4\\],\\[4,5\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\n**Example 2:**\n\n**Input:** coins = \\[0,0,0,1,1,0,0,1\\], edges = \\[\\[0,1\\],\\[0,2\\],\\[1,3\\],\\[1,4\\],\\[2,5\\],\\[5,6\\],\\[5,7\\]\\]\n**Output:** 2\n**Explanation:** Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n**Constraints:**\n\n*   `n == coins.length`\n*   `1 <= n <= 3 * 104`\n*   `0 <= coins[i] <= 1`\n*   `edges.length == n - 1`\n*   `edges[i].length == 2`\n*   `0 <= ai, bi < n`\n*   `ai != bi`\n*   `edges` represents a valid tree.",
    "There are two mice and `n` different types of cheese, each type of cheese should be eaten by exactly one mouse.\n\nA point of the cheese with index `i` (**0-indexed**) is:\n\n*   `reward1[i]` if the first mouse eats it.\n*   `reward2[i]` if the second mouse eats it.\n\nYou are given a positive integer array `reward1`, a positive integer array `reward2`, and a non-negative integer `k`.\n\nReturn _**the maximum** points the mice can achieve if the first mouse eats exactly_ `k` _types of cheese._\n\n**Example 1:**\n\n**Input:** reward1 = \\[1,1,3,4\\], reward2 = \\[4,4,1,1\\], k = 2\n**Output:** 15\n**Explanation:** In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\n**Example 2:**\n\n**Input:** reward1 = \\[1,1\\], reward2 = \\[1,1\\], k = 2\n**Output:** 2\n**Explanation:** In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n**Constraints:**\n\n*   `1 <= n == reward1.length == reward2.length <= 105`\n*   `1 <= reward1[i], reward2[i] <= 1000`\n*   `0 <= k <= n`"
]