# Query `124`

## Original Question

*You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.

To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.

Return _the maximum money you can earn after cutting an_ `m x n` _piece of wood_.

Note that you can cut the piece of wood as many times as you want.

Example 1:

Input: m = 3, n = 5, prices = \[\[1,4,2\],\[2,2,7\],\[2,1,3\]\]
Output: 19
Explanation: The diagram above shows a possible scenario. It consists of:
- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \ 7 = 14.
- 1 piece of wood shaped 2 x 1, selling for a price of 1 \ 3 = 3.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.
This obtains a total of 14 + 3 + 2 = 19 money earned.
It can be shown that 19 is the maximum amount of money that can be earned.

Example 2:

Input: m = 4, n = 6, prices = \[\[3,2,10\],\[1,4,2\],\[4,1,3\]\]
Output: 32
Explanation: The diagram above shows a possible scenario. It consists of:
- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \ 10 = 30.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.
This obtains a total of 30 + 2 = 32 money earned.
It can be shown that 32 is the maximum amount of money that can be earned.
Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.

Constraints:

   `1 <= m, n <= 200`
   `1 <= prices.length <= 2  104`
   `prices[i].length == 3`
   `1 <= hi <= m`
   `1 <= wi <= n`
   `1 <= pricei <= 106`
   All the shapes of wood `(hi, wi)` are pairwise distinct.*


### Metrics

```
recip_rank: 0.0909
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.1710
ndcg_cut_50: 0.1710
ndcg_cut_100: 0.1710
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0455
map_cut_50: 0.0455
map_cut_100: 0.0455
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1801.txt
> from heapq import <br>    """You are given a 2D integer array `orders`, where each `orders[i] = [pricei, amounti, orderTypei]` denotes that `amounti` orders have been placed of type `orderTypei` at the price `pricei`. The `orderTypei` is:<br><br>   `0` if it is a batch of `buy` orders, or<br>   `1` if it is a batch of `sell` orders.<br><br>Note that `orders[i]` represents a batch of `amounti` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`.<br><br>There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:<br><br>   If the order is a `buy` order, you look at the `sell` order with the smallest price in the backlog. If that `sell` order's price is smaller than or equal to the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.<br>   Vice versa, if the order is a `sell` order, you look at the `buy` order with the largest price in the backlog. If that `buy` order's price is larger than or equal to the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.<br><br>Return _the total amount of orders in the backlog after placing all the orders from the input_. Since this number can be large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: orders = \[\[10,5,0\],\[15,2,1\],\[25,1,1\],\[30,4,0\]\]<br>Output: 6<br>Explanation: Here is what happens with the orders:<br>- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.<br>- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.<br>- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.<br>- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.<br>Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.<br><br>Example 2:<br><br>Input: orders = \[\[7,1000000000,1\],\[15,3,0\],\[5,999999995,0\],\[5,1,1\]\]<br>Output: 999999984<br>Explanation: Here is what happens with the orders:<br>- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.<br>- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.<br>- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.<br>- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.<br>Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).<br><br>Constraints:<br><br>   `1 <= orders.length <= 105`<br>   `orders[i].length == 3`<br>   `1 <= pricei, amounti <= 109`<br>   `orderTypei` is either `0` or `1`."""<br><br><br>def getNumberOfBacklogOrders(orders):<br>    buy_orders, sell_orders = [], []<br>    num_orders, mod = 0, int(1e9) + 7<br><br>    for price, amount, order_type in orders:<br>        if order_type == 0: # buy order<br>            while amount and sell_orders and sell_orders[0][0] <= price:<br>                x = min(amount, sell_orders[0][1])<br>                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x<br>                if sell_orders[0][1] == 0:<br>                    heappop(sell_orders)<br>            if amount:<br>                heappush(buy_orders, (-price, amount))<br>        else: # sell order<br>            while amount and buy_orders and -buy_orders[0][0] = price:<br>                x = min(amount, buy_orders[0][1])<br>                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x<br>                if buy_orders[0][1] == 0:<br>                    heappop(buy_orders)<br>            if amount:<br>                heappush(sell_orders, (price, amount))<br>    <br>    while buy_orders:<br>        num_orders = (num_orders + heappop(buy_orders)[1]) % mod<br><br>    while sell_orders:<br>        num_orders = (num_orders + heappop(sell_orders)[1]) % mod<br><br>    return num_orders

### DOC[2] (IRRELEVANT) leetcode/leetcode_1465.txt
> class TreeNode:<br>    """You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where:<br><br>   `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly, and<br>   `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut.<br><br>Return _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this modulo `109 + 7`.<br><br>Example 1:<br><br>Input: h = 5, w = 4, horizontalCuts = \[1,2,4\], verticalCuts = \[1,3\]<br>Output: 4 <br>Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.<br><br>Example 2:<br><br>Input: h = 5, w = 4, horizontalCuts = \[3,1\], verticalCuts = \[1\]<br>Output: 6<br>Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.<br><br>Example 3:<br><br>Input: h = 5, w = 4, horizontalCuts = \[3\], verticalCuts = \[3\]<br>Output: 9<br><br>Constraints:<br><br>   `2 <= h, w <= 109`<br>   `1 <= horizontalCuts.length <= min(h - 1, 105)`<br>   `1 <= verticalCuts.length <= min(w - 1, 105)`<br>   `1 <= horizontalCuts[i] < h`<br>   `1 <= verticalCuts[i] < w`<br>   All the elements in `horizontalCuts` are distinct.<br>   All the elements in `verticalCuts` are distinct."""<br><br>    def __init__(self, x):<br>        self.val = x<br>        self.left = None<br>        self.right = None<br><br>class Solution:<br>    def maxProduct(self, root: TreeNode) - int:<br>        def dfs(node):<br>            if not node:<br>                return 0<br>            return node.val + dfs(node.left) + dfs(node.right)<br><br>        def dfs2(node, half):<br>            nonlocal result<br><br>            if not node:<br>                return 0<br>            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)<br>            result = max(result, (total - cur_sum)  cur_sum)<br>            return cur_sum<br><br>        total = dfs(root)<br>        result = 0<br>        dfs2(root, total / 2)<br>        return result % (109 + 7)

### DOC[3] (IRRELEVANT) leetcode/leetcode_2280.txt
> def count_good_triplets(nums1: list, nums2: list) - int:<br>    """You are given a 2D integer array `stockPrices` where `stockPrices[i] = [dayi, pricei]` indicates the price of the stock on day `dayi` is `pricei`. A line chart is created from the array by plotting the points on an XY plane with the X-axis representing the day and the Y-axis representing the price and connecting adjacent points. One such example is shown below:<br><br>Return _the minimum number of lines needed to represent the line chart_.<br><br>Example 1:<br><br>Input: stockPrices = \[\[1,7\],\[2,6\],\[3,5\],\[4,4\],\[5,4\],\[6,3\],\[7,2\],\[8,1\]\]<br>Output: 3<br>Explanation:<br>The diagram above represents the input, with the X-axis representing the day and Y-axis representing the price.<br>The following 3 lines can be drawn to represent the line chart:<br>- Line 1 (in red) from (1,7) to (4,4) passing through (1,7), (2,6), (3,5), and (4,4).<br>- Line 2 (in blue) from (4,4) to (5,4).<br>- Line 3 (in green) from (5,4) to (8,1) passing through (5,4), (6,3), (7,2), and (8,1).<br>It can be shown that it is not possible to represent the line chart using less than 3 lines.<br><br>Example 2:<br><br>Input: stockPrices = \[\[3,4\],\[1,2\],\[7,8\],\[2,3\]\]<br>Output: 1<br>Explanation:<br>As shown in the diagram above, the line chart can be represented with a single line.<br><br>Constraints:<br><br>   `1 <= stockPrices.length <= 105`<br>   `stockPrices[i].length == 2`<br>   `1 <= dayi, pricei <= 109`<br>   All `dayi` are distinct."""<br><br>    n = len(nums1)<br>    pos1 = [0]  n<br>    pos2 = [0]  n<br>    for i in range(n):<br>        pos1[nums1[i]] = i<br>        pos2[nums2[i]] = i<br>    count = 0<br>    for x in range(n):<br>        for y in range(x + 1, n):<br>            for z in range(y + 1, n):<br>                if pos1[x] < pos1[y] < pos1[z] and pos2[x] < pos2[y] < pos2[z]:<br>                    count += 1<br>    return count

### DOC[4] (IRRELEVANT) leetcode/leetcode_2303.txt
> def tax_amount(brackets, income):<br>    """You are given a 0-indexed 2D integer array `brackets` where `brackets[i] = [upperi, percenti]` means that the `ith` tax bracket has an upper bound of `upperi` and is taxed at a rate of `percenti`. The brackets are sorted by upper bound (i.e. `upperi-1 < upperi` for `0 < i < brackets.length`).<br><br>Tax is calculated as follows:<br><br>   The first `upper0` dollars earned are taxed at a rate of `percent0`.<br>   The next `upper1 - upper0` dollars earned are taxed at a rate of `percent1`.<br>   The next `upper2 - upper1` dollars earned are taxed at a rate of `percent2`.<br>   And so on.<br><br>You are given an integer `income` representing the amount of money you earned. Return _the amount of money that you have to pay in taxes._ Answers within `10-5` of the actual answer will be accepted.<br><br>Example 1:<br><br>Input: brackets = \[\[3,50\],\[7,10\],\[12,25\]\], income = 10<br>Output: 2.65000<br>Explanation:<br>Based on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.<br>The tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.<br>In total, you pay $3 \ 50% + $4 \ 10% + $3 \ 25% = $2.65 in taxes.<br><br>Example 2:<br><br>Input: brackets = \[\[1,0\],\[4,25\],\[5,50\]\], income = 2<br>Output: 0.25000<br>Explanation:<br>Based on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket.<br>The tax rate for the two tax brackets is 0% and 25%, respectively.<br>In total, you pay $1 \ 0% + $1 \ 25% = $0.25 in taxes.<br><br>Example 3:<br><br>Input: brackets = \[\[2,50\]\], income = 0<br>Output: 0.00000<br>Explanation:<br>You have no income to tax, so you have to pay a total of $0 in taxes.<br><br>Constraints:<br><br>   `1 <= brackets.length <= 100`<br>   `1 <= upperi <= 1000`<br>   `0 <= percenti <= 100`<br>   `0 <= income <= 1000`<br>   `upperi` is sorted in ascending order.<br>   All the values of `upperi` are unique.<br>   The upper bound of the last tax bracket is greater than or equal to `income`."""<br><br>    tax = 0<br>    prev_upper = 0<br>    for upper, percent in brackets:<br>        tax += (min(upper, income) - prev_upper)  (percent / 100)<br>        prev_upper = upper<br>        if income <= upper:<br>            break<br>    return tax

### DOC[5] (IRRELEVANT) leetcode/leetcode_1928.txt
> from heapq import heappush, heappop<br>    """There is a country of `n` cities numbered from `0` to `n - 1` where all the cities are connected by bi-directional roads. The roads are represented as a 2D integer array `edges` where `edges[i] = [xi, yi, timei]` denotes a road between cities `xi` and `yi` that takes `timei` minutes to travel. There may be multiple roads of differing travel times connecting the same two cities, but no road connects a city to itself.<br><br>Each time you pass through a city, you must pay a passing fee. This is represented as a 0-indexed integer array `passingFees` of length `n` where `passingFees[j]` is the amount of dollars you must pay when you pass through city `j`.<br><br>In the beginning, you are at city `0` and want to reach city `n - 1` in `maxTime` minutes or less. The cost of your journey is the summation of passing fees for each city that you passed through at some moment of your journey (including the source and destination cities).<br><br>Given `maxTime`, `edges`, and `passingFees`, return _the minimum cost to complete your journey, or_ `-1` _if you cannot complete it within_ `maxTime` _minutes_.<br><br>Example 1:<br><br>Input: maxTime = 30, edges = \[\[0,1,10\],\[1,2,10\],\[2,5,10\],\[0,3,1\],\[3,4,10\],\[4,5,15\]\], passingFees = \[5,1,2,20,20,3\]<br>Output: 11<br>Explanation: The path to take is 0 - 1 - 2 - 5, which takes 30 minutes and has $11 worth of passing fees.<br><br>Example 2:<br><br>Input: maxTime = 29, edges = \[\[0,1,10\],\[1,2,10\],\[2,5,10\],\[0,3,1\],\[3,4,10\],\[4,5,15\]\], passingFees = \[5,1,2,20,20,3\]<br>Output: 48<br>Explanation: The path to take is 0 - 3 - 4 - 5, which takes 26 minutes and has $48 worth of passing fees.<br>You cannot take path 0 - 1 - 2 - 5 since it would take too long.<br><br>Example 3:<br><br>Input: maxTime = 25, edges = \[\[0,1,10\],\[1,2,10\],\[2,5,10\],\[0,3,1\],\[3,4,10\],\[4,5,15\]\], passingFees = \[5,1,2,20,20,3\]<br>Output: -1<br>Explanation: There is no way to reach city 5 from city 0 within 25 minutes.<br><br>Constraints:<br><br>   `1 <= maxTime <= 1000`<br>   `n == passingFees.length`<br>   `2 <= n <= 1000`<br>   `n - 1 <= edges.length <= 1000`<br>   `0 <= xi, yi <= n - 1`<br>   `1 <= timei <= 1000`<br>   `1 <= passingFees[j] <= 1000`<br>   The graph may contain multiple edges between two nodes.<br>   The graph does not contain self loops."""<br><br><br>def getNumberOfBacklogOrders(orders):<br>    buy, sell = [], []<br><br>    for price, amount, orderType in orders:<br>        if orderType == 0:<br>            while amount  0 and sell and -sell[0][0] <= price:<br>                executedAmount = min(amount, sell[0][1])<br>                amount -= executedAmount<br>                sell[0] = [-sell[0][0], sell[0][1] - executedAmount]<br>                if sell[0][1] == 0:<br>                    heappop(sell)<br>            if amount:<br>                heappush(buy, [-price, amount])<br>        else:<br>            while amount  0 and buy and buy[0][0] = price:<br>                executedAmount = min(amount, buy[0][1])<br>                amount -= executedAmount<br>                buy[0] = [buy[0][0], buy[0][1] - executedAmount]<br>                if buy[0][1] == 0:<br>                    heappop(buy)<br>            if amount:<br>                heappush(sell, [-price, amount])<br><br>    res = sum(item[1] for item in buy) + sum(item[1] for item in sell)<br>    return res % 1000000007


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_1240.txt
> from functools import lru_cache<br>    """Given a rectangle of size `n` x `m`, return _the minimum number of integer-sided squares that tile the rectangle_.<br><br>Example 1:<br><br>Input: n = 2, m = 3<br>Output: 3<br>Explanation: `3` squares are necessary to cover the rectangle.<br>`2` (squares of `1x1`)<br>`1` (square of `2x2`)<br><br>Example 2:<br><br>Input: n = 5, m = 8<br>Output: 5<br><br>Example 3:<br><br>Input: n = 11, m = 13<br>Output: 6<br><br>Constraints:<br><br>   `1 <= n, m <= 13`"""<br><br><br>def stoneGameII(piles):<br>    n = len(piles)<br>    for i in range(n - 2, -1, -1):<br>        piles[i] += piles[i + 1]<br><br>    @lru_cache(None)<br>    def search(idx, M):<br>        if idx + 2  M = n:<br>            return piles[idx]<br>        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2  M + 1))<br><br>    return search(0, 1)

### GROUND TRUTH 1, ranked 10, leetcode/leetcode_1444.txt
> def number_of_steps(num):<br>    """Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.<br><br>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.<br><br>_Return the number of ways of cutting the pizza such that each piece contains at least one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.<br><br>Example 1:<br><br>Input: pizza = \[ "A.. ", "AAA ", "... "\], k = 3<br>Output: 3 <br>Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.<br><br>Example 2:<br><br>Input: pizza = \[ "A.. ", "AA. ", "... "\], k = 3<br>Output: 1<br><br>Example 3:<br><br>Input: pizza = \[ "A.. ", "A.. ", "... "\], k = 1<br>Output: 1<br><br>Constraints:<br><br>   `1 <= rows, cols <= 50`<br>   `rows == pizza.length`<br>   `cols == pizza[i].length`<br>   `1 <= k <= 10`<br>   `pizza` consists of characters `'A'` and `'.'` only."""<br><br>    steps = 0<br>    while num:<br>        steps += 1 if num % 2 == 0 else 2<br>        num = 1<br>    return steps - 1
