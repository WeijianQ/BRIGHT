# Query `23`

## Original Question

*You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

Return `true` if you can make this square and `false` otherwise.

Example 1:

Input: matchsticks = \[1,1,2,2,2\]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.

Example 2:

Input: matchsticks = \[3,3,3,3,4\]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.

Constraints:

   `1 <= matchsticks.length <= 15`
   `1 <= matchsticks[i] <= 108`*


### Metrics

```
recip_rank: 0.0015
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_699.txt
> def fallingSquares(positions):<br>    """There are several squares being dropped onto the X-axis of a 2D plane.<br><br>You are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.<br><br>Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.<br><br>After each square is dropped, you must record the height of the current tallest stack of squares.<br><br>Return _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.<br><br>Example 1:<br><br>Input: positions = \[\[1,2\],\[2,3\],\[6,1\]\]<br>Output: \[2,5,5\]<br>Explanation:<br>After the first drop, the tallest stack is square 1 with a height of 2.<br>After the second drop, the tallest stack is squares 1 and 2 with a height of 5.<br>After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.<br>Thus, we return an answer of \[2, 5, 5\].<br><br>Example 2:<br><br>Input: positions = \[\[100,100\],\[200,100\]\]<br>Output: \[100,100\]<br>Explanation:<br>After the first drop, the tallest stack is square 1 with a height of 100.<br>After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.<br>Thus, we return an answer of \[100, 100\].<br>Note that square 2 only brushes the right side of square 1, which does not count as landing on it.<br><br>Constraints:<br><br>   `1 <= positions.length <= 1000`<br>   `1 <= lefti <= 108`<br>   `1 <= sideLengthi <= 106`"""<br><br>    ans = []<br>    intervals = []<br><br>    for p in positions:<br>        L, size = p<br>        R = L + size<br>        h = size<br>        for h2, R2 in intervals:<br>            if R2  L and R  R2:<br>                h = max(h, size + h2)<br><br>        maxHeight = max((h2 for h2, R2 in intervals), default=0)<br>        ans.append(max(maxHeight, h))<br>        intervals.append((h, R))<br><br>    return ans

### DOC[2] (IRRELEVANT) leetcode/leetcode_1725.txt
> def numberOfSets(n, k):<br>    """You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`.<br><br>You can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`.<br><br>Let `maxLen` be the side length of the largest square you can obtain from any of the given rectangles.<br><br>Return _the number of rectangles that can make a square with a side length of_ `maxLen`.<br><br>Example 1:<br><br>Input: rectangles = \[\[5,8\],\[3,9\],\[5,12\],\[16,5\]\]<br>Output: 3<br>Explanation: The largest squares you can get from each rectangle are of lengths \[5,3,5,5\].<br>The largest possible square is of length 5, and you can get it out of 3 rectangles.<br><br>Example 2:<br><br>Input: rectangles = \[\[2,3\],\[3,7\],\[4,3\],\[3,7\]\]<br>Output: 3<br><br>Constraints:<br><br>   `1 <= rectangles.length <= 1000`<br>   `rectangles[i].length == 2`<br>   `1 <= li, wi <= 109`<br>   `li != wi`"""<br><br>    mod = 109 + 7<br>    dp = [[0]  (k + 1) for _ in range(n)]<br>    presum = [1]  n<br>    <br>    for j in range(1, k + 1):<br>        for i in range(n):<br>            dp[i][j] = presum[i]<br>            if i  0:<br>                dp[i][j] += dp[i - 1][j]<br>            dp[i][j] %= mod<br>            presum[i] = (presum[i] + dp[i][j - 1]) % mod<br>    <br>    return dp[n - 1][k]

### DOC[3] (IRRELEVANT) leetcode/leetcode_1866.txt
> from collections import defaultdict<br>    """There are `n` uniquely-sized sticks whose lengths are integers from `1` to `n`. You want to arrange the sticks such that exactly `k` sticks are visible from the left. A stick is visible from the left if there are no longer sticks to the left of it.<br><br>   For example, if the sticks are arranged `[1,3,2,5,4]`, then the sticks with lengths `1`, `3`, and `5` are visible from the left.<br><br>Given `n` and `k`, return _the number of such arrangements_. Since the answer may be large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: n = 3, k = 2<br>Output: 3<br>Explanation: \[1,3,2\], \[2,3,1\], and \[2,1,3\] are the only arrangements such that exactly 2 sticks are visible.<br>The visible sticks are underlined.<br><br>Example 2:<br><br>Input: n = 5, k = 5<br>Output: 1<br>Explanation: \[1,2,3,4,5\] is the only arrangement such that all 5 sticks are visible.<br>The visible sticks are underlined.<br><br>Example 3:<br><br>Input: n = 20, k = 11<br>Output: 647427950<br>Explanation: There are 647427950 (mod 109 \+ 7) ways to rearrange the sticks such that exactly 11 sticks are visible.<br><br>Constraints:<br><br>   `1 <= n <= 1000`<br>   `1 <= k <= n`"""<br><br><br>def restoreArray(adjacentPairs):<br>    graph = defaultdict(list)<br>    for pair in adjacentPairs:<br>        graph[pair[0]].append(pair[1])<br>        graph[pair[1]].append(pair[0])<br><br>    n = len(graph)<br>    nums = [0]  n<br>    for key, nodes in graph.items():<br>        if len(nodes) == 1:<br>            nums[0] = key<br>            break<br><br>    nums[1] = graph[nums[0]][0]<br>    for i in range(2, n):<br>        nums[i] = (graph[nums[i - 1]][1]<br>                   if (nums[i - 2] == graph[nums[i - 1]][0])<br>                   else graph[nums[i - 1]][0])<br><br>    return nums

### DOC[4] (IRRELEVANT) leetcode/leetcode_2056.txt
> def count_valid_combos(pieces, positions, index=0):<br>    """There is an `8 x 8` chessboard containing `n` pieces (rooks, queens, or bishops). You are given a string array `pieces` of length `n`, where `pieces[i]` describes the type (rook, queen, or bishop) of the `ith` piece. In addition, you are given a 2D integer array `positions` also of length `n`, where `positions[i] = [ri, ci]` indicates that the `ith` piece is currently at the 1-based coordinate `(ri, ci)` on the chessboard.<br><br>When making a move for a piece, you choose a destination square that the piece will travel toward and stop on.<br><br>   A rook can only travel horizontally or vertically from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, or `(r, c-1)`.<br>   A queen can only travel horizontally, vertically, or diagonally from `(r, c)` to the direction of `(r+1, c)`, `(r-1, c)`, `(r, c+1)`, `(r, c-1)`, `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.<br>   A bishop can only travel diagonally from `(r, c)` to the direction of `(r+1, c+1)`, `(r+1, c-1)`, `(r-1, c+1)`, `(r-1, c-1)`.<br><br>You must make a move for every piece on the board simultaneously. A move combination consists of all the moves performed on all the given pieces. Every second, each piece will instantaneously travel one square towards their destination if they are not already at it. All pieces start traveling at the `0th` second. A move combination is invalid if, at a given time, two or more pieces occupy the same square.<br><br>Return _the number of valid move combinations_​​​​​.<br><br>Notes:<br><br>   No two pieces will start in the same square.<br>   You may choose the square a piece is already on as its destination.<br>   If two pieces are directly adjacent to each other, it is valid for them to move past each other and swap positions in one second.<br><br>Example 1:<br><br>Input: pieces = \[ "rook "\], positions = \[\[1,1\]\]<br>Output: 15<br>Explanation: The image above shows the possible squares the piece can move to.<br><br>Example 2:<br><br>Input: pieces = \[ "queen "\], positions = \[\[1,1\]\]<br>Output: 22<br>Explanation: The image above shows the possible squares the piece can move to.<br><br>Example 3:<br><br>Input: pieces = \[ "bishop "\], positions = \[\[4,3\]\]<br>Output: 12<br>Explanation: The image above shows the possible squares the piece can move to.<br><br>Constraints:<br><br>   `n == pieces.length`<br>   `n == positions.length`<br>   `1 <= n <= 4`<br>   `pieces` only contains the strings `"rook "`, `"queen "`, and `"bishop "`.<br>   There will be at most one queen on the chessboard.<br>   `1 <= xi, yi <= 8`<br>   Each `positions[i]` is distinct."""<br><br>    if index == len(pieces):<br>        return 1<br><br>    r, c = positions[index]<br>    dr = [0, 1, 0, -1, 1, 1, -1, -1]<br>    dc = [1, 0, -1, 0, 1, -1, 1, -1]<br>    valids = 0<br><br>    for x in range(8):<br>        if pieces[index] == "bishop" and x < 4:<br>            continue<br>        if pieces[index] == "rook" and x = 4:<br>            break<br><br>        for dist in range(1, 9):<br>            nr, nc = r + dr[x]  dist, c + dc[x]  dist<br>            if nr < 1 or nr  8 or nc < 1 or nc  8:<br>                break<br>            if nr == r and nc == c:<br>                continue<br><br>            valid = True<br>            for other in range(len(positions)):<br>                if other == index:<br>                    continue<br>                orr, occ = positions[other]<br>                if orr == nr and occ == nc:<br>                    valid = False<br>                    break<br>                if orr + occ == nr + nc or orr - occ == nr - nc:<br>                    valid = False<br>                    break<br>                if orr == nr or occ == nc:<br>                    valid = False<br>                    break<br><br>            if valid:<br>                positions[index] = [nr, nc]<br>                valids += count_valid_combos(pieces, positions, index + 1)<br>                positions[index] = [r, c]<br><br>    return valids

### DOC[5] (IRRELEVANT) leetcode/leetcode_1547.txt
> def destCity(paths):<br>    """Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length 6 is labelled as follows:<br><br>Given an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.<br><br>You should perform the cuts in order, you can change the order of the cuts as you wish.<br><br>The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.<br><br>Return _the minimum total cost_ of the cuts.<br><br>Example 1:<br><br>Input: n = 7, cuts = \[1,3,4,5\]<br>Output: 16<br>Explanation: Using cuts order = \[1, 3, 4, 5\] as in the input leads to the following scenario:<br> <br>The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.<br>Rearranging the cuts to be \[3, 5, 1, 4\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).<br><br>Example 2:<br><br>Input: n = 9, cuts = \[5,6,1,4,2\]<br>Output: 22<br>Explanation: If you try the given cuts ordering the cost will be 25.<br>There are much ordering with total cost <= 25, for example, the order \[4, 6, 5, 2, 1\] has total cost = 22 which is the minimum possible.<br><br>Constraints:<br><br>   `2 <= n <= 106`<br>   `1 <= cuts.length <= min(n - 1, 100)`<br>   `1 <= cuts[i] <= n - 1`<br>   All the integers in `cuts` array are distinct."""<br><br>    starting_cities = set()<br>    <br>    for path in paths:<br>        starting_cities.add(path[0])<br><br>    for path in paths:<br>        if path[1] not in starting_cities:<br>            return path[1]<br><br>    return ""


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2397.txt
> def max_covered_rows(matrix, num_select):<br>    """You are given a 0-indexed `m x n` binary matrix `matrix` and an integer `numSelect`, which denotes the number of distinct columns you must select from `matrix`.<br><br>Let us consider `s = {c1, c2, ...., cnumSelect}` as the set of columns selected by you. A row `row` is covered by `s` if:<br><br>   For each cell `matrix[row][col]` (`0 <= col <= n - 1`) where `matrix[row][col] == 1`, `col` is present in `s` or,<br>   No cell in `row` has a value of `1`.<br><br>You need to choose `numSelect` columns such that the number of rows that are covered is maximized.<br><br>Return _the maximum number of rows that can be covered by a set of_ `numSelect` _columns._<br><br>Example 1:<br><br>Input: matrix = \[\[0,0,0\],\[1,0,1\],\[0,1,1\],\[0,0,1\]\], numSelect = 2<br>Output: 3<br>Explanation: One possible way to cover 3 rows is shown in the diagram above.<br>We choose s = {0, 2}.<br>- Row 0 is covered because it has no occurrences of 1.<br>- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.<br>- Row 2 is not covered because matrix\[2\]\[1\] == 1 but 1 is not present in s.<br>- Row 3 is covered because matrix\[2\]\[2\] == 1 and 2 is present in s.<br>Thus, we can cover three rows.<br>Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.<br><br>Example 2:<br><br>Input: matrix = \[\[1\],\[0\]\], numSelect = 1<br>Output: 2<br>Explanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.<br>Therefore, we return 2.<br><br>Constraints:<br><br>   `m == matrix.length`<br>   `n == matrix[i].length`<br>   `1 <= m, n <= 12`<br>   `matrix[i][j]` is either `0` or `1`.<br>   `1 <= numSelect <= n`"""<br><br>    m, n = len(matrix), len(matrix[0])<br>    max_covered = 0<br>    for i in range(1 << n):<br>        if bin(i).count('1') == num_select:<br>            covered = 0<br>            for row in range(m):<br>                for col in range(n):<br>                    if matrix[row][col] == 1 and i & (1 << col):<br>                        covered += 1<br>                        break<br>            max_covered = max(max_covered, covered)<br>    return max_covered
