# Query `14`

## Original Question

*There are `n` bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.

On the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the `ith` round, you toggle every `i` bulb. For the `nth` round, you only toggle the last bulb.

Return _the number of bulbs that are on after `n` rounds_.

Example 1:

Input: n = 3
Output: 1
Explanation: At first, the three bulbs are \[off, off, off\].
After the first round, the three bulbs are \[on, on, on\].
After the second round, the three bulbs are \[on, off, on\].
After the third round, the three bulbs are \[on, off, off\]. 
So you should return 1 because there is only one bulb is on.

Example 2:

Input: n = 0
Output: 0

Example 3:

Input: n = 1
Output: 1

Constraints:

   `0 <= n <= 109`*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.2500
recall_5: 0.2500
recall_10: 0.2500
recall_25: 0.2500
recall_50: 0.2500
recall_100: 0.2500
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.3904
ndcg_cut_10: 0.3904
ndcg_cut_25: 0.3904
ndcg_cut_50: 0.3904
ndcg_cut_100: 0.3904
map_cut_1: 0.2500
map_cut_5: 0.2500
map_cut_10: 0.2500
map_cut_25: 0.2500
map_cut_50: 0.2500
map_cut_100: 0.2500
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_672.txt
> def num_light_configuration(n, presses):<br>    """There is a room with `n` bulbs labeled from `1` to `n` that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where:<br><br>   Button 1: Flips the status of all the bulbs.<br>   Button 2: Flips the status of all the bulbs with even labels (i.e., `2, 4, ...`).<br>   Button 3: Flips the status of all the bulbs with odd labels (i.e., `1, 3, ...`).<br>   Button 4: Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...` (i.e., `1, 4, 7, 10, ...`).<br><br>You must make exactly `presses` button presses in total. For each press, you may pick any of the four buttons to press.<br><br>Given the two integers `n` and `presses`, return _the number of different possible statuses after performing all_ `presses` _button presses_.<br><br>Example 1:<br><br>Input: n = 1, presses = 1<br>Output: 2<br>Explanation: Status can be:<br>- \[off\] by pressing button 1<br>- \[on\] by pressing button 2<br><br>Example 2:<br><br>Input: n = 2, presses = 1<br>Output: 3<br>Explanation: Status can be:<br>- \[off, off\] by pressing button 1<br>- \[on, off\] by pressing button 2<br>- \[off, on\] by pressing button 3<br><br>Example 3:<br><br>Input: n = 3, presses = 1<br>Output: 4<br>Explanation: Status can be:<br>- \[off, off, off\] by pressing button 1<br>- \[off, on, off\] by pressing button 2<br>- \[on, off, on\] by pressing button 3<br>- \[off, on, on\] by pressing button 4<br><br>Constraints:<br><br>   `1 <= n <= 1000`<br>   `0 <= presses <= 1000`"""<br><br>    dp = [[0]  (presses + 1) for _ in range(n+1)]<br>    dp[0][0] = 1<br><br>    for i in range(n + 1):<br>        for j in range(1, presses + 1):<br>            dp[i][j] = dp[i][j - 1]  (i + 1) + (dp[i - 1][j - 1] if i  0 else 0)<br><br>    return dp[n][presses]

### DOC[2] (IRRELEVANT) leetcode/leetcode_1488.txt
> def get_power(x):<br>    """Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the `nth` lake, the `nth` lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.<br><br>Given an integer array `rains` where:<br><br>   `rains[i]  0` means there will be rains over the `rains[i]` lake.<br>   `rains[i] == 0` means there are no rains this day and you can choose one lake this day and dry it.<br><br>Return _an array `ans`_ where:<br><br>   `ans.length == rains.length`<br>   `ans[i] == -1` if `rains[i]  0`.<br>   `ans[i]` is the lake you choose to dry in the `ith` day if `rains[i] == 0`.<br><br>If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.<br><br>Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.<br><br>Example 1:<br><br>Input: rains = \[1,2,3,4\]<br>Output: \[-1,-1,-1,-1\]<br>Explanation: After the first day full lakes are \[1\]<br>After the second day full lakes are \[1,2\]<br>After the third day full lakes are \[1,2,3\]<br>After the fourth day full lakes are \[1,2,3,4\]<br>There's no day to dry any lake and there is no flood in any lake.<br><br>Example 2:<br><br>Input: rains = \[1,2,0,0,2,1\]<br>Output: \[-1,-1,2,1,-1,-1\]<br>Explanation: After the first day full lakes are \[1\]<br>After the second day full lakes are \[1,2\]<br>After the third day, we dry lake 2. Full lakes are \[1\]<br>After the fourth day, we dry lake 1. There is no full lakes.<br>After the fifth day, full lakes are \[2\].<br>After the sixth day, full lakes are \[1,2\].<br>It is easy that this scenario is flood-free. \[-1,-1,1,2,-1,-1\] is another acceptable scenario.<br><br>Example 3:<br><br>Input: rains = \[1,2,0,1,2\]<br>Output: \[\]<br>Explanation: After the second day, full lakes are  \[1,2\]. We have to dry one lake in the third day.<br>After that, it will rain over lakes \[1,2\]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.<br><br>Constraints:<br><br>   `1 <= rains.length <= 105`<br>   `0 <= rains[i] <= 109`"""<br><br>    steps = 0<br>    while x != 1:<br>        if x % 2 == 0:<br>            x //= 2<br>        else:<br>            x = 3  x + 1<br>        steps += 1<br>    return steps<br><br>def sort_by_power(lo, hi, k):<br>    nums = [(get_power(i), i) for i in range(lo, hi + 1)]<br>    nums.sort()<br>    return nums[k - 1][1]

### DOC[3] (IRRELEVANT) leetcode/leetcode_1509.txt
> def minDifference(nums):<br>    """You are given an integer array `nums`.<br><br>In one move, you can choose one element of `nums` and change it to any value.<br><br>Return _the minimum difference between the largest and smallest value of `nums` after performing at most three moves_.<br><br>Example 1:<br><br>Input: nums = \[5,3,2,4\]<br>Output: 0<br>Explanation: We can make at most 3 moves.<br>In the first move, change 2 to 3. nums becomes \[5,3,3,4\].<br>In the second move, change 4 to 3. nums becomes \[5,3,3,3\].<br>In the third move, change 5 to 3. nums becomes \[3,3,3,3\].<br>After performing 3 moves, the difference between the minimum and maximum is 3 - 3 = 0.<br><br>Example 2:<br><br>Input: nums = \[1,5,0,10,14\]<br>Output: 1<br>Explanation: We can make at most 3 moves.<br>In the first move, change 5 to 0. nums becomes \[1,0,0,10,14\].<br>In the second move, change 10 to 0. nums becomes \[1,0,0,0,14\].<br>In the third move, change 14 to 1. nums becomes \[1,0,0,0,1\].<br>After performing 3 moves, the difference between the minimum and maximum is 1 - 0 = 0.<br>It can be shown that there is no way to make the difference 0 in 3 moves.<br><br>Example 3:<br><br>Input: nums = \[3,100,20\]<br>Output: 0<br>Explanation: We can make at most 3 moves.<br>In the first move, change 100 to 7. nums becomes \[4,7,20\].<br>In the second move, change 20 to 7. nums becomes \[4,7,7\].<br>In the third move, change 4 to 3. nums becomes \[7,7,7\].<br>After performing 3 moves, the difference between the minimum and maximum is 7 - 7 = 0.<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `-109 <= nums[i] <= 109`"""<br><br>    n = len(nums)<br>    if n <= 4: return 0<br>    nums.sort()<br>    res = float('inf')<br>    for i in range(4):<br>        res = min(res, nums[n - 4 + i] - nums[i])<br>    return res

### DOC[4] (IRRELEVANT) leetcode/leetcode_2589.txt
> def min_time_on(tasks):<br>    """There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array `tasks` where `tasks[i] = [starti, endi, durationi]` indicates that the `ith` task should run for a total of `durationi` seconds (not necessarily continuous) within the inclusive time range `[starti, endi]`.<br><br>You may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.<br><br>Return _the minimum time during which the computer should be turned on to complete all tasks_.<br><br>Example 1:<br><br>Input: tasks = \[\[2,3,1\],\[4,5,1\],\[1,5,2\]\]<br>Output: 2<br>Explanation: <br>- The first task can be run in the inclusive time range \[2, 2\].<br>- The second task can be run in the inclusive time range \[5, 5\].<br>- The third task can be run in the two inclusive time ranges \[2, 2\] and \[5, 5\].<br>The computer will be on for a total of 2 seconds.<br><br>Example 2:<br><br>Input: tasks = \[\[1,3,2\],\[2,5,3\],\[5,6,2\]\]<br>Output: 4<br>Explanation: <br>- The first task can be run in the inclusive time range \[2, 3\].<br>- The second task can be run in the inclusive time ranges \[2, 3\] and \[5, 5\].<br>- The third task can be run in the two inclusive time range \[5, 6\].<br>The computer will be on for a total of 4 seconds.<br><br>Constraints:<br><br>   `1 <= tasks.length <= 2000`<br>   `tasks[i].length == 3`<br>   `1 <= starti, endi <= 2000`<br>   `1 <= durationi <= endi - starti + 1`"""<br><br>    intervals = sorted([[task[1] + 1, task[2]] for task in tasks])<br><br>    dp = [0]  2001<br>    for interval in intervals:<br>        for i in range(2000, interval[0] - 1, -1):<br>            dp[i] = max(dp[i], dp[i - interval[1]] + interval[1])<br><br>    return dp[-1]

### DOC[5] (IRRELEVANT) leetcode/leetcode_2462.txt
> def hireWorkers(costs, k, candidates):<br>    """You are given a 0-indexed integer array `costs` where `costs[i]` is the cost of hiring the `ith` worker.<br><br>You are also given two integers `k` and `candidates`. We want to hire exactly `k` workers according to the following rules:<br><br>   You will run `k` sessions and hire exactly one worker in each session.<br>   In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index.<br>       For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,1,2]`.<br>       In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,2,7,7,2]`. Please note that the indexing may be changed in the process.<br>   If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.<br>   A worker can only be chosen once.<br><br>Return _the total cost to hire exactly_ `k` _workers._<br><br>Example 1:<br><br>Input: costs = \[17,12,10,2,7,2,11,20,8\], k = 3, candidates = 4<br>Output: 11<br>Explanation: We hire 3 workers in total. The total cost is initially 0.<br>- In the first hiring round we choose the worker from \[17,12,10,2,7,2,11,20,8\]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.<br>- In the second hiring round we choose the worker from \[17,12,10,7,2,11,20,8\]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.<br>- In the third hiring round we choose the worker from \[17,12,10,7,11,20,8\]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.<br>The total hiring cost is 11.<br><br>Example 2:<br><br>Input: costs = \[1,2,4,1\], k = 3, candidates = 3<br>Output: 4<br>Explanation: We hire 3 workers in total. The total cost is initially 0.<br>- In the first hiring round we choose the worker from \[1,2,4,1\]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.<br>- In the second hiring round we choose the worker from \[2,4,1\]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.<br>- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers \[2,4\]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.<br>The total hiring cost is 4.<br><br>Constraints:<br><br>   `1 <= costs.length <= 105`<br>   `1 <= costs[i] <= 105`<br>   `1 <= k, candidates <= costs.length`"""<br><br>    n = len(costs)<br>    workers = sorted([(cost, i) for i, cost in enumerate(costs)])<br><br>    cost = 0<br>    for i in range(k):<br>        if min(workers[i][1], n - workers[i][1] - 1) < candidates:<br>            cost += workers[i][0]<br><br>    return cost


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_672.txt
> def num_light_configuration(n, presses):<br>    """There is a room with `n` bulbs labeled from `1` to `n` that all are turned on initially, and four buttons on the wall. Each of the four buttons has a different functionality where:<br><br>   Button 1: Flips the status of all the bulbs.<br>   Button 2: Flips the status of all the bulbs with even labels (i.e., `2, 4, ...`).<br>   Button 3: Flips the status of all the bulbs with odd labels (i.e., `1, 3, ...`).<br>   Button 4: Flips the status of all the bulbs with a label `j = 3k + 1` where `k = 0, 1, 2, ...` (i.e., `1, 4, 7, 10, ...`).<br><br>You must make exactly `presses` button presses in total. For each press, you may pick any of the four buttons to press.<br><br>Given the two integers `n` and `presses`, return _the number of different possible statuses after performing all_ `presses` _button presses_.<br><br>Example 1:<br><br>Input: n = 1, presses = 1<br>Output: 2<br>Explanation: Status can be:<br>- \[off\] by pressing button 1<br>- \[on\] by pressing button 2<br><br>Example 2:<br><br>Input: n = 2, presses = 1<br>Output: 3<br>Explanation: Status can be:<br>- \[off, off\] by pressing button 1<br>- \[on, off\] by pressing button 2<br>- \[off, on\] by pressing button 3<br><br>Example 3:<br><br>Input: n = 3, presses = 1<br>Output: 4<br>Explanation: Status can be:<br>- \[off, off, off\] by pressing button 1<br>- \[off, on, off\] by pressing button 2<br>- \[on, off, on\] by pressing button 3<br>- \[off, on, on\] by pressing button 4<br><br>Constraints:<br><br>   `1 <= n <= 1000`<br>   `0 <= presses <= 1000`"""<br><br>    dp = [[0]  (presses + 1) for _ in range(n+1)]<br>    dp[0][0] = 1<br><br>    for i in range(n + 1):<br>        for j in range(1, presses + 1):<br>            dp[i][j] = dp[i][j - 1]  (i + 1) + (dp[i - 1][j - 1] if i  0 else 0)<br><br>    return dp[n][presses]

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_995.txt
> def min_k_bit_flips(nums, k):<br>    """You are given a binary array `nums` and an integer `k`.<br><br>A k-bit flip is choosing a subarray of length `k` from `nums` and simultaneously changing every `0` in the subarray to `1`, and every `1` in the subarray to `0`.<br><br>Return _the minimum number of k-bit flips required so that there is no_ `0` _in the array_. If it is not possible, return `-1`.<br><br>A subarray is a contiguous part of an array.<br><br>Example 1:<br><br>Input: nums = \[0,1,0\], k = 1<br>Output: 2<br>Explanation: Flip nums\[0\], then flip nums\[2\].<br><br>Example 2:<br><br>Input: nums = \[1,1,0\], k = 2<br>Output: -1<br>Explanation: No matter how we flip subarrays of size 2, we cannot make the array become \[1,1,1\].<br><br>Example 3:<br><br>Input: nums = \[0,0,0,1,0,1,1,0\], k = 3<br>Output: 3<br>Explanation: <br>Flip nums\[0\],nums\[1\],nums\[2\]: nums becomes \[1,1,1,1,0,1,1,0\]<br>Flip nums\[4\],nums\[5\],nums\[6\]: nums becomes \[1,1,1,1,1,0,0,0\]<br>Flip nums\[5\],nums\[6\],nums\[7\]: nums becomes \[1,1,1,1,1,1,1,1\]<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `1 <= k <= nums.length`"""<br><br>    n = len(nums)<br>    flipped = [0]  n<br>    flips = ans = 0<br>    for i in range(n):<br>        if i = k:<br>            flips -= flipped[i - k]<br>        if (flips + nums[i]) % 2 == 0:<br>            if i + k  n:<br>                return -1<br>            flipped[i] = 1<br>            flips += 1<br>            ans += 1<br>    return ans

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_1375.txt
> def find_kth_palindrome(k, int_length):<br>    """You have a 1-indexed binary string of length `n` where all the bits are `0` initially. We will flip all the bits of this binary string (i.e., change them from `0` to `1`) one by one. You are given a 1-indexed integer array `flips` where `flips[i]` indicates that the bit at index `i` will be flipped in the `ith` step.<br><br>A binary string is prefix-aligned if, after the `ith` step, all the bits in the inclusive range `[1, i]` are ones and all the other bits are zeros.<br><br>Return _the number of times the binary string is prefix-aligned during the flipping process_.<br><br>Example 1:<br><br>Input: flips = \[3,2,4,1,5\]<br>Output: 2<br>Explanation: The binary string is initially  "00000 ".<br>After applying step 1: The string becomes  "00100 ", which is not prefix-aligned.<br>After applying step 2: The string becomes  "01100 ", which is not prefix-aligned.<br>After applying step 3: The string becomes  "01110 ", which is not prefix-aligned.<br>After applying step 4: The string becomes  "11110 ", which is prefix-aligned.<br>After applying step 5: The string becomes  "11111 ", which is prefix-aligned.<br>We can see that the string was prefix-aligned 2 times, so we return 2.<br><br>Example 2:<br><br>Input: flips = \[4,1,2,3\]<br>Output: 1<br>Explanation: The binary string is initially  "0000 ".<br>After applying step 1: The string becomes  "0001 ", which is not prefix-aligned.<br>After applying step 2: The string becomes  "1001 ", which is not prefix-aligned.<br>After applying step 3: The string becomes  "1101 ", which is not prefix-aligned.<br>After applying step 4: The string becomes  "1111 ", which is prefix-aligned.<br>We can see that the string was prefix-aligned 1 time, so we return 1.<br><br>Constraints:<br><br>   `n == flips.length`<br>   `1 <= n <= 5  104`<br>   `flips` is a permutation of the integers in the range `[1, n]`."""<br><br>    mid = (int_length + 1) // 2<br>    limit = 10  mid - 1<br><br>    i = 0<br>    while i <= limit:<br>        num = str(i)<br>        rev = num[::-1]<br>        if int_length % 2 != 0:<br>            rev = rev[1:]<br>        palindrome = int(num + rev)<br>        if palindrome  0:<br>            k -= 1<br>        if k == 0:<br>            return palindrome<br>        i += 1<br>    return -1<br><br>def palindrome_queries(queries, int_length):<br>    return [find_kth_palindrome(query, int_length) for query in queries]

### GROUND TRUTH 3, ranked not in top 100, leetcode/leetcode_2485.txt
> def find_pivot(n: int) - int:<br>    """Given a positive integer `n`, find the pivot integer `x` such that:<br><br>   The sum of all elements between `1` and `x` inclusively equals the sum of all elements between `x` and `n` inclusively.<br><br>Return _the pivot integer_ `x`. If no such integer exists, return `-1`. It is guaranteed that there will be at most one pivot index for the given input.<br><br>Example 1:<br><br>Input: n = 8<br>Output: 6<br>Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.<br><br>Example 2:<br><br>Input: n = 1<br>Output: 1<br>Explanation: 1 is the pivot integer since: 1 = 1.<br><br>Example 3:<br><br>Input: n = 4<br>Output: -1<br>Explanation: It can be proved that no such integer exist.<br><br>Constraints:<br><br>   `1 <= n <= 1000`"""<br><br>    total = n  (n + 1) // 2<br>    left_sum = 0<br>    for x in range(1, n + 1):<br>        left_sum += x<br>        if 2  left_sum == total:<br>            return x<br>    return -1
