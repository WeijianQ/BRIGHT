# Query `90`

## Original Question

*You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.

You are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the shortest amount of time.

Return _the number of ways you can arrive at your destination in the shortest amount of time_. Since the answer may be large, return it modulo `109 + 7`.

Example 1:

Input: n = 7, roads = \[\[0,6,7\],\[0,1,2\],\[1,2,3\],\[1,3,3\],\[6,3,3\],\[3,5,1\],\[6,5,1\],\[2,5,1\],\[0,4,5\],\[4,6,2\]\]
Output: 4
Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6

Example 2:

Input: n = 2, roads = \[\[1,0,10\]\]
Output: 1
Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.

Constraints:

   `1 <= n <= 200`
   `n - 1 <= roads.length <= n  (n - 1) / 2`
   `roads[i].length == 3`
   `0 <= ui, vi <= n - 1`
   `1 <= timei <= 109`
   `ui != vi`
   There is at most one road connecting any two intersections.
   You can reach any intersection from any other intersection.*


### Metrics

```
recip_rank: 0.1429
P_1: 0.0000
P_5: 0.0000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.3333
recall_25: 0.3333
recall_50: 0.3333
recall_100: 0.3333
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.1564
ndcg_cut_25: 0.1564
ndcg_cut_50: 0.1564
ndcg_cut_100: 0.1564
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0476
map_cut_25: 0.0476
map_cut_50: 0.0476
map_cut_100: 0.0476
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2477.txt
> from collections import defaultdict, deque<br>    """There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of `n` cities numbered from `0` to `n - 1` and exactly `n - 1` roads. The capital city is city `0`. You are given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a bidirectional road connecting cities `ai` and `bi`.<br><br>There is a meeting for the representatives of each city. The meeting is in the capital city.<br><br>There is a car in each city. You are given an integer `seats` that indicates the number of seats in each car.<br><br>A representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.<br><br>Return _the minimum number of liters of fuel to reach the capital city_.<br><br>Example 1:<br><br>Input: roads = \[\[0,1\],\[0,2\],\[0,3\]\], seats = 5<br>Output: 3<br>Explanation: <br>- Representative1 goes directly to the capital with 1 liter of fuel.<br>- Representative2 goes directly to the capital with 1 liter of fuel.<br>- Representative3 goes directly to the capital with 1 liter of fuel.<br>It costs 3 liters of fuel at minimum. <br>It can be proven that 3 is the minimum number of liters of fuel needed.<br><br>Example 2:<br><br>Input: roads = \[\[3,1\],\[3,2\],\[1,0\],\[0,4\],\[0,5\],\[4,6\]\], seats = 2<br>Output: 7<br>Explanation: <br>- Representative2 goes directly to city 3 with 1 liter of fuel.<br>- Representative2 and representative3 go together to city 1 with 1 liter of fuel.<br>- Representative2 and representative3 go together to the capital with 1 liter of fuel.<br>- Representative1 goes directly to the capital with 1 liter of fuel.<br>- Representative5 goes directly to the capital with 1 liter of fuel.<br>- Representative6 goes directly to city 4 with 1 liter of fuel.<br>- Representative4 and representative6 go together to the capital with 1 liter of fuel.<br>It costs 7 liters of fuel at minimum. <br>It can be proven that 7 is the minimum number of liters of fuel needed.<br><br>Example 3:<br><br>Input: roads = \[\], seats = 1<br>Output: 0<br>Explanation: No representatives need to travel to the capital city.<br><br>Constraints:<br><br>   `1 <= n <= 105`<br>   `roads.length == n - 1`<br>   `roads[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `roads` represents a valid tree.<br>   `1 <= seats <= 105`"""<br><br><br><br>def min_fuel(roads, seats):<br>    n = len(roads) + 1<br>    graph = defaultdict(list)<br>    for road in roads:<br>        graph[road[0]].append(road[1])<br>        graph[road[1]].append(road[0])<br><br>    distance = [-1]  n<br>    q = deque([0])<br>    distance[0] = 0<br><br>    while q:<br>        city = q.popleft()<br>        for neighbor in graph[city]:<br>            if distance[neighbor] == -1:<br>                distance[neighbor] = distance[city] + 1<br>                q.append(neighbor)<br><br>    total_fuel = 0<br>    for city in range(1, n):<br>        total_fuel += (distance[city] - 1) // (seats - 1) + 1<br>    return total_fuel

### DOC[2] (IRRELEVANT) leetcode/leetcode_2285.txt
> class BitSet:<br>    """You are given an integer `n` denoting the number of cities in a country. The cities are numbered from `0` to `n - 1`.<br><br>You are also given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a bidirectional road connecting cities `ai` and `bi`.<br><br>You need to assign each city with an integer value from `1` to `n`, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.<br><br>Return _the maximum total importance of all roads possible after assigning the values optimally._<br><br>Example 1:<br><br>Input: n = 5, roads = \[\[0,1\],\[1,2\],\[2,3\],\[0,2\],\[1,3\],\[2,4\]\]<br>Output: 43<br>Explanation: The figure above shows the country and the assigned values of \[2,4,5,3,1\].<br>- The road (0,1) has an importance of 2 + 4 = 6.<br>- The road (1,2) has an importance of 4 + 5 = 9.<br>- The road (2,3) has an importance of 5 + 3 = 8.<br>- The road (0,2) has an importance of 2 + 5 = 7.<br>- The road (1,3) has an importance of 4 + 3 = 7.<br>- The road (2,4) has an importance of 5 + 1 = 6.<br>The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.<br>It can be shown that we cannot obtain a greater total importance than 43.<br><br>Example 2:<br><br>Input: n = 5, roads = \[\[0,3\],\[2,4\],\[1,3\]\]<br>Output: 20<br>Explanation: The figure above shows the country and the assigned values of \[4,3,2,5,1\].<br>- The road (0,3) has an importance of 4 + 5 = 9.<br>- The road (2,4) has an importance of 2 + 1 = 3.<br>- The road (1,3) has an importance of 3 + 5 = 8.<br>The total importance of all roads is 9 + 3 + 8 = 20.<br>It can be shown that we cannot obtain a greater total importance than 20.<br><br>Constraints:<br><br>   `2 <= n <= 5  104`<br>   `1 <= roads.length <= 5  104`<br>   `roads[i].length == 2`<br>   `0 <= ai, bi <= n - 1`<br>   `ai != bi`<br>   There are no duplicate roads."""<br><br>    def __init__(self, size):<br>        self.bits = [0]  ((size + 31) // 32)<br><br>    def set(self, index):<br>        self.bits[index // 32] |= (1 << (index % 32))<br><br>    def get(self, index):<br>        return (self.bits[index // 32] & (1 << (index % 32))) != 0

### DOC[3] (IRRELEVANT) leetcode/leetcode_1615.txt
> def range_sum(nums, n, left, right):<br>    """There is an infrastructure of `n` cities with some number of `roads` connecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a bidirectional road between cities `ai` and `bi`.<br><br>The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.<br><br>The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.<br><br>Given the integer `n` and the array `roads`, return _the maximal network rank of the entire infrastructure_.<br><br>Example 1:<br><br>Input: n = 4, roads = \[\[0,1\],\[0,3\],\[1,2\],\[1,3\]\]<br>Output: 4<br>Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.<br><br>Example 2:<br><br>Input: n = 5, roads = \[\[0,1\],\[0,3\],\[1,2\],\[1,3\],\[2,3\],\[2,4\]\]<br>Output: 5<br>Explanation: There are 5 roads that are connected to cities 1 or 2.<br><br>Example 3:<br><br>Input: n = 8, roads = \[\[0,1\],\[1,2\],\[2,3\],\[2,4\],\[5,6\],\[5,7\]\]<br>Output: 5<br>Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.<br><br>Constraints:<br><br>   `2 <= n <= 100`<br>   `0 <= roads.length <= n  (n - 1) / 2`<br>   `roads[i].length == 2`<br>   `0 <= ai, bi <= n-1`<br>   `ai != bi`<br>   Each pair of cities has at most one road connecting them."""<br><br>    MOD = 109 + 7<br>    sums = []<br>    for i in range(n):<br>        sum = 0<br>        for j in range(i, n):<br>            sum += nums[j]<br>            sums.append(sum)<br>    sums.sort()<br>    result = 0<br>    for i in range(left-1, right):<br>        result = (result + sums[i]) % MOD<br>    return result

### DOC[4] (IRRELEVANT) leetcode/leetcode_1466.txt
> def maxJumps(arr, d):<br>    """There are `n` cities numbered from `0` to `n - 1` and `n - 1` roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.<br><br>Roads are represented by `connections` where `connections[i] = [ai, bi]` represents a road from city `ai` to city `bi`.<br><br>This year, there will be a big event in the capital (city `0`), and many people want to travel to this city.<br><br>Your task consists of reorienting some roads such that each city can visit the city `0`. Return the minimum number of edges changed.<br><br>It's guaranteed that each city can reach city `0` after reorder.<br><br>Example 1:<br><br>Input: n = 6, connections = \[\[0,1\],\[1,3\],\[2,3\],\[4,0\],\[4,5\]\]<br>Output: 3<br>Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).<br><br>Example 2:<br><br>Input: n = 5, connections = \[\[1,0\],\[1,2\],\[3,2\],\[3,4\]\]<br>Output: 2<br>Explanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).<br><br>Example 3:<br><br>Input: n = 3, connections = \[\[1,0\],\[2,0\]\]<br>Output: 0<br><br>Constraints:<br><br>   `2 <= n <= 5  104`<br>   `connections.length == n - 1`<br>   `connections[i].length == 2`<br>   `0 <= ai, bi <= n - 1`<br>   `ai != bi`"""<br><br>    n = len(arr)<br>    dp = [1]  n<br><br>    def helper(idx):<br>        if dp[idx]  1:<br>            return dp[idx]<br>        maximum = 1<br>        for i in range(1, d + 1):<br>            if idx + i < n and arr[idx] <= arr[idx + i]:<br>                break<br>            if idx + i < n:<br>                maximum = max(maximum, 1 + helper(idx + i))<br><br>            if idx - i = 0 and arr[idx] <= arr[idx - i]:<br>                break<br>            if idx - i = 0:<br>                maximum = max(maximum, 1 + helper(idx - i))<br>        <br>        dp[idx] = maximum<br>        return maximum<br><br>    for i in range(n):<br>        helper(i)<br><br>    return max(dp)

### DOC[5] (IRRELEVANT) leetcode/leetcode_1883.txt
> def minSkips(dist, speed, hoursBefore):<br>    """You are given an integer `hoursBefore`, the number of hours you have to travel to your meeting. To arrive at your meeting, you have to travel through `n` roads. The road lengths are given as an integer array `dist` of length `n`, where `dist[i]` describes the length of the `ith` road in kilometers. In addition, you are given an integer `speed`, which is the speed (in km/h) you will travel at.<br><br>After you travel road `i`, you must rest and wait for the next integer hour before you can begin traveling on the next road. Note that you do not have to rest after traveling the last road because you are already at the meeting.<br><br>   For example, if traveling a road takes `1.4` hours, you must wait until the `2` hour mark before traveling the next road. If traveling a road takes exactly `2` hours, you do not need to wait.<br><br>However, you are allowed to skip some rests to be able to arrive on time, meaning you do not need to wait for the next integer hour. Note that this means you may finish traveling future roads at different hour marks.<br><br>   For example, suppose traveling the first road takes `1.4` hours and traveling the second road takes `0.6` hours. Skipping the rest after the first road will mean you finish traveling the second road right at the `2` hour mark, letting you start traveling the third road immediately.<br><br>Return _the minimum number of skips required to arrive at the meeting on time, or_ `-1` _if it is impossible_.<br><br>Example 1:<br><br>Input: dist = \[1,3,2\], speed = 4, hoursBefore = 2<br>Output: 1<br>Explanation:<br>Without skipping any rests, you will arrive in (1/4 + 3/4) + (3/4 + 1/4) + (2/4) = 2.5 hours.<br>You can skip the first rest to arrive in ((1/4 + 0) + (3/4 + 0)) + (2/4) = 1.5 hours.<br>Note that the second rest is shortened because you finish traveling the second road at an integer hour due to skipping the first rest.<br><br>Example 2:<br><br>Input: dist = \[7,3,5,5\], speed = 2, hoursBefore = 10<br>Output: 2<br>Explanation:<br>Without skipping any rests, you will arrive in (7/2 + 1/2) + (3/2 + 1/2) + (5/2 + 1/2) + (5/2) = 11.5 hours.<br>You can skip the first and third rest to arrive in ((7/2 + 0) + (3/2 + 0)) + ((5/2 + 0) + (5/2)) = 10 hours.<br><br>Example 3:<br><br>Input: dist = \[7,3,5,5\], speed = 1, hoursBefore = 10<br>Output: -1<br>Explanation: It is impossible to arrive at the meeting on time even if you skip all the rests.<br><br>Constraints:<br><br>   `n == dist.length`<br>   `1 <= n <= 1000`<br>   `1 <= dist[i] <= 105`<br>   `1 <= speed <= 106`<br>   `1 <= hoursBefore <= 107`"""<br><br>    n = len(dist)<br>    dp = [[1e9]  (n + 1) for _ in range(n + 1)]<br>    dp[0][0] = 0<br><br>    for i in range(n):<br>        for j in range(i+1):<br>            t = dist[i] / speed + (1 if j else 0)<br>            dp[i + 1][j + 1] = min(dp[i + 1][j + 1], dp[i][j] + t)<br>            skipped_t = -(-dist[i] / speed) - dp[i][j]<br>            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + skipped_t)<br><br>    for i in range(n + 1):<br>        if dp[n][i] <= hoursBefore:<br>            return i<br>    return -1


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_797.txt
> from collections import defaultdict<br>    """Given a directed acyclic graph (DAG) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in any order.<br><br>The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).<br><br>Example 1:<br><br>Input: graph = \[\[1,2\],\[3\],\[3\],\[\]\]<br>Output: \[\[0,1,3\],\[0,2,3\]\]<br>Explanation: There are two paths: 0 - 1 - 3 and 0 - 2 - 3.<br><br>Example 2:<br><br>Input: graph = \[\[4,3,1\],\[3,2,4\],\[3\],\[4\],\[\]\]<br>Output: \[\[0,4\],\[0,3,4\],\[0,1,3,4\],\[0,1,2,3,4\],\[0,1,4\]\]<br><br>Constraints:<br><br>   `n == graph.length`<br>   `2 <= n <= 15`<br>   `0 <= graph[i][j] < n`<br>   `graph[i][j] != i` (i.e., there will be no self-loops).<br>   All the elements of `graph[i]` are unique.<br>   The input graph is guaranteed to be a DAG."""<br><br>def numRabbits(answers):<br>    count = defaultdict(int)<br>    res = 0<br>    for a in answers:<br>        count[a] += 1<br>        if count[a] == 1:<br>            res += (a + 1)<br>        elif count[a]  a + 1:<br>            count[a] = 1<br>            res += (a + 1)<br>    return res

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_1514.txt
> def min_start_value(nums):<br>    """You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.<br><br>Given two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.<br><br>If there is no path from `start` to `end`, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.<br><br>Example 1:<br><br>Input: n = 3, edges = \[\[0,1\],\[1,2\],\[0,2\]\], succProb = \[0.5,0.5,0.2\], start = 0, end = 2<br>Output: 0.25000<br>Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 \ 0.5 = 0.25.<br><br>Example 2:<br><br>Input: n = 3, edges = \[\[0,1\],\[1,2\],\[0,2\]\], succProb = \[0.5,0.5,0.3\], start = 0, end = 2<br>Output: 0.30000<br><br>Example 3:<br><br>Input: n = 3, edges = \[\[0,1\]\], succProb = \[0.5\], start = 0, end = 2<br>Output: 0.00000<br>Explanation: There is no path between 0 and 2.<br><br>Constraints:<br><br>   `2 <= n <= 10^4`<br>   `0 <= start, end < n`<br>   `start != end`<br>   `0 <= a, b < n`<br>   `a != b`<br>   `0 <= succProb.length == edges.length <= 210^4`<br>   `0 <= succProb[i] <= 1`<br>   There is at most one edge between every two nodes."""<br><br>    min_sum, sum = 0, 0<br>    for num in nums:<br>        sum += num<br>        min_sum = min(min_sum, sum)<br>    return 1 - min_sum

### GROUND TRUTH 2, ranked 6, leetcode/leetcode_2045.txt
> from collections import defaultdict, deque<br>    """A city is represented as a bi-directional connected graph with `n` vertices where each vertex is labeled from `1` to `n` (inclusive). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.<br><br>Each vertex has a traffic signal which changes its color from green to red and vice versa every `change` minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.<br><br>The second minimum value is defined as the smallest value strictly larger than the minimum value.<br><br>   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.<br><br>Given `n`, `edges`, `time`, and `change`, return _the second minimum time it will take to go from vertex_ `1` _to vertex_ `n`.<br><br>Notes:<br><br>   You can go through any vertex any number of times, including `1` and `n`.<br>   You can assume that when the journey starts, all signals have just turned green.<br><br>Example 1:<br><br>       <br><br>Input: n = 5, edges = \[\[1,2\],\[1,3\],\[1,4\],\[3,4\],\[4,5\]\], time = 3, change = 5<br>Output: 13<br>Explanation:<br>The figure on the left shows the given graph.<br>The blue path in the figure on the right is the minimum time path.<br>The time taken is:<br>- Start at 1, time elapsed=0<br>- 1 - 4: 3 minutes, time elapsed=3<br>- 4 - 5: 3 minutes, time elapsed=6<br>Hence the minimum time needed is 6 minutes.<br><br>The red path shows the path to get the second minimum time.<br>- Start at 1, time elapsed=0<br>- 1 - 3: 3 minutes, time elapsed=3<br>- 3 - 4: 3 minutes, time elapsed=6<br>- Wait at 4 for 4 minutes, time elapsed=10<br>- 4 - 5: 3 minutes, time elapsed=13<br>Hence the second minimum time is 13 minutes.      <br><br>Example 2:<br><br>Input: n = 2, edges = \[\[1,2\]\], time = 3, change = 2<br>Output: 11<br>Explanation:<br>The minimum time path is 1 - 2 with time = 3 minutes.<br>The second minimum time path is 1 - 2 - 1 - 2 with time = 11 minutes.<br><br>Constraints:<br><br>   `2 <= n <= 104`<br>   `n - 1 <= edges.length <= min(2  104, n  (n - 1) / 2)`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`<br>   There are no duplicate edges.<br>   Each vertex can be reached directly or indirectly from every other vertex.<br>   `1 <= time, change <= 103`"""<br><br><br>def secondMinimum(n, edges, time, change):<br>    graph = defaultdict(list)<br>    <br>    for u, v in edges:<br>        graph[u].append(v)<br>        graph[v].append(u)<br><br>    dist = [float('inf')]  (n + 1)<br>    dist2 = [float('inf')]  (n + 1)<br>    dist[1] = 0<br><br>    q = deque([1])<br><br>    while q:<br>        cur = q.popleft()<br><br>        nextDist = dist[cur] + time<br>        waitTime = change if (nextDist // change) % 2 == 1 else 0<br>        nextDist += waitTime<br><br>        for next in graph[cur]:<br>            if nextDist < dist[next]:<br>                nextDist, dist[next] = dist[next], nextDist<br>                q.append(next)<br>            if nextDist < dist2[next]:<br>                nextDist, dist2[next] = dist2[next], nextDist<br>                q.append(next)<br><br>    return dist2[n]
