# Query `49`

## Original Question

*You are given an integer array of unique positive integers `nums`. Consider the following graph:

   There are `nums.length` nodes, labeled `nums[0]` to `nums[nums.length - 1]`,
   There is an undirected edge between `nums[i]` and `nums[j]` if `nums[i]` and `nums[j]` share a common factor greater than `1`.

Return _the size of the largest connected component in the graph_.

Example 1:

Input: nums = \[4,6,15,35\]
Output: 4

Example 2:

Input: nums = \[20,50,9,63\]
Output: 2

Example 3:

Input: nums = \[2,3,6,7,4,12,21,39\]
Output: 8

Constraints:

   `1 <= nums.length <= 2  104`
   `1 <= nums[i] <= 105`
   All the values of `nums` are unique.*


### Metrics

```
recip_rank: 0.1000
P_1: 0.0000
P_5: 0.0000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.1772
ndcg_cut_25: 0.1772
ndcg_cut_50: 0.1772
ndcg_cut_100: 0.1772
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0500
map_cut_25: 0.0500
map_cut_50: 0.0500
map_cut_100: 0.0500
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2322.txt
> def dfs(node, parent, xor_values, tree):<br>    """There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.<br><br>You are given a 0-indexed integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:<br><br>1.  Get the XOR of all the values of the nodes for each of the three components respectively.<br>2.  The difference between the largest XOR value and the smallest XOR value is the score of the pair.<br><br>   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = 6`, `1 ^ 9 = 8`, and `3 ^ 3 ^ 3 = 3`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.<br><br>Return _the minimum score of any possible pair of edge removals on the given tree_.<br><br>Example 1:<br><br>Input: nums = \[1,5,5,4,11\], edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\]\]<br>Output: 9<br>Explanation: The diagram above shows a way to make a pair of removals.<br>- The 1st component has nodes \[1,3,4\] with values \[5,4,11\]. Its XOR value is 5 ^ 4 ^ 11 = 10.<br>- The 2nd component has node \[0\] with value \[1\]. Its XOR value is 1 = 1.<br>- The 3rd component has node \[2\] with value \[5\]. Its XOR value is 5 = 5.<br>The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.<br>It can be shown that no other pair of removals will obtain a smaller score than 9.<br><br>Example 2:<br><br>Input: nums = \[5,5,2,4,4,2\], edges = \[\[0,1\],\[1,2\],\[5,2\],\[4,3\],\[1,3\]\]<br>Output: 0<br>Explanation: The diagram above shows a way to make a pair of removals.<br>- The 1st component has nodes \[3,4\] with values \[4,4\]. Its XOR value is 4 ^ 4 = 0.<br>- The 2nd component has nodes \[1,0\] with values \[5,5\]. Its XOR value is 5 ^ 5 = 0.<br>- The 3rd component has nodes \[2,5\] with values \[2,2\]. Its XOR value is 2 ^ 2 = 0.<br>The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.<br>We cannot obtain a smaller score than 0.<br><br>Constraints:<br><br>   `n == nums.length`<br>   `3 <= n <= 1000`<br>   `1 <= nums[i] <= 108`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree."""<br><br>    xor_value = xor_values[node]<br>    for child in tree[node]:<br>        if child != parent:<br>            xor_value ^= dfs(child, node, xor_values, tree)<br>    return xor_value<br><br><br>def minimumScore(nums, edges):<br>    n = len(nums)<br>    tree = [[] for _ in range(n)]<br>    <br>    for edge in edges:<br>        tree[edge[0]].append(edge[1])<br>        tree[edge[1]].append(edge[0])<br>    <br>    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]<br>    <br>    ans = float('inf')<br>    for i in range(n):<br>        for j in range(i + 1, n):<br>            xor1 = xor_values[i]<br>            xor2 = xor_values[j] ^ nums[i]<br>            xor3 = nums[i] ^ nums[j]<br>            max_xor = max(xor1, xor2, xor3)<br>            min_xor = min(xor1, xor2, xor3)<br>            ans = min(ans, max_xor - min_xor)<br>    <br>    return ans

### DOC[2] (IRRELEVANT) leetcode/leetcode_2440.txt
> from collections import defaultdict<br>    """There is an undirected tree with `n` nodes labeled from `0` to `n - 1`.<br><br>You are given a 0-indexed integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all `nums[i]` for which node `i` is in the component.<br><br>Return _the maximum number of edges you can delete, such that every connected component in the tree has the same value._<br><br>Example 1:<br><br>Input: nums = \[6,2,2,2,6\], edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\]\] <br>Output: 2 <br>Explanation: The above figure shows how we can delete the edges \[0,1\] and \[3,4\]. The created components are nodes \[0\], \[1,2,3\] and \[4\]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.<br><br>Example 2:<br><br>Input: nums = \[2\], edges = \[\]<br>Output: 0<br>Explanation: There are no edges to be deleted.<br><br>Constraints:<br><br>   `1 <= n <= 2  104`<br>   `nums.length == n`<br>   `1 <= nums[i] <= 50`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= edges[i][0], edges[i][1] <= n - 1`<br>   `edges` represents a valid tree."""<br><br><br>def dfs(node, parent, nums, graph, total, result):<br>    total_sum = nums[node]<br>    for neighbor in graph[node]:<br>        if neighbor != parent:<br>            total_sum += dfs(neighbor, node, nums, graph, total, result)<br>    if total_sum == total // 2:<br>        result.append(1)<br>        return 0<br>    return total_sum<br><br>def delete_edges_to_balance_tree(nums, edges):<br>    n = len(nums)<br>    graph = defaultdict(list)<br>    for e in edges:<br>        graph[e[0]].append(e[1])<br>        graph[e[1]].append(e[0])<br><br>    total = sum(nums)<br>    if total % 2 != 0:<br>        return 0  # It is impossible to split the tree fairly.<br><br>    result = []<br>    dfs(0, -1, nums, graph, total, result)<br>    return len(result) - 1

### DOC[3] (IRRELEVANT) leetcode/leetcode_2009.txt
> def min_operations(nums):<br>    """You are given an integer array `nums`. In one operation, you can replace any element in `nums` with any integer.<br><br>`nums` is considered continuous if both of the following conditions are fulfilled:<br><br>   All elements in `nums` are unique.<br>   The difference between the maximum element and the minimum element in `nums` equals `nums.length - 1`.<br><br>For example, `nums = [4, 2, 5, 3]` is continuous, but `nums = [1, 2, 3, 5, 6]` is not continuous.<br><br>Return _the minimum number of operations to make_ `nums` _continuous_.<br><br>Example 1:<br><br>Input: nums = \[4,2,5,3\]<br>Output: 0<br>Explanation: nums is already continuous.<br><br>Example 2:<br><br>Input: nums = \[1,2,3,5,6\]<br>Output: 1<br>Explanation: One possible solution is to change the last element to 4.<br>The resulting array is \[1,2,3,5,4\], which is continuous.<br><br>Example 3:<br><br>Input: nums = \[1,10,100,1000\]<br>Output: 3<br>Explanation: One possible solution is to:<br>- Change the second element to 2.<br>- Change the third element to 3.<br>- Change the fourth element to 4.<br>The resulting array is \[1,2,3,4\], which is continuous.<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `1 <= nums[i] <= 109`"""<br><br>    n = len(nums)<br>    s = sorted(set(nums))<br>    res = float('inf')<br>    j = 0<br>    <br>    for i in range(len(s)):<br>        while j < len(s) and s[j] <= s[i] + n - 1:<br>            j += 1<br>        res = min(res, n - (j - i))<br>        <br>    return res

### DOC[4] (IRRELEVANT) leetcode/leetcode_1887.txt
> from collections import defaultdict<br>    """Given an integer array `nums`, your goal is to make all elements in `nums` equal. To complete one operation, follow these steps:<br><br>1.  Find the largest value in `nums`. Let its index be `i` (0-indexed) and its value be `largest`. If there are multiple elements with the largest value, pick the smallest `i`.<br>2.  Find the next largest value in `nums` strictly smaller than `largest`. Let its value be `nextLargest`.<br>3.  Reduce `nums[i]` to `nextLargest`.<br><br>Return _the number of operations to make all elements in_ `nums` _equal_.<br><br>Example 1:<br><br>Input: nums = \[5,1,3\]<br>Output: 3<br>Explanation: It takes 3 operations to make all elements in nums equal:<br>1. largest = 5 at index 0. nextLargest = 3. Reduce nums\[0\] to 3. nums = \[3,1,3\].<br>2. largest = 3 at index 0. nextLargest = 1. Reduce nums\[0\] to 1. nums = \[1,1,3\].<br>3. largest = 3 at index 2. nextLargest = 1. Reduce nums\[2\] to 1. nums = \[1,1,1\].<br><br>Example 2:<br><br>Input: nums = \[1,1,1\]<br>Output: 0<br>Explanation: All elements in nums are already equal.<br><br>Example 3:<br><br>Input: nums = \[1,1,2,2,3\]<br>Output: 4<br>Explanation: It takes 4 operations to make all elements in nums equal:<br>1. largest = 3 at index 4. nextLargest = 2. Reduce nums\[4\] to 2. nums = \[1,1,2,2,2\].<br>2. largest = 2 at index 2. nextLargest = 1. Reduce nums\[2\] to 1. nums = \[1,1,1,2,2\].<br>3. largest = 2 at index 3. nextLargest = 1. Reduce nums\[3\] to 1. nums = \[1,1,1,1,2\].<br>4. largest = 2 at index 4. nextLargest = 1. Reduce nums\[4\] to 1. nums = \[1,1,1,1,1\].<br><br>Constraints:<br><br>   `1 <= nums.length <= 5  104`<br>   `1 <= nums[i] <= 5  104`"""<br><br><br>def min_trio_degree(n, edges):<br>    graph = defaultdict(dict)<br>    degree = [0]  (n + 1)<br><br>    for u, v in edges:<br>        graph[u][v] = graph[v][u] = True<br>        degree[u] += 1<br>        degree[v] += 1<br><br>    min_degree = float('inf')<br>    for u, v in edges:<br>        for w in range(1, n + 1):<br>            if graph[u].get(w) and graph[v].get(w):<br>                min_degree = min(min_degree, degree[u] + degree[v] + degree[w] - 6)<br><br>    return min_degree if min_degree != float('inf') else -1

### DOC[5] (IRRELEVANT) leetcode/leetcode_2497.txt
> def max_star_sum(vals, edges, k):<br>    """There is an undirected graph consisting of `n` nodes numbered from `0` to `n - 1`. You are given a 0-indexed integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node.<br><br>You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an undirected edge connecting nodes `ai` and `bi.`<br><br>A star graph is a subgraph of the given graph having a center node containing `0` or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.<br><br>The image below shows star graphs with `3` and `4` neighbors respectively, centered at the blue node.<br><br>The star sum is the sum of the values of all the nodes present in the star graph.<br><br>Given an integer `k`, return _the maximum star sum of a star graph containing at most_ `k` _edges._<br><br>Example 1:<br><br>Input: vals = \[1,2,3,4,10,-10,-20\], edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\],\[3,5\],\[3,6\]\], k = 2<br>Output: 16<br>Explanation: The above diagram represents the input graph.<br>The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.<br>It can be shown it is not possible to get a star graph with a sum greater than 16.<br><br>Example 2:<br><br>Input: vals = \[-5\], edges = \[\], k = 0<br>Output: -5<br>Explanation: There is only one possible star graph, which is node 0 itself.<br>Hence, we return -5.<br><br>Constraints:<br><br>   `n == vals.length`<br>   `1 <= n <= 105`<br>   `-104 <= vals[i] <= 104`<br>   `0 <= edges.length <= min(n  (n - 1) / 2``, 105)`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi <= n - 1`<br>   `ai != bi`<br>   `0 <= k <= n - 1`"""<br><br>    adj = [[] for _ in range(len(vals))]<br><br>    for edge in edges:<br>        adj[edge[0]].append(vals[edge[1]])<br>        adj[edge[1]].append(vals[edge[0]])<br><br>    ans = float("-inf")<br>    for i in range(len(vals)):<br>        adj[i].sort(reverse=True)<br>        ans = max(ans, vals[i] + sum(adj[i][:k]))<br><br>    return ans


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2157.txt
> from heapq import heappop, heappush<br>    """You are given a 0-indexed array of strings `words`. Each string consists of lowercase English letters only. No letter occurs more than once in any string of `words`.<br><br>Two strings `s1` and `s2` are said to be connected if the set of letters of `s2` can be obtained from the set of letters of `s1` by any one of the following operations:<br><br>   Adding exactly one letter to the set of the letters of `s1`.<br>   Deleting exactly one letter from the set of the letters of `s1`.<br>   Replacing exactly one letter from the set of the letters of `s1` with any letter, including itself.<br><br>The array `words` can be divided into one or more non-intersecting groups. A string belongs to a group if any one of the following is true:<br><br>   It is connected to at least one other string of the group.<br>   It is the only string present in the group.<br><br>Note that the strings in `words` should be grouped in such a manner that a string belonging to a group cannot be connected to a string present in any other group. It can be proved that such an arrangement is always unique.<br><br>Return _an array_ `ans` _of size_ `2` _where:_<br><br>   `ans[0]` _is the maximum number of groups_ `words` _can be divided into, and_<br>   `ans[1]` _is the size of the largest group_.<br><br>Example 1:<br><br>Input: words = \[ "a ", "b ", "ab ", "cde "\]<br>Output: \[2,3\]<br>Explanation:<br>- words\[0\] can be used to obtain words\[1\] (by replacing 'a' with 'b'), and words\[2\] (by adding 'b'). So words\[0\] is connected to words\[1\] and words\[2\].<br>- words\[1\] can be used to obtain words\[0\] (by replacing 'b' with 'a'), and words\[2\] (by adding 'a'). So words\[1\] is connected to words\[0\] and words\[2\].<br>- words\[2\] can be used to obtain words\[0\] (by deleting 'b'), and words\[1\] (by deleting 'a'). So words\[2\] is connected to words\[0\] and words\[1\].<br>- words\[3\] is not connected to any string in words.<br>Thus, words can be divided into 2 groups \[ "a ", "b ", "ab "\] and \[ "cde "\]. The size of the largest group is 3.  <br><br>Example 2:<br><br>Input: words = \[ "a ", "ab ", "abc "\]<br>Output: \[1,3\]<br>Explanation:<br>- words\[0\] is connected to words\[1\].<br>- words\[1\] is connected to words\[0\] and words\[2\].<br>- words\[2\] is connected to words\[1\].<br>Since all strings are connected to each other, they should be grouped together.<br>Thus, the size of the largest group is 3.<br><br>Constraints:<br><br>   `1 <= words.length <= 2  104`<br>   `1 <= words[i].length <= 26`<br>   `words[i]` consists of lowercase English letters only.<br>   No letter occurs more than once in `words[i]`."""<br><br><br>def smallest_subsequence(s, k, letter, repetition):<br>    result = []<br>    letter_count = s.count(letter)<br><br>    pq = []<br>    for c in s:<br>        if c <= letter or letter_count  repetition:<br>            while pq and pq[0]  c:<br>                if heappop(pq) == letter:<br>                    letter_count -= 1<br>            heappush(pq, c)<br>            if len(pq)  k:<br>                heappop(pq)<br>        if k - len(pq) == repetition:<br>            letter_count -= 1<br>        repetition = max(0, repetition)<br><br>    return "".join(pq)

### GROUND TRUTH 1, ranked 9, leetcode/leetcode_2521.txt
> def count_distinct_prime_factors(nums):<br>    """Given an array of positive integers `nums`, return _the number of distinct prime factors in the product of the elements of_ `nums`.<br><br>Note that:<br><br>   A number greater than `1` is called prime if it is divisible by only `1` and itself.<br>   An integer `val1` is a factor of another integer `val2` if `val2 / val1` is an integer.<br><br>Example 1:<br><br>Input: nums = \[2,4,3,7,10,6\]<br>Output: 4<br>Explanation:<br>The product of all the elements in nums is: 2 \ 4 \ 3 \ 7 \ 10 \ 6 = 10080 = 25 \ 32 \ 5 \ 7.<br>There are 4 distinct prime factors so we return 4.<br><br>Example 2:<br><br>Input: nums = \[2,4,8,16\]<br>Output: 1<br>Explanation:<br>The product of all the elements in nums is: 2 \ 4 \ 8 \ 16 = 1024 = 210.<br>There is 1 distinct prime factor so we return 1.<br><br>Constraints:<br><br>   `1 <= nums.length <= 104`<br>   `2 <= nums[i] <= 1000`"""<br><br>    prime_factors = set()<br>    for n in nums:<br>        for divisor in range(2, int(n0.5) + 1):<br>            if n % divisor == 0:<br>                prime_factors.add(divisor)<br>                prime_factors.add(n // divisor)<br>    return len(prime_factors)
