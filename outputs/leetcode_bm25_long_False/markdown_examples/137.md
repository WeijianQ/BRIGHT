# Query `137`

## Original Question

*There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`.

The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (0-indexed) can :

   Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.
   Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.
   Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.
   Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.

A worker `i` is less efficient than a worker `j` if either condition is met:

   `leftToRighti + rightToLefti > leftToRightj + rightToLeftj`
   `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i > j`

The following rules regulate the movement of the workers through the bridge :

   If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.
   If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.
   If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.

Return _the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse_.

Example 1:

Input: n = 1, k = 3, time = \[\[1,1,2,1\],\[1,1,3,1\],\[1,1,4,1\]\]
Output: 6
Explanation: 
From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.
From 1 to 2: worker 2 picks up a box from the old warehouse.
From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.
From 6 to 7: worker 2 puts a box at the new warehouse.
The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.

Example 2:

Input: n = 3, k = 2, time = \[\[1,9,1,8\],\[10,10,10,10\]\]
Output: 50
Explanation: 
From 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.
From 10 to 20: worker 1 picks up a box from the old warehouse.
From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.
From 11 to 20: worker 0 picks up a box from the old warehouse.
From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.
From 30 to 40: worker 1 puts a box at the new warehouse.
From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.
From 31 to 39: worker 0 puts a box at the new warehouse.
From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.
From 40 to 49: worker 0 picks up a box from the old warehouse.
From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.
From 50 to 58: worker 0 puts a box at the new warehouse.
The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.

Constraints:

   `1 <= n, k <= 104`
   `time.length == k`
   `time[i].length == 4`
   `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0400
P_100: 0.0200
recall_1: 0.5000
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.6131
ndcg_cut_10: 0.6131
ndcg_cut_25: 0.6131
ndcg_cut_50: 0.7327
ndcg_cut_100: 0.7327
map_cut_1: 0.5000
map_cut_5: 0.5000
map_cut_10: 0.5000
map_cut_25: 0.5000
map_cut_50: 0.5294
map_cut_100: 0.5294
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2462.txt
> def hireWorkers(costs, k, candidates):<br>    """You are given a 0-indexed integer array `costs` where `costs[i]` is the cost of hiring the `ith` worker.<br><br>You are also given two integers `k` and `candidates`. We want to hire exactly `k` workers according to the following rules:<br><br>   You will run `k` sessions and hire exactly one worker in each session.<br>   In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index.<br>       For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,1,2]`.<br>       In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,2,7,7,2]`. Please note that the indexing may be changed in the process.<br>   If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.<br>   A worker can only be chosen once.<br><br>Return _the total cost to hire exactly_ `k` _workers._<br><br>Example 1:<br><br>Input: costs = \[17,12,10,2,7,2,11,20,8\], k = 3, candidates = 4<br>Output: 11<br>Explanation: We hire 3 workers in total. The total cost is initially 0.<br>- In the first hiring round we choose the worker from \[17,12,10,2,7,2,11,20,8\]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.<br>- In the second hiring round we choose the worker from \[17,12,10,7,2,11,20,8\]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.<br>- In the third hiring round we choose the worker from \[17,12,10,7,11,20,8\]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.<br>The total hiring cost is 11.<br><br>Example 2:<br><br>Input: costs = \[1,2,4,1\], k = 3, candidates = 3<br>Output: 4<br>Explanation: We hire 3 workers in total. The total cost is initially 0.<br>- In the first hiring round we choose the worker from \[1,2,4,1\]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.<br>- In the second hiring round we choose the worker from \[2,4,1\]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.<br>- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers \[2,4\]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.<br>The total hiring cost is 4.<br><br>Constraints:<br><br>   `1 <= costs.length <= 105`<br>   `1 <= costs[i] <= 105`<br>   `1 <= k, candidates <= costs.length`"""<br><br>    n = len(costs)<br>    workers = sorted([(cost, i) for i, cost in enumerate(costs)])<br><br>    cost = 0<br>    for i in range(k):<br>        if min(workers[i][1], n - workers[i][1] - 1) < candidates:<br>            cost += workers[i][0]<br><br>    return cost

### DOC[2] (IRRELEVANT) leetcode/leetcode_1739.txt
> def check_palindrome_formation(a: str, b: str) - bool:<br>    """You have a cubic storeroom where the width, length, and height of the room are all equal to `n` units. You are asked to place `n` boxes in this room where each box is a cube of unit side length. There are however some rules to placing the boxes:<br><br>   You can place the boxes anywhere on the floor.<br>   If box `x` is placed on top of the box `y`, then each side of the four vertical sides of the box `y` must either be adjacent to another box or to a wall.<br><br>Given an integer `n`, return _the minimum possible number of boxes touching the floor._<br><br>Example 1:<br><br>Input: n = 3<br>Output: 3<br>Explanation: The figure above is for the placement of the three boxes.<br>These boxes are placed in the corner of the room, where the corner is on the left side.<br><br>Example 2:<br><br>Input: n = 4<br>Output: 3<br>Explanation: The figure above is for the placement of the four boxes.<br>These boxes are placed in the corner of the room, where the corner is on the left side.<br><br>Example 3:<br><br>Input: n = 10<br>Output: 6<br>Explanation: The figure above is for the placement of the ten boxes.<br>These boxes are placed in the corner of the room, where the corner is on the back side.<br><br>Constraints:<br><br>   `1 <= n <= 109`"""<br><br>    def is_palindrome(s: str, left: int, right: int) - bool:<br>        while left < right:<br>            if s[left] != s[right]:<br>                return False<br>            left += 1<br>            right -= 1<br>        return True<br><br>    i, j = 0, len(a) - 1<br>    while i < j:<br>        if a[i] != b[j]:<br>            return is_palindrome(a, i, j) or is_palindrome(b, i, j)<br>        i += 1<br>        j -= 1<br>    return True

### DOC[3] (IRRELEVANT) leetcode/leetcode_1889.txt
> def check_powers_of_three(n: int) - bool:<br>    """You have `n` packages that you are trying to place in boxes, one package in each box. There are `m` suppliers that each produce boxes of different sizes (with infinite supply). A package can be placed in a box if the size of the package is less than or equal to the size of the box.<br><br>The package sizes are given as an integer array `packages`, where `packages[i]` is the size of the `ith` package. The suppliers are given as a 2D integer array `boxes`, where `boxes[j]` is an array of box sizes that the `jth` supplier produces.<br><br>You want to choose a single supplier and use boxes from them such that the total wasted space is minimized. For each package in a box, we define the space wasted to be `size of the box - size of the package`. The total wasted space is the sum of the space wasted in all the boxes.<br><br>   For example, if you have to fit packages with sizes `[2,3,5]` and the supplier offers boxes of sizes `[4,8]`, you can fit the packages of size-`2` and size-`3` into two boxes of size-`4` and the package with size-`5` into a box of size-`8`. This would result in a waste of `(4-2) + (4-3) + (8-5) = 6`.<br><br>Return _the minimum total wasted space by choosing the box supplier optimally, or_ `-1` _if it is impossible to fit all the packages inside boxes._ Since the answer may be large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: packages = \[2,3,5\], boxes = \[\[4,8\],\[2,8\]\]<br>Output: 6<br>Explanation: It is optimal to choose the first supplier, using two size-4 boxes and one size-8 box.<br>The total waste is (4-2) + (4-3) + (8-5) = 6.<br><br>Example 2:<br><br>Input: packages = \[2,3,5\], boxes = \[\[1,4\],\[2,3\],\[3,4\]\]<br>Output: -1<br>Explanation: There is no box that the package of size 5 can fit in.<br><br>Example 3:<br><br>Input: packages = \[3,5,8,10,11,12\], boxes = \[\[12\],\[11,9\],\[10,5,14\]\]<br>Output: 9<br>Explanation: It is optimal to choose the third supplier, using two size-5 boxes, two size-10 boxes, and two size-14 boxes.<br>The total waste is (5-3) + (5-5) + (10-8) + (10-10) + (14-11) + (14-12) = 9.<br><br>Constraints:<br><br>   `n == packages.length`<br>   `m == boxes.length`<br>   `1 <= n <= 105`<br>   `1 <= m <= 105`<br>   `1 <= packages[i] <= 105`<br>   `1 <= boxes[j].length <= 105`<br>   `1 <= boxes[j][k] <= 105`<br>   `sum(boxes[j].length) <= 105`<br>   The elements in `boxes[j]` are distinct."""<br><br>    while n  0:<br>        if n % 3 == 2:<br>            return False<br>        n //= 3<br>    return True

### DOC[4] (IRRELEVANT) leetcode/leetcode_2258.txt
> from collections import deque<br>    """You are given a 0-indexed 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:<br><br>   `0` represents grass,<br>   `1` represents fire,<br>   `2` represents a wall that you and fire cannot pass through.<br><br>You are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.<br><br>Return _the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can always reach the safehouse regardless of the minutes stayed, return `109`.<br><br>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.<br><br>A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).<br><br>Example 1:<br><br>Input: grid = \[\[0,2,0,0,0,0,0\],\[0,0,0,2,2,1,0\],\[0,2,0,0,1,2,0\],\[0,0,2,2,2,0,2\],\[0,0,0,0,0,0,0\]\]<br>Output: 3<br>Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.<br>You will still be able to safely reach the safehouse.<br>Staying for more than 3 minutes will not allow you to safely reach the safehouse.<br><br>Example 2:<br><br>Input: grid = \[\[0,0,0,0\],\[0,1,2,0\],\[0,2,0,0\]\]<br>Output: -1<br>Explanation: The figure above shows the scenario where you immediately move towards the safehouse.<br>Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.<br>Thus, -1 is returned.<br><br>Example 3:<br><br>Input: grid = \[\[0,0,0\],\[2,2,0\],\[1,2,0\]\]<br>Output: 1000000000<br>Explanation: The figure above shows the initial grid.<br>Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.<br>Thus, 109 is returned.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `2 <= m, n <= 300`<br>   `4 <= m  n <= 2  104`<br>   `grid[i][j]` is either `0`, `1`, or `2`.<br>   `grid[0][0] == grid[m - 1][n - 1] == 0`"""<br><br><br>dx = [0, 1, 0, -1]<br>dy = [1, 0, -1, 0]<br><br>def getMaxSafeMinutes(grid):<br>    m, n = len(grid), len(grid[0])<br>    dist = [[-1 for _ in range(n)] for _ in range(m)]<br>    q = deque()<br><br>    if grid[m - 1][n - 1] != 1:<br>        dist[m - 1][n - 1] = 0<br>        q.append((m - 1, n - 1))<br><br>    while q:<br>        x, y = q.popleft()<br>        for d in range(4):<br>            nx, ny = x + dx[d], y + dy[d]<br>            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:<br>                dist[nx][ny] = dist[x][y] + 1<br>                q.append((nx, ny))<br><br>    if dist[0][0] == -1:<br>        return -1<br><br>    res = 0<br>    for test in range(dist[0][0], int(1e9)):<br>        ok = True<br>        for x in range(m):<br>            for y in range(n):<br>                if grid[x][y] == 1:<br>                    for d in range(4):<br>                        nx, ny = x + dx[d], y + dy[d]<br>                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:<br>                            break<br>                    else:<br>                        ok = False<br>                        break<br>        if ok:<br>            res = test<br>        else:<br>            break<br>    return res

### DOC[5] (IRRELEVANT) leetcode/leetcode_2106.txt
> from math import gcd<br>    """Fruits are available at some positions on an infinite x-axis. You are given a 2D integer array `fruits` where `fruits[i] = [positioni, amounti]` depicts `amounti` fruits at the position `positioni`. `fruits` is already sorted by `positioni` in ascending order, and each `positioni` is unique.<br><br>You are also given an integer `startPos` and an integer `k`. Initially, you are at the position `startPos`. From any position, you can either walk to the left or right. It takes one step to move one unit on the x-axis, and you can walk at most `k` steps in total. For every position you reach, you harvest all the fruits at that position, and the fruits will disappear from that position.<br><br>Return _the maximum total number of fruits you can harvest_.<br><br>Example 1:<br><br>Input: fruits = \[\[2,8\],\[6,3\],\[8,6\]\], startPos = 5, k = 4<br>Output: 9<br>Explanation: <br>The optimal way is to:<br>- Move right to position 6 and harvest 3 fruits<br>- Move right to position 8 and harvest 6 fruits<br>You moved 3 steps and harvested 3 + 6 = 9 fruits in total.<br><br>Example 2:<br><br>Input: fruits = \[\[0,9\],\[4,1\],\[5,7\],\[6,2\],\[7,4\],\[10,9\]\], startPos = 5, k = 4<br>Output: 14<br>Explanation: <br>You can move at most k = 4 steps, so you cannot reach position 0 nor 10.<br>The optimal way is to:<br>- Harvest the 7 fruits at the starting position 5<br>- Move left to position 4 and harvest 1 fruit<br>- Move right to position 6 and harvest 2 fruits<br>- Move right to position 7 and harvest 4 fruits<br>You moved 1 + 3 = 4 steps and harvested 7 + 1 + 2 + 4 = 14 fruits in total.<br><br>Example 3:<br><br>Input: fruits = \[\[0,3\],\[6,4\],\[8,5\]\], startPos = 3, k = 2<br>Output: 0<br>Explanation:<br>You can move at most k = 2 steps and cannot reach any position with fruits.<br><br>Constraints:<br><br>   `1 <= fruits.length <= 105`<br>   `fruits[i].length == 2`<br>   `0 <= startPos, positioni <= 2  105`<br>   `positioni-1 < positioni` for any `i  0` (0-indexed)<br>   `1 <= amounti <= 104`<br>   `0 <= k <= 2  105`"""<br><br><br>def findGCD(nums):<br>    return gcd(min(nums), max(nums))


## Ground Truth

### GROUND TRUTH 0, ranked 33, leetcode/leetcode_2332.txt
> def last_passenger_time(buses, passengers, capacity):<br>    """You are given a 0-indexed integer array `buses` of length `n`, where `buses[i]` represents the departure time of the `ith` bus. You are also given a 0-indexed integer array `passengers` of length `m`, where `passengers[j]` represents the arrival time of the `jth` passenger. All bus departure times are unique. All passenger arrival times are unique.<br><br>You are given an integer `capacity`, which represents the maximum number of passengers that can get on each bus.<br><br>When a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at `x` minutes if you arrive at `y` minutes where `y <= x`, and the bus is not full. Passengers with the earliest arrival times get on the bus first.<br><br>More formally when a bus arrives, either:<br><br>   If `capacity` or fewer passengers are waiting for a bus, they will all get on the bus, or<br>   The `capacity` passengers with the earliest arrival times will get on the bus.<br><br>Return _the latest time you may arrive at the bus station to catch a bus_. You cannot arrive at the same time as another passenger.<br><br>Note: The arrays `buses` and `passengers` are not necessarily sorted.<br><br>Example 1:<br><br>Input: buses = \[10,20\], passengers = \[2,17,18,19\], capacity = 2<br>Output: 16<br>Explanation: Suppose you arrive at time 16.<br>At time 10, the first bus departs with the 0th passenger. <br>At time 20, the second bus departs with you and the 1st passenger.<br>Note that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.<br><br>Example 2:<br><br>Input: buses = \[20,30,10\], passengers = \[19,13,26,4,25,11,21\], capacity = 2<br>Output: 20<br>Explanation: Suppose you arrive at time 20.<br>At time 10, the first bus departs with the 3rd passenger. <br>At time 20, the second bus departs with the 5th and 1st passengers.<br>At time 30, the third bus departs with the 0th passenger and you.<br>Notice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus.<br><br>Constraints:<br><br>   `n == buses.length`<br>   `m == passengers.length`<br>   `1 <= n, m, capacity <= 105`<br>   `2 <= buses[i], passengers[i] <= 109`<br>   Each element in `buses` is unique.<br>   Each element in `passengers` is unique."""<br><br>    buses.sort()<br>    passengers.sort()<br><br>    last_index = 0<br>    for bus in buses:<br>        cnt = 0<br>        while last_index < len(passengers) and passengers[last_index] <= bus and cnt < capacity:<br>            cnt += 1<br>            last_index += 1<br><br>    return buses[0] - 1 if last_index == 0 else passengers[last_index - 1] - 1

### GROUND TRUTH 1, ranked 0, leetcode/leetcode_2462.txt
> def hireWorkers(costs, k, candidates):<br>    """You are given a 0-indexed integer array `costs` where `costs[i]` is the cost of hiring the `ith` worker.<br><br>You are also given two integers `k` and `candidates`. We want to hire exactly `k` workers according to the following rules:<br><br>   You will run `k` sessions and hire exactly one worker in each session.<br>   In each hiring session, choose the worker with the lowest cost from either the first `candidates` workers or the last `candidates` workers. Break the tie by the smallest index.<br>       For example, if `costs = [3,2,7,7,1,2]` and `candidates = 2`, then in the first hiring session, we will choose the `4th` worker because they have the lowest cost `[3,2,7,7,1,2]`.<br>       In the second hiring session, we will choose `1st` worker because they have the same lowest cost as `4th` worker but they have the smallest index `[3,2,7,7,2]`. Please note that the indexing may be changed in the process.<br>   If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.<br>   A worker can only be chosen once.<br><br>Return _the total cost to hire exactly_ `k` _workers._<br><br>Example 1:<br><br>Input: costs = \[17,12,10,2,7,2,11,20,8\], k = 3, candidates = 4<br>Output: 11<br>Explanation: We hire 3 workers in total. The total cost is initially 0.<br>- In the first hiring round we choose the worker from \[17,12,10,2,7,2,11,20,8\]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.<br>- In the second hiring round we choose the worker from \[17,12,10,7,2,11,20,8\]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.<br>- In the third hiring round we choose the worker from \[17,12,10,7,11,20,8\]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.<br>The total hiring cost is 11.<br><br>Example 2:<br><br>Input: costs = \[1,2,4,1\], k = 3, candidates = 3<br>Output: 4<br>Explanation: We hire 3 workers in total. The total cost is initially 0.<br>- In the first hiring round we choose the worker from \[1,2,4,1\]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.<br>- In the second hiring round we choose the worker from \[2,4,1\]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.<br>- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers \[2,4\]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.<br>The total hiring cost is 4.<br><br>Constraints:<br><br>   `1 <= costs.length <= 105`<br>   `1 <= costs[i] <= 105`<br>   `1 <= k, candidates <= costs.length`"""<br><br>    n = len(costs)<br>    workers = sorted([(cost, i) for i, cost in enumerate(costs)])<br><br>    cost = 0<br>    for i in range(k):<br>        if min(workers[i][1], n - workers[i][1] - 1) < candidates:<br>            cost += workers[i][0]<br><br>    return cost
