# Query `75`

## Original Question

*You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array `code` of length of `n` and a key `k`.

To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.

   If `k > 0`, replace the `ith` number with the sum of the next `k` numbers.
   If `k < 0`, replace the `ith` number with the sum of the previous `k` numbers.
   If `k == 0`, replace the `ith` number with `0`.

As `code` is circular, the next element of `code[n-1]` is `code[0]`, and the previous element of `code[0]` is `code[n-1]`.

Given the circular array `code` and an integer key `k`, return _the decrypted code to defuse the bomb_!

Example 1:

Input: code = \[5,7,1,4\], k = 3
Output: \[12,10,16,13\]
Explanation: Each number is replaced by the sum of the next 3 numbers. The decrypted code is \[7+1+4, 1+4+5, 4+5+7, 5+7+1\]. Notice that the numbers wrap around.

Example 2:

Input: code = \[1,2,3,4\], k = 0
Output: \[0,0,0,0\]
Explanation: When k is zero, the numbers are replaced by 0. 

Example 3:

Input: code = \[2,4,9,3\], k = -2
Output: \[12,5,6,13\]
Explanation: The decrypted code is \[3+9, 2+3, 4+2, 9+4\]. Notice that the numbers wrap around again. If k is negative, the sum is of the previous numbers.

Constraints:

   `n == code.length`
   `1 <= n <= 100`
   `1 <= code[i] <= 100`
   `-(n - 1) <= k <= n - 1`*


### Metrics

```
recip_rank: 0.1667
P_1: 0.0000
P_5: 0.0000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.3333
recall_25: 0.3333
recall_50: 0.3333
recall_100: 0.3333
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.1672
ndcg_cut_25: 0.1672
ndcg_cut_50: 0.1672
ndcg_cut_100: 0.1672
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0556
map_cut_25: 0.0556
map_cut_50: 0.0556
map_cut_100: 0.0556
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_375.txt
> def getMoneyAmount(n: int) - int:<br>    """We are playing the Guessing Game. The game will work as follows:<br><br>1.  I pick a number between `1` and `n`.<br>2.  You guess a number.<br>3.  If you guess the right number, you win the game.<br>4.  If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.<br>5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, you lose the game.<br><br>Given a particular `n`, return _the minimum amount of money you need to guarantee a win regardless of what number I pick_.<br><br>Example 1:<br><br>Input: n = 10<br>Output: 16<br>Explanation: The winning strategy is as follows:<br>- The range is \[1,10\]. Guess 7.<br>    - If this is my number, your total is $0. Otherwise, you pay $7.<br>    - If my number is higher, the range is \[8,10\]. Guess 9.<br>        - If this is my number, your total is $7. Otherwise, you pay $9.<br>        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.<br>        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.<br>    - If my number is lower, the range is \[1,6\]. Guess 3.<br>        - If this is my number, your total is $7. Otherwise, you pay $3.<br>        - If my number is higher, the range is \[4,6\]. Guess 5.<br>            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.<br>            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.<br>            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.<br>        - If my number is lower, the range is \[1,2\]. Guess 1.<br>            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.<br>            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.<br>The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.<br><br>Example 2:<br><br>Input: n = 1<br>Output: 0<br>Explanation: There is only one possible number, so you can guess 1 and not have to pay anything.<br><br>Example 3:<br><br>Input: n = 2<br>Output: 1<br>Explanation: There are two possible numbers, 1 and 2.<br>- Guess 1.<br>    - If this is my number, your total is $0. Otherwise, you pay $1.<br>    - If my number is higher, it must be 2. Guess 2. Your total is $1.<br>The worst case is that you pay $1.<br><br>Constraints:<br><br>   `1 <= n <= 200`"""<br><br>    dp = [[0]  (n + 1) for _ in range(n + 1)]<br>    for i in range(n - 1, 0, -1):<br>        for j in range(i + 1, n + 1):<br>            min_cost = float("inf")<br>            for k in range(i, j):<br>                cost = k + max(dp[i][k - 1], dp[k + 1][j])<br>                min_cost = min(min_cost, cost)<br>            dp[i][j] = min_cost<br>    return dp[1][n]

### DOC[2] (IRRELEVANT) leetcode/leetcode_2081.txt
> def minWastedSpace(nums, k):<br>    """A k-mirror number is a positive integer without leading zeros that reads the same both forward and backward in base-10 as well as in base-k.<br><br>   For example, `9` is a 2-mirror number. The representation of `9` in base-10 and base-2 are `9` and `1001` respectively, which read the same both forward and backward.<br>   On the contrary, `4` is not a 2-mirror number. The representation of `4` in base-2 is `100`, which does not read the same both forward and backward.<br><br>Given the base `k` and the number `n`, return _the sum of the_ `n` _smallest k-mirror numbers_.<br><br>Example 1:<br><br>Input: k = 2, n = 5<br>Output: 25<br>Explanation:<br>The 5 smallest 2-mirror numbers and their representations in base-2 are listed as follows:<br>  base-10    base-2<br>    1          1<br>    3          11<br>    5          101<br>    7          111<br>    9          1001<br>Their sum = 1 + 3 + 5 + 7 + 9 = 25. <br><br>Example 2:<br><br>Input: k = 3, n = 7<br>Output: 499<br>Explanation:<br>The 7 smallest 3-mirror numbers are and their representations in base-3 are listed as follows:<br>  base-10    base-3<br>    1          1<br>    2          2<br>    4          11<br>    8          22<br>    121        11111<br>    151        12121<br>    212        21212<br>Their sum = 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499.<br><br>Example 3:<br><br>Input: k = 7, n = 17<br>Output: 20379000<br>Explanation: The 17 smallest 7-mirror numbers are:<br>1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596<br><br>Constraints:<br><br>   `2 <= k <= 9`<br>   `1 <= n <= 30`"""<br><br>    n = len(nums)<br>    dp = [[float('inf')]  (k + 1) for _ in range(n + 1)]<br>    dp[0][0] = 0<br><br>    for i in range(1, n + 1):<br>        total = 0<br>        for j in range(i, 0, -1):<br>            total += nums[j - 1]<br>            for l in range(k):<br>                dp[i][l + 1] = min(dp[i][l + 1], dp[j - 1][l] + (i - j + 1)  nums[j - 1] - total)<br><br>    return min(dp[n])

### DOC[3] (IRRELEVANT) leetcode/leetcode_1615.txt
> def range_sum(nums, n, left, right):<br>    """There is an infrastructure of `n` cities with some number of `roads` connecting these cities. Each `roads[i] = [ai, bi]` indicates that there is a bidirectional road between cities `ai` and `bi`.<br><br>The network rank of two different cities is defined as the total number of directly connected roads to either city. If a road is directly connected to both cities, it is only counted once.<br><br>The maximal network rank of the infrastructure is the maximum network rank of all pairs of different cities.<br><br>Given the integer `n` and the array `roads`, return _the maximal network rank of the entire infrastructure_.<br><br>Example 1:<br><br>Input: n = 4, roads = \[\[0,1\],\[0,3\],\[1,2\],\[1,3\]\]<br>Output: 4<br>Explanation: The network rank of cities 0 and 1 is 4 as there are 4 roads that are connected to either 0 or 1. The road between 0 and 1 is only counted once.<br><br>Example 2:<br><br>Input: n = 5, roads = \[\[0,1\],\[0,3\],\[1,2\],\[1,3\],\[2,3\],\[2,4\]\]<br>Output: 5<br>Explanation: There are 5 roads that are connected to cities 1 or 2.<br><br>Example 3:<br><br>Input: n = 8, roads = \[\[0,1\],\[1,2\],\[2,3\],\[2,4\],\[5,6\],\[5,7\]\]<br>Output: 5<br>Explanation: The network rank of 2 and 5 is 5. Notice that all the cities do not have to be connected.<br><br>Constraints:<br><br>   `2 <= n <= 100`<br>   `0 <= roads.length <= n  (n - 1) / 2`<br>   `roads[i].length == 2`<br>   `0 <= ai, bi <= n-1`<br>   `ai != bi`<br>   Each pair of cities has at most one road connecting them."""<br><br>    MOD = 109 + 7<br>    sums = []<br>    for i in range(n):<br>        sum = 0<br>        for j in range(i, n):<br>            sum += nums[j]<br>            sums.append(sum)<br>    sums.sort()<br>    result = 0<br>    for i in range(left-1, right):<br>        result = (result + sums[i]) % MOD<br>    return result

### DOC[4] (IRRELEVANT) leetcode/leetcode_2127.txt
> def max_invited(favorite):<br>    """A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.<br><br>The employees are numbered from `0` to `n - 1`. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.<br><br>Given a 0-indexed integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the maximum number of employees that can be invited to the meeting_.<br><br>Example 1:<br><br>Input: favorite = \[2,2,1,2\]<br>Output: 3<br>Explanation:<br>The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.<br>All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.<br>Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.<br>The maximum number of employees that can be invited to the meeting is 3. <br><br>Example 2:<br><br>Input: favorite = \[1,2,0\]<br>Output: 3<br>Explanation: <br>Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.<br>The seating arrangement will be the same as that in the figure given in example 1:<br>- Employee 0 will sit between employees 2 and 1.<br>- Employee 1 will sit between employees 0 and 2.<br>- Employee 2 will sit between employees 1 and 0.<br>The maximum number of employees that can be invited to the meeting is 3.<br><br>Example 3:<br><br>Input: favorite = \[3,0,1,4,1\]<br>Output: 4<br>Explanation:<br>The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.<br>Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.<br>So the company leaves them out of the meeting.<br>The maximum number of employees that can be invited to the meeting is 4.<br><br>Constraints:<br><br>   `n == favorite.length`<br>   `2 <= n <= 105`<br>   `0 <= favorite[i] <= n - 1`<br>   `favorite[i] != i`"""<br><br>    in_degree = [0]  len(favorite)<br>    for fav in favorite:<br>        in_degree[fav] += 1<br>    result = 0<br>    for degree in in_degree:<br>        result += max(degree - 1, 0)<br>    return min(result + 2, len(favorite))

### DOC[5] (IRRELEVANT) leetcode/leetcode_1805.txt
> def min_moves(nums, k):<br>    """You are given a string `word` that consists of digits and lowercase English letters.<br><br>You will replace every non-digit character with a space. For example, `"a123bc34d8ef34 "` will become `" 123 34 8 34 "`. Notice that you are left with some integers that are separated by at least one space: `"123 "`, `"34 "`, `"8 "`, and `"34 "`.<br><br>Return _the number of different integers after performing the replacement operations on_ `word`.<br><br>Two integers are considered different if their decimal representations without any leading zeros are different.<br><br>Example 1:<br><br>Input: word =  "a123bc34d8ef34 "<br>Output: 3<br>Explanation: The three different integers are  "123 ",  "34 ", and  "8 ". Notice that  "34 " is only counted once.<br><br>Example 2:<br><br>Input: word =  "leet1234code234 "<br>Output: 2<br><br>Example 3:<br><br>Input: word =  "a1b01c001 "<br>Output: 1<br>Explanation: The three integers  "1 ",  "01 ", and  "001 " all represent the same integer because<br>the leading zeros are ignored when comparing their decimal values.<br><br>Constraints:<br><br>   `1 <= word.length <= 1000`<br>   `word` consists of digits and lowercase English letters."""<br><br>    n = len(nums)<br>    ones = [i - j for i, j in enumerate(nums) if j == 1]<br>    <br>    moves = sum(ones[i] - ones[k // 2] for i in range(k))<br>    min_moves = moves<br>    <br>    for i in range(k, len(ones)):<br>        moves += ones[i] - ones[i - k] - k<br>        min_moves = min(min_moves, moves)<br>    <br>    return min_moves


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2490.txt
> def is_circular(sentence: str) - bool:<br>    """A sentence is a list of words that are separated by a single space with no leading or trailing spaces.<br><br>   For example, `"Hello World "`, `"HELLO "`, `"hello world hello world "` are all sentences.<br><br>Words consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.<br><br>A sentence is circular if:<br><br>   The last character of a word is equal to the first character of the next word.<br>   The last character of the last word is equal to the first character of the first word.<br><br>For example, `"leetcode exercises sound delightful "`, `"eetcode "`, `"leetcode eats soul "` are all circular sentences. However, `"Leetcode is cool "`, `"happy Leetcode "`, `"Leetcode "` and `"I like Leetcode "` are not circular sentences.<br><br>Given a string `sentence`, return `true` _if it is circular_. Otherwise, return `false`.<br><br>Example 1:<br><br>Input: sentence =  "leetcode exercises sound delightful "<br>Output: true<br>Explanation: The words in sentence are \[ "leetcode ",  "exercises ",  "sound ",  "delightful "\].<br>- leetcode's last character is equal to exercises's first character.<br>- exercises's last character is equal to sound's first character.<br>- sound's last character is equal to delightful's first character.<br>- delightful's last character is equal to leetcode's first character.<br>The sentence is circular.<br><br>Example 2:<br><br>Input: sentence =  "eetcode "<br>Output: true<br>Explanation: The words in sentence are \[ "eetcode "\].<br>- eetcode's last character is equal to eetcode's first character.<br>The sentence is circular.<br><br>Example 3:<br><br>Input: sentence =  "Leetcode is cool "<br>Output: false<br>Explanation: The words in sentence are \[ "Leetcode ",  "is ",  "cool "\].<br>- Leetcode's last character is not equal to is's first character.<br>The sentence is not circular.<br><br>Constraints:<br><br>   `1 <= sentence.length <= 500`<br>   `sentence` consist of only lowercase and uppercase English letters and spaces.<br>   The words in `sentence` are separated by a single space.<br>   There are no leading or trailing spaces."""<br><br>    words = sentence.split()<br>    for i in range(1, len(words)):<br>        if words[i - 1][-1] != words[i][0]:<br>            return False<br>    return words[-1][-1] == words[0][0]

### GROUND TRUTH 1, ranked 5, leetcode/leetcode_2515.txt
> def shortest_distance(words, target, startIndex):<br>    """You are given a 0-indexed circular string array `words` and a string `target`. A circular array means that the array's end connects to the array's beginning.<br><br>   Formally, the next element of `words[i]` is `words[(i + 1) % n]` and the previous element of `words[i]` is `words[(i - 1 + n) % n]`, where `n` is the length of `words`.<br><br>Starting from `startIndex`, you can move to either the next word or the previous word with `1` step at a time.<br><br>Return _the shortest distance needed to reach the string_ `target`. If the string `target` does not exist in `words`, return `-1`.<br><br>Example 1:<br><br>Input: words = \[ "hello ", "i ", "am ", "leetcode ", "hello "\], target =  "hello ", startIndex = 1<br>Output: 1<br>Explanation: We start from index 1 and can reach  "hello " by<br>- moving 3 units to the right to reach index 4.<br>- moving 2 units to the left to reach index 4.<br>- moving 4 units to the right to reach index 0.<br>- moving 1 unit to the left to reach index 0.<br>The shortest distance to reach  "hello " is 1.<br><br>Example 2:<br><br>Input: words = \[ "a ", "b ", "leetcode "\], target =  "leetcode ", startIndex = 0<br>Output: 1<br>Explanation: We start from index 0 and can reach  "leetcode " by<br>- moving 2 units to the right to reach index 3.<br>- moving 1 unit to the left to reach index 3.<br>The shortest distance to reach  "leetcode " is 1.<br><br>Example 3:<br><br>Input: words = \[ "i ", "eat ", "leetcode "\], target =  "ate ", startIndex = 0<br>Output: -1<br>Explanation: Since  "ate " does not exist in `words`, we return -1.<br><br>Constraints:<br><br>   `1 <= words.length <= 100`<br>   `1 <= words[i].length <= 100`<br>   `words[i]` and `target` consist of only lowercase English letters.<br>   `0 <= startIndex < words.length`"""<br><br>    n = len(words)<br>    left, right, i = 0, 0, startIndex<br>    while True:<br>        if words[i] == target:<br>            return min(left, right)<br>        left += 1<br>        right += 1<br>        i = (i + 1) % n<br>        if left == n:<br>            break<br>    return -1

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_2516.txt
> def min_minutes(s: str, k: int) - int:<br>    """You are given a string `s` consisting of the characters `'a'`, `'b'`, and `'c'` and a non-negative integer `k`. Each minute, you may take either the leftmost character of `s`, or the rightmost character of `s`.<br><br>Return _the minimum number of minutes needed for you to take at least_ `k` _of each character, or return_ `-1` _if it is not possible to take_ `k` _of each character._<br><br>Example 1:<br><br>Input: s =  "aabaaaacaabc ", k = 2<br>Output: 8<br>Explanation: <br>Take three characters from the left of s. You now have two 'a' characters, and one 'b' character.<br>Take five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.<br>A total of 3 + 5 = 8 minutes is needed.<br>It can be proven that 8 is the minimum number of minutes needed.<br><br>Example 2:<br><br>Input: s =  "a ", k = 1<br>Output: -1<br>Explanation: It is not possible to take one 'b' or 'c' so return -1.<br><br>Constraints:<br><br>   `1 <= s.length <= 105`<br>   `s` consists of only the letters `'a'`, `'b'`, and `'c'`.<br>   `0 <= k <= s.length`"""<br><br>    n = len(s)<br>    left_counts = [0]  3<br>    right_counts = [0]  3<br>    for c in s:<br>        right_counts[ord(c) - ord('a')] += 1<br><br>    ans, total = n, 0<br>    l, r = 0, n - 1<br>    while l < r:<br>        while l < r and left_counts[ord(s[l]) - ord('a')] < k and right_counts[ord(s[r]) - ord('a')] < k:<br>            need_left = max(0, k - left_counts[ord(s[l]) - ord('a')])<br>            need_right = max(0, k - right_counts[ord(s[r]) - ord('a')])<br>            if need_left <= need_right:<br>                total += need_left<br>                l += 1<br>                left_counts[ord(s[l]) - ord('a')] += 1<br>                right_counts[ord(s[l]) - ord('a')] -= 1<br>            else:<br>                total += need_right<br>                r -= 1<br>                right_counts[ord(s[r]) - ord('a')] -= 1<br>                left_counts[ord(s[r]) - ord('a')] += 1<br>        ans = min(ans, total)<br>        if l + 1 < n:<br>            total -= left_counts[ord(s[l]) - ord('a')]<br>            left_counts[ord(s[l]) - ord('a')] -= 1<br>            right_counts[ord(s[l + 1]) - ord('a')] += 1<br>            l += 1<br>        else:<br>            break<br>    if all(cnt = k for cnt in left_counts): <br>        return ans<br>    return -1
