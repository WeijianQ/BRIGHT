# Query `29`

## Original Question

*There is a robot starting at the position `(0, 0)`, the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at `(0, 0)` after it completes its moves.

You are given a string `moves` that represents the move sequence of the robot where `moves[i]` represents its `ith` move. Valid moves are `'R'` (right), `'L'` (left), `'U'` (up), and `'D'` (down).

Return `true` _if the robot returns to the origin after it finishes all of its moves, or_ `false` _otherwise_.

Note: The way that the robot is "facing " is irrelevant. `'R'` will always make the robot move to the right once, `'L'` will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.

Example 1:

Input: moves =  "UD "
Output: true
Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.

Example 2:

Input: moves =  "LL "
Output: false
Explanation: The robot moves left twice. It ends up two  "moves " to the left of the origin. We return false because it is not at the origin at the end of its moves.

Constraints:

   `1 <= moves.length <= 2  104`
   `moves` only contains the characters `'U'`, `'D'`, `'L'` and `'R'`.*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.5000
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.6131
ndcg_cut_10: 0.6131
ndcg_cut_25: 0.6131
ndcg_cut_50: 0.6131
ndcg_cut_100: 0.6131
map_cut_1: 0.5000
map_cut_5: 0.5000
map_cut_10: 0.5000
map_cut_25: 0.5000
map_cut_50: 0.5000
map_cut_100: 0.5000
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2120.txt
> def findNoOfInstructions(n: int, startPos: List[int], s: str) - List[int]:<br>    """There is an `n x n` grid, with the top-left cell at `(0, 0)` and the bottom-right cell at `(n - 1, n - 1)`. You are given the integer `n` and an integer array `startPos` where `startPos = [startrow, startcol]` indicates that a robot is initially at cell `(startrow, startcol)`.<br><br>You are also given a 0-indexed string `s` of length `m` where `s[i]` is the `ith` instruction for the robot: `'L'` (move left), `'R'` (move right), `'U'` (move up), and `'D'` (move down).<br><br>The robot can begin executing from any `ith` instruction in `s`. It executes the instructions one by one towards the end of `s` but it stops if either of these conditions is met:<br><br>   The next instruction will move the robot off the grid.<br>   There are no more instructions left to execute.<br><br>Return _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the number of instructions the robot can execute if the robot begins executing from the_ `ith` _instruction in_ `s`.<br><br>Example 1:<br><br>Input: n = 3, startPos = \[0,1\], s =  "RRDDLU "<br>Output: \[1,5,4,3,1,0\]<br>Explanation: Starting from startPos and beginning execution from the ith instruction:<br>- 0th:  "RRDDLU ". Only one instruction  "R " can be executed before it moves off the grid.<br>- 1st:   "RDDLU ". All five instructions can be executed while it stays in the grid and ends at (1, 1).<br>- 2nd:    "DDLU ". All four instructions can be executed while it stays in the grid and ends at (1, 0).<br>- 3rd:     "DLU ". All three instructions can be executed while it stays in the grid and ends at (0, 0).<br>- 4th:      "LU ". Only one instruction  "L " can be executed before it moves off the grid.<br>- 5th:       "U ". If moving up, it would move off the grid.<br><br>Example 2:<br><br>Input: n = 2, startPos = \[1,1\], s =  "LURD "<br>Output: \[4,1,0,0\]<br>Explanation:<br>- 0th:  "LURD ".<br>- 1st:   "URD ".<br>- 2nd:    "RD ".<br>- 3rd:     "D ".<br><br>Example 3:<br><br>Input: n = 1, startPos = \[0,0\], s =  "LRUD "<br>Output: \[0,0,0,0\]<br>Explanation: No matter which instruction the robot begins execution from, it would move off the grid.<br><br>Constraints:<br><br>   `m == s.length`<br>   `1 <= n, m <= 500`<br>   `startPos.length == 2`<br>   `0 <= startrow, startcol < n`<br>   `s` consists of `'L'`, `'R'`, `'U'`, and `'D'`."""<br><br>    answer = [0]  len(s)<br>    x, y = startPos<br><br>    for i in range(len(s)):<br>        cnt = 0<br>        cx, cy = x, y<br>        for j in range(i, len(s)):<br>            step = s[j]<br>            if step == 'L':<br>                if cy == 0: break<br>                cy -= 1<br>            elif step == 'R':<br>                if cy == n - 1: break<br>                cy += 1<br>            elif step == 'U':<br>                if cx == 0: break<br>                cx -= 1<br>            else:<br>                if cx == n - 1: break<br>                cx += 1<br>            cnt += 1<br>            if j == len(s) - 1: break<br>        answer[i] = cnt<br><br>    return answer

### DOC[2] (IRRELEVANT) leetcode/leetcode_2087.txt
> def minTotalCost(startPos, homePos, rowCosts, colCosts):<br>    """There is an `m x n` grid, where `(0, 0)` is the top-left cell and `(m - 1, n - 1)` is the bottom-right cell. You are given an integer array `startPos` where `startPos = [startrow, startcol]` indicates that initially, a robot is at the cell `(startrow, startcol)`. You are also given an integer array `homePos` where `homePos = [homerow, homecol]` indicates that its home is at the cell `(homerow, homecol)`.<br><br>The robot needs to go to its home. It can move one cell in four directions: left, right, up, or down, and it can not move outside the boundary. Every move incurs some cost. You are further given two 0-indexed integer arrays: `rowCosts` of length `m` and `colCosts` of length `n`.<br><br>   If the robot moves up or down into a cell whose row is `r`, then this move costs `rowCosts[r]`.<br>   If the robot moves left or right into a cell whose column is `c`, then this move costs `colCosts[c]`.<br><br>Return _the minimum total cost for this robot to return home_.<br><br>Example 1:<br><br>Input: startPos = \[1, 0\], homePos = \[2, 3\], rowCosts = \[5, 4, 3\], colCosts = \[8, 2, 6, 7\]<br>Output: 18<br>Explanation: One optimal path is that:<br>Starting from (1, 0)<br>- It goes down to (2, 0). This move costs rowCosts\[2\] = 3.<br>- It goes right to (2, 1). This move costs colCosts\[1\] = 2.<br>- It goes right to (2, 2). This move costs colCosts\[2\] = 6.<br>- It goes right to (2, 3). This move costs colCosts\[3\] = 7.<br>The total cost is 3 + 2 + 6 + 7 = 18<br><br>Example 2:<br><br>Input: startPos = \[0, 0\], homePos = \[0, 0\], rowCosts = \[5\], colCosts = \[26\]<br>Output: 0<br>Explanation: The robot is already at its home. Since no moves occur, the total cost is 0.<br><br>Constraints:<br><br>   `m == rowCosts.length`<br>   `n == colCosts.length`<br>   `1 <= m, n <= 105`<br>   `0 <= rowCosts[r], colCosts[c] <= 104`<br>   `startPos.length == 2`<br>   `homePos.length == 2`<br>   `0 <= startrow, homerow < m`<br>   `0 <= startcol, homecol < n`"""<br><br>    row_difference = abs(startPos[0] - homePos[0])<br>    col_difference = abs(startPos[1] - homePos[1])<br><br>    row_cost = sum(rowCosts[min(startPos[0], homePos[0]):min(startPos[0], homePos[0]) + row_difference])<br>    col_cost = sum(colCosts[min(startPos[1], homePos[1]):min(startPos[1], homePos[1]) + col_difference])<br><br>    return row_cost + col_cost

### DOC[3] (IRRELEVANT) leetcode/leetcode_2017.txt
> def min_operations(s):<br>    """You are given a 0-indexed 2D array `grid` of size `2 x n`, where `grid[r][c]` represents the number of points at position `(r, c)` on the matrix. Two robots are playing a game on this matrix.<br><br>Both robots initially start at `(0, 0)` and want to reach `(1, n-1)`. Each robot may only move to the right (`(r, c)` to `(r, c + 1)`) or down (`(r, c)` to `(r + 1, c)`).<br><br>At the start of the game, the first robot moves from `(0, 0)` to `(1, n-1)`, collecting all the points from the cells on its path. For all cells `(r, c)` traversed on the path, `grid[r][c]` is set to `0`. Then, the second robot moves from `(0, 0)` to `(1, n-1)`, collecting the points on its path. Note that their paths may intersect with one another.<br><br>The first robot wants to minimize the number of points collected by the second robot. In contrast, the second robot wants to maximize the number of points it collects. If both robots play optimally, return _the number of points collected by the second robot._<br><br>Example 1:<br><br>Input: grid = \[\[2,5,4\],\[1,5,1\]\]<br>Output: 4<br>Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.<br>The cells visited by the first robot are set to 0.<br>The second robot will collect 0 + 0 + 4 + 0 = 4 points.<br><br>Example 2:<br><br>Input: grid = \[\[3,3,1\],\[8,5,2\]\]<br>Output: 4<br>Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.<br>The cells visited by the first robot are set to 0.<br>The second robot will collect 0 + 3 + 1 + 0 = 4 points.<br><br>Example 3:<br><br>Input: grid = \[\[1,3,1,15\],\[1,3,3,1\]\]<br>Output: 7<br>Explanation: The optimal path taken by the first robot is shown in red, and the optimal path taken by the second robot is shown in blue.<br>The cells visited by the first robot are set to 0.<br>The second robot will collect 0 + 1 + 3 + 3 + 0 = 7 points.<br><br>Constraints:<br><br>   `grid.length == 2`<br>   `n == grid[r].length`<br>   `1 <= n <= 5  104`<br>   `1 <= grid[r][c] <= 105`"""<br><br>    cnt = 0<br>    for i in range(1, len(s)):<br>        if s[i] == s[i-1]:<br>            cnt += 1<br>    return cnt

### DOC[4] (IRRELEVANT) leetcode/leetcode_2463.txt
> def min_total_distance(robot: List[int], factory: List[List[int]]) - int:<br>    """There are some robots and factories on the X-axis. You are given an integer array `robot` where `robot[i]` is the position of the `ith` robot. You are also given a 2D integer array `factory` where `factory[j] = [positionj, limitj]` indicates that `positionj` is the position of the `jth` factory and that the `jth` factory can repair at most `limitj` robots.<br><br>The positions of each robot are unique. The positions of each factory are also unique. Note that a robot can be in the same position as a factory initially.<br><br>All the robots are initially broken; they keep moving in one direction. The direction could be the negative or the positive direction of the X-axis. When a robot reaches a factory that did not reach its limit, the factory repairs the robot, and it stops moving.<br><br>At any moment, you can set the initial direction of moving for some robot. Your target is to minimize the total distance traveled by all the robots.<br><br>Return _the minimum total distance traveled by all the robots_. The test cases are generated such that all the robots can be repaired.<br><br>Note that<br><br>   All robots move at the same speed.<br>   If two robots move in the same direction, they will never collide.<br>   If two robots move in opposite directions and they meet at some point, they do not collide. They cross each other.<br>   If a robot passes by a factory that reached its limits, it crosses it as if it does not exist.<br>   If the robot moved from a position `x` to a position `y`, the distance it moved is `|y - x|`.<br><br>Example 1:<br><br>Input: robot = \[0,4,6\], factory = \[\[2,2\],\[6,2\]\]<br>Output: 4<br>Explanation: As shown in the figure:<br>- The first robot at position 0 moves in the positive direction. It will be repaired at the first factory.<br>- The second robot at position 4 moves in the negative direction. It will be repaired at the first factory.<br>- The third robot at position 6 will be repaired at the second factory. It does not need to move.<br>The limit of the first factory is 2, and it fixed 2 robots.<br>The limit of the second factory is 2, and it fixed 1 robot.<br>The total distance is |2 - 0| + |2 - 4| + |6 - 6| = 4. It can be shown that we cannot achieve a better total distance than 4.<br><br>Example 2:<br><br>Input: robot = \[1,-1\], factory = \[\[-2,1\],\[2,1\]\]<br>Output: 2<br>Explanation: As shown in the figure:<br>- The first robot at position 1 moves in the positive direction. It will be repaired at the second factory.<br>- The second robot at position -1 moves in the negative direction. It will be repaired at the first factory.<br>The limit of the first factory is 1, and it fixed 1 robot.<br>The limit of the second factory is 1, and it fixed 1 robot.<br>The total distance is |2 - 1| + |(-2) - (-1)| = 2. It can be shown that we cannot achieve a better total distance than 2.<br><br>Constraints:<br><br>   `1 <= robot.length, factory.length <= 100`<br>   `factory[j].length == 2`<br>   `-109 <= robot[i], positionj <= 109`<br>   `0 <= limitj <= robot.length`<br>   The input will be generated such that it is always possible to repair every robot."""<br><br>    robot.sort()<br>    factory.sort()<br><br>    res = 0<br>    idx = 0<br>    for f_pos, f_limit in factory:<br>        while f_limit  0 and idx < len(robot):<br>            res += abs(f_pos - robot[idx])<br>            idx += 1<br>            f_limit -= 1<br>    <br>    return res

### DOC[5] (IRRELEVANT) leetcode/leetcode_457.txt
> def circularArrayLoop(nums: List[int]) - bool:<br>    """You are playing a game involving a circular array of non-zero integers `nums`. Each `nums[i]` denotes the number of indices forward/backward you must move if you are located at index `i`:<br><br>   If `nums[i]` is positive, move `nums[i]` steps forward, and<br>   If `nums[i]` is negative, move `nums[i]` steps backward.<br><br>Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.<br><br>A cycle in the array consists of a sequence of indices `seq` of length `k` where:<br><br>   Following the movement rules above results in the repeating index sequence `seq[0] - seq[1] - ... - seq[k - 1] - seq[0] - ...`<br>   Every `nums[seq[j]]` is either all positive or all negative.<br>   `k  1`<br><br>Return `true` _if there is a cycle in_ `nums`_, or_ `false` _otherwise_.<br><br>Example 1:<br><br>Input: nums = \[2,-1,1,2,2\]<br>Output: true<br>Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.<br>We can see the cycle 0 -- 2 -- 3 -- 0 -- ..., and all of its nodes are white (jumping in the same direction).<br><br>Example 2:<br><br>Input: nums = \[-1,-2,-3,-4,-5,6\]<br>Output: false<br>Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.<br>The only cycle is of size 1, so we return false.<br><br>Example 3:<br><br>Input: nums = \[1,-1,5,1,4\]<br>Output: true<br>Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.<br>We can see the cycle 0 -- 1 -- 0 -- ..., and while it is of size  1, it has a node jumping forward and a node jumping backward, so it is not a cycle.<br>We can see the cycle 3 -- 4 -- 3 -- ..., and all of its nodes are white (jumping in the same direction).<br><br>Constraints:<br><br>   `1 <= nums.length <= 5000`<br>   `-1000 <= nums[i] <= 1000`<br>   `nums[i] != 0`<br><br>Follow up: Could you solve it in `O(n)` time complexity and `O(1)` extra space complexity?"""<br><br>    N = len(nums)<br>    for i in range(N):<br>        slow, fast = i, i<br>        while True:<br>            slow = getNextIndex(slow, nums)<br>            fast = getNextIndex(getNextIndex(fast, nums), nums)<br>            if slow != fast and nums[slow]  nums[fast]  0:<br>                break<br>            if slow == fast:<br>                break<br>        else:<br>            continue<br>        cycle = False<br>        start = slow<br>        while start != slow:<br>            cycle |= getNextIndex(start, nums) == start<br>            start = getNextIndex(start, nums)<br>        if not cycle:<br>            return True<br>    return False<br><br>def getNextIndex(idx: int, nums: List[int]) - int:<br>    N = len(nums)<br>    return (idx + nums[idx]) % N


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_547.txt
> def findCircleNum(isConnected):<br>    """There are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.<br><br>A province is a group of directly or indirectly connected cities and no other cities outside of the group.<br><br>You are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.<br><br>Return _the total number of provinces_.<br><br>Example 1:<br><br>Input: isConnected = \[\[1,1,0\],\[1,1,0\],\[0,0,1\]\]<br>Output: 2<br><br>Example 2:<br><br>Input: isConnected = \[\[1,0,0\],\[0,1,0\],\[0,0,1\]\]<br>Output: 3<br><br>Constraints:<br><br>   `1 <= n <= 200`<br>   `n == isConnected.length`<br>   `n == isConnected[i].length`<br>   `isConnected[i][j]` is `1` or `0`.<br>   `isConnected[i][i] == 1`<br>   `isConnected[i][j] == isConnected[j][i]`"""<br><br>    def dfs(isConnected, visited, i):<br>        visited[i] = True<br>        for j in range(len(isConnected)):<br>            if isConnected[i][j] == 1 and not visited[j]:<br>                dfs(isConnected, visited, j)<br><br>    provinces = 0<br>    visited = [False]  len(isConnected)<br>    for i in range(len(isConnected)):<br>        if not visited[i]:<br>            dfs(isConnected, visited, i)<br>            provinces += 1<br>    return provinces

### GROUND TRUTH 1, ranked 0, leetcode/leetcode_2120.txt
> def findNoOfInstructions(n: int, startPos: List[int], s: str) - List[int]:<br>    """There is an `n x n` grid, with the top-left cell at `(0, 0)` and the bottom-right cell at `(n - 1, n - 1)`. You are given the integer `n` and an integer array `startPos` where `startPos = [startrow, startcol]` indicates that a robot is initially at cell `(startrow, startcol)`.<br><br>You are also given a 0-indexed string `s` of length `m` where `s[i]` is the `ith` instruction for the robot: `'L'` (move left), `'R'` (move right), `'U'` (move up), and `'D'` (move down).<br><br>The robot can begin executing from any `ith` instruction in `s`. It executes the instructions one by one towards the end of `s` but it stops if either of these conditions is met:<br><br>   The next instruction will move the robot off the grid.<br>   There are no more instructions left to execute.<br><br>Return _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the number of instructions the robot can execute if the robot begins executing from the_ `ith` _instruction in_ `s`.<br><br>Example 1:<br><br>Input: n = 3, startPos = \[0,1\], s =  "RRDDLU "<br>Output: \[1,5,4,3,1,0\]<br>Explanation: Starting from startPos and beginning execution from the ith instruction:<br>- 0th:  "RRDDLU ". Only one instruction  "R " can be executed before it moves off the grid.<br>- 1st:   "RDDLU ". All five instructions can be executed while it stays in the grid and ends at (1, 1).<br>- 2nd:    "DDLU ". All four instructions can be executed while it stays in the grid and ends at (1, 0).<br>- 3rd:     "DLU ". All three instructions can be executed while it stays in the grid and ends at (0, 0).<br>- 4th:      "LU ". Only one instruction  "L " can be executed before it moves off the grid.<br>- 5th:       "U ". If moving up, it would move off the grid.<br><br>Example 2:<br><br>Input: n = 2, startPos = \[1,1\], s =  "LURD "<br>Output: \[4,1,0,0\]<br>Explanation:<br>- 0th:  "LURD ".<br>- 1st:   "URD ".<br>- 2nd:    "RD ".<br>- 3rd:     "D ".<br><br>Example 3:<br><br>Input: n = 1, startPos = \[0,0\], s =  "LRUD "<br>Output: \[0,0,0,0\]<br>Explanation: No matter which instruction the robot begins execution from, it would move off the grid.<br><br>Constraints:<br><br>   `m == s.length`<br>   `1 <= n, m <= 500`<br>   `startPos.length == 2`<br>   `0 <= startrow, startcol < n`<br>   `s` consists of `'L'`, `'R'`, `'U'`, and `'D'`."""<br><br>    answer = [0]  len(s)<br>    x, y = startPos<br><br>    for i in range(len(s)):<br>        cnt = 0<br>        cx, cy = x, y<br>        for j in range(i, len(s)):<br>            step = s[j]<br>            if step == 'L':<br>                if cy == 0: break<br>                cy -= 1<br>            elif step == 'R':<br>                if cy == n - 1: break<br>                cy += 1<br>            elif step == 'U':<br>                if cx == 0: break<br>                cx -= 1<br>            else:<br>                if cx == n - 1: break<br>                cx += 1<br>            cnt += 1<br>            if j == len(s) - 1: break<br>        answer[i] = cnt<br><br>    return answer
