# Query `57`

## Original Question

*In an infinite binary tree where every node has two children, the nodes are labelled in row order.

In the odd numbered rows (ie., the first, third, fifth,...), the labelling is left to right, while in the even numbered rows (second, fourth, sixth,...), the labelling is right to left.

Given the `label` of a node in this tree, return the labels in the path from the root of the tree to the node with that `label`.

Example 1:

Input: label = 14
Output: \[1,3,4,14\]

Example 2:

Input: label = 26
Output: \[1,2,6,10,26\]

Constraints:

   `1 <= label <= 10^6`*


### Metrics

```
recip_rank: 0.0833
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 1.0000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.2702
ndcg_cut_50: 0.2702
ndcg_cut_100: 0.2702
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0833
map_cut_50: 0.0833
map_cut_100: 0.0833
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1705.txt
> def unhappyFriends(n, preferences, pairs):<br>    """There is a special kind of apple tree that grows apples every day for `n` days. On the `ith` day, the tree grows `apples[i]` apples that will rot after `days[i]` days, that is on day `i + days[i]` the apples will be rotten and cannot be eaten. On some days, the apple tree does not grow any apples, which are denoted by `apples[i] == 0` and `days[i] == 0`.<br><br>You decided to eat at most one apple a day (to keep the doctors away). Note that you can keep eating after the first `n` days.<br><br>Given two integer arrays `days` and `apples` of length `n`, return _the maximum number of apples you can eat._<br><br>Example 1:<br><br>Input: apples = \[1,2,3,5,2\], days = \[3,2,1,4,2\]<br>Output: 7<br>Explanation: You can eat 7 apples:<br>- On the first day, you eat an apple that grew on the first day.<br>- On the second day, you eat an apple that grew on the second day.<br>- On the third day, you eat an apple that grew on the second day. After this day, the apples that grew on the third day rot.<br>- On the fourth to the seventh days, you eat apples that grew on the fourth day.<br><br>Example 2:<br><br>Input: apples = \[3,0,0,0,0,2\], days = \[3,0,0,0,0,2\]<br>Output: 5<br>Explanation: You can eat 5 apples:<br>- On the first to the third day you eat apples that grew on the first day.<br>- Do nothing on the fouth and fifth days.<br>- On the sixth and seventh days you eat apples that grew on the sixth day.<br><br>Constraints:<br><br>   `n == apples.length == days.length`<br>   `1 <= n <= 2  104`<br>   `0 <= apples[i], days[i] <= 2  104`<br>   `days[i] = 0` if and only if `apples[i] = 0`."""<br><br>    pair_mapping = [0]  n<br>    for pair in pairs:<br>        pair_mapping[pair[0]] = pair[1]<br>        pair_mapping[pair[1]] = pair[0]<br><br>    unhappy_count = 0<br>    for x in range(n):<br>        y = pair_mapping[x]<br>        pref_x = preferences[x]<br>        idx_y = pref_x.index(y)<br><br>        for i in range(idx_y):<br>            u = pref_x[i]<br>            v = pair_mapping[u]<br>            pref_u = preferences[u]<br>            if x in pref_u[:pref_u.index(v)]:<br>                unhappy_count += 1<br>                break<br><br>    return unhappy_count // 2

### DOC[2] (IRRELEVANT) leetcode/leetcode_2058.txt
> def get_concatenation(nums):<br>    """A critical point in a linked list is defined as either a local maxima or a local minima.<br><br>A node is a local maxima if the current node has a value strictly greater than the previous node and the next node.<br><br>A node is a local minima if the current node has a value strictly smaller than the previous node and the next node.<br><br>Note that a node can only be a local maxima/minima if there exists both a previous node and a next node.<br><br>Given a linked list `head`, return _an array of length 2 containing_ `[minDistance, maxDistance]` _where_ `minDistance` _is the minimum distance between any two distinct critical points and_ `maxDistance` _is the maximum distance between any two distinct critical points. If there are fewer than two critical points, return_ `[-1, -1]`.<br><br>Example 1:<br><br>Input: head = \[3,1\]<br>Output: \[-1,-1\]<br>Explanation: There are no critical points in \[3,1\].<br><br>Example 2:<br><br>Input: head = \[5,3,1,2,5,1,2\]<br>Output: \[1,3\]<br>Explanation: There are three critical points:<br>- \[5,3,1,2,5,1,2\]: The third node is a local minima because 1 is less than 3 and 2.<br>- \[5,3,1,2,5,1,2\]: The fifth node is a local maxima because 5 is greater than 2 and 1.<br>- \[5,3,1,2,5,1,2\]: The sixth node is a local minima because 1 is less than 5 and 2.<br>The minimum distance is between the fifth and the sixth node. minDistance = 6 - 5 = 1.<br>The maximum distance is between the third and the sixth node. maxDistance = 6 - 3 = 3.<br><br>Example 3:<br><br>Input: head = \[1,3,2,2,3,2,2,2,7\]<br>Output: \[3,3\]<br>Explanation: There are two critical points:<br>- \[1,3,2,2,3,2,2,2,7\]: The second node is a local maxima because 3 is greater than 1 and 2.<br>- \[1,3,2,2,3,2,2,2,7\]: The fifth node is a local maxima because 3 is greater than 2 and 2.<br>Both the minimum and maximum distances are between the second and the fifth node.<br>Thus, minDistance and maxDistance is 5 - 2 = 3.<br>Note that the last node is not considered a local maxima because it does not have a next node.<br><br>Constraints:<br><br>   The number of nodes in the list is in the range `[2, 105]`.<br>   `1 <= Node.val <= 105`"""<br><br>    n = len(nums)<br>    ans = [0]  (2  n)<br>    for i in range(n):<br>        ans[i] = nums[i]<br>        ans[i + n] = nums[i]<br>    return ans

### DOC[3] (IRRELEVANT) leetcode/leetcode_1687.txt
> def min_trips(boxes, portsCount, maxBoxes, maxWeight):<br>    """You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.<br><br>You are given an array `boxes`, where `boxes[i] = [ports​​i​, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.<br><br>   `ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.<br>   `portsCount` is the number of ports.<br>   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.<br><br>The boxes need to be delivered in the order they are given. The ship will follow these steps:<br><br>   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.<br>   For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.<br>   The ship then makes a return trip to storage to take more boxes from the queue.<br><br>The ship must end at storage after all the boxes have been delivered.<br><br>Return _the minimum number of trips the ship needs to make to deliver all boxes to their respective ports._<br><br>Example 1:<br><br>Input: boxes = \[\[1,1\],\[2,1\],\[1,1\]\], portsCount = 2, maxBoxes = 3, maxWeight = 3<br>Output: 4<br>Explanation: The optimal strategy is as follows: <br>- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.<br>So the total number of trips is 4.<br>Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).<br><br>Example 2:<br><br>Input: boxes = \[\[1,2\],\[3,3\],\[3,1\],\[3,1\],\[2,4\]\], portsCount = 3, maxBoxes = 3, maxWeight = 6<br>Output: 6<br>Explanation: The optimal strategy is as follows: <br>- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.<br>- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.<br>- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.<br>So the total number of trips is 2 + 2 + 2 = 6.<br><br>Example 3:<br><br>Input: boxes = \[\[1,4\],\[1,2\],\[2,1\],\[2,1\],\[3,2\],\[3,4\]\], portsCount = 3, maxBoxes = 6, maxWeight = 7<br>Output: 6<br>Explanation: The optimal strategy is as follows:<br>- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.<br>- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.<br>- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.<br>So the total number of trips is 2 + 2 + 2 = 6.<br><br>Constraints:<br><br>   `1 <= boxes.length <= 105`<br>   `1 <= portsCount, maxBoxes, maxWeight <= 105`<br>   `1 <= ports​​i <= portsCount`<br>   `1 <= weightsi <= maxWeight`"""<br><br>    trips = 0<br>    idx = 0<br>    n = len(boxes)<br>    while idx < n:<br>        curr_limit = maxWeight<br>        prev_port = 0<br>        count = 0<br>        while count < maxBoxes and idx < n:<br>            if boxes[idx][1] <= curr_limit:<br>                if prev_port != boxes[idx][0]:<br>                    prev_port = boxes[idx][0]<br>                    trips += 1<br>                curr_limit -= boxes[idx][1]<br>                count += 1<br>                idx += 1<br>            else:<br>                break<br>        trips += 1<br>    return trips

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_245187.txt
> def determine(note1, note2, shorthand=False):<br>    """Name the interval between note1 and note2.<br><br>    Examples:<br>     determine('C', 'E')<br>    'major third'<br>     determine('C', 'Eb')<br>    'minor third'<br>     determine('C', 'E#')<br>    'augmented third'<br>     determine('C', 'Ebb')<br>    'diminished third'<br><br>    This works for all intervals. Note that there are corner cases for major<br>    fifths and fourths:<br>     determine('C', 'G')<br>    'perfect fifth'<br>     determine('C', 'F')<br>    'perfect fourth'<br>    """<br>    # Corner case for unisons ('A' and 'Ab', for instance)<br>    if note1[0] == note2[0]:<br>        def get_val(note):<br>            """Private function: count the value of accidentals."""<br>            r = 0<br>            for x in note[1:]:<br>                if x == 'b':<br>                    r -= 1<br>                elif x == '#':<br>                    r += 1<br>            return r<br><br>        x = get_val(note1)<br>        y = get_val(note2)<br>        if x == y:<br>            if not shorthand:<br>                return 'major unison'<br>            return '1'<br>        elif x < y:<br>            if not shorthand:<br>                return 'augmented unison'<br>            return '#1'<br>        elif x - y == 1:<br>            if not shorthand:<br>                return 'minor unison'<br>            return 'b1'<br>        else:<br>            if not shorthand:<br>                return 'diminished unison'<br>            return 'bb1'<br><br>    # Other intervals<br>    n1 = notes.fifths.index(note1[0])<br>    n2 = notes.fifths.index(note2[0])<br>    number_of_fifth_steps = n2 - n1<br>    if n2 < n1:<br>        number_of_fifth_steps = len(notes.fifths) - n1 + n2<br><br>    # [name, shorthand_name, half notes for major version of this interval]<br>    fifth_steps = [<br>        ['unison', '1', 0],<br>        ['fifth', '5', 7],<br>        ['second', '2', 2],<br>        ['sixth', '6', 9],<br>        ['third', '3', 4],<br>        ['seventh', '7', 11],<br>        ['fourth', '4', 5],<br>        ]<br><br>    # Count half steps between note1 and note2<br>    half_notes = measure(note1, note2)<br><br>    # Get the proper list from the number of fifth steps<br>    current = fifth_steps[number_of_fifth_steps]<br><br>    # maj = number of major steps for this interval<br>    maj = current[2]<br><br>    # if maj is equal to the half steps between note1 and note2 the interval is<br>    # major or perfect<br>    if maj == half_notes:<br>        # Corner cases for perfect fifths and fourths<br>        if current[0] == 'fifth':<br>            if not shorthand:<br>                return 'perfect fifth'<br>        elif current[0] == 'fourth':<br>            if not shorthand:<br>                return 'perfect fourth'<br>        if not shorthand:<br>            return 'major ' + current[0]<br>        return current[1]<br>    elif maj + 1 <= half_notes:<br>        # if maj + 1 is equal to half_notes, the interval is augmented.<br>        if not shorthand:<br>            return 'augmented ' + current[0]<br>        return '#'  (half_notes - maj) + current[1]<br>    elif maj - 1 == half_notes:<br>        # etc.<br>        if not shorthand:<br>            return 'minor ' + current[0]<br>        return 'b' + current[1]<br>    elif maj - 2 = half_notes:<br>        if not shorthand:<br>            return 'diminished ' + current[0]<br>        return 'b'  (maj - half_notes) + current[1]

### DOC[5] (IRRELEVANT) leetcode/leetcode_2493.txt
> from collections import defaultdict, deque<br>    """You are given a positive integer `n` representing the number of nodes in an undirected graph. The nodes are labeled from `1` to `n`.<br><br>You are also given a 2D integer array `edges`, where `edges[i] = [ai, bi]` indicates that there is a bidirectional edge between nodes `ai` and `bi`. Notice that the given graph may be disconnected.<br><br>Divide the nodes of the graph into `m` groups (1-indexed) such that:<br><br>   Each node in the graph belongs to exactly one group.<br>   For every pair of nodes in the graph that are connected by an edge `[ai, bi]`, if `ai` belongs to the group with index `x`, and `bi` belongs to the group with index `y`, then `|y - x| = 1`.<br><br>Return _the maximum number of groups (i.e., maximum_ `m`_) into which you can divide the nodes_. Return `-1` _if it is impossible to group the nodes with the given conditions_.<br><br>Example 1:<br><br>Input: n = 6, edges = \[\[1,2\],\[1,4\],\[1,5\],\[2,6\],\[2,3\],\[4,6\]\]<br>Output: 4<br>Explanation: As shown in the image we:<br>- Add node 5 to the first group.<br>- Add node 1 to the second group.<br>- Add nodes 2 and 4 to the third group.<br>- Add nodes 3 and 6 to the fourth group.<br>We can see that every edge is satisfied.<br>It can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.<br><br>Example 2:<br><br>Input: n = 3, edges = \[\[1,2\],\[2,3\],\[3,1\]\]<br>Output: -1<br>Explanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.<br>It can be shown that no grouping is possible.<br><br>Constraints:<br><br>   `1 <= n <= 500`<br>   `1 <= edges.length <= 104`<br>   `edges[i].length == 2`<br>   `1 <= ai, bi <= n`<br>   `ai != bi`<br>   There is at most one edge between any pair of vertices."""<br><br><br>def maxGroups(n, edges):<br>    graph = defaultdict(list)<br>    color = [0]  (n + 1)<br><br>    for edge in edges:<br>        graph[edge[0]].append(edge[1])<br>        graph[edge[1]].append(edge[0])<br><br>    max_group = 0<br>    for i in range(1, n + 1):<br>        if color[i] == 0:<br>            q = deque([i])<br>            color[i] = 1<br>            while q:<br>                node = q.popleft()<br>                max_group = max(max_group, color[node])<br>                for neighbor in graph[node]:<br>                    if color[neighbor] == 0:<br>                        color[neighbor] = color[node] + 1<br>                        q.append(neighbor)<br>                    elif color[neighbor] == color[node]:<br>                        return -1<br>                        <br>    return max_group


## Ground Truth

### GROUND TRUTH 0, ranked 11, leetcode/leetcode_2509.txt
> def length_of_cycle(n, queries):<br>    """You are given an integer `n`. There is a complete binary tree with `2n - 1` nodes. The root of that tree is the node with the value `1`, and every node with a value `val` in the range `[1, 2n - 1 - 1]` has two children where:<br><br>   The left node has the value `2  val`, and<br>   The right node has the value `2  val + 1`.<br><br>You are also given a 2D integer array `queries` of length `m`, where `queries[i] = [ai, bi]`. For each query, solve the following problem:<br><br>1.  Add an edge between the nodes with values `ai` and `bi`.<br>2.  Find the length of the cycle in the graph.<br>3.  Remove the added edge between nodes with values `ai` and `bi`.<br><br>Note that:<br><br>   A cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.<br>   The length of a cycle is the number of edges visited in the cycle.<br>   There could be multiple edges between two nodes in the tree after adding the edge of the query.<br><br>Return _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the answer to the_ `ith` _query._<br><br>Example 1:<br><br>Input: n = 3, queries = \[\[5,3\],\[4,7\],\[2,3\]\]<br>Output: \[4,5,3\]<br>Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.<br>- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes \[5,2,1,3\]. Thus answer to the first query is 4. We delete the added edge and process the next query.<br>- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes \[4,2,1,3,7\]. Thus answer to the second query is 5. We delete the added edge and process the next query.<br>- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes \[2,1,3\]. Thus answer to the third query is 3. We delete the added edge.<br><br>Example 2:<br><br>Input: n = 2, queries = \[\[1,2\]\]<br>Output: \[2\]<br>Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.<br>- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes \[2,1\]. Thus answer for the first query is 2. We delete the added edge.<br><br>Constraints:<br><br>   `2 <= n <= 30`<br>   `m == queries.length`<br>   `1 <= m <= 105`<br>   `queries[i].length == 2`<br>   `1 <= ai, bi <= 2n - 1`<br>   `ai != bi`"""<br><br>    result = []<br>    for A, B in queries:<br>        depth_A, depth_B = 0, 0<br>        while A != B:<br>            if A < B:<br>                A, B = B, A<br>            A = 1<br>            depth_A += 1<br>        result.append(depth_A + depth_B)<br>    return result
