# Query `77`

## Original Question

*You are assigned to put some amount of boxes onto one truck. You are given a 2D array `boxTypes`, where `boxTypes[i] = [numberOfBoxesi, numberOfUnitsPerBoxi]`:

   `numberOfBoxesi` is the number of boxes of type `i`.
   `numberOfUnitsPerBoxi` is the number of units in each box of the type `i`.

You are also given an integer `truckSize`, which is the maximum number of boxes that can be put on the truck. You can choose any boxes to put on the truck as long as the number of boxes does not exceed `truckSize`.

Return _the maximum total number of units that can be put on the truck._

Example 1:

Input: boxTypes = \[\[1,3\],\[2,2\],\[3,1\]\], truckSize = 4
Output: 8
Explanation: There are:
- 1 box of the first type that contains 3 units.
- 2 boxes of the second type that contain 2 units each.
- 3 boxes of the third type that contain 1 unit each.
You can take all the boxes of the first and second types, and one box of the third type.
The total number of units will be = (1 \ 3) + (2 \ 2) + (1 \ 1) = 8.

Example 2:

Input: boxTypes = \[\[5,10\],\[2,5\],\[4,7\],\[3,9\]\], truckSize = 10
Output: 91

Constraints:

   `1 <= boxTypes.length <= 1000`
   `1 <= numberOfBoxesi, numberOfUnitsPerBoxi <= 1000`
   `1 <= truckSize <= 106`*


### Metrics

```
recip_rank: 0.0052
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1829.txt
> def maximumUnits(boxTypes, truckSize):<br>    """You are given a sorted array `nums` of `n` non-negative integers and an integer `maximumBit`. You want to perform the following query `n` times:<br><br>1.  Find a non-negative integer `k < 2maximumBit` such that `nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k` is maximized. `k` is the answer to the `ith` query.<br>2.  Remove the last element from the current array `nums`.<br><br>Return _an array_ `answer`_, where_ `answer[i]` _is the answer to the_ `ith` _query_.<br><br>Example 1:<br><br>Input: nums = \[0,1,1,3\], maximumBit = 2<br>Output: \[0,3,2,3\]<br>Explanation: The queries are answered as follows:<br>1st query: nums = \[0,1,1,3\], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.<br>2nd query: nums = \[0,1,1\], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.<br>3rd query: nums = \[0,1\], k = 2 since 0 XOR 1 XOR 2 = 3.<br>4th query: nums = \[0\], k = 3 since 0 XOR 3 = 3.<br><br>Example 2:<br><br>Input: nums = \[2,3,4,7\], maximumBit = 3<br>Output: \[5,2,6,5\]<br>Explanation: The queries are answered as follows:<br>1st query: nums = \[2,3,4,7\], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.<br>2nd query: nums = \[2,3,4\], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.<br>3rd query: nums = \[2,3\], k = 6 since 2 XOR 3 XOR 6 = 7.<br>4th query: nums = \[2\], k = 5 since 2 XOR 5 = 7.<br><br>Example 3:<br><br>Input: nums = \[0,1,2,2,5,7\], maximumBit = 3<br>Output: \[4,3,6,4,6,7\]<br><br>Constraints:<br><br>   `nums.length == n`<br>   `1 <= n <= 105`<br>   `1 <= maximumBit <= 20`<br>   `0 <= nums[i] < 2maximumBit`<br>   `nums`​​​ is sorted in ascending order."""<br><br>    boxTypes.sort(key=lambda x: x[1], reverse=True)<br>    <br>    totalUnits = 0<br>    for box in boxTypes:<br>        boxCount = min(truckSize, box[0])<br>        totalUnits += boxCount  box[1]<br>        truckSize -= boxCount<br>        if truckSize == 0:<br>            break<br>    <br>    return totalUnits

### DOC[2] (IRRELEVANT) leetcode/leetcode_2391.txt
> def min_minutes(garbage: list[str], travel: list[int]) - int:<br>    """You are given a 0-indexed array of strings `garbage` where `garbage[i]` represents the assortment of garbage at the `ith` house. `garbage[i]` consists only of the characters `'M'`, `'P'` and `'G'` representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes `1` minute.<br><br>You are also given a 0-indexed integer array `travel` where `travel[i]` is the number of minutes needed to go from house `i` to house `i + 1`.<br><br>There are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house `0` and must visit each house in order; however, they do not need to visit every house.<br><br>Only one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.<br><br>Return _the minimum number of minutes needed to pick up all the garbage._<br><br>Example 1:<br><br>Input: garbage = \[ "G ", "P ", "GP ", "GG "\], travel = \[2,4,3\]<br>Output: 21<br>Explanation:<br>The paper garbage truck:<br>1. Travels from house 0 to house 1<br>2. Collects the paper garbage at house 1<br>3. Travels from house 1 to house 2<br>4. Collects the paper garbage at house 2<br>Altogether, it takes 8 minutes to pick up all the paper garbage.<br>The glass garbage truck:<br>1. Collects the glass garbage at house 0<br>2. Travels from house 0 to house 1<br>3. Travels from house 1 to house 2<br>4. Collects the glass garbage at house 2<br>5. Travels from house 2 to house 3<br>6. Collects the glass garbage at house 3<br>Altogether, it takes 13 minutes to pick up all the glass garbage.<br>Since there is no metal garbage, we do not need to consider the metal garbage truck.<br>Therefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.<br><br>Example 2:<br><br>Input: garbage = \[ "MMM ", "PGM ", "GP "\], travel = \[3,10\]<br>Output: 37<br>Explanation:<br>The metal garbage truck takes 7 minutes to pick up all the metal garbage.<br>The paper garbage truck takes 15 minutes to pick up all the paper garbage.<br>The glass garbage truck takes 15 minutes to pick up all the glass garbage.<br>It takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.<br><br>Constraints:<br><br>   `2 <= garbage.length <= 105`<br>   `garbage[i]` consists of only the letters `'M'`, `'P'`, and `'G'`.<br>   `1 <= garbage[i].length <= 10`<br>   `travel.length == garbage.length - 1`<br>   `1 <= travel[i] <= 100`"""<br><br>    time_garbage = [0, 0, 0]<br>    time_travel = [0, 0, 0]<br><br>    for i, g in enumerate(garbage):<br>        m, p, g = g.count('M'), g.count('P'), g.count('G')<br>        time_garbage[0] += m<br>        time_garbage[1] += p<br>        time_garbage[2] += g<br>        if i < len(garbage) - 1:<br>            time_travel[0] += travel[i]<br>            time_travel[1] += travel[i]<br>            time_travel[2] += travel[i]<br>    <br>    return sum(time_garbage) + sum(time_travel)

### DOC[3] (IRRELEVANT) leetcode/leetcode_1687.txt
> def min_trips(boxes, portsCount, maxBoxes, maxWeight):<br>    """You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a limit on the number of boxes and the total weight that it can carry.<br><br>You are given an array `boxes`, where `boxes[i] = [ports​​i​, weighti]`, and three integers `portsCount`, `maxBoxes`, and `maxWeight`.<br><br>   `ports​​i` is the port where you need to deliver the `ith` box and `weightsi` is the weight of the `ith` box.<br>   `portsCount` is the number of ports.<br>   `maxBoxes` and `maxWeight` are the respective box and weight limits of the ship.<br><br>The boxes need to be delivered in the order they are given. The ship will follow these steps:<br><br>   The ship will take some number of boxes from the `boxes` queue, not violating the `maxBoxes` and `maxWeight` constraints.<br>   For each loaded box in order, the ship will make a trip to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no trip is needed, and the box can immediately be delivered.<br>   The ship then makes a return trip to storage to take more boxes from the queue.<br><br>The ship must end at storage after all the boxes have been delivered.<br><br>Return _the minimum number of trips the ship needs to make to deliver all boxes to their respective ports._<br><br>Example 1:<br><br>Input: boxes = \[\[1,1\],\[2,1\],\[1,1\]\], portsCount = 2, maxBoxes = 3, maxWeight = 3<br>Output: 4<br>Explanation: The optimal strategy is as follows: <br>- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.<br>So the total number of trips is 4.<br>Note that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).<br><br>Example 2:<br><br>Input: boxes = \[\[1,2\],\[3,3\],\[3,1\],\[3,1\],\[2,4\]\], portsCount = 3, maxBoxes = 3, maxWeight = 6<br>Output: 6<br>Explanation: The optimal strategy is as follows: <br>- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.<br>- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.<br>- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.<br>So the total number of trips is 2 + 2 + 2 = 6.<br><br>Example 3:<br><br>Input: boxes = \[\[1,4\],\[1,2\],\[2,1\],\[2,1\],\[3,2\],\[3,4\]\], portsCount = 3, maxBoxes = 6, maxWeight = 7<br>Output: 6<br>Explanation: The optimal strategy is as follows:<br>- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.<br>- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.<br>- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.<br>So the total number of trips is 2 + 2 + 2 = 6.<br><br>Constraints:<br><br>   `1 <= boxes.length <= 105`<br>   `1 <= portsCount, maxBoxes, maxWeight <= 105`<br>   `1 <= ports​​i <= portsCount`<br>   `1 <= weightsi <= maxWeight`"""<br><br>    trips = 0<br>    idx = 0<br>    n = len(boxes)<br>    while idx < n:<br>        curr_limit = maxWeight<br>        prev_port = 0<br>        count = 0<br>        while count < maxBoxes and idx < n:<br>            if boxes[idx][1] <= curr_limit:<br>                if prev_port != boxes[idx][0]:<br>                    prev_port = boxes[idx][0]<br>                    trips += 1<br>                curr_limit -= boxes[idx][1]<br>                count += 1<br>                idx += 1<br>            else:<br>                break<br>        trips += 1<br>    return trips

### DOC[4] (IRRELEVANT) leetcode/leetcode_1467.txt
> from math import factorial<br>    """Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`.<br><br>All the balls will be shuffled uniformly at random, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully).<br><br>Please note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a)` (Please read the explanation of the first example carefully).<br><br>Return _the probability_ that the two boxes have the same number of distinct balls. Answers within `10-5` of the actual value will be accepted as correct.<br><br>Example 1:<br><br>Input: balls = \[1,1\]<br>Output: 1.00000<br>Explanation: Only 2 ways to divide the balls equally:<br>- A ball of color 1 to box 1 and a ball of color 2 to box 2<br>- A ball of color 2 to box 1 and a ball of color 1 to box 2<br>In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1<br><br>Example 2:<br><br>Input: balls = \[2,1,1\]<br>Output: 0.66667<br>Explanation: We have the set of balls \[1, 1, 2, 3\]<br>This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):<br>\[1,1 / 2,3\], \[1,1 / 3,2\], \[1,2 / 1,3\], \[1,2 / 3,1\], \[1,3 / 1,2\], \[1,3 / 2,1\], \[2,1 / 1,3\], \[2,1 / 3,1\], \[2,3 / 1,1\], \[3,1 / 1,2\], \[3,1 / 2,1\], \[3,2 / 1,1\]<br>After that, we add the first two balls to the first box and the second two balls to the second box.<br>We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.<br>Probability is 8/12 = 0.66667<br><br>Example 3:<br><br>Input: balls = \[1,2,1,2\]<br>Output: 0.60000<br>Explanation: The set of balls is \[1, 2, 2, 3, 4, 4\]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.<br>Probability = 108 / 180 = 0.6<br><br>Constraints:<br><br>   `1 <= balls.length <= 8`<br>   `1 <= balls[i] <= 6`<br>   `sum(balls)` is even."""<br><br><br>def count_combinations(balls, combinations, curr_ball):<br>    total_combinations = 1<br>    for i in range(curr_ball):<br>        total_combinations = factorial(balls[i] + combinations[i]) / (factorial(balls[i])  factorial(combinations[i]))<br><br>    return total_combinations<br><br>def dfs(balls, combinations, curr_ball):<br>    if curr_ball == len(balls):<br>        if combinations[-1] == combinations[0]:<br>            return count_combinations(balls, combinations, curr_ball)<br>        else:<br>            return 0<br><br>    result = 0<br>    for i in range(balls[curr_ball] + 1):<br>        combinations.append(i)<br>        result += dfs(balls, combinations, curr_ball + 1)<br>        combinations.pop()<br><br>    return result<br><br>def get_probability(balls):<br>    sum_balls = sum(balls)<br><br>    total_combinations = 1<br>    for ball in balls:<br>        total_combinations = factorial(ball)<br><br>    combinations = []<br>    return dfs(balls, combinations, 0) / total_combinations

### DOC[5] (IRRELEVANT) leetcode/leetcode_1105.txt
> def max_uncrossed_lines(nums1, nums2):<br>    """You are given an array `books` where `books[i] = [thicknessi, heighti]` indicates the thickness and height of the `ith` book. You are also given an integer `shelfWidth`.<br><br>We want to place these books in order onto bookcase shelves that have a total width `shelfWidth`.<br><br>We choose some of the books to place on this shelf such that the sum of their thickness is less than or equal to `shelfWidth`, then build another level of the shelf of the bookcase so that the total height of the bookcase has increased by the maximum height of the books we just put down. We repeat this process until there are no more books to place.<br><br>Note that at each step of the above process, the order of the books we place is the same order as the given sequence of books.<br><br>   For example, if we have an ordered list of `5` books, we might place the first and second book onto the first shelf, the third book on the second shelf, and the fourth and fifth book on the last shelf.<br><br>Return _the minimum possible height that the total bookshelf can be after placing shelves in this manner_.<br><br>Example 1:<br><br>Input: books = \[\[1,1\],\[2,3\],\[2,3\],\[1,1\],\[1,1\],\[1,1\],\[1,2\]\], shelfWidth = 4<br>Output: 6<br>Explanation:<br>The sum of the heights of the 3 shelves is 1 + 3 + 2 = 6.<br>Notice that book number 2 does not have to be on the first shelf.<br><br>Example 2:<br><br>Input: books = \[\[1,3\],\[2,4\],\[3,2\]\], shelfWidth = 6<br>Output: 4<br><br>Constraints:<br><br>   `1 <= books.length <= 1000`<br>   `1 <= thicknessi <= shelfWidth <= 1000`<br>   `1 <= heighti <= 1000`"""<br><br>    m, n = len(nums1), len(nums2)<br>    dp = [[0]  (n + 1) for _ in range(m + 1)]<br><br>    for i in range(1, m + 1):<br>        for j in range(1, n + 1):<br>            if nums1[i - 1] == nums2[j - 1]:<br>                dp[i][j] = dp[i - 1][j - 1] + 1<br>            else:<br>                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])<br><br>    return dp[m][n]


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2279.txt
> def max_unique_even_sum(final_sum):<br>    """You have `n` bags numbered from `0` to `n - 1`. You are given two 0-indexed integer arrays `capacity` and `rocks`. The `ith` bag can hold a maximum of `capacity[i]` rocks and currently contains `rocks[i]` rocks. You are also given an integer `additionalRocks`, the number of additional rocks you can place in any of the bags.<br><br>Return _the maximum number of bags that could have full capacity after placing the additional rocks in some bags._<br><br>Example 1:<br><br>Input: capacity = \[2,3,4,5\], rocks = \[1,2,4,4\], additionalRocks = 2<br>Output: 3<br>Explanation:<br>Place 1 rock in bag 0 and 1 rock in bag 1.<br>The number of rocks in each bag are now \[2,3,4,4\].<br>Bags 0, 1, and 2 have full capacity.<br>There are 3 bags at full capacity, so we return 3.<br>It can be shown that it is not possible to have more than 3 bags at full capacity.<br>Note that there may be other ways of placing the rocks that result in an answer of 3.<br><br>Example 2:<br><br>Input: capacity = \[10,2,2\], rocks = \[2,2,0\], additionalRocks = 100<br>Output: 3<br>Explanation:<br>Place 8 rocks in bag 0 and 2 rocks in bag 2.<br>The number of rocks in each bag are now \[10,2,2\].<br>Bags 0, 1, and 2 have full capacity.<br>There are 3 bags at full capacity, so we return 3.<br>It can be shown that it is not possible to have more than 3 bags at full capacity.<br>Note that we did not use all of the additional rocks.<br><br>Constraints:<br><br>   `n == capacity.length == rocks.length`<br>   `1 <= n <= 5  104`<br>   `1 <= capacity[i] <= 109`<br>   `0 <= rocks[i] <= capacity[i]`<br>   `1 <= additionalRocks <= 109`"""<br><br>    result = []<br>    current = 2<br>    while final_sum  0:<br>        if final_sum = current:<br>            result.append(current)<br>            final_sum -= current<br>            current += 2<br>        else:<br>            break<br>    return result
