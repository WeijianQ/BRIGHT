# Query `98`

## Original Question

*You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given a 2D integer array `relations` where `relations[j] = [prevCoursej, nextCoursej]` denotes that course `prevCoursej` has to be completed before course `nextCoursej` (prerequisite relationship). Furthermore, you are given a 0-indexed integer array `time` where `time[i]` denotes how many months it takes to complete the `(i+1)th` course.

You must find the minimum number of months needed to complete all the courses following these rules:

   You may start taking a course at any time if the prerequisites are met.
   Any number of courses can be taken at the same time.

Return _the minimum number of months needed to complete all the courses_.

Note: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).

Example 1:

Input: n = 3, relations = \[\[1,3\],\[2,3\]\], time = \[3,2,5\]
Output: 8
Explanation: The figure above represents the given graph and the time required to complete each course. 
We start course 1 and course 2 simultaneously at month 0.
Course 1 takes 3 months and course 2 takes 2 months to complete respectively.
Thus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.

Example 2:

Input: n = 5, relations = \[\[1,5\],\[2,5\],\[3,5\],\[3,4\],\[4,5\]\], time = \[1,2,3,4,5\]
Output: 12
Explanation: The figure above represents the given graph and the time required to complete each course.
You can start courses 1, 2, and 3 at month 0.
You can complete them after 1, 2, and 3 months respectively.
Course 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.
Course 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.
Thus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.

Constraints:

   `1 <= n <= 5  104`
   `0 <= relations.length <= min(n  (n - 1) / 2, 5  104)`
   `relations[j].length == 2`
   `1 <= prevCoursej, nextCoursej <= n`
   `prevCoursej != nextCoursej`
   All the pairs `[prevCoursej, nextCoursej]` are unique.
   `time.length == n`
   `1 <= time[i] <= 104`
   The given graph is a directed acyclic graph.*


### Metrics

```
recip_rank: 0.0625
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0200
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.2500
recall_50: 0.2500
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0955
ndcg_cut_50: 0.0955
ndcg_cut_100: 0.1619
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0156
map_cut_50: 0.0156
map_cut_100: 0.0242
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2045.txt
> from collections import defaultdict, deque<br>    """A city is represented as a bi-directional connected graph with `n` vertices where each vertex is labeled from `1` to `n` (inclusive). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.<br><br>Each vertex has a traffic signal which changes its color from green to red and vice versa every `change` minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.<br><br>The second minimum value is defined as the smallest value strictly larger than the minimum value.<br><br>   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.<br><br>Given `n`, `edges`, `time`, and `change`, return _the second minimum time it will take to go from vertex_ `1` _to vertex_ `n`.<br><br>Notes:<br><br>   You can go through any vertex any number of times, including `1` and `n`.<br>   You can assume that when the journey starts, all signals have just turned green.<br><br>Example 1:<br><br>       <br><br>Input: n = 5, edges = \[\[1,2\],\[1,3\],\[1,4\],\[3,4\],\[4,5\]\], time = 3, change = 5<br>Output: 13<br>Explanation:<br>The figure on the left shows the given graph.<br>The blue path in the figure on the right is the minimum time path.<br>The time taken is:<br>- Start at 1, time elapsed=0<br>- 1 - 4: 3 minutes, time elapsed=3<br>- 4 - 5: 3 minutes, time elapsed=6<br>Hence the minimum time needed is 6 minutes.<br><br>The red path shows the path to get the second minimum time.<br>- Start at 1, time elapsed=0<br>- 1 - 3: 3 minutes, time elapsed=3<br>- 3 - 4: 3 minutes, time elapsed=6<br>- Wait at 4 for 4 minutes, time elapsed=10<br>- 4 - 5: 3 minutes, time elapsed=13<br>Hence the second minimum time is 13 minutes.      <br><br>Example 2:<br><br>Input: n = 2, edges = \[\[1,2\]\], time = 3, change = 2<br>Output: 11<br>Explanation:<br>The minimum time path is 1 - 2 with time = 3 minutes.<br>The second minimum time path is 1 - 2 - 1 - 2 with time = 11 minutes.<br><br>Constraints:<br><br>   `2 <= n <= 104`<br>   `n - 1 <= edges.length <= min(2  104, n  (n - 1) / 2)`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`<br>   There are no duplicate edges.<br>   Each vertex can be reached directly or indirectly from every other vertex.<br>   `1 <= time, change <= 103`"""<br><br><br>def secondMinimum(n, edges, time, change):<br>    graph = defaultdict(list)<br>    <br>    for u, v in edges:<br>        graph[u].append(v)<br>        graph[v].append(u)<br><br>    dist = [float('inf')]  (n + 1)<br>    dist2 = [float('inf')]  (n + 1)<br>    dist[1] = 0<br><br>    q = deque([1])<br><br>    while q:<br>        cur = q.popleft()<br><br>        nextDist = dist[cur] + time<br>        waitTime = change if (nextDist // change) % 2 == 1 else 0<br>        nextDist += waitTime<br><br>        for next in graph[cur]:<br>            if nextDist < dist[next]:<br>                nextDist, dist[next] = dist[next], nextDist<br>                q.append(next)<br>            if nextDist < dist2[next]:<br>                nextDist, dist2[next] = dist2[next], nextDist<br>                q.append(next)<br><br>    return dist2[n]

### DOC[2] (IRRELEVANT) leetcode/leetcode_2285.txt
> class BitSet:<br>    """You are given an integer `n` denoting the number of cities in a country. The cities are numbered from `0` to `n - 1`.<br><br>You are also given a 2D integer array `roads` where `roads[i] = [ai, bi]` denotes that there exists a bidirectional road connecting cities `ai` and `bi`.<br><br>You need to assign each city with an integer value from `1` to `n`, where each value can only be used once. The importance of a road is then defined as the sum of the values of the two cities it connects.<br><br>Return _the maximum total importance of all roads possible after assigning the values optimally._<br><br>Example 1:<br><br>Input: n = 5, roads = \[\[0,1\],\[1,2\],\[2,3\],\[0,2\],\[1,3\],\[2,4\]\]<br>Output: 43<br>Explanation: The figure above shows the country and the assigned values of \[2,4,5,3,1\].<br>- The road (0,1) has an importance of 2 + 4 = 6.<br>- The road (1,2) has an importance of 4 + 5 = 9.<br>- The road (2,3) has an importance of 5 + 3 = 8.<br>- The road (0,2) has an importance of 2 + 5 = 7.<br>- The road (1,3) has an importance of 4 + 3 = 7.<br>- The road (2,4) has an importance of 5 + 1 = 6.<br>The total importance of all roads is 6 + 9 + 8 + 7 + 7 + 6 = 43.<br>It can be shown that we cannot obtain a greater total importance than 43.<br><br>Example 2:<br><br>Input: n = 5, roads = \[\[0,3\],\[2,4\],\[1,3\]\]<br>Output: 20<br>Explanation: The figure above shows the country and the assigned values of \[4,3,2,5,1\].<br>- The road (0,3) has an importance of 4 + 5 = 9.<br>- The road (2,4) has an importance of 2 + 1 = 3.<br>- The road (1,3) has an importance of 3 + 5 = 8.<br>The total importance of all roads is 9 + 3 + 8 = 20.<br>It can be shown that we cannot obtain a greater total importance than 20.<br><br>Constraints:<br><br>   `2 <= n <= 5  104`<br>   `1 <= roads.length <= 5  104`<br>   `roads[i].length == 2`<br>   `0 <= ai, bi <= n - 1`<br>   `ai != bi`<br>   There are no duplicate roads."""<br><br>    def __init__(self, size):<br>        self.bits = [0]  ((size + 31) // 32)<br><br>    def set(self, index):<br>        self.bits[index // 32] |= (1 << (index % 32))<br><br>    def get(self, index):<br>        return (self.bits[index // 32] & (1 << (index % 32))) != 0

### DOC[3] (IRRELEVANT) leetcode/leetcode_1627.txt
> def lastMoment(n, left, right):<br>    """We have `n` cities labeled from `1` to `n`. Two different cities with labels `x` and `y` are directly connected by a bidirectional road if and only if `x` and `y` share a common divisor strictly greater than some `threshold`. More formally, cities with labels `x` and `y` have a road between them if there exists an integer `z` such that all of the following are true:<br><br>   `x % z == 0`,<br>   `y % z == 0`, and<br>   `z  threshold`.<br><br>Given the two integers, `n` and `threshold`, and an array of `queries`, you must determine for each `queries[i] = [ai, bi]` if cities `ai` and `bi` are connected directly or indirectly. (i.e. there is some path between them).<br><br>Return _an array_ `answer`_, where_ `answer.length == queries.length` _and_ `answer[i]` _is_ `true` _if for the_ `ith` _query, there is a path between_ `ai` _and_ `bi`_, or_ `answer[i]` _is_ `false` _if there is no path._<br><br>Example 1:<br><br>Input: n = 6, threshold = 2, queries = \[\[1,4\],\[2,5\],\[3,6\]\]<br>Output: \[false,false,true\]<br>Explanation: The divisors for each number:<br>1:   1<br>2:   1, 2<br>3:   1, 3<br>4:   1, 2, 4<br>5:   1, 5<br>6:   1, 2, 3, 6<br>Using the underlined divisors above the threshold, only cities 3 and 6 share a common divisor, so they are the<br>only ones directly connected. The result of each query:<br>\[1,4\]   1 is not connected to 4<br>\[2,5\]   2 is not connected to 5<br>\[3,6\]   3 is connected to 6 through path 3--6<br><br>Example 2:<br><br>Input: n = 6, threshold = 0, queries = \[\[4,5\],\[3,4\],\[3,2\],\[2,6\],\[1,3\]\]<br>Output: \[true,true,true,true,true\]<br>Explanation: The divisors for each number are the same as the previous example. However, since the threshold is 0,<br>all divisors can be used. Since all numbers share 1 as a divisor, all cities are connected.<br><br>Example 3:<br><br>Input: n = 5, threshold = 1, queries = \[\[4,5\],\[4,5\],\[3,2\],\[2,3\],\[3,4\]\]<br>Output: \[false,false,false,false,false\]<br>Explanation: Only cities 2 and 4 share a common divisor 2 which is strictly greater than the threshold 1, so they are the only ones directly connected.<br>Please notice that there can be multiple queries for the same pair of nodes \[x, y\], and that the query \[x, y\] is equivalent to the query \[y, x\].<br><br>Constraints:<br><br>   `2 <= n <= 104`<br>   `0 <= threshold <= n`<br>   `1 <= queries.length <= 105`<br>   `queries[i].length == 2`<br>   `1 <= ai, bi <= cities`<br>   `ai != bi`"""<br><br>    max_left = max(left, default=0)<br>    min_right = min(right, default=n)<br><br>    return max(max_left, n - min_right)

### DOC[4] (IRRELEVANT) leetcode/leetcode_2187.txt
> def sum_of_vowels_in_the_substrings(word: str) - int:<br>    """You are given an array `time` where `time[i]` denotes the time taken by the `ith` bus to complete one trip.<br><br>Each bus can make multiple trips successively; that is, the next trip can start immediately after completing the current trip. Also, each bus operates independently; that is, the trips of one bus do not influence the trips of any other bus.<br><br>You are also given an integer `totalTrips`, which denotes the number of trips all buses should make in total. Return _the minimum time required for all buses to complete at least_ `totalTrips` _trips_.<br><br>Example 1:<br><br>Input: time = \[1,2,3\], totalTrips = 5<br>Output: 3<br>Explanation:<br>- At time t = 1, the number of trips completed by each bus are \[1,0,0\]. <br>  The total number of trips completed is 1 + 0 + 0 = 1.<br>- At time t = 2, the number of trips completed by each bus are \[2,1,0\]. <br>  The total number of trips completed is 2 + 1 + 0 = 3.<br>- At time t = 3, the number of trips completed by each bus are \[3,1,1\]. <br>  The total number of trips completed is 3 + 1 + 1 = 5.<br>So the minimum time needed for all buses to complete at least 5 trips is 3.<br><br>Example 2:<br><br>Input: time = \[2\], totalTrips = 1<br>Output: 2<br>Explanation:<br>There is only one bus, and it will complete its first trip at t = 2.<br>So the minimum time needed to complete 1 trip is 2.<br><br>Constraints:<br><br>   `1 <= time.length <= 105`<br>   `1 <= time[i], totalTrips <= 107`"""<br><br>    total_sum = 0<br>    n = len(word)<br><br>    for i, char in enumerate(word):<br>        if char in {'a', 'e', 'i', 'o', 'u'}:<br>            total_sum += (i + 1)  (n - i)<br><br>    return total_sum

### DOC[5] (IRRELEVANT) leetcode/leetcode_1557.txt
> def has_all_codes(s, k):<br>    """Given a directed acyclic graph, with `n` vertices numbered from `0` to `n-1`, and an array `edges` where `edges[i] = [fromi, toi]` represents a directed edge from node `fromi` to node `toi`.<br><br>Find _the smallest set of vertices from which all nodes in the graph are reachable_. It's guaranteed that a unique solution exists.<br><br>Notice that you can return the vertices in any order.<br><br>Example 1:<br><br>Input: n = 6, edges = \[\[0,1\],\[0,2\],\[2,5\],\[3,4\],\[4,2\]\]<br>Output: \[0,3\]<br>Explanation: It's not possible to reach all the nodes from a single vertex. From 0 we can reach \[0,1,2,5\]. From 3 we can reach \[3,4,2,5\]. So we output \[0,3\].<br><br>Example 2:<br><br>Input: n = 5, edges = \[\[0,1\],\[2,1\],\[3,1\],\[1,4\],\[2,4\]\]<br>Output: \[0,2,3\]<br>Explanation: Notice that vertices 0, 3 and 2 are not reachable from any other node, so we must include them. Also any of these vertices can reach nodes 1 and 4.<br><br>Constraints:<br><br>   `2 <= n <= 10^5`<br>   `1 <= edges.length <= min(10^5, n  (n - 1) / 2)`<br>   `edges[i].length == 2`<br>   `0 <= fromi, toi < n`<br>   All pairs `(fromi, toi)` are distinct."""<br><br>    need = 1 << k<br>    got = set()<br>    <br>    for i in range(len(s) - k + 1):<br>        got.add(s[i:i + k])<br>    <br>    return len(got) == need


## Ground Truth

### GROUND TRUTH 0, ranked 15, leetcode/leetcode_630.txt
> import heapq<br>    """There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken continuously for `durationi` days and must be finished before or on `lastDayi`.<br><br>You will start on the `1st` day and you cannot take two or more courses simultaneously.<br><br>Return _the maximum number of courses that you can take_.<br><br>Example 1:<br><br>Input: courses = \[\[100,200\],\[200,1300\],\[1000,1250\],\[2000,3200\]\]<br>Output: 3<br>Explanation: <br>There are totally 4 courses, but you can take 3 courses at most:<br>First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.<br>Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. <br>Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. <br>The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.<br><br>Example 2:<br><br>Input: courses = \[\[1,2\]\]<br>Output: 1<br><br>Example 3:<br><br>Input: courses = \[\[3,2\],\[4,3\]\]<br>Output: 0<br><br>Constraints:<br><br>   `1 <= courses.length <= 104`<br>   `1 <= durationi, lastDayi <= 104`"""<br><br><br>def scheduleCourse(courses):<br>    courses.sort(key=lambda x: x[1])<br>    curr_time, duration_sum = 0, []<br><br>    for duration, deadline in courses:<br>        curr_time += duration<br>        heapq.heappush(duration_sum, -duration)<br><br>        if curr_time  deadline:<br>            curr_time += heapq.heappop(duration_sum)<br><br>    return len(duration_sum)

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_1834.txt
> def minimum_teachings(n, languages, friendships):<br>    """You are given `n`​​​​​​ tasks labeled from `0` to `n - 1` represented by a 2D integer array `tasks`, where `tasks[i] = [enqueueTimei, processingTimei]` means that the `i​​​​​​th`​​​​ task will be available to process at `enqueueTimei` and will take `processingTimei` to finish processing.<br><br>You have a single-threaded CPU that can process at most one task at a time and will act in the following way:<br><br>   If the CPU is idle and there are no available tasks to process, the CPU remains idle.<br>   If the CPU is idle and there are available tasks, the CPU will choose the one with the shortest processing time. If multiple tasks have the same shortest processing time, it will choose the task with the smallest index.<br>   Once a task is started, the CPU will process the entire task without stopping.<br>   The CPU can finish a task then start a new one instantly.<br><br>Return _the order in which the CPU will process the tasks._<br><br>Example 1:<br><br>Input: tasks = \[\[1,2\],\[2,4\],\[3,2\],\[4,1\]\]<br>Output: \[0,2,3,1\]<br>Explanation: The events go as follows: <br>- At time = 1, task 0 is available to process. Available tasks = {0}.<br>- Also at time = 1, the idle CPU starts processing task 0. Available tasks = {}.<br>- At time = 2, task 1 is available to process. Available tasks = {1}.<br>- At time = 3, task 2 is available to process. Available tasks = {1, 2}.<br>- Also at time = 3, the CPU finishes task 0 and starts processing task 2 as it is the shortest. Available tasks = {1}.<br>- At time = 4, task 3 is available to process. Available tasks = {1, 3}.<br>- At time = 5, the CPU finishes task 2 and starts processing task 3 as it is the shortest. Available tasks = {1}.<br>- At time = 6, the CPU finishes task 3 and starts processing task 1. Available tasks = {}.<br>- At time = 10, the CPU finishes task 1 and becomes idle.<br><br>Example 2:<br><br>Input: tasks = \[\[7,10\],\[7,12\],\[7,5\],\[7,4\],\[7,2\]\]<br>Output: \[4,3,2,0,1\]<br>Explanation: The events go as follows:<br>- At time = 7, all the tasks become available. Available tasks = {0,1,2,3,4}.<br>- Also at time = 7, the idle CPU starts processing task 4. Available tasks = {0,1,2,3}.<br>- At time = 9, the CPU finishes task 4 and starts processing task 3. Available tasks = {0,1,2}.<br>- At time = 13, the CPU finishes task 3 and starts processing task 2. Available tasks = {0,1}.<br>- At time = 18, the CPU finishes task 2 and starts processing task 0. Available tasks = {1}.<br>- At time = 28, the CPU finishes task 0 and starts processing task 1. Available tasks = {}.<br>- At time = 40, the CPU finishes task 1 and becomes idle.<br><br>Constraints:<br><br>   `tasks.length == n`<br>   `1 <= n <= 105`<br>   `1 <= enqueueTimei, processingTimei <= 109`"""<br><br>    language_users = {}<br>    unconnected_users = set()<br><br>    for u, v in friendships:<br>        can_communicate = any(lang in languages[v-1] for lang in languages[u-1])<br>        if not can_communicate:<br>            unconnected_users.add(u)<br>            unconnected_users.add(v)<br><br>    res = len(unconnected_users)<br>    for i in range(1, n+1):<br>        cnt = sum(i not in languages[user-1] for user in unconnected_users)<br>        res = min(res, cnt)<br><br>    return res

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_1882.txt
> import heapq<br>    """You are given two 0-indexed integer arrays `servers` and `tasks` of lengths `n`​​​​​​ and `m`​​​​​​ respectively. `servers[i]` is the weight of the `i​​​​​​th`​​​​ server, and `tasks[j]` is the time needed to process the `j​​​​​​th`​​​​ task in seconds.<br><br>Tasks are assigned to the servers using a task queue. Initially, all servers are free, and the queue is empty.<br><br>At second `j`, the `jth` task is inserted into the queue (starting with the `0th` task being inserted at second `0`). As long as there are free servers and the queue is not empty, the task in the front of the queue will be assigned to a free server with the smallest weight, and in case of a tie, it is assigned to a free server with the smallest index.<br><br>If there are no free servers and the queue is not empty, we wait until a server becomes free and immediately assign the next task. If multiple servers become free at the same time, then multiple tasks from the queue will be assigned in order of insertion following the weight and index priorities above.<br><br>A server that is assigned task `j` at second `t` will be free again at second `t + tasks[j]`.<br><br>Build an array `ans`​​​​ of length `m`, where `ans[j]` is the index of the server the `j​​​​​​th` task will be assigned to.<br><br>Return _the array_ `ans`​​​​.<br><br>Example 1:<br><br>Input: servers = \[3,3,2\], tasks = \[1,2,3,2,1,2\]<br>Output: \[2,2,0,2,1,2\]<br>Explanation: Events in chronological order go as follows:<br>- At second 0, task 0 is added and processed using server 2 until second 1.<br>- At second 1, server 2 becomes free. Task 1 is added and processed using server 2 until second 3.<br>- At second 2, task 2 is added and processed using server 0 until second 5.<br>- At second 3, server 2 becomes free. Task 3 is added and processed using server 2 until second 5.<br>- At second 4, task 4 is added and processed using server 1 until second 5.<br>- At second 5, all servers become free. Task 5 is added and processed using server 2 until second 7.<br><br>Example 2:<br><br>Input: servers = \[5,1,4,3,2\], tasks = \[2,1,2,4,5,2,1\]<br>Output: \[1,4,1,4,1,3,2\]<br>Explanation: Events in chronological order go as follows: <br>- At second 0, task 0 is added and processed using server 1 until second 2.<br>- At second 1, task 1 is added and processed using server 4 until second 2.<br>- At second 2, servers 1 and 4 become free. Task 2 is added and processed using server 1 until second 4. <br>- At second 3, task 3 is added and processed using server 4 until second 7.<br>- At second 4, server 1 becomes free. Task 4 is added and processed using server 1 until second 9. <br>- At second 5, task 5 is added and processed using server 3 until second 7.<br>- At second 6, task 6 is added and processed using server 2 until second 7.<br><br>Constraints:<br><br>   `servers.length == n`<br>   `tasks.length == m`<br>   `1 <= n, m <= 2  105`<br>   `1 <= servers[i], tasks[j] <= 2  105`"""<br><br>from typing import List<br><br>def assignTasks(servers: List[int], tasks: List[int]) - List[int]:<br>    free_servers = [(servers[i], i) for i in range(len(servers))]<br>    heapq.heapify(free_servers)<br>    busy_servers = []<br>    result = [0]  len(tasks)<br><br>    for time in range(len(tasks)):<br>        while busy_servers and busy_servers[0][0] <= time:<br>            _, server_elem = heapq.heappop(busy_servers)<br>            heapq.heappush(free_servers, server_elem)<br>        <br>        if free_servers:<br>            server_elem = heapq.heappop(free_servers)<br>            result[time] = server_elem[1]<br>            heapq.heappush(busy_servers, (time + tasks[time], server_elem))<br><br>    return result

### GROUND TRUTH 3, ranked 57, leetcode/leetcode_2127.txt
> def max_invited(favorite):<br>    """A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.<br><br>The employees are numbered from `0` to `n - 1`. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.<br><br>Given a 0-indexed integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the maximum number of employees that can be invited to the meeting_.<br><br>Example 1:<br><br>Input: favorite = \[2,2,1,2\]<br>Output: 3<br>Explanation:<br>The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.<br>All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.<br>Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.<br>The maximum number of employees that can be invited to the meeting is 3. <br><br>Example 2:<br><br>Input: favorite = \[1,2,0\]<br>Output: 3<br>Explanation: <br>Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.<br>The seating arrangement will be the same as that in the figure given in example 1:<br>- Employee 0 will sit between employees 2 and 1.<br>- Employee 1 will sit between employees 0 and 2.<br>- Employee 2 will sit between employees 1 and 0.<br>The maximum number of employees that can be invited to the meeting is 3.<br><br>Example 3:<br><br>Input: favorite = \[3,0,1,4,1\]<br>Output: 4<br>Explanation:<br>The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.<br>Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.<br>So the company leaves them out of the meeting.<br>The maximum number of employees that can be invited to the meeting is 4.<br><br>Constraints:<br><br>   `n == favorite.length`<br>   `2 <= n <= 105`<br>   `0 <= favorite[i] <= n - 1`<br>   `favorite[i] != i`"""<br><br>    in_degree = [0]  len(favorite)<br>    for fav in favorite:<br>        in_degree[fav] += 1<br>    result = 0<br>    for degree in in_degree:<br>        result += max(degree - 1, 0)<br>    return min(result + 2, len(favorite))
