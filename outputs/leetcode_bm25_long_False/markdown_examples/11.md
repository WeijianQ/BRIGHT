# Query `11`

## Original Question

*According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. "

The board is made up of an `m x n` grid of cells, where each cell has an initial state: live (represented by a `1`) or dead (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.
2.  Any live cell with two or three live neighbors lives on to the next generation.
3.  Any live cell with more than three live neighbors dies, as if by over-population.
4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.

Example 1:

Input: board = \[\[0,1,0\],\[0,0,1\],\[1,1,1\],\[0,0,0\]\]
Output: \[\[0,0,0\],\[1,0,1\],\[0,1,1\],\[0,1,0\]\]

Example 2:

Input: board = \[\[1,1\],\[1,0\]\]
Output: \[\[1,1\],\[1,1\]\]

Constraints:

   `m == board.length`
   `n == board[i].length`
   `1 <= m, n <= 25`
   `board[i][j]` is `0` or `1`.

Follow up:

   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.
   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?*


### Metrics

```
recip_rank: 0.2000
P_1: 0.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 1.0000
recall_10: 1.0000
recall_25: 1.0000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.3869
ndcg_cut_10: 0.3869
ndcg_cut_25: 0.3869
ndcg_cut_50: 0.3869
ndcg_cut_100: 0.3869
map_cut_1: 0.0000
map_cut_5: 0.2000
map_cut_10: 0.2000
map_cut_25: 0.2000
map_cut_50: 0.2000
map_cut_100: 0.2000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_239131.txt
> def binary_shrink_old(image, iterations=-1):<br>    """Shrink an image by repeatedly removing pixels which have partners<br>       above, to the left, to the right and below until the image doesn't change<br>       <br>       image - binary image to be manipulated<br>       iterations - # of times to shrink, -1 to shrink until idempotent<br>       <br>       There are horizontal/vertical thinners which detect a pixel on<br>       an edge with an interior pixel either horizontally or vertically<br>       attached like this:<br>       0  0  0<br>       X  1  X<br>       X  1  X<br>       and there are much more specific diagonal thinners which detect<br>       a pixel on the edge of a diagonal, like this:<br>       0  0  0<br>       0  1  0<br>       0  0  1<br>       Rotate each of these 4x to get the four directions for each<br>    """<br>    global binary_shrink_top_right, binary_shrink_bottom_left<br>    if binary_shrink_top_right is None:<br>        #<br>        # None of these patterns can remove both of two isolated<br>        # eight-connected pixels. Taken together, they can remove any<br>        # pixel touching a background pixel.<br>        #<br>        # The top right pixels:<br>        # <br>        # 0xx<br>        # ..0<br>        # ...<br>        #<br>        binary_shrink_top_right = make_table(False,<br>                                             np.array([[0,0,0],<br>                                                       [0,1,0],<br>                                                       [0,1,0]],bool),<br>                                             np.array([[1,1,1],<br>                                                       [0,1,0],<br>                                                       [0,1,0]],bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [0,1,0],<br>                                                        [1,0,0]], bool),<br>                                              np.array([[1,1,1],<br>                                                        [0,1,1],<br>                                                        [1,0,1]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [1,1,0],<br>                                                        [0,0,0]], bool),<br>                                              np.array([[0,0,1],<br>                                                        [1,1,1],<br>                                                        [0,0,1]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [1,1,0],<br>                                                        [0,1,1]], bool),<br>                                              np.array([[0,0,1],<br>                                                        [1,1,1],<br>                                                        [0,1,0]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [0,1,0],<br>                                                        [0,0,1]], bool),<br>                                              np.array([[1,1,1],<br>                                                        [1,1,0],<br>                                                        [1,0,1]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [0,1,0],<br>                                                        [1,1,1]], bool),<br>                                              np.array([[1,1,1],<br>                                                        [1,1,0],<br>                                                        [0,1,1]], bool))<br>        #<br>        # bottom left pixels<br>        #<br>        # ...<br>        # 0..<br>        # xx0<br>        binary_shrink_bottom_left = make_table(False,<br>                                               np.array([[0,1,0],<br>                                                         [0,1,0],<br>                                                         [0,0,0]],bool),<br>                                               np.array([[0,1,0],<br>                                                         [0,1,0],<br>                                                         [1,1,1]],bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[0,0,1],<br>                                                          [0,1,0],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,0,1],<br>                                                          [1,1,0],<br>                                                          [1,1,1]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[0,0,0],<br>                                                          [0,1,1],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,0,0],<br>                                                          [1,1,1],<br>                                                          [1,0,0]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[1,1,0],<br>                                                          [0,1,1],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[0,1,0],<br>                                                          [1,1,1],<br>                                                          [1,0,0]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[1,0,0],<br>                                                          [0,1,0],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,0,1],<br>                                                          [0,1,1],<br>                                                          [1,1,1]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[1,1,1],<br>                                                          [0,1,0],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,1,0],<br>                                                          [0,1,1],<br>                                                          [1,1,1]], bool))<br>    orig_image = image<br>    index_i, index_j, image = prepare_for_index_lookup(image, False)<br>    if iterations == -1:<br>        iterations = len(index_i)<br>    for i in range(iterations):<br>        pixel_count = len(index_i)<br>        for table in (binary_shrink_top_right, <br>                      binary_shrink_bottom_left):<br>            index_i, index_j = index_lookup(index_i, index_j, <br>                                            image, table, 1)<br>        if len(index_i) == pixel_count:<br>            break<br>    image = extract_from_image_lookup(orig_image, index_i, index_j)<br>    return image

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_17939.txt
> def play(self):<br>        """ Play Conway's Game of Life. """<br><br>        # Write the initial configuration to file.<br><br>        self.t = 1  # Current time level<br>        while self.t <= self.T:  # Evolve!<br>            # print( "At time level %d" % t)<br><br>            # Loop over each cell of the grid and apply Conway's rules.<br>            for i in range(self.N):<br>                for j in range(self.N):<br>                    live = self.live_neighbours(i, j)<br>                    if (self.old_grid[i][j] == 1 and live < 2):<br>                        self.new_grid[i][j] = 0  # Dead from starvation.<br>                    elif (self.old_grid[i][j] == 1 and (live == 2 or live == 3)):<br>                        self.new_grid[i][j] = 1  # Continue living.<br>                    elif (self.old_grid[i][j] == 1 and live  3):<br>                        self.new_grid[i][j] = 0  # Dead from overcrowding.<br>                    elif (self.old_grid[i][j] == 0 and live == 3):<br>                        self.new_grid[i][j] = 1  # Alive from reproduction.<br><br>            # Output the new configuration.<br><br>            # The new configuration becomes the old configuration for the next generation.<br>            self.old_grid = self.new_grid.copy()<br>            self.draw_board()<br>            # Move on to the next time level<br>            self.t += 1

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_239132.txt
> def binary_shrink(image, iterations=-1):<br>    """Shrink an image by repeatedly removing pixels which have partners<br>       above, to the left, to the right and below until the image doesn't change<br>       <br>       image - binary image to be manipulated<br>       iterations - # of times to shrink, -1 to shrink until idempotent<br>       <br>       There are horizontal/vertical thinners which detect a pixel on<br>       an edge with an interior pixel either horizontally or vertically<br>       attached like this:<br>       0  0  0<br>       X  1  X<br>       X  1  X<br>       and there are much more specific diagonal thinners which detect<br>       a pixel on the edge of a diagonal, like this:<br>       0  0  0<br>       0  1  0<br>       0  0  1<br>       Rotate each of these 4x to get the four directions for each<br>    """<br>    global erode_table, binary_shrink_ulr_table, binary_shrink_lrl_table<br>    global binary_shrink_urb_table, binary_shrink_llt_table<br>    if erode_table is None:<br>        #<br>        # The erode table hits all patterns that can be eroded without<br>        # changing the euler_number<br>        erode_table = np.array([pattern_of(index)[1,1] and<br>                                (scind.label(pattern_of(index-16))[1] != 1)<br>                                for index in range(512)])<br>        erode_table[index_of(np.ones((3,3), bool))] = True<br>        #<br>        # Each other table is more specific: a specific corner or a specific<br>        # edge must be on where the corner and edge are not adjacent<br>        #<br>        binary_shrink_ulr_table = (<br>            erode_table | <br>            (make_table(False, np.array([[0,0,0],<br>                                         [1,1,0],<br>                                         [0,0,0]], bool),<br>                        np.array([[0,0,0],<br>                                  [1,1,1],<br>                                  [0,0,0]],bool)) &<br>             make_table(False, np.array([[1,0,0],<br>                                         [0,1,0],<br>                                         [0,0,0]],bool),<br>                        np.array([[1,0,0],<br>                                  [0,1,1],<br>                                  [0,1,1]],bool))))<br>        binary_shrink_urb_table = (<br>            erode_table | <br>            (make_table(False, np.array([[0,1,0],<br>                                         [0,1,0],<br>                                         [0,0,0]], bool),<br>                       np.array([[0,1,0],<br>                                 [0,1,0],<br>                                 [0,1,0]],bool)) &<br>             make_table(False, np.array([[0,0,1],<br>                                         [0,1,0],<br>                                         [0,0,0]],bool),<br>                        np.array([[0,0,1],<br>                                  [1,1,0],<br>                                  [1,1,0]],bool))))<br>        binary_shrink_lrl_table = (<br>            erode_table |<br>            (make_table(False, np.array([[0,0,0],<br>                                         [0,1,1],<br>                                         [0,0,0]], bool),<br>                        np.array([[0,0,0],<br>                                  [1,1,1],<br>                                  [0,0,0]],bool)) &<br>             make_table(False, np.array([[0,0,0],<br>                                         [0,1,0],<br>                                         [0,0,1]], bool),<br>                        np.array([[1,1,0],<br>                                  [1,1,0],<br>                                  [0,0,1]], bool))))<br>        binary_shrink_llt_table = (<br>            erode_table | <br>            (make_table(False, np.array([[0,0,0],<br>                                         [0,1,0],<br>                                         [0,1,0]], bool),<br>                        np.array([[0,1,0],<br>                                  [0,1,0],<br>                                  [0,1,0]],bool)) &<br>             make_table(False, np.array([[0,0,0],<br>                                         [0,1,0],<br>                                         [1,0,0]], bool),<br>                        np.array([[0,1,1],<br>                                  [0,1,1],<br>                                  [1,0,0]], bool))))<br>    <br>    orig_image = image<br>    index_i, index_j, image = prepare_for_index_lookup(image, False)<br>    if iterations == -1:<br>        iterations = len(index_i)<br>    for i in range(iterations):<br>        pixel_count = len(index_i)<br>        for table in (binary_shrink_ulr_table, <br>                      binary_shrink_urb_table,<br>                      binary_shrink_lrl_table,<br>                      binary_shrink_llt_table):<br>            index_i, index_j = index_lookup(index_i, index_j, <br>                                            image, table, 1)<br>        if len(index_i) == pixel_count:<br>            break<br>    image = extract_from_image_lookup(orig_image, index_i, index_j)<br>    return image

### DOC[4] (IRRELEVANT) leetcode/leetcode_1659.txt
> def maxSum(nums1, nums2):<br>    """You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.<br><br>You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.<br><br>The happiness of each person is calculated as follows:<br><br>   Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).<br>   Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).<br><br>Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.<br><br>The grid happiness is the sum of each person's happiness. Return _the maximum possible grid happiness._<br><br>Example 1:<br><br>Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2<br>Output: 240<br>Explanation: Assume the grid is 1-indexed with coordinates (row, column).<br>We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).<br>- Introvert at (1,1) happiness: 120 (starting happiness) - (0 \ 30) (0 neighbors) = 120<br>- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 \ 20) (1 neighbor) = 60<br>- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 \ 20) (1 neighbor) = 60<br>The grid happiness is 120 + 60 + 60 = 240.<br>The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.<br><br>Example 2:<br><br>Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1<br>Output: 260<br>Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).<br>- Introvert at (1,1) happiness: 120 (starting happiness) - (1 \ 30) (1 neighbor) = 90<br>- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 \ 20) (2 neighbors) = 80<br>- Introvert at (3,1) happiness: 120 (starting happiness) - (1 \ 30) (1 neighbor) = 90<br>The grid happiness is 90 + 80 + 90 = 260.<br><br>Example 3:<br><br>Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0<br>Output: 240<br><br>Constraints:<br><br>   `1 <= m, n <= 5`<br>   `0 <= introvertsCount, extrovertsCount <= min(m  n, 6)`"""<br><br>    mod = 109 + 7<br>    m, n = len(nums1), len(nums2)<br>    dp1, dp2 = [0]  (m + 1), [0]  (n + 1)<br>    i, j = m - 1, n - 1<br>    while i = 0 or j = 0:<br>        a = dp1[i] + nums1[i] if i = 0 else float('-inf')<br>        b = dp2[j] + nums2[j] if j = 0 else float('-inf')<br>        seen = set()<br>        if a  b:<br>            dp1[i] = a % mod<br>            i -= 1<br>            seen.add(nums1[i + 1])<br>        else:<br>            dp2[j] = b % mod<br>            j -= 1<br>            seen.add(nums2[j + 1])<br>    return max(dp1[0], dp2[0]) % mod

### DOC[5] (GROUND TRUTH) leetcode/leetcode_73.txt
> def setZeroes(matrix):<br>    """Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.<br><br>You must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).<br><br>Example 1:<br><br>Input: matrix = \[\[1,1,1\],\[1,0,1\],\[1,1,1\]\]<br>Output: \[\[1,0,1\],\[0,0,0\],\[1,0,1\]\]<br><br>Example 2:<br><br>Input: matrix = \[\[0,1,2,0\],\[3,4,5,2\],\[1,3,1,5\]\]<br>Output: \[\[0,0,0,0\],\[0,4,5,0\],\[0,3,1,0\]\]<br><br>Constraints:<br><br>   `m == matrix.length`<br>   `n == matrix[0].length`<br>   `1 <= m, n <= 200`<br>   `-231 <= matrix[i][j] <= 231 - 1`<br><br>Follow up:<br><br>   A straightforward solution using `O(mn)` space is probably a bad idea.<br>   A simple improvement uses `O(m + n)` space, but still not the best solution.<br>   Could you devise a constant space solution?"""<br><br>    rows = len(matrix)<br>    cols = len(matrix[0])<br>    firstRow, firstCol = False, False<br><br>    for i in range(rows):<br>        for j in range(cols):<br>            if matrix[i][j] == 0:<br>                if i == 0: firstRow = True<br>                if j == 0: firstCol = True<br>                matrix[i][0] = 0<br>                matrix[0][j] = 0<br><br>    for i in range(1, rows):<br>        for j in range(1, cols):<br>            if matrix[i][0] == 0 or matrix[0][j] == 0:<br>                matrix[i][j] = 0<br><br>    if firstRow:<br>        for j in range(cols):<br>            matrix[0][j] = 0<br><br>    if firstCol:<br>        for i in range(rows):<br>            matrix[i][0] = 0


## Ground Truth

### GROUND TRUTH 0, ranked 4, leetcode/leetcode_73.txt
> def setZeroes(matrix):<br>    """Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.<br><br>You must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).<br><br>Example 1:<br><br>Input: matrix = \[\[1,1,1\],\[1,0,1\],\[1,1,1\]\]<br>Output: \[\[1,0,1\],\[0,0,0\],\[1,0,1\]\]<br><br>Example 2:<br><br>Input: matrix = \[\[0,1,2,0\],\[3,4,5,2\],\[1,3,1,5\]\]<br>Output: \[\[0,0,0,0\],\[0,4,5,0\],\[0,3,1,0\]\]<br><br>Constraints:<br><br>   `m == matrix.length`<br>   `n == matrix[0].length`<br>   `1 <= m, n <= 200`<br>   `-231 <= matrix[i][j] <= 231 - 1`<br><br>Follow up:<br><br>   A straightforward solution using `O(mn)` space is probably a bad idea.<br>   A simple improvement uses `O(m + n)` space, but still not the best solution.<br>   Could you devise a constant space solution?"""<br><br>    rows = len(matrix)<br>    cols = len(matrix[0])<br>    firstRow, firstCol = False, False<br><br>    for i in range(rows):<br>        for j in range(cols):<br>            if matrix[i][j] == 0:<br>                if i == 0: firstRow = True<br>                if j == 0: firstCol = True<br>                matrix[i][0] = 0<br>                matrix[0][j] = 0<br><br>    for i in range(1, rows):<br>        for j in range(1, cols):<br>            if matrix[i][0] == 0 or matrix[0][j] == 0:<br>                matrix[i][j] = 0<br><br>    if firstRow:<br>        for j in range(cols):<br>            matrix[0][j] = 0<br><br>    if firstCol:<br>        for i in range(rows):<br>            matrix[i][0] = 0
