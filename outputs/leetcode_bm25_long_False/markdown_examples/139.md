# Query `139`

## Original Question

*There are some prizes on the X-axis. You are given an integer array `prizePositions` that is sorted in non-decreasing order, where `prizePositions[i]` is the position of the `ith` prize. There could be different prizes at the same position on the line. You are also given an integer `k`.

You are allowed to select two segments with integer endpoints. The length of each segment must be `k`. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.

   For example if `k = 2`, you can choose segments `[1, 3]` and `[2, 4]`, and you will win any prize i that satisfies `1 <= prizePositions[i] <= 3` or `2 <= prizePositions[i] <= 4`.

Return _the maximum number of prizes you can win if you choose the two segments optimally_.

Example 1:

Input: prizePositions = \[1,1,2,2,3,3,5\], k = 2
Output: 7
Explanation: In this example, you can win all 7 prizes by selecting two segments \[1, 3\] and \[3, 5\].

Example 2:

Input: prizePositions = \[1,2,3,4\], k = 0
Output: 2
Explanation: For this example, one choice for the segments is `[3, 3]` and `[4, 4],` and you will be able to get `2` prizes. 

Constraints:

   `1 <= prizePositions.length <= 105`
   `1 <= prizePositions[i] <= 109`
   `0 <= k <= 109`
   `prizePositions` is sorted in non-decreasing order.

.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler > div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\[value="Show Message"\] + .spoiler > div {margin-top:-500%;} .spoilerbutton\[value="Hide Message"\] + .spoiler {padding:5px;}*


### Metrics

```
recip_rank: 0.0370
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.1275
ndcg_cut_100: 0.1275
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0185
map_cut_100: 0.0185
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2544.txt
> def sum_of_digits(n: int) - int:<br>    """You are given a positive integer `n`. Each digit of `n` has a sign according to the following rules:<br><br>   The most significant digit is assigned a positive sign.<br>   Each other digit has an opposite sign to its adjacent digits.<br><br>Return _the sum of all digits with their corresponding sign_.<br><br>Example 1:<br><br>Input: n = 521<br>Output: 4<br>Explanation: (+5) + (-2) + (+1) = 4.<br><br>Example 2:<br><br>Input: n = 111<br>Output: 1<br>Explanation: (+1) + (-1) + (+1) = 1.<br><br>Example 3:<br><br>Input: n = 886996<br>Output: 0<br>Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.<br><br>Constraints:<br><br>   `1 <= n <= 109`<br><br>.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler  div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\[value="Show Message"\] + .spoiler  div {margin-top:-500%;} .spoilerbutton\[value="Hide Message"\] + .spoiler {padding:5px;}"""<br><br>    total = 0<br>    positive = True<br><br>    while n  0:<br>        digit = n % 10<br>        n //= 10<br><br>        if positive:<br>            total += digit<br>        else:<br>            total -= digit<br><br>        positive = not positive<br><br>    return total

### DOC[2] (IRRELEVANT) leetcode/leetcode_2522.txt
> def min_partitions(s: str, k: int) - int:<br>    """You are given a string `s` consisting of digits from `1` to `9` and an integer `k`.<br><br>A partition of a string `s` is called good if:<br><br>   Each digit of `s` is part of exactly one substring.<br>   The value of each substring is less than or equal to `k`.<br><br>Return _the minimum number of substrings in a good partition of_ `s`. If no good partition of `s` exists, return `-1`.<br><br>Note that:<br><br>   The value of a string is its result when interpreted as an integer. For example, the value of `"123 "` is `123` and the value of `"1 "` is `1`.<br>   A substring is a contiguous sequence of characters within a string.<br><br>Example 1:<br><br>Input: s =  "165462 ", k = 60<br>Output: 4<br>Explanation: We can partition the string into substrings  "16 ",  "54 ",  "6 ", and  "2 ". Each substring has a value less than or equal to k = 60.<br>It can be shown that we cannot partition the string into less than 4 substrings.<br><br>Example 2:<br><br>Input: s =  "238182 ", k = 5<br>Output: -1<br>Explanation: There is no good partition for this string.<br><br>Constraints:<br><br>   `1 <= s.length <= 105`<br>   `s[i]` is a digit from `'1'` to `'9'`.<br>   `1 <= k <= 109`<br><br>.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler  div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\[value="Show Message"\] + .spoiler  div {margin-top:-500%;} .spoilerbutton\[value="Hide Message"\] + .spoiler {padding:5px;}"""<br><br>    n = len(s)<br>    count = 0<br>    idx = 0<br><br>    while idx < n:<br>        currentValue = 0<br>        while idx < n and currentValue  10 + int(s[idx]) <= k:<br>            currentValue = currentValue  10 + int(s[idx])<br>            idx += 1<br><br>        if currentValue == 0:<br>            return -1<br>        count += 1<br><br>    return count

### DOC[3] (IRRELEVANT) leetcode/leetcode_2523.txt
> def is_prime(n):<br>    """Given two positive integers `left` and `right`, find the two integers `num1` and `num2` such that:<br><br>   `left <= nums1 < nums2 <= right` .<br>   `nums1` and `nums2` are both prime numbers.<br>   `nums2 - nums1` is the minimum amongst all other pairs satisfying the above conditions.<br><br>Return _the positive integer array_ `ans = [nums1, nums2]`. _If there are multiple pairs satisfying these conditions, return the one with the minimum_ `nums1` _value or_ `[-1, -1]` _if such numbers do not exist._<br><br>A number greater than `1` is called prime if it is only divisible by `1` and itself.<br><br>Example 1:<br><br>Input: left = 10, right = 19<br>Output: \[11,13\]<br>Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.<br>The closest gap between any pair is 2, which can be achieved by \[11,13\] or \[17,19\].<br>Since 11 is smaller than 17, we return the first pair.<br><br>Example 2:<br><br>Input: left = 4, right = 6<br>Output: \[-1,-1\]<br>Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.<br><br>Constraints:<br><br>   `1 <= left <= right <= 106`<br><br>.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;  } .spoiler {overflow:hidden;} .spoiler  div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\[value="Show Message"\] + .spoiler  div {margin-top:-500%;} .spoilerbutton\[value="Hide Message"\] + .spoiler {padding:5px;}"""<br><br>    if n <= 1:<br>        return False<br>    i = 2<br>    while i  i <= n:<br>        if n % i == 0:<br>            return False<br>        i += 1<br>    return True<br><br>def closest_prime_pair(left, right):<br>    min_dist = right - left + 1<br>    ans = [-1, -1]<br>    for i in range(left, right + 1):<br>        if is_prime(i):<br>            for j in range(i + 1, right + 1):<br>                if is_prime(j) and j - i < min_dist:<br>                    min_dist = j - i<br>                    ans = [i, j]<br>    return ans

### DOC[4] (IRRELEVANT) leetcode/leetcode_2547.txt
> def minCost(nums: List[int], k: int) - int:<br>    """You are given an integer array `nums` and an integer `k`.<br><br>Split the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.<br><br>Let `trimmed(subarray)` be the version of the subarray where all numbers which appear only once are removed.<br><br>   For example, `trimmed([3,1,2,4,3,4]) = [3,4,3,4].`<br><br>The importance value of a subarray is `k + trimmed(subarray).length`.<br><br>   For example, if a subarray is `[1,2,3,3,3,4,4]`, then trimmed(`[1,2,3,3,3,4,4]) = [3,3,3,4,4].`The importance value of this subarray will be `k + 5`.<br><br>Return _the minimum possible cost of a split of_ `nums`.<br><br>A subarray is a contiguous non-empty sequence of elements within an array.<br><br>Example 1:<br><br>Input: nums = \[1,2,1,2,1,3,3\], k = 2<br>Output: 8<br>Explanation: We split nums to have two subarrays: \[1,2\], \[1,2,1,3,3\].<br>The importance value of \[1,2\] is 2 + (0) = 2.<br>The importance value of \[1,2,1,3,3\] is 2 + (2 + 2) = 6.<br>The cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.<br><br>Example 2:<br><br>Input: nums = \[1,2,1,2,1\], k = 2<br>Output: 6<br>Explanation: We split nums to have two subarrays: \[1,2\], \[1,2,1\].<br>The importance value of \[1,2\] is 2 + (0) = 2.<br>The importance value of \[1,2,1\] is 2 + (2) = 4.<br>The cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.<br><br>Example 3:<br><br>Input: nums = \[1,2,1,2,1\], k = 5<br>Output: 10<br>Explanation: We split nums to have one subarray: \[1,2,1,2,1\].<br>The importance value of \[1,2,1,2,1\] is 5 + (3 + 2) = 10.<br>The cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.<br><br>Constraints:<br><br>   `1 <= nums.length <= 1000`<br>   `0 <= nums[i] < nums.length`<br>   `1 <= k <= 109`<br><br>.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0;  } .spoiler {overflow:hidden;} .spoiler  div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\[value="Show Message"\] + .spoiler  div {margin-top:-500%;} .spoilerbutton\[value="Hide Message"\] + .spoiler {padding:5px;}"""<br><br>    n = len(nums)<br>    count = [0]  1001<br>    dp = [0]  (n + 1)<br><br>    i = 0<br>    for j in range(n):<br>        count[nums[j]] += 1<br>        <br>        if count[nums[j]] == 2:<br>            dp[j + 1] = dp[i] + k + (j - i + 1)<br>        elif count[nums[j]]  2:<br>            dp[j + 1] = min(dp[j], dp[j - 1] + 1)<br>        else:<br>            dp[j + 1] = dp[j] + 1<br><br>        while i <= j and count[nums[i]] = 2:<br>            count[nums[i]] -= 1<br>            i += 1<br><br>    return dp[n] + n  k

### DOC[5] (IRRELEVANT) leetcode/leetcode_2577.txt
> from collections import deque<br>    """You are given a `m x n` matrix `grid` consisting of non-negative integers where `grid[row][col]` represents the minimum time required to be able to visit the cell `(row, col)`, which means you can visit the cell `(row, col)` only when the time you visit it is greater than or equal to `grid[row][col]`.<br><br>You are standing in the top-left cell of the matrix in the `0th` second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.<br><br>Return _the minimum time required in which you can visit the bottom-right cell of the matrix_. If you cannot visit the bottom-right cell, then return `-1`.<br><br>Example 1:<br><br>Input: grid = \[\[0,1,3,2\],\[5,1,2,5\],\[4,3,8,6\]\]<br>Output: 7<br>Explanation: One of the paths that we can take is the following:<br>- at t = 0, we are on the cell (0,0).<br>- at t = 1, we move to the cell (0,1). It is possible because grid\[0\]\[1\] <= 1.<br>- at t = 2, we move to the cell (1,1). It is possible because grid\[1\]\[1\] <= 2.<br>- at t = 3, we move to the cell (1,2). It is possible because grid\[1\]\[2\] <= 3.<br>- at t = 4, we move to the cell (1,1). It is possible because grid\[1\]\[1\] <= 4.<br>- at t = 5, we move to the cell (1,2). It is possible because grid\[1\]\[2\] <= 5.<br>- at t = 6, we move to the cell (1,3). It is possible because grid\[1\]\[3\] <= 6.<br>- at t = 7, we move to the cell (2,3). It is possible because grid\[2\]\[3\] <= 7.<br>The final time is 7. It can be shown that it is the minimum time possible.<br><br>Example 2:<br><br>Input: grid = \[\[0,2,4\],\[3,2,1\],\[1,0,4\]\]<br>Output: -1<br>Explanation: There is no path from the top left to the bottom-right cell.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `2 <= m, n <= 1000`<br>   `4 <= m  n <= 105`<br>   `0 <= grid[i][j] <= 105`<br>   `grid[0][0] == 0`<br><br>.spoilerbutton {display:block; border:dashed; padding: 0px 0px; margin:10px 0px; font-size:150%; font-weight: bold; color:#000000; background-color:cyan; outline:0; } .spoiler {overflow:hidden;} .spoiler  div {-webkit-transition: all 0s ease;-moz-transition: margin 0s ease;-o-transition: all 0s ease;transition: margin 0s ease;} .spoilerbutton\[value="Show Message"\] + .spoiler  div {margin-top:-500%;} .spoilerbutton\[value="Hide Message"\] + .spoiler {padding:5px;}"""<br><br><br>def minTime(grid: list[list[int]]) - int:<br>    m, n = len(grid), len(grid[0])<br>    visited = [[1000000]  n for _ in range(m)]<br><br>    dx = [-1, 0, 1, 0]<br>    dy = [0, 1, 0, -1]<br><br>    visited[0][0] = 0<br><br>    q = deque([(0, 0)])<br><br>    while q:<br>        x, y = q.popleft()<br><br>        for i in range(4):<br>            nx, ny = x + dx[i], y + dy[i]<br><br>            if 0 <= nx < m and 0 <= ny < n:<br>                t = max(grid[nx][ny], visited[x][y] + 1)<br>                if visited[nx][ny]  t:<br>                    visited[nx][ny] = t<br>                    q.append((nx, ny))<br><br>    return visited[m - 1][n - 1] if visited[m - 1][n - 1] != 1000000 else -1


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_123.txt
> def maxProfit(prices):<br>    """You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.<br><br>Find the maximum profit you can achieve. You may complete at most two transactions.<br><br>Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).<br><br>Example 1:<br><br>Input: prices = \[3,3,5,0,0,3,1,4\]<br>Output: 6<br>Explanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.<br>Then buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.<br><br>Example 2:<br><br>Input: prices = \[1,2,3,4,5\]<br>Output: 4<br>Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.<br>Note that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.<br><br>Example 3:<br><br>Input: prices = \[7,6,4,3,1\]<br>Output: 0<br>Explanation: In this case, no transaction is done, i.e. max profit = 0.<br><br>Constraints:<br><br>   `1 <= prices.length <= 105`<br>   `0 <= prices[i] <= 105`"""<br><br>    buy1, buy2 = float("inf"), float("inf")<br>    profit1, profit2 = 0, 0<br><br>    for price in prices:<br>        buy1 = min(buy1, price)<br>        profit1 = max(profit1, price - buy1)<br>        buy2 = min(buy2, price - profit1)<br>        profit2 = max(profit2, price - buy2)<br><br>    return profit2

### GROUND TRUTH 1, ranked 26, leetcode/leetcode_2054.txt
> def find_chair(times, target_friend):<br>    """You are given a 0-indexed 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.<br><br>Return _this maximum sum._<br><br>Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.<br><br>Example 1:<br><br>Input: events = \[\[1,3,2\],\[4,5,2\],\[2,4,3\]\]<br>Output: 4<br>Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.<br><br>Example 2:<br><br>Input: events = \[\[1,3,2\],\[4,5,2\],\[1,5,5\]\]<br>Output: 5<br>Explanation: Choose event 2 for a sum of 5.<br><br>Example 3:<br><br>Input: events = \[\[1,5,3\],\[1,5,1\],\[6,6,5\]\]<br>Output: 8<br>Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.<br><br>Constraints:<br><br>   `2 <= events.length <= 105`<br>   `events[i].length == 3`<br>   `1 <= startTimei <= endTimei <= 109`<br>   `1 <= valuei <= 106`"""<br><br>    n = len(times)<br>    events = []<br>    for i, (arrival, leaving) in enumerate(times):<br>        events.append((arrival, i))<br>        events.append((leaving, ~i))<br>    events.sort()<br>    chairs = [-1]  n<br>    available_chairs = sorted(range(n))<br>    for time, friend_id in events:<br>        if friend_id = 0:<br>            chairs[friend_id] = available_chairs.pop(0)<br>            if friend_id == target_friend:<br>                return chairs[friend_id]<br>        else:<br>            available_chairs.append(chairs[~friend_id])<br>            available_chairs.sort()<br>    return -1
