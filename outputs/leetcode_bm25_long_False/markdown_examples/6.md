# Query `6`

## Original Question

*There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.

   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return _the ordering of courses you should take to finish all courses_. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

Example 1:

Input: numCourses = 2, prerequisites = \[\[1,0\]\]
Output: \[0,1\]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \[0,1\].

Example 2:

Input: numCourses = 4, prerequisites = \[\[1,0\],\[2,0\],\[3,1\],\[3,2\]\]
Output: \[0,2,1,3\]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is \[0,1,2,3\]. Another correct ordering is \[0,2,1,3\].

Example 3:

Input: numCourses = 1, prerequisites = \[\]
Output: \[0\]

Constraints:

   `1 <= numCourses <= 2000`
   `0 <= prerequisites.length <= numCourses  (numCourses - 1)`
   `prerequisites[i].length == 2`
   `0 <= ai, bi < numCourses`
   `ai != bi`
   All the pairs `[ai, bi]` are distinct.*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.4000
P_10: 0.2000
P_25: 0.1200
P_50: 0.0800
P_100: 0.0400
recall_1: 0.2000
recall_5: 0.4000
recall_10: 0.4000
recall_25: 0.6000
recall_50: 0.8000
recall_100: 0.8000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.4704
ndcg_cut_10: 0.4704
ndcg_cut_25: 0.5620
ndcg_cut_50: 0.6218
ndcg_cut_100: 0.6218
map_cut_1: 0.2000
map_cut_5: 0.2800
map_cut_10: 0.2800
map_cut_25: 0.3300
map_cut_50: 0.3460
map_cut_100: 0.3460
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_207.txt
> from collections import defaultdict, deque<br>    """There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.<br><br>   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.<br><br>Return `true` if you can finish all courses. Otherwise, return `false`.<br><br>Example 1:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\]\]<br>Output: true<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0. So it is possible.<br><br>Example 2:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\],\[0,1\]\]<br>Output: false<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br><br>Constraints:<br><br>   `1 <= numCourses <= 2000`<br>   `0 <= prerequisites.length <= 5000`<br>   `prerequisites[i].length == 2`<br>   `0 <= ai, bi < numCourses`<br>   All the pairs prerequisites\[i\] are unique."""<br><br><br>def canFinish(numCourses, prerequisites):<br>    adj = defaultdict(list)<br>    inDegree = [0]  numCourses<br>    <br>    for a, b in prerequisites:<br>        adj[b].append(a)<br>        inDegree[a] += 1<br>    <br>    q = deque([i for i in range(numCourses) if inDegree[i]==0])<br>    <br>    while q:<br>        currCourse = q.popleft()<br>        numCourses -= 1<br>        <br>        for nextCourse in adj[currCourse]:<br>            inDegree[nextCourse] -= 1<br>            if inDegree[nextCourse] == 0:<br>                q.append(nextCourse)<br>    <br>    return numCourses == 0

### DOC[2] (IRRELEVANT) leetcode/leetcode_2581.txt
> def possibleRoots(edges, guesses, k):<br>    """Alice has an undirected tree with `n` nodes labeled from `0` to `n - 1`. The tree is represented as a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>Alice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:<br><br>   Chooses two distinct integers `u` and `v` such that there exists an edge `[u, v]` in the tree.<br>   He tells Alice that `u` is the parent of `v` in the tree.<br><br>Bob's guesses are represented by a 2D integer array `guesses` where `guesses[j] = [uj, vj]` indicates Bob guessed `uj` to be the parent of `vj`.<br><br>Alice being lazy, does not reply to each of Bob's guesses, but just says that at least `k` of his guesses are `true`.<br><br>Given the 2D integer arrays `edges`, `guesses` and the integer `k`, return _the number of possible nodes that can be the root of Alice's tree_. If there is no such tree, return `0`.<br><br>Example 1:<br><br>Input: edges = \[\[0,1\],\[1,2\],\[1,3\],\[4,2\]\], guesses = \[\[1,3\],\[0,1\],\[1,0\],\[2,4\]\], k = 3<br>Output: 3<br>Explanation: <br>Root = 0, correct guesses = \[1,3\], \[0,1\], \[2,4\]<br>Root = 1, correct guesses = \[1,3\], \[1,0\], \[2,4\]<br>Root = 2, correct guesses = \[1,3\], \[1,0\], \[2,4\]<br>Root = 3, correct guesses = \[1,0\], \[2,4\]<br>Root = 4, correct guesses = \[1,3\], \[1,0\]<br>Considering 0, 1, or 2 as root node leads to 3 correct guesses.<br><br>Example 2:<br><br>Input: edges = \[\[0,1\],\[1,2\],\[2,3\],\[3,4\]\], guesses = \[\[1,0\],\[3,4\],\[2,1\],\[3,2\]\], k = 1<br>Output: 5<br>Explanation: <br>Root = 0, correct guesses = \[3,4\]<br>Root = 1, correct guesses = \[1,0\], \[3,4\]<br>Root = 2, correct guesses = \[1,0\], \[2,1\], \[3,4\]<br>Root = 3, correct guesses = \[1,0\], \[2,1\], \[3,2\], \[3,4\]<br>Root = 4, correct guesses = \[1,0\], \[2,1\], \[3,2\]<br>Considering any node as root will give at least 1 correct guess. <br><br>Constraints:<br><br>   `edges.length == n - 1`<br>   `2 <= n <= 105`<br>   `1 <= guesses.length <= 105`<br>   `0 <= ai, bi, uj, vj <= n - 1`<br>   `ai != bi`<br>   `uj != vj`<br>   `edges` represents a valid tree.<br>   `guesses[j]` is an edge of the tree.<br>   `guesses` is unique.<br>   `0 <= k <= guesses.length`"""<br><br>    n = len(edges) + 1<br>    in_degree = [0]  n<br>    guess_parents = set()<br>    <br>    for guess in guesses:<br>        guess_parents.add(guess[0])<br>    <br>    for edge in edges:<br>        in_degree[edge[1]] += 1<br>    <br>    possible_roots = 0<br>    for i in range(n):<br>        if in_degree[i] == 0:<br>            if k == 0 or i in guess_parents:<br>                possible_roots += 1<br>        elif in_degree[i] == 1 and len(guesses) - k < in_degree[i]:<br>            possible_roots += 1<br>    <br>    return possible_roots

### DOC[3] (IRRELEVANT) leetcode/leetcode_1558.txt
> from collections import defaultdict<br>    """You are given an integer array `nums`. You have an integer array `arr` of the same length with all values set to `0` initially. You also have the following `modify` function:<br><br>You want to use the modify function to covert `arr` to `nums` using the minimum number of calls.<br><br>Return _the minimum number of function calls to make_ `nums` _from_ `arr`.<br><br>The test cases are generated so that the answer fits in a 32-bit signed integer.<br><br>Example 1:<br><br>Input: nums = \[1,5\]<br>Output: 5<br>Explanation: Increment by 1 (second element): \[0, 0\] to get \[0, 1\] (1 operation).<br>Double all the elements: \[0, 1\] - \[0, 2\] - \[0, 4\] (2 operations).<br>Increment by 1 (both elements)  \[0, 4\] - \[1, 4\] - \[1, 5\] (2 operations).<br>Total of operations: 1 + 2 + 2 = 5.<br><br>Example 2:<br><br>Input: nums = \[2,2\]<br>Output: 3<br>Explanation: Increment by 1 (both elements) \[0, 0\] - \[0, 1\] - \[1, 1\] (2 operations).<br>Double all the elements: \[1, 1\] - \[2, 2\] (1 operation).<br>Total of operations: 2 + 1 = 3.<br><br>Example 3:<br><br>Input: nums = \[4,2,5\]<br>Output: 6<br>Explanation: (initial)\[0,0,0\] - \[1,0,0\] - \[1,0,1\] - \[2,0,2\] - \[2,1,2\] - \[4,2,4\] - \[4,2,5\](nums).<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `0 <= nums[i] <= 109`"""<br><br><br>def DFS(src, graph, visited, transitive_closure, dest):<br>    if src == dest:<br>        transitive_closure[dest] = True<br>        return<br>    if visited[src]:<br>        return<br>    visited[src] = True<br>    for neighbor in graph[src]:<br>        DFS(neighbor, graph, visited, transitive_closure, dest)<br>        if transitive_closure[dest]:<br>            return<br><br>def checkIfPrerequisite(numCourses, prerequisites, queries):<br>    graph = defaultdict(list)<br><br>    for pre in prerequisites:<br>        graph[pre[0]].append(pre[1])<br><br>    result = []<br><br>    for i in range(len(queries)):<br>        visited = [False]  numCourses<br>        transitive_closure = [False]  numCourses<br>        DFS(queries[i][0], graph, visited, transitive_closure, queries[i][1])<br>        result.append(transitive_closure[queries[i][1]])<br><br>    return result

### DOC[4] (IRRELEVANT) leetcode/leetcode_1494.txt
> from collections import deque<br>    """You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.<br><br>In one semester, you can take at most `k` courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.<br><br>Return _the minimum number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.<br><br>Example 1:<br><br>Input: n = 4, relations = \[\[2,1\],\[3,1\],\[1,4\]\], k = 2<br>Output: 3<br>Explanation: The figure above represents the given graph.<br>In the first semester, you can take courses 2 and 3.<br>In the second semester, you can take course 1.<br>In the third semester, you can take course 4.<br><br>Example 2:<br><br>Input: n = 5, relations = \[\[2,1\],\[3,1\],\[4,1\],\[1,5\]\], k = 2<br>Output: 4<br>Explanation: The figure above represents the given graph.<br>In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.<br>In the second semester, you can take course 4.<br>In the third semester, you can take course 1.<br>In the fourth semester, you can take course 5.<br><br>Constraints:<br><br>   `1 <= n <= 15`<br>   `1 <= k <= n`<br>   `0 <= relations.length <= n  (n-1) / 2`<br>   `relations[i].length == 2`<br>   `1 <= prevCoursei, nextCoursei <= n`<br>   `prevCoursei != nextCoursei`<br>   All the pairs `[prevCoursei, nextCoursei]` are unique.<br>   The given graph is a directed acyclic graph."""<br><br><br>def minNumberOfSemesters(n, relations, k):<br>    indegree = [0]  (n + 1)<br>    graph = [[] for _ in range(n + 1)]<br><br>    for prev_course, next_course in relations:<br>        graph[prev_course].append(next_course)<br>        indegree[next_course] += 1<br><br>    semesters = 0<br>    while n  0:<br>        zero_indegree = deque()<br>        for i in range(1, len(indegree)):<br>            if indegree[i] == 0:<br>                zero_indegree.append(i)<br>                indegree[i] = -1<br><br>        courses = 0<br>        while zero_indegree and courses < k:<br>            curr_course = zero_indegree.popleft()<br>            n -= 1<br><br>            for next_course in graph[curr_course]:<br>                indegree[next_course] -= 1<br>            courses += 1<br>        semesters += 1<br>    return semesters

### DOC[5] (GROUND TRUTH) leetcode/leetcode_310.txt
> from collections import deque<br>    """A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.<br><br>Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called minimum height trees (MHTs).<br><br>Return _a list of all MHTs' root labels_. You can return the answer in any order.<br><br>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.<br><br>Example 1:<br><br>Input: n = 4, edges = \[\[1,0\],\[1,2\],\[1,3\]\]<br>Output: \[1\]<br>Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.<br><br>Example 2:<br><br>Input: n = 6, edges = \[\[3,0\],\[3,1\],\[3,2\],\[3,4\],\[5,4\]\]<br>Output: \[3,4\]<br><br>Constraints:<br><br>   `1 <= n <= 2  104`<br>   `edges.length == n - 1`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   All the pairs `(ai, bi)` are distinct.<br>   The given input is guaranteed to be a tree and there will be no repeated edges."""<br><br>from typing import List<br><br>def find_min_height_trees(n: int, edges: List[List[int]]) - List[int]:<br>    if n == 1:<br>        return [0]<br><br>    adj_list = [set() for _ in range(n)]<br>    for a, b in edges:<br>        adj_list[a].add(b)<br>        adj_list[b].add(a)<br><br>    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)<br><br>    while n  2:<br>        leaves_size = len(leaves)<br>        n -= leaves_size<br>        for _ in range(leaves_size):<br>            leaf = leaves.popleft()<br>            for neighbor in adj_list[leaf]:<br>                adj_list[neighbor].remove(leaf)<br>                if len(adj_list[neighbor]) == 1:<br>                    leaves.append(neighbor)<br><br>    return list(leaves)


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_207.txt
> from collections import defaultdict, deque<br>    """There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.<br><br>   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.<br><br>Return `true` if you can finish all courses. Otherwise, return `false`.<br><br>Example 1:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\]\]<br>Output: true<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0. So it is possible.<br><br>Example 2:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\],\[0,1\]\]<br>Output: false<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br><br>Constraints:<br><br>   `1 <= numCourses <= 2000`<br>   `0 <= prerequisites.length <= 5000`<br>   `prerequisites[i].length == 2`<br>   `0 <= ai, bi < numCourses`<br>   All the pairs prerequisites\[i\] are unique."""<br><br><br>def canFinish(numCourses, prerequisites):<br>    adj = defaultdict(list)<br>    inDegree = [0]  numCourses<br>    <br>    for a, b in prerequisites:<br>        adj[b].append(a)<br>        inDegree[a] += 1<br>    <br>    q = deque([i for i in range(numCourses) if inDegree[i]==0])<br>    <br>    while q:<br>        currCourse = q.popleft()<br>        numCourses -= 1<br>        <br>        for nextCourse in adj[currCourse]:<br>            inDegree[nextCourse] -= 1<br>            if inDegree[nextCourse] == 0:<br>                q.append(nextCourse)<br>    <br>    return numCourses == 0

### GROUND TRUTH 1, ranked 4, leetcode/leetcode_310.txt
> from collections import deque<br>    """A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.<br><br>Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called minimum height trees (MHTs).<br><br>Return _a list of all MHTs' root labels_. You can return the answer in any order.<br><br>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.<br><br>Example 1:<br><br>Input: n = 4, edges = \[\[1,0\],\[1,2\],\[1,3\]\]<br>Output: \[1\]<br>Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.<br><br>Example 2:<br><br>Input: n = 6, edges = \[\[3,0\],\[3,1\],\[3,2\],\[3,4\],\[5,4\]\]<br>Output: \[3,4\]<br><br>Constraints:<br><br>   `1 <= n <= 2  104`<br>   `edges.length == n - 1`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   All the pairs `(ai, bi)` are distinct.<br>   The given input is guaranteed to be a tree and there will be no repeated edges."""<br><br>from typing import List<br><br>def find_min_height_trees(n: int, edges: List[List[int]]) - List[int]:<br>    if n == 1:<br>        return [0]<br><br>    adj_list = [set() for _ in range(n)]<br>    for a, b in edges:<br>        adj_list[a].add(b)<br>        adj_list[b].add(a)<br><br>    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)<br><br>    while n  2:<br>        leaves_size = len(leaves)<br>        n -= leaves_size<br>        for _ in range(leaves_size):<br>            leaf = leaves.popleft()<br>            for neighbor in adj_list[leaf]:<br>                adj_list[neighbor].remove(leaf)<br>                if len(adj_list[neighbor]) == 1:<br>                    leaves.append(neighbor)<br><br>    return list(leaves)

### GROUND TRUTH 2, ranked 11, leetcode/leetcode_630.txt
> import heapq<br>    """There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken continuously for `durationi` days and must be finished before or on `lastDayi`.<br><br>You will start on the `1st` day and you cannot take two or more courses simultaneously.<br><br>Return _the maximum number of courses that you can take_.<br><br>Example 1:<br><br>Input: courses = \[\[100,200\],\[200,1300\],\[1000,1250\],\[2000,3200\]\]<br>Output: 3<br>Explanation: <br>There are totally 4 courses, but you can take 3 courses at most:<br>First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.<br>Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. <br>Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. <br>The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.<br><br>Example 2:<br><br>Input: courses = \[\[1,2\]\]<br>Output: 1<br><br>Example 3:<br><br>Input: courses = \[\[3,2\],\[4,3\]\]<br>Output: 0<br><br>Constraints:<br><br>   `1 <= courses.length <= 104`<br>   `1 <= durationi, lastDayi <= 104`"""<br><br><br>def scheduleCourse(courses):<br>    courses.sort(key=lambda x: x[1])<br>    curr_time, duration_sum = 0, []<br><br>    for duration, deadline in courses:<br>        curr_time += duration<br>        heapq.heappush(duration_sum, -duration)<br><br>        if curr_time  deadline:<br>            curr_time += heapq.heappop(duration_sum)<br><br>    return len(duration_sum)

### GROUND TRUTH 3, ranked not in top 100, leetcode/leetcode_2115.txt
> def numDistinct(binary):<br>    """You have information about `n` different recipes. You are given a string array `recipes` and a 2D string array `ingredients`. The `ith` recipe has the name `recipes[i]`, and you can create it if you have all the needed ingredients from `ingredients[i]`. Ingredients to a recipe may need to be created from other recipes, i.e., `ingredients[i]` may contain a string that is in `recipes`.<br><br>You are also given a string array `supplies` containing all the ingredients that you initially have, and you have an infinite supply of all of them.<br><br>Return _a list of all the recipes that you can create._ You may return the answer in any order.<br><br>Note that two recipes may contain each other in their ingredients.<br><br>Example 1:<br><br>Input: recipes = \[ "bread "\], ingredients = \[\[ "yeast ", "flour "\]\], supplies = \[ "yeast ", "flour ", "corn "\]<br>Output: \[ "bread "\]<br>Explanation:<br>We can create  "bread " since we have the ingredients  "yeast " and  "flour ".<br><br>Example 2:<br><br>Input: recipes = \[ "bread ", "sandwich "\], ingredients = \[\[ "yeast ", "flour "\],\[ "bread ", "meat "\]\], supplies = \[ "yeast ", "flour ", "meat "\]<br>Output: \[ "bread ", "sandwich "\]<br>Explanation:<br>We can create  "bread " since we have the ingredients  "yeast " and  "flour ".<br>We can create  "sandwich " since we have the ingredient  "meat " and can create the ingredient  "bread ".<br><br>Example 3:<br><br>Input: recipes = \[ "bread ", "sandwich ", "burger "\], ingredients = \[\[ "yeast ", "flour "\],\[ "bread ", "meat "\],\[ "sandwich ", "meat ", "bread "\]\], supplies = \[ "yeast ", "flour ", "meat "\]<br>Output: \[ "bread ", "sandwich ", "burger "\]<br>Explanation:<br>We can create  "bread " since we have the ingredients  "yeast " and  "flour ".<br>We can create  "sandwich " since we have the ingredient  "meat " and can create the ingredient  "bread ".<br>We can create  "burger " since we have the ingredient  "meat " and can create the ingredients  "bread " and  "sandwich ".<br><br>Constraints:<br><br>   `n == recipes.length == ingredients.length`<br>   `1 <= n <= 100`<br>   `1 <= ingredients[i].length, supplies.length <= 100`<br>   `1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10`<br>   `recipes[i], ingredients[i][j]`, and `supplies[k]` consist only of lowercase English letters.<br>   All the values of `recipes` and `supplies` combined are unique.<br>   Each `ingredients[i]` does not contain any duplicate values."""<br><br>    mod = 109 + 7<br>    zero_count, ones_count = 0, 0<br><br>    for c in binary:<br>        if c == '0':<br>            zero_count = (zero_count + ones_count) % mod<br>        else:<br>            ones_count = (ones_count  2 + 1) % mod<br>    <br>    return zero_count

### GROUND TRUTH 4, ranked 49, leetcode/leetcode_2392.txt
> def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) - List[List[int]]:<br>    """You are given a positive integer `k`. You are also given:<br><br>   a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and<br>   a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.<br><br>The two arrays contain integers from `1` to `k`.<br><br>You have to build a `k x k` matrix that contains each of the numbers from `1` to `k` exactly once. The remaining cells should have the value `0`.<br><br>The matrix should also satisfy the following conditions:<br><br>   The number `abovei` should appear in a row that is strictly above the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.<br>   The number `lefti` should appear in a column that is strictly left of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.<br><br>Return _any matrix that satisfies the conditions_. If no answer exists, return an empty matrix.<br><br>Example 1:<br><br>Input: k = 3, rowConditions = \[\[1,2\],\[3,2\]\], colConditions = \[\[2,1\],\[3,2\]\]<br>Output: \[\[3,0,0\],\[0,0,1\],\[0,2,0\]\]<br>Explanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.<br>The row conditions are the following:<br>- Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.<br>- Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.<br>The column conditions are the following:<br>- Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.<br>- Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.<br>Note that there may be multiple correct answers.<br><br>Example 2:<br><br>Input: k = 3, rowConditions = \[\[1,2\],\[2,3\],\[3,1\],\[2,3\]\], colConditions = \[\[2,1\]\]<br>Output: \[\]<br>Explanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.<br>No matrix can satisfy all the conditions, so we return the empty matrix.<br><br>Constraints:<br><br>   `2 <= k <= 400`<br>   `1 <= rowConditions.length, colConditions.length <= 104`<br>   `rowConditions[i].length == colConditions[i].length == 2`<br>   `1 <= abovei, belowi, lefti, righti <= k`<br>   `abovei != belowi`<br>   `lefti != righti`"""<br><br>    row, col = [0]  (k + 1), [0]  (k + 1)<br>    for condition in row_conditions:<br>        if row[condition[0]] = row[condition[1]]:<br>            return []<br>        row[condition[1]] = row[condition[0]] + 1<br>    for condition in col_conditions:<br>        if col[condition[0]] = col[condition[1]]:<br>            return []<br>        col[condition[1]] = col[condition[0]] + 1<br>    matrix = [[0]  k for _ in range(k)]<br>    for i in range(1, k + 1):<br>        matrix[row[i]][col[i]] = i<br>    return matrix
