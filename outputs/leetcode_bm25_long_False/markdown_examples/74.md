# Query `74`

## Original Question

*You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of any color.

The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).

You are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls in any order.

Return _the maximum total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it modulo `109 + 7`.

Example 1:

Input: inventory = \[2,5\], orders = 4
Output: 14
Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).
The maximum total value is 2 + 5 + 4 + 3 = 14.

Example 2:

Input: inventory = \[3,5\], orders = 6
Output: 19
Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).
The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.

Constraints:

   `1 <= inventory.length <= 105`
   `1 <= inventory[i] <= 109`
   `1 <= orders <= min(sum(inventory[i]), 109)`*


### Metrics

```
recip_rank: 0.0145
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 1.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.1632
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0145
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2438.txt
> def getPowers(n):<br>    """Given a positive integer `n`, there exists a 0-indexed array called `powers`, composed of the minimum number of powers of `2` that sum to `n`. The array is sorted in non-decreasing order, and there is only one way to form the array.<br><br>You are also given a 0-indexed 2D integer array `queries`, where `queries[i] = [lefti, righti]`. Each `queries[i]` represents a query where you have to find the product of all `powers[j]` with `lefti <= j <= righti`.<br><br>Return _an array_ `answers`_, equal in length to_ `queries`_, where_ `answers[i]` _is the answer to the_ `ith` _query_. Since the answer to the `ith` query may be too large, each `answers[i]` should be returned modulo `109 + 7`.<br><br>Example 1:<br><br>Input: n = 15, queries = \[\[0,1\],\[2,2\],\[0,3\]\]<br>Output: \[2,4,64\]<br>Explanation:<br>For n = 15, powers = \[1,2,4,8\]. It can be shown that powers cannot be a smaller size.<br>Answer to 1st query: powers\[0\] \ powers\[1\] = 1 \ 2 = 2.<br>Answer to 2nd query: powers\[2\] = 4.<br>Answer to 3rd query: powers\[0\] \ powers\[1\] \ powers\[2\] \ powers\[3\] = 1 \ 2 \ 4 \ 8 = 64.<br>Each answer modulo 109 + 7 yields the same answer, so \[2,4,64\] is returned.<br><br>Example 2:<br><br>Input: n = 2, queries = \[\[0,0\]\]<br>Output: \[2\]<br>Explanation:<br>For n = 2, powers = \[2\].<br>The answer to the only query is powers\[0\] = 2. The answer modulo 109 + 7 is the same, so \[2\] is returned.<br><br>Constraints:<br><br>   `1 <= n <= 109`<br>   `1 <= queries.length <= 105`<br>   `0 <= starti <= endi < powers.length`"""<br><br>    powers = []<br>    while n  0:<br>        powers.append(n & (-n))<br>        n -= n & (-n)<br>    return powers<br><br>def productOfPowers(n, queries):<br>    powers = getPowers(n)<br>    answers = []<br><br>    mod = 109 + 7<br><br>    for query in queries:<br>        product = 1<br>        for i in range(query[0], query[1] + 1):<br>            product = (product  powers[i]) % mod<br>        answers.append(product)<br><br>    return answers

### DOC[2] (IRRELEVANT) leetcode/leetcode_1760.txt
> def can_form_array(arr, pieces):<br>    """You are given an integer array `nums` where the `ith` bag contains `nums[i]` balls. You are also given an integer `maxOperations`.<br><br>You can perform the following operation at most `maxOperations` times:<br><br>   Take any bag of balls and divide it into two new bags with a positive number of balls.<br>       For example, a bag of `5` balls can become two new bags of `1` and `4` balls, or two new bags of `2` and `3` balls.<br><br>Your penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.<br><br>Return _the minimum possible penalty after performing the operations_.<br><br>Example 1:<br><br>Input: nums = \[9\], maxOperations = 2<br>Output: 3<br>Explanation: <br>- Divide the bag with 9 balls into two bags of sizes 6 and 3. \[9\] - \[6,3\].<br>- Divide the bag with 6 balls into two bags of sizes 3 and 3. \[6,3\] - \[3,3,3\].<br>The bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.<br><br>Example 2:<br><br>Input: nums = \[2,4,8,2\], maxOperations = 4<br>Output: 2<br>Explanation:<br>- Divide the bag with 8 balls into two bags of sizes 4 and 4. \[2,4,8,2\] - \[2,4,4,4,2\].<br>- Divide the bag with 4 balls into two bags of sizes 2 and 2. \[2,4,4,4,2\] - \[2,2,2,4,4,2\].<br>- Divide the bag with 4 balls into two bags of sizes 2 and 2. \[2,2,2,4,4,2\] - \[2,2,2,2,2,4,2\].<br>- Divide the bag with 4 balls into two bags of sizes 2 and 2. \[2,2,2,2,2,4,2\] - \[2,2,2,2,2,2,2,2\].<br>The bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `1 <= maxOperations, nums[i] <= 109`"""<br><br>    piece_map = {piece[0]: piece for piece in pieces}<br>    <br>    i = 0<br>    while i < len(arr):<br>        if arr[i] not in piece_map:<br>            return False<br>        <br>        for num in piece_map[arr[i]]:<br>            if arr[i] != num:<br>                return False<br>            i += 1<br>            <br>    return True

### DOC[3] (IRRELEVANT) leetcode/leetcode_1801.txt
> from heapq import <br>    """You are given a 2D integer array `orders`, where each `orders[i] = [pricei, amounti, orderTypei]` denotes that `amounti` orders have been placed of type `orderTypei` at the price `pricei`. The `orderTypei` is:<br><br>   `0` if it is a batch of `buy` orders, or<br>   `1` if it is a batch of `sell` orders.<br><br>Note that `orders[i]` represents a batch of `amounti` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`.<br><br>There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:<br><br>   If the order is a `buy` order, you look at the `sell` order with the smallest price in the backlog. If that `sell` order's price is smaller than or equal to the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.<br>   Vice versa, if the order is a `sell` order, you look at the `buy` order with the largest price in the backlog. If that `buy` order's price is larger than or equal to the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.<br><br>Return _the total amount of orders in the backlog after placing all the orders from the input_. Since this number can be large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: orders = \[\[10,5,0\],\[15,2,1\],\[25,1,1\],\[30,4,0\]\]<br>Output: 6<br>Explanation: Here is what happens with the orders:<br>- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.<br>- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.<br>- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.<br>- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.<br>Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.<br><br>Example 2:<br><br>Input: orders = \[\[7,1000000000,1\],\[15,3,0\],\[5,999999995,0\],\[5,1,1\]\]<br>Output: 999999984<br>Explanation: Here is what happens with the orders:<br>- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.<br>- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.<br>- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.<br>- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.<br>Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).<br><br>Constraints:<br><br>   `1 <= orders.length <= 105`<br>   `orders[i].length == 3`<br>   `1 <= pricei, amounti <= 109`<br>   `orderTypei` is either `0` or `1`."""<br><br><br>def getNumberOfBacklogOrders(orders):<br>    buy_orders, sell_orders = [], []<br>    num_orders, mod = 0, int(1e9) + 7<br><br>    for price, amount, order_type in orders:<br>        if order_type == 0: # buy order<br>            while amount and sell_orders and sell_orders[0][0] <= price:<br>                x = min(amount, sell_orders[0][1])<br>                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x<br>                if sell_orders[0][1] == 0:<br>                    heappop(sell_orders)<br>            if amount:<br>                heappush(buy_orders, (-price, amount))<br>        else: # sell order<br>            while amount and buy_orders and -buy_orders[0][0] = price:<br>                x = min(amount, buy_orders[0][1])<br>                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x<br>                if buy_orders[0][1] == 0:<br>                    heappop(buy_orders)<br>            if amount:<br>                heappush(sell_orders, (price, amount))<br>    <br>    while buy_orders:<br>        num_orders = (num_orders + heappop(buy_orders)[1]) % mod<br><br>    while sell_orders:<br>        num_orders = (num_orders + heappop(sell_orders)[1]) % mod<br><br>    return num_orders

### DOC[4] (IRRELEVANT) leetcode/leetcode_638.txt
> from typing import List<br>    """In LeetCode Store, there are `n` items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.<br><br>You are given an integer array `price` where `price[i]` is the price of the `ith` item, and an integer array `needs` where `needs[i]` is the number of pieces of the `ith` item you want to buy.<br><br>You are also given an array `special` where `special[i]` is of size `n + 1` where `special[i][j]` is the number of pieces of the `jth` item in the `ith` offer and `special[i][n]` (i.e., the last integer in the array) is the price of the `ith` offer.<br><br>Return _the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers_. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.<br><br>Example 1:<br><br>Input: price = \[2,5\], special = \[\[3,0,5\],\[1,2,10\]\], needs = \[3,2\]<br>Output: 14<br>Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. <br>In special offer 1, you can pay $5 for 3A and 0B<br>In special offer 2, you can pay $10 for 1A and 2B. <br>You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.<br><br>Example 2:<br><br>Input: price = \[2,3,4\], special = \[\[1,1,0,4\],\[2,2,1,9\]\], needs = \[1,2,1\]<br>Output: 11<br>Explanation: The price of A is $2, and $3 for B, $4 for C. <br>You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. <br>You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. <br>You cannot add more items, though only $9 for 2A ,2B and 1C.<br><br>Constraints:<br><br>   `n == price.length == needs.length`<br>   `1 <= n <= 6`<br>   `0 <= price[i], needs[i] <= 10`<br>   `1 <= special.length <= 100`<br>   `special[i].length == n + 1`<br>   `0 <= special[i][j] <= 50`"""<br><br><br>def shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) - int:<br>    def helper(index):<br>        if index == len(special):<br>            return sum(needs[i]  price[i] for i in range(len(needs)))<br><br>        no_offer = helper(index + 1)<br>        can_apply_offer = True<br>        for i in range(len(needs)):<br>            needs[i] -= special[index][i]<br>            if needs[i] < 0:<br>                can_apply_offer = False<br><br>        with_offer = float('inf')<br>        if can_apply_offer:<br>            offer_cost = special[index][-1] + helper(index)<br>            with_offer = min(no_offer, offer_cost)<br><br>        for i in range(len(needs)):<br>            needs[i] += special[index][i]<br>        <br>        return with_offer if can_apply_offer else no_offer<br><br>    return helper(0)

### DOC[5] (IRRELEVANT) leetcode/leetcode_2585.txt
> def numberOfWays(target, types):<br>    """There is a test that has `n` types of questions. You are given an integer `target` and a 0-indexed 2D integer array `types` where `types[i] = [counti, marksi]` indicates that there are `counti` questions of the `ith` type, and each one of them is worth `marksi` points.<br><br>Return _the number of ways you can earn exactly_ `target` _points in the exam_. Since the answer may be too large, return it modulo `109 + 7`.<br><br>Note that questions of the same type are indistinguishable.<br><br>   For example, if there are `3` questions of the same type, then solving the `1st` and `2nd` questions is the same as solving the `1st` and `3rd` questions, or the `2nd` and `3rd` questions.<br><br>Example 1:<br><br>Input: target = 6, types = \[\[6,1\],\[3,2\],\[2,3\]\]<br>Output: 7<br>Explanation: You can earn 6 points in one of the seven ways:<br>- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6<br>- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6<br>- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6<br>- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6<br>- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6<br>- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6<br>- Solve 2 questions of the 2nd type: 3 + 3 = 6<br><br>Example 2:<br><br>Input: target = 5, types = \[\[50,1\],\[50,2\],\[50,5\]\]<br>Output: 4<br>Explanation: You can earn 5 points in one of the four ways:<br>- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5<br>- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5<br>- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5<br>- Solve 1 question of the 2nd type: 5<br><br>Example 3:<br><br>Input: target = 18, types = \[\[6,1\],\[3,2\],\[2,3\]\]<br>Output: 1<br>Explanation: You can only earn 18 points by answering all questions.<br><br>Constraints:<br><br>   `1 <= target <= 1000`<br>   `n == types.length`<br>   `1 <= n <= 50`<br>   `types[i].length == 2`<br>   `1 <= counti, marksi <= 50`"""<br><br>    MOD = 109 + 7<br>    dp = [0]  (target + 1)<br>    dp[0] = 1<br>    for count, marks in types:<br>        dptmp = [0]  (target + 1)<br>        for i in range(target + 1):<br>            for j in range(count + 1):<br>                if j  marks + i <= target:<br>                    dptmp[i + j  marks] = (dptmp[i + j  marks] + dp[i]) % MOD<br>        dp = dptmp<br>    return dp[target]


## Ground Truth

### GROUND TRUTH 0, ranked 68, leetcode/leetcode_2141.txt
> def max_computer_runtime(n, batteries):<br>    """You have `n` computers. You are given the integer `n` and a 0-indexed integer array `batteries` where the `ith` battery can run a computer for `batteries[i]` minutes. You are interested in running all `n` computers simultaneously using the given batteries.<br><br>Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.<br><br>Note that the batteries cannot be recharged.<br><br>Return _the maximum number of minutes you can run all the_ `n` _computers simultaneously._<br><br>Example 1:<br><br>Input: n = 2, batteries = \[3,3,3\]<br>Output: 4<br>Explanation: <br>Initially, insert battery 0 into the first computer and battery 1 into the second computer.<br>After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.<br>At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.<br>By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.<br>We can run the two computers simultaneously for at most 4 minutes, so we return 4.<br><br>Example 2:<br><br>Input: n = 2, batteries = \[1,1,1,1\]<br>Output: 2<br>Explanation: <br>Initially, insert battery 0 into the first computer and battery 2 into the second computer. <br>After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. <br>After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.<br>We can run the two computers simultaneously for at most 2 minutes, so we return 2.<br><br>Constraints:<br><br>   `1 <= n <= batteries.length <= 105`<br>   `1 <= batteries[i] <= 109`"""<br><br>    batteries.sort()<br>    result = 0<br>    for i in range(len(batteries)):<br>        result = max(result, min(n, len(batteries) - i)  batteries[i])<br>    return result
