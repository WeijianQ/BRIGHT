# Query `119`

## Original Question

*You are given two integers `m` and `n` representing a 0-indexed `m x n` grid. You are also given two 2D integer arrays `guards` and `walls` where `guards[i] = [rowi, coli]` and `walls[j] = [rowj, colj]` represent the positions of the `ith` guard and `jth` wall respectively.

A guard can see every cell in the four cardinal directions (north, east, south, or west) starting from their position unless obstructed by a wall or another guard. A cell is guarded if there is at least one guard that can see it.

Return _the number of unoccupied cells that are not guarded._

Example 1:

Input: m = 4, n = 6, guards = \[\[0,0\],\[1,1\],\[2,3\]\], walls = \[\[0,1\],\[2,2\],\[1,4\]\]
Output: 7
Explanation: The guarded and unguarded cells are shown in red and green respectively in the above diagram.
There are a total of 7 unguarded cells, so we return 7.

Example 2:

Input: m = 3, n = 3, guards = \[\[1,1\]\], walls = \[\[0,1\],\[1,0\],\[2,1\],\[1,2\]\]
Output: 4
Explanation: The unguarded cells are shown in green in the above diagram.
There are a total of 4 unguarded cells, so we return 4.

Constraints:

   `1 <= m, n <= 105`
   `2 <= m  n <= 105`
   `1 <= guards.length, walls.length <= 5  104`
   `2 <= guards.length + walls.length <= m  n`
   `guards[i].length == walls[j].length == 2`
   `0 <= rowi, rowj < m`
   `0 <= coli, colj < n`
   All the positions in `guards` and `walls` are unique.*


### Metrics

```
recip_rank: 0.0100
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 1.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.1502
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0100
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1001.txt
> def repeatedNTimes(nums):<br>    """There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp that is initially turned off.<br><br>You are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi, coli]` indicates that the lamp at `grid[rowi][coli]` is turned on. Even if the same lamp is listed more than once, it is turned on.<br><br>When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.<br><br>You are also given another 2D array `queries`, where `queries[j] = [rowj, colj]`. For the `jth` query, determine whether `grid[rowj][colj]` is illuminated or not. After answering the `jth` query, turn off the lamp at `grid[rowj][colj]` and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with `grid[rowj][colj]`.<br><br>Return _an array of integers_ `ans`_,_ _where_ `ans[j]` _should be_ `1` _if the cell in the_ `jth` _query was illuminated, or_ `0` _if the lamp was not._<br><br>Example 1:<br><br>Input: n = 5, lamps = \[\[0,0\],\[4,4\]\], queries = \[\[1,1\],\[1,0\]\]<br>Output: \[1,0\]<br>Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid\[0\]\[0\] then turning on the lamp at grid\[4\]\[4\].<br>The 0th query asks if the lamp at grid\[1\]\[1\] is illuminated or not (the blue square). It is illuminated, so set ans\[0\] = 1. Then, we turn off all lamps in the red square.<br> <br>The 1st query asks if the lamp at grid\[1\]\[0\] is illuminated or not (the blue square). It is not illuminated, so set ans\[1\] = 0. Then, we turn off all lamps in the red rectangle.<br> <br><br>Example 2:<br><br>Input: n = 5, lamps = \[\[0,0\],\[4,4\]\], queries = \[\[1,1\],\[1,1\]\]<br>Output: \[1,1\]<br><br>Example 3:<br><br>Input: n = 5, lamps = \[\[0,0\],\[0,4\]\], queries = \[\[0,4\],\[0,1\],\[1,4\]\]<br>Output: \[1,1,0\]<br><br>Constraints:<br><br>   `1 <= n <= 109`<br>   `0 <= lamps.length <= 20000`<br>   `0 <= queries.length <= 20000`<br>   `lamps[i].length == 2`<br>   `0 <= rowi, coli < n`<br>   `queries[j].length == 2`<br>   `0 <= rowj, colj < n`"""<br><br>    hash_map = {}<br>    for num in nums:<br>        if num in hash_map:<br>            return num<br>        else:<br>            hash_map[num] = 1

### DOC[2] (IRRELEVANT) leetcode/leetcode_1610.txt
> def xor_operation(n, start):<br>    """You are given an array `points`, an integer `angle`, and your `location`, where `location = [posx, posy]` and `points[i] = [xi, yi]` both denote integral coordinates on the X-Y plane.<br><br>Initially, you are facing directly east from your position. You cannot move from your position, but you can rotate. In other words, `posx` and `posy` cannot be changed. Your field of view in degrees is represented by `angle`, determining how wide you can see from any given view direction. Let `d` be the amount in degrees that you rotate counterclockwise. Then, your field of view is the inclusive range of angles `[d - angle/2, d + angle/2]`.<br><br>Your browser does not support the video tag or this video format.<br><br>You can see some set of points if, for each point, the angle formed by the point, your position, and the immediate east direction from your position is in your field of view.<br><br>There can be multiple points at one coordinate. There may be points at your location, and you can always see these points regardless of your rotation. Points do not obstruct your vision to other points.<br><br>Return _the maximum number of points you can see_.<br><br>Example 1:<br><br>Input: points = \[\[2,1\],\[2,2\],\[3,3\]\], angle = 90, location = \[1,1\]<br>Output: 3<br>Explanation: The shaded region represents your field of view. All points can be made visible in your field of view, including \[3,3\] even though \[2,2\] is in front and in the same line of sight.<br><br>Example 2:<br><br>Input: points = \[\[2,1\],\[2,2\],\[3,4\],\[1,1\]\], angle = 90, location = \[1,1\]<br>Output: 4<br>Explanation: All points can be made visible in your field of view, including the one at your location.<br><br>Example 3:<br><br>Input: points = \[\[1,0\],\[2,1\]\], angle = 13, location = \[1,1\]<br>Output: 1<br>Explanation: You can only see one of the two points, as shown above.<br><br>Constraints:<br><br>   `1 <= points.length <= 105`<br>   `points[i].length == 2`<br>   `location.length == 2`<br>   `0 <= angle < 360`<br>   `0 <= posx, posy, xi, yi <= 100`"""<br><br>    xor_result = 0<br>    for i in range(n):<br>        xor_result ^= (start + 2  i)<br>    return xor_result

### DOC[3] (IRRELEVANT) leetcode/leetcode_947.txt
> from collections import defaultdict<br>    """On a 2D plane, we place `n` stones at some integer coordinate points. Each coordinate point may have at most one stone.<br><br>A stone can be removed if it shares either the same row or the same column as another stone that has not been removed.<br><br>Given an array `stones` of length `n` where `stones[i] = [xi, yi]` represents the location of the `ith` stone, return _the largest possible number of stones that can be removed_.<br><br>Example 1:<br><br>Input: stones = \[\[0,0\],\[0,1\],\[1,0\],\[1,2\],\[2,1\],\[2,2\]\]<br>Output: 5<br>Explanation: One way to remove 5 stones is as follows:<br>1. Remove stone \[2,2\] because it shares the same row as \[2,1\].<br>2. Remove stone \[2,1\] because it shares the same column as \[0,1\].<br>3. Remove stone \[1,2\] because it shares the same row as \[1,0\].<br>4. Remove stone \[1,0\] because it shares the same column as \[0,0\].<br>5. Remove stone \[0,1\] because it shares the same row as \[0,0\].<br>Stone \[0,0\] cannot be removed since it does not share a row/column with another stone still on the plane.<br><br>Example 2:<br><br>Input: stones = \[\[0,0\],\[0,2\],\[1,1\],\[2,0\],\[2,2\]\]<br>Output: 3<br>Explanation: One way to make 3 moves is as follows:<br>1. Remove stone \[2,2\] because it shares the same row as \[2,0\].<br>2. Remove stone \[2,0\] because it shares the same column as \[0,0\].<br>3. Remove stone \[0,2\] because it shares the same row as \[0,0\].<br>Stones \[0,0\] and \[1,1\] cannot be removed since they do not share a row/column with another stone still on the plane.<br><br>Example 3:<br><br>Input: stones = \[\[0,0\]\]<br>Output: 0<br>Explanation: \[0,0\] is the only stone on the plane, so you cannot remove it.<br><br>Constraints:<br><br>   `1 <= stones.length <= 1000`<br>   `0 <= xi, yi <= 104`<br>   No two stones are at the same coordinate point."""<br><br>from bisect import bisect<br><br>class TopVotedCandidate:<br><br>    def __init__(self, persons, times):<br>        self.leader_map = {}<br>        self.times = times<br>        votes = defaultdict(int)<br>        leader = -1<br>        for i, t in enumerate(times):<br>            votes[persons[i]] += 1<br>            if votes[persons[i]] = votes[leader]:<br>                leader = persons[i]<br>            self.leader_map[t] = leader<br><br>    def q(self, t):<br>        idx = bisect.bisect(self.times, t)<br>        return self.times[idx - 1]

### DOC[4] (IRRELEVANT) leetcode/leetcode_1659.txt
> def maxSum(nums1, nums2):<br>    """You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.<br><br>You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.<br><br>The happiness of each person is calculated as follows:<br><br>   Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).<br>   Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).<br><br>Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.<br><br>The grid happiness is the sum of each person's happiness. Return _the maximum possible grid happiness._<br><br>Example 1:<br><br>Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2<br>Output: 240<br>Explanation: Assume the grid is 1-indexed with coordinates (row, column).<br>We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).<br>- Introvert at (1,1) happiness: 120 (starting happiness) - (0 \ 30) (0 neighbors) = 120<br>- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 \ 20) (1 neighbor) = 60<br>- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 \ 20) (1 neighbor) = 60<br>The grid happiness is 120 + 60 + 60 = 240.<br>The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.<br><br>Example 2:<br><br>Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1<br>Output: 260<br>Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).<br>- Introvert at (1,1) happiness: 120 (starting happiness) - (1 \ 30) (1 neighbor) = 90<br>- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 \ 20) (2 neighbors) = 80<br>- Introvert at (3,1) happiness: 120 (starting happiness) - (1 \ 30) (1 neighbor) = 90<br>The grid happiness is 90 + 80 + 90 = 260.<br><br>Example 3:<br><br>Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0<br>Output: 240<br><br>Constraints:<br><br>   `1 <= m, n <= 5`<br>   `0 <= introvertsCount, extrovertsCount <= min(m  n, 6)`"""<br><br>    mod = 109 + 7<br>    m, n = len(nums1), len(nums2)<br>    dp1, dp2 = [0]  (m + 1), [0]  (n + 1)<br>    i, j = m - 1, n - 1<br>    while i = 0 or j = 0:<br>        a = dp1[i] + nums1[i] if i = 0 else float('-inf')<br>        b = dp2[j] + nums2[j] if j = 0 else float('-inf')<br>        seen = set()<br>        if a  b:<br>            dp1[i] = a % mod<br>            i -= 1<br>            seen.add(nums1[i + 1])<br>        else:<br>            dp2[j] = b % mod<br>            j -= 1<br>            seen.add(nums2[j + 1])<br>    return max(dp1[0], dp2[0]) % mod

### DOC[5] (IRRELEVANT) leetcode/leetcode_2250.txt
> from heapq import heappush, heappop<br>    """You are given a 2D integer array `rectangles` where `rectangles[i] = [li, hi]` indicates that `ith` rectangle has a length of `li` and a height of `hi`. You are also given a 2D integer array `points` where `points[j] = [xj, yj]` is a point with coordinates `(xj, yj)`.<br><br>The `ith` rectangle has its bottom-left corner point at the coordinates `(0, 0)` and its top-right corner point at `(li, hi)`.<br><br>Return _an integer array_ `count` _of length_ `points.length` _where_ `count[j]` _is the number of rectangles that contain the_ `jth` _point._<br><br>The `ith` rectangle contains the `jth` point if `0 <= xj <= li` and `0 <= yj <= hi`. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.<br><br>Example 1:<br><br>Input: rectangles = \[\[1,2\],\[2,3\],\[2,5\]\], points = \[\[2,1\],\[1,4\]\]<br>Output: \[2,1\]<br>Explanation: <br>The first rectangle contains no points.<br>The second rectangle contains only the point (2, 1).<br>The third rectangle contains the points (2, 1) and (1, 4).<br>The number of rectangles that contain the point (2, 1) is 2.<br>The number of rectangles that contain the point (1, 4) is 1.<br>Therefore, we return \[2, 1\].<br><br>Example 2:<br><br>Input: rectangles = \[\[1,1\],\[2,2\],\[3,3\]\], points = \[\[1,3\],\[1,1\]\]<br>Output: \[1,3\]<br>Explanation:<br>The first rectangle contains only the point (1, 1).<br>The second rectangle contains only the point (1, 1).<br>The third rectangle contains the points (1, 3) and (1, 1).<br>The number of rectangles that contain the point (1, 3) is 1.<br>The number of rectangles that contain the point (1, 1) is 3.<br>Therefore, we return \[1, 3\].<br><br>Constraints:<br><br>   `1 <= rectangles.length, points.length <= 5  104`<br>   `rectangles[i].length == points[j].length == 2`<br>   `1 <= li, xj <= 109`<br>   `1 <= hi, yj <= 100`<br>   All the `rectangles` are unique.<br>   All the `points` are unique."""<br><br><br>def kHighestRankedItems(grid, pricing, start, k):<br>    m, n = len(grid), len(grid[0])<br>    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]<br>    res = []<br>    pq = []<br>    visited = [[False for _ in range(n)] for _ in range(m)]<br><br>    heappush(pq, (0, -grid[start[0]][start[1]], start[0], start[1]))<br>    visited[start[0]][start[1]] = True<br><br>    while pq and k  0:<br>        size = len(pq)<br>        for _ in range(size):<br>            curr = heappop(pq)<br>            steps, price, row, col = curr<br><br>            if pricing[0] <= -price <= pricing[1]:<br>                res.append([row, col])<br>                k -= 1<br><br>            for dr, dc in directions:<br>                newRow, newCol = row + dr, col + dc<br>                if 0 <= newRow < m and 0 <= newCol < n and not visited[newRow][newCol]:<br>                    visited[newRow][newCol] = True<br>                    heappush(pq, (steps + 1, -grid[newRow][newCol], newRow, newCol))<br><br>    return res


## Ground Truth

### GROUND TRUTH 0, ranked 99, leetcode/leetcode_999.txt
> def regionsBySlashes(grid):<br>    """On an `8 x 8` chessboard, there is exactly one white rook `'R'` and some number of white bishops `'B'`, black pawns `'p'`, and empty squares `'.'`.<br><br>When the rook moves, it chooses one of four cardinal directions (north, east, south, or west), then moves in that direction until it chooses to stop, reaches the edge of the board, captures a black pawn, or is blocked by a white bishop. A rook is considered attacking a pawn if the rook can capture the pawn on the rook's turn. The number of available captures for the white rook is the number of pawns that the rook is attacking.<br><br>Return _the number of available captures for the white rook_.<br><br>Example 1:<br><br>Input: board = \[\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "R ", ". ", ". ", ". ", "p "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\]\]<br>Output: 3<br>Explanation: In this example, the rook is attacking all the pawns.<br><br>Example 2:<br><br>Input: board = \[\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", "p ", "p ", "p ", "p ", "p ", ". ", ". "\],\[ ". ", "p ", "p ", "B ", "p ", "p ", ". ", ". "\],\[ ". ", "p ", "B ", "R ", "B ", "p ", ". ", ". "\],\[ ". ", "p ", "p ", "B ", "p ", "p ", ". ", ". "\],\[ ". ", "p ", "p ", "p ", "p ", "p ", ". ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\]\]<br>Output: 0<br>Explanation: The bishops are blocking the rook from attacking any of the pawns.<br><br>Example 3:<br><br>Input: board = \[\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "\],\[ "p ", "p ", ". ", "R ", ". ", "p ", "B ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "B ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", "p ", ". ", ". ", ". ", ". "\],\[ ". ", ". ", ". ", ". ", ". ", ". ", ". ", ". "\]\]<br>Output: 3<br>Explanation: The rook is attacking the pawns at positions b5, d6, and f5.<br><br>Constraints:<br><br>   `board.length == 8`<br>   `board[i].length == 8`<br>   `board[i][j]` is either `'R'`, `'.'`, `'B'`, or `'p'`<br>   There is exactly one cell with `board[i][j] == 'R'`"""<br><br>    n = len(grid)<br>    graph = [[0]  (n  3) for _ in range(n  3)]<br><br>    for i in range(n):<br>        for j in range(n):<br>            if grid[i][j] == '/':<br>                graph[i  3][j  3 + 2] = graph[i  3 + 1][j  3 + 1] = graph[i  3 + 2][j  3] = 1<br>            if grid[i][j] == '\\':<br>                graph[i  3][j  3] = graph[i  3 + 1][j  3 + 1] = graph[i  3 + 2][j  3 + 2] = 1<br><br>    regions = 0<br>    for i in range(n  3):<br>        for j in range(n  3):<br>            if not graph[i][j]:<br>                regions += 1<br>                dfs(graph, i, j)<br><br>    return regions<br><br>def dfs(graph, i, j):<br>    n = len(graph)<br>    if i < 0 or j < 0 or i = n or j = n or graph[i][j]:<br>        return<br><br>    graph[i][j] = 1<br>    dfs(graph, i - 1, j)<br>    dfs(graph, i + 1, j)<br>    dfs(graph, i, j - 1)<br>    dfs(graph, i, j + 1)
