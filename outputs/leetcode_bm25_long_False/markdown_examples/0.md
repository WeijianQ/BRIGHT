# Query `0`

## Original Question

*Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

Example 1:

Input: height = \[0,1,0,2,1,0,1,3,2,1,2,1\]
Output: 6
Explanation: The above elevation map (black section) is represented by array \[0,1,0,2,1,0,1,3,2,1,2,1\]. In this case, 6 units of rain water (blue section) are being trapped.

Example 2:

Input: height = \[4,2,0,3,2,5\]
Output: 9

Constraints:

   `n == height.length`
   `1 <= n <= 2  104`
   `0 <= height[i] <= 105`*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.4000
P_10: 0.2000
P_25: 0.0800
P_50: 0.0400
P_100: 0.0200
recall_1: 0.3333
recall_5: 0.6667
recall_10: 0.6667
recall_25: 0.6667
recall_50: 0.6667
recall_100: 0.6667
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.7654
ndcg_cut_10: 0.7654
ndcg_cut_25: 0.7654
ndcg_cut_50: 0.7654
ndcg_cut_100: 0.7654
map_cut_1: 0.3333
map_cut_5: 0.6667
map_cut_10: 0.6667
map_cut_25: 0.6667
map_cut_50: 0.6667
map_cut_100: 0.6667
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_11.txt
> def max_area(height):<br>    """You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.<br><br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br><br>Return _the maximum amount of water a container can store_.<br><br>Notice that you may not slant the container.<br><br>Example 1:<br><br>Input: height = \[1,8,6,2,5,4,8,3,7\]<br>Output: 49<br>Explanation: The above vertical lines are represented by array \[1,8,6,2,5,4,8,3,7\]. In this case, the max area of water (blue section) the container can contain is 49.<br><br>Example 2:<br><br>Input: height = \[1,1\]<br>Output: 1<br><br>Constraints:<br><br>   `n == height.length`<br>   `2 <= n <= 105`<br>   `0 <= height[i] <= 104`"""<br><br>    max_area, left, right = 0, 0, len(height) - 1<br>    while left < right:<br>        max_area = max(max_area, min(height[left], height[right])  (right - left))<br>        if height[left] < height[right]:<br>            left += 1<br>        else:<br>            right -= 1<br>    return max_area

### DOC[2] (GROUND TRUTH) leetcode/leetcode_407.txt
> import heapq<br>    """Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return _the volume of water it can trap after raining_.<br><br>Example 1:<br><br>Input: heightMap = \[\[1,4,3,1,3,2\],\[3,2,1,3,2,4\],\[2,3,3,2,3,1\]\]<br>Output: 4<br>Explanation: After the rain, water is trapped between the blocks.<br>We have two small ponds 1 and 3 units trapped.<br>The total volume of water trapped is 4.<br><br>Example 2:<br><br>Input: heightMap = \[\[3,3,3,3,3\],\[3,2,2,2,3\],\[3,2,1,2,3\],\[3,2,2,2,3\],\[3,3,3,3,3\]\]<br>Output: 10<br><br>Constraints:<br><br>   `m == heightMap.length`<br>   `n == heightMap[i].length`<br>   `1 <= m, n <= 200`<br>   `0 <= heightMap[i][j] <= 2  104`"""<br><br><br>def trapRainWater(heightMap):<br>    m, n = len(heightMap), len(heightMap[0])<br>    pq = []<br>    visited = [[False]  n for _ in range(m)]<br><br>    for i in range(m):<br>        heapq.heappush(pq, (heightMap[i][0], i, 0))<br>        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))<br>        visited[i][0] = visited[i][n - 1] = True<br><br>    for i in range(1, n - 1):<br>        heapq.heappush(pq, (heightMap[0][i], 0, i))<br>        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))<br>        visited[0][i] = visited[m - 1][i] = True<br><br>    water, maxHeight = 0, 0<br>    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))<br><br>    while pq:<br>        h, r, c = heapq.heappop(pq)<br>        maxHeight = max(maxHeight, h)<br>        for dx, dy in dirs:<br>            x, y = r + dx, c + dy<br>            if x < 0 or x = m or y < 0 or y = n or visited[x][y]:<br>                continue<br>            if heightMap[x][y] < maxHeight:<br>                water += maxHeight - heightMap[x][y]<br>            heapq.heappush(pq, (heightMap[x][y], x, y))<br>            visited[x][y] = True<br><br>    return water

### DOC[3] (IRRELEVANT) leetcode/leetcode_1488.txt
> def get_power(x):<br>    """Your country has an infinite number of lakes. Initially, all the lakes are empty, but when it rains over the `nth` lake, the `nth` lake becomes full of water. If it rains over a lake that is full of water, there will be a flood. Your goal is to avoid floods in any lake.<br><br>Given an integer array `rains` where:<br><br>   `rains[i]  0` means there will be rains over the `rains[i]` lake.<br>   `rains[i] == 0` means there are no rains this day and you can choose one lake this day and dry it.<br><br>Return _an array `ans`_ where:<br><br>   `ans.length == rains.length`<br>   `ans[i] == -1` if `rains[i]  0`.<br>   `ans[i]` is the lake you choose to dry in the `ith` day if `rains[i] == 0`.<br><br>If there are multiple valid answers return any of them. If it is impossible to avoid flood return an empty array.<br><br>Notice that if you chose to dry a full lake, it becomes empty, but if you chose to dry an empty lake, nothing changes.<br><br>Example 1:<br><br>Input: rains = \[1,2,3,4\]<br>Output: \[-1,-1,-1,-1\]<br>Explanation: After the first day full lakes are \[1\]<br>After the second day full lakes are \[1,2\]<br>After the third day full lakes are \[1,2,3\]<br>After the fourth day full lakes are \[1,2,3,4\]<br>There's no day to dry any lake and there is no flood in any lake.<br><br>Example 2:<br><br>Input: rains = \[1,2,0,0,2,1\]<br>Output: \[-1,-1,2,1,-1,-1\]<br>Explanation: After the first day full lakes are \[1\]<br>After the second day full lakes are \[1,2\]<br>After the third day, we dry lake 2. Full lakes are \[1\]<br>After the fourth day, we dry lake 1. There is no full lakes.<br>After the fifth day, full lakes are \[2\].<br>After the sixth day, full lakes are \[1,2\].<br>It is easy that this scenario is flood-free. \[-1,-1,1,2,-1,-1\] is another acceptable scenario.<br><br>Example 3:<br><br>Input: rains = \[1,2,0,1,2\]<br>Output: \[\]<br>Explanation: After the second day, full lakes are  \[1,2\]. We have to dry one lake in the third day.<br>After that, it will rain over lakes \[1,2\]. It's easy to prove that no matter which lake you choose to dry in the 3rd day, the other one will flood.<br><br>Constraints:<br><br>   `1 <= rains.length <= 105`<br>   `0 <= rains[i] <= 109`"""<br><br>    steps = 0<br>    while x != 1:<br>        if x % 2 == 0:<br>            x //= 2<br>        else:<br>            x = 3  x + 1<br>        steps += 1<br>    return steps<br><br>def sort_by_power(lo, hi, k):<br>    nums = [(get_power(i), i) for i in range(lo, hi + 1)]<br>    nums.sort()<br>    return nums[k - 1][1]

### DOC[4] (IRRELEVANT) leetcode/leetcode_417.txt
> def pacificAtlantic(heights):<br>    """There is an `m x n` rectangular island that borders both the Pacific Ocean and Atlantic Ocean. The Pacific Ocean touches the island's left and top edges, and the Atlantic Ocean touches the island's right and bottom edges.<br><br>The island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the height above sea level of the cell at coordinate `(r, c)`.<br><br>The island receives a lot of rain, and the rain water can flow to neighboring cells directly north, south, east, and west if the neighboring cell's height is less than or equal to the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.<br><br>Return _a 2D list of grid coordinates_ `result` _where_ `result[i] = [ri, ci]` _denotes that rain water can flow from cell_ `(ri, ci)` _to both the Pacific and Atlantic oceans_.<br><br>Example 1:<br><br>Input: heights = \[\[1,2,2,3,5\],\[3,2,3,4,4\],\[2,4,5,3,1\],\[6,7,1,4,5\],\[5,1,1,2,4\]\]<br>Output: \[\[0,4\],\[1,3\],\[1,4\],\[2,2\],\[3,0\],\[3,1\],\[4,0\]\]<br>Explanation: The following cells can flow to the Pacific and Atlantic oceans, as shown below:<br>\[0,4\]: \[0,4\] - Pacific Ocean <br>       \[0,4\] - Atlantic Ocean<br>\[1,3\]: \[1,3\] - \[0,3\] - Pacific Ocean <br>       \[1,3\] - \[1,4\] - Atlantic Ocean<br>\[1,4\]: \[1,4\] - \[1,3\] - \[0,3\] - Pacific Ocean <br>       \[1,4\] - Atlantic Ocean<br>\[2,2\]: \[2,2\] - \[1,2\] - \[0,2\] - Pacific Ocean <br>       \[2,2\] - \[2,3\] - \[2,4\] - Atlantic Ocean<br>\[3,0\]: \[3,0\] - Pacific Ocean <br>       \[3,0\] - \[4,0\] - Atlantic Ocean<br>\[3,1\]: \[3,1\] - \[3,0\] - Pacific Ocean <br>       \[3,1\] - \[4,1\] - Atlantic Ocean<br>\[4,0\]: \[4,0\] - Pacific Ocean <br>       \[4,0\] - Atlantic Ocean<br>Note that there are other possible paths for these cells to flow to the Pacific and Atlantic oceans.<br><br>Example 2:<br><br>Input: heights = \[\[1\]\]<br>Output: \[\[0,0\]\]<br>Explanation: The water can flow from the only cell to the Pacific and Atlantic oceans.<br><br>Constraints:<br><br>   `m == heights.length`<br>   `n == heights[r].length`<br>   `1 <= m, n <= 200`<br>   `0 <= heights[r][c] <= 105`"""<br><br>    def dfs(r, c, prev_height, visited):<br>        if not (0 <= r < len(heights)) or not (0 <= c < len(heights[0])):<br>            return<br>        if heights[r][c] = prev_height and not visited[r][c]:<br>            visited[r][c] = True<br>            dfs(r - 1, c, heights[r][c], visited)<br>            dfs(r + 1, c, heights[r][c], visited)<br>            dfs(r, c - 1, heights[r][c], visited)<br>            dfs(r, c + 1, heights[r][c], visited)<br><br>    m, n = len(heights), len(heights[0])<br>    pacific = [[False]  n for _ in range(m)]<br>    atlantic = [[False]  n for _ in range(m)]<br><br>    for r in range(m):<br>        dfs(r, 0, -1, pacific)<br>        dfs(r, n - 1, -1, atlantic)<br>    for c in range(n):<br>        dfs(0, c, -1, pacific)<br>        dfs(m - 1, c, -1, atlantic)<br><br>    result = []<br>    for r in range(m):<br>        for c in range(n):<br>            if pacific[r][c] and atlantic[r][c]:<br>                result.append([r, c])<br>    return result

### DOC[5] (IRRELEVANT) leetcode/leetcode_778.txt
> import heapq<br>    """You are given an `n x n` integer matrix `grid` where each value `grid[i][j]` represents the elevation at that point `(i, j)`.<br><br>The rain starts to fall. At time `t`, the depth of the water everywhere is `t`. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most `t`. You can swim infinite distances in zero time. Of course, you must stay within the boundaries of the grid during your swim.<br><br>Return _the least time until you can reach the bottom right square_ `(n - 1, n - 1)` _if you start at the top left square_ `(0, 0)`.<br><br>Example 1:<br><br>Input: grid = \[\[0,2\],\[1,3\]\]<br>Output: 3<br>Explanation:<br>At time 0, you are in grid location (0, 0).<br>You cannot go anywhere else because 4-directionally adjacent neighbors have a higher elevation than t = 0.<br>You cannot reach point (1, 1) until time 3.<br>When the depth of water is 3, we can swim anywhere inside the grid.<br><br>Example 2:<br><br>Input: grid = \[\[0,1,2,3,4\],\[24,23,22,21,5\],\[12,13,14,15,16\],\[11,17,18,19,20\],\[10,9,8,7,6\]\]<br>Output: 16<br>Explanation: The final route is shown.<br>We need to wait until time 16 so that (0, 0) and (4, 4) are connected.<br><br>Constraints:<br><br>   `n == grid.length`<br>   `n == grid[i].length`<br>   `1 <= n <= 50`<br>   `0 <= grid[i][j] < n2`<br>   Each value `grid[i][j]` is unique."""<br><br><br>def rearrange_string(s):<br>    counts = {}<br>    for c in s:<br>        counts[c] = counts.get(c, 0) + 1<br>    <br>    pq = [(-count, char) for char, count in counts.items()]<br>    heapq.heapify(pq)<br>    <br>    result = []<br>    previous = (0, '')<br>    <br>    while pq:<br>        count, char = heapq.heappop(pq)<br>        result.append(char)<br>        <br>        if previous[0] < 0:<br>            heapq.heappush(pq, previous)<br>        <br>        count += 1<br>        previous = (count, char)<br>    <br>    result_str = ''.join(result)<br>    return result_str if len(result_str) == len(s) else ""


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_11.txt
> def max_area(height):<br>    """You are given an integer array `height` of length `n`. There are `n` vertical lines drawn such that the two endpoints of the `ith` line are `(i, 0)` and `(i, height[i])`.<br><br>Find two lines that together with the x-axis form a container, such that the container contains the most water.<br><br>Return _the maximum amount of water a container can store_.<br><br>Notice that you may not slant the container.<br><br>Example 1:<br><br>Input: height = \[1,8,6,2,5,4,8,3,7\]<br>Output: 49<br>Explanation: The above vertical lines are represented by array \[1,8,6,2,5,4,8,3,7\]. In this case, the max area of water (blue section) the container can contain is 49.<br><br>Example 2:<br><br>Input: height = \[1,1\]<br>Output: 1<br><br>Constraints:<br><br>   `n == height.length`<br>   `2 <= n <= 105`<br>   `0 <= height[i] <= 104`"""<br><br>    max_area, left, right = 0, 0, len(height) - 1<br>    while left < right:<br>        max_area = max(max_area, min(height[left], height[right])  (right - left))<br>        if height[left] < height[right]:<br>            left += 1<br>        else:<br>            right -= 1<br>    return max_area

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_238.txt
> def productExceptSelf(nums):<br>    """Given an integer array `nums`, return _an array_ `answer` _such that_ `answer[i]` _is equal to the product of all the elements of_ `nums` _except_ `nums[i]`.<br><br>The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.<br><br>You must write an algorithm that runs in `O(n)` time and without using the division operation.<br><br>Example 1:<br><br>Input: nums = \[1,2,3,4\]<br>Output: \[24,12,8,6\]<br><br>Example 2:<br><br>Input: nums = \[-1,1,0,-3,3\]<br>Output: \[0,0,9,0,0\]<br><br>Constraints:<br><br>   `2 <= nums.length <= 105`<br>   `-30 <= nums[i] <= 30`<br>   The product of any prefix or suffix of `nums` is guaranteed to fit in a 32-bit integer.<br><br>Follow up: Can you solve the problem in `O(1)` extra space complexity? (The output array does not count as extra space for space complexity analysis.)"""<br><br>    n = len(nums)<br>    answer = [1]  n<br>    <br>    left = 1<br>    for i in range(n):<br>        answer[i] = left<br>        left = nums[i]<br>    <br>    right = 1<br>    for i in range(n - 1, -1, -1):<br>        answer[i] = right<br>        right = nums[i]<br>    <br>    return answer

### GROUND TRUTH 2, ranked 1, leetcode/leetcode_407.txt
> import heapq<br>    """Given an `m x n` integer matrix `heightMap` representing the height of each unit cell in a 2D elevation map, return _the volume of water it can trap after raining_.<br><br>Example 1:<br><br>Input: heightMap = \[\[1,4,3,1,3,2\],\[3,2,1,3,2,4\],\[2,3,3,2,3,1\]\]<br>Output: 4<br>Explanation: After the rain, water is trapped between the blocks.<br>We have two small ponds 1 and 3 units trapped.<br>The total volume of water trapped is 4.<br><br>Example 2:<br><br>Input: heightMap = \[\[3,3,3,3,3\],\[3,2,2,2,3\],\[3,2,1,2,3\],\[3,2,2,2,3\],\[3,3,3,3,3\]\]<br>Output: 10<br><br>Constraints:<br><br>   `m == heightMap.length`<br>   `n == heightMap[i].length`<br>   `1 <= m, n <= 200`<br>   `0 <= heightMap[i][j] <= 2  104`"""<br><br><br>def trapRainWater(heightMap):<br>    m, n = len(heightMap), len(heightMap[0])<br>    pq = []<br>    visited = [[False]  n for _ in range(m)]<br><br>    for i in range(m):<br>        heapq.heappush(pq, (heightMap[i][0], i, 0))<br>        heapq.heappush(pq, (heightMap[i][n - 1], i, n - 1))<br>        visited[i][0] = visited[i][n - 1] = True<br><br>    for i in range(1, n - 1):<br>        heapq.heappush(pq, (heightMap[0][i], 0, i))<br>        heapq.heappush(pq, (heightMap[m - 1][i], m - 1, i))<br>        visited[0][i] = visited[m - 1][i] = True<br><br>    water, maxHeight = 0, 0<br>    dirs = ((0, 1), (0, -1), (1, 0), (-1, 0))<br><br>    while pq:<br>        h, r, c = heapq.heappop(pq)<br>        maxHeight = max(maxHeight, h)<br>        for dx, dy in dirs:<br>            x, y = r + dx, c + dy<br>            if x < 0 or x = m or y < 0 or y = n or visited[x][y]:<br>                continue<br>            if heightMap[x][y] < maxHeight:<br>                water += maxHeight - heightMap[x][y]<br>            heapq.heappush(pq, (heightMap[x][y], x, y))<br>            visited[x][y] = True<br><br>    return water
