# Query `13`

## Original Question

*A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.

Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called minimum height trees (MHTs).

Return _a list of all MHTs' root labels_. You can return the answer in any order.

The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.

Example 1:

Input: n = 4, edges = \[\[1,0\],\[1,2\],\[1,3\]\]
Output: \[1\]
Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.

Example 2:

Input: n = 6, edges = \[\[3,0\],\[3,1\],\[3,2\],\[3,4\],\[5,4\]\]
Output: \[3,4\]

Constraints:

   `1 <= n <= 2  104`
   `edges.length == n - 1`
   `0 <= ai, bi < n`
   `ai != bi`
   All the pairs `(ai, bi)` are distinct.
   The given input is guaranteed to be a tree and there will be no repeated edges.*


### Metrics

```
recip_rank: 0.1667
P_1: 0.0000
P_5: 0.0000
P_10: 0.1000
P_25: 0.0800
P_50: 0.0600
P_100: 0.0300
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.3333
recall_25: 0.6667
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.1672
ndcg_cut_25: 0.2845
ndcg_cut_50: 0.3775
ndcg_cut_100: 0.3775
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0556
map_cut_25: 0.1000
map_cut_50: 0.1313
map_cut_100: 0.1313
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2581.txt
> def possibleRoots(edges, guesses, k):<br>    """Alice has an undirected tree with `n` nodes labeled from `0` to `n - 1`. The tree is represented as a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>Alice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:<br><br>   Chooses two distinct integers `u` and `v` such that there exists an edge `[u, v]` in the tree.<br>   He tells Alice that `u` is the parent of `v` in the tree.<br><br>Bob's guesses are represented by a 2D integer array `guesses` where `guesses[j] = [uj, vj]` indicates Bob guessed `uj` to be the parent of `vj`.<br><br>Alice being lazy, does not reply to each of Bob's guesses, but just says that at least `k` of his guesses are `true`.<br><br>Given the 2D integer arrays `edges`, `guesses` and the integer `k`, return _the number of possible nodes that can be the root of Alice's tree_. If there is no such tree, return `0`.<br><br>Example 1:<br><br>Input: edges = \[\[0,1\],\[1,2\],\[1,3\],\[4,2\]\], guesses = \[\[1,3\],\[0,1\],\[1,0\],\[2,4\]\], k = 3<br>Output: 3<br>Explanation: <br>Root = 0, correct guesses = \[1,3\], \[0,1\], \[2,4\]<br>Root = 1, correct guesses = \[1,3\], \[1,0\], \[2,4\]<br>Root = 2, correct guesses = \[1,3\], \[1,0\], \[2,4\]<br>Root = 3, correct guesses = \[1,0\], \[2,4\]<br>Root = 4, correct guesses = \[1,3\], \[1,0\]<br>Considering 0, 1, or 2 as root node leads to 3 correct guesses.<br><br>Example 2:<br><br>Input: edges = \[\[0,1\],\[1,2\],\[2,3\],\[3,4\]\], guesses = \[\[1,0\],\[3,4\],\[2,1\],\[3,2\]\], k = 1<br>Output: 5<br>Explanation: <br>Root = 0, correct guesses = \[3,4\]<br>Root = 1, correct guesses = \[1,0\], \[3,4\]<br>Root = 2, correct guesses = \[1,0\], \[2,1\], \[3,4\]<br>Root = 3, correct guesses = \[1,0\], \[2,1\], \[3,2\], \[3,4\]<br>Root = 4, correct guesses = \[1,0\], \[2,1\], \[3,2\]<br>Considering any node as root will give at least 1 correct guess. <br><br>Constraints:<br><br>   `edges.length == n - 1`<br>   `2 <= n <= 105`<br>   `1 <= guesses.length <= 105`<br>   `0 <= ai, bi, uj, vj <= n - 1`<br>   `ai != bi`<br>   `uj != vj`<br>   `edges` represents a valid tree.<br>   `guesses[j]` is an edge of the tree.<br>   `guesses` is unique.<br>   `0 <= k <= guesses.length`"""<br><br>    n = len(edges) + 1<br>    in_degree = [0]  n<br>    guess_parents = set()<br>    <br>    for guess in guesses:<br>        guess_parents.add(guess[0])<br>    <br>    for edge in edges:<br>        in_degree[edge[1]] += 1<br>    <br>    possible_roots = 0<br>    for i in range(n):<br>        if in_degree[i] == 0:<br>            if k == 0 or i in guess_parents:<br>                possible_roots += 1<br>        elif in_degree[i] == 1 and len(guesses) - k < in_degree[i]:<br>            possible_roots += 1<br>    <br>    return possible_roots

### DOC[2] (IRRELEVANT) leetcode/leetcode_2508.txt
> from collections import defaultdict<br>    """There is an undirected graph consisting of `n` nodes numbered from `1` to `n`. You are given the integer `n` and a 2D array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. The graph can be disconnected.<br><br>You can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.<br><br>Return `true` _if it is possible to make the degree of each node in the graph even, otherwise return_ `false`_._<br><br>The degree of a node is the number of edges connected to it.<br><br>Example 1:<br><br>Input: n = 5, edges = \[\[1,2\],\[2,3\],\[3,4\],\[4,2\],\[1,4\],\[2,5\]\]<br>Output: true<br>Explanation: The above diagram shows a valid way of adding an edge.<br>Every node in the resulting graph is connected to an even number of edges.<br><br>Example 2:<br><br>Input: n = 4, edges = \[\[1,2\],\[3,4\]\]<br>Output: true<br>Explanation: The above diagram shows a valid way of adding two edges.<br><br>Example 3:<br><br>Input: n = 4, edges = \[\[1,2\],\[1,3\],\[1,4\]\]<br>Output: false<br>Explanation: It is not possible to obtain a valid graph with adding at most 2 edges.<br><br>Constraints:<br><br>   `3 <= n <= 105`<br>   `2 <= edges.length <= 105`<br>   `edges[i].length == 2`<br>   `1 <= ai, bi <= n`<br>   `ai != bi`<br>   There are no repeated edges."""<br><br><br>def possible_degree_even(n, edges):<br>    degrees = defaultdict(int)<br>    for a, b in edges:<br>        degrees[a] += 1<br>        degrees[b] += 1<br><br>    odd_degrees = sum(1 for d in range(1, n + 1) if degrees[d] % 2 != 0)<br>    return odd_degrees == 0 or odd_degrees == 2

### DOC[3] (IRRELEVANT) leetcode/leetcode_2322.txt
> def dfs(node, parent, xor_values, tree):<br>    """There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.<br><br>You are given a 0-indexed integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>Remove two distinct edges of the tree to form three connected components. For a pair of removed edges, the following steps are defined:<br><br>1.  Get the XOR of all the values of the nodes for each of the three components respectively.<br>2.  The difference between the largest XOR value and the smallest XOR value is the score of the pair.<br><br>   For example, say the three components have the node values: `[4,5,7]`, `[1,9]`, and `[3,3,3]`. The three XOR values are `4 ^ 5 ^ 7 = 6`, `1 ^ 9 = 8`, and `3 ^ 3 ^ 3 = 3`. The largest XOR value is `8` and the smallest XOR value is `3`. The score is then `8 - 3 = 5`.<br><br>Return _the minimum score of any possible pair of edge removals on the given tree_.<br><br>Example 1:<br><br>Input: nums = \[1,5,5,4,11\], edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\]\]<br>Output: 9<br>Explanation: The diagram above shows a way to make a pair of removals.<br>- The 1st component has nodes \[1,3,4\] with values \[5,4,11\]. Its XOR value is 5 ^ 4 ^ 11 = 10.<br>- The 2nd component has node \[0\] with value \[1\]. Its XOR value is 1 = 1.<br>- The 3rd component has node \[2\] with value \[5\]. Its XOR value is 5 = 5.<br>The score is the difference between the largest and smallest XOR value which is 10 - 1 = 9.<br>It can be shown that no other pair of removals will obtain a smaller score than 9.<br><br>Example 2:<br><br>Input: nums = \[5,5,2,4,4,2\], edges = \[\[0,1\],\[1,2\],\[5,2\],\[4,3\],\[1,3\]\]<br>Output: 0<br>Explanation: The diagram above shows a way to make a pair of removals.<br>- The 1st component has nodes \[3,4\] with values \[4,4\]. Its XOR value is 4 ^ 4 = 0.<br>- The 2nd component has nodes \[1,0\] with values \[5,5\]. Its XOR value is 5 ^ 5 = 0.<br>- The 3rd component has nodes \[2,5\] with values \[2,2\]. Its XOR value is 2 ^ 2 = 0.<br>The score is the difference between the largest and smallest XOR value which is 0 - 0 = 0.<br>We cannot obtain a smaller score than 0.<br><br>Constraints:<br><br>   `n == nums.length`<br>   `3 <= n <= 1000`<br>   `1 <= nums[i] <= 108`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree."""<br><br>    xor_value = xor_values[node]<br>    for child in tree[node]:<br>        if child != parent:<br>            xor_value ^= dfs(child, node, xor_values, tree)<br>    return xor_value<br><br><br>def minimumScore(nums, edges):<br>    n = len(nums)<br>    tree = [[] for _ in range(n)]<br>    <br>    for edge in edges:<br>        tree[edge[0]].append(edge[1])<br>        tree[edge[1]].append(edge[0])<br>    <br>    xor_values = [dfs(i, -1, nums, tree) for i in range(n)]<br>    <br>    ans = float('inf')<br>    for i in range(n):<br>        for j in range(i + 1, n):<br>            xor1 = xor_values[i]<br>            xor2 = xor_values[j] ^ nums[i]<br>            xor3 = nums[i] ^ nums[j]<br>            max_xor = max(xor1, xor2, xor3)<br>            min_xor = min(xor1, xor2, xor3)<br>            ans = min(ans, max_xor - min_xor)<br>    <br>    return ans

### DOC[4] (IRRELEVANT) leetcode/leetcode_2497.txt
> def max_star_sum(vals, edges, k):<br>    """There is an undirected graph consisting of `n` nodes numbered from `0` to `n - 1`. You are given a 0-indexed integer array `vals` of length `n` where `vals[i]` denotes the value of the `ith` node.<br><br>You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an undirected edge connecting nodes `ai` and `bi.`<br><br>A star graph is a subgraph of the given graph having a center node containing `0` or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.<br><br>The image below shows star graphs with `3` and `4` neighbors respectively, centered at the blue node.<br><br>The star sum is the sum of the values of all the nodes present in the star graph.<br><br>Given an integer `k`, return _the maximum star sum of a star graph containing at most_ `k` _edges._<br><br>Example 1:<br><br>Input: vals = \[1,2,3,4,10,-10,-20\], edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\],\[3,5\],\[3,6\]\], k = 2<br>Output: 16<br>Explanation: The above diagram represents the input graph.<br>The star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.<br>It can be shown it is not possible to get a star graph with a sum greater than 16.<br><br>Example 2:<br><br>Input: vals = \[-5\], edges = \[\], k = 0<br>Output: -5<br>Explanation: There is only one possible star graph, which is node 0 itself.<br>Hence, we return -5.<br><br>Constraints:<br><br>   `n == vals.length`<br>   `1 <= n <= 105`<br>   `-104 <= vals[i] <= 104`<br>   `0 <= edges.length <= min(n  (n - 1) / 2``, 105)`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi <= n - 1`<br>   `ai != bi`<br>   `0 <= k <= n - 1`"""<br><br>    adj = [[] for _ in range(len(vals))]<br><br>    for edge in edges:<br>        adj[edge[0]].append(vals[edge[1]])<br>        adj[edge[1]].append(vals[edge[0]])<br><br>    ans = float("-inf")<br>    for i in range(len(vals)):<br>        adj[i].sort(reverse=True)<br>        ans = max(ans, vals[i] + sum(adj[i][:k]))<br><br>    return ans

### DOC[5] (IRRELEVANT) leetcode/leetcode_2440.txt
> from collections import defaultdict<br>    """There is an undirected tree with `n` nodes labeled from `0` to `n - 1`.<br><br>You are given a 0-indexed integer array `nums` of length `n` where `nums[i]` represents the value of the `ith` node. You are also given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>You are allowed to delete some edges, splitting the tree into multiple connected components. Let the value of a component be the sum of all `nums[i]` for which node `i` is in the component.<br><br>Return _the maximum number of edges you can delete, such that every connected component in the tree has the same value._<br><br>Example 1:<br><br>Input: nums = \[6,2,2,2,6\], edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\]\] <br>Output: 2 <br>Explanation: The above figure shows how we can delete the edges \[0,1\] and \[3,4\]. The created components are nodes \[0\], \[1,2,3\] and \[4\]. The sum of the values in each component equals 6. It can be proven that no better deletion exists, so the answer is 2.<br><br>Example 2:<br><br>Input: nums = \[2\], edges = \[\]<br>Output: 0<br>Explanation: There are no edges to be deleted.<br><br>Constraints:<br><br>   `1 <= n <= 2  104`<br>   `nums.length == n`<br>   `1 <= nums[i] <= 50`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= edges[i][0], edges[i][1] <= n - 1`<br>   `edges` represents a valid tree."""<br><br><br>def dfs(node, parent, nums, graph, total, result):<br>    total_sum = nums[node]<br>    for neighbor in graph[node]:<br>        if neighbor != parent:<br>            total_sum += dfs(neighbor, node, nums, graph, total, result)<br>    if total_sum == total // 2:<br>        result.append(1)<br>        return 0<br>    return total_sum<br><br>def delete_edges_to_balance_tree(nums, edges):<br>    n = len(nums)<br>    graph = defaultdict(list)<br>    for e in edges:<br>        graph[e[0]].append(e[1])<br>        graph[e[1]].append(e[0])<br><br>    total = sum(nums)<br>    if total % 2 != 0:<br>        return 0  # It is impossible to split the tree fairly.<br><br>    result = []<br>    dfs(0, -1, nums, graph, total, result)<br>    return len(result) - 1


## Ground Truth

### GROUND TRUTH 0, ranked 31, leetcode/leetcode_207.txt
> from collections import defaultdict, deque<br>    """There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.<br><br>   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.<br><br>Return `true` if you can finish all courses. Otherwise, return `false`.<br><br>Example 1:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\]\]<br>Output: true<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0. So it is possible.<br><br>Example 2:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\],\[0,1\]\]<br>Output: false<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br><br>Constraints:<br><br>   `1 <= numCourses <= 2000`<br>   `0 <= prerequisites.length <= 5000`<br>   `prerequisites[i].length == 2`<br>   `0 <= ai, bi < numCourses`<br>   All the pairs prerequisites\[i\] are unique."""<br><br><br>def canFinish(numCourses, prerequisites):<br>    adj = defaultdict(list)<br>    inDegree = [0]  numCourses<br>    <br>    for a, b in prerequisites:<br>        adj[b].append(a)<br>        inDegree[a] += 1<br>    <br>    q = deque([i for i in range(numCourses) if inDegree[i]==0])<br>    <br>    while q:<br>        currCourse = q.popleft()<br>        numCourses -= 1<br>        <br>        for nextCourse in adj[currCourse]:<br>            inDegree[nextCourse] -= 1<br>            if inDegree[nextCourse] == 0:<br>                q.append(nextCourse)<br>    <br>    return numCourses == 0

### GROUND TRUTH 1, ranked 14, leetcode/leetcode_210.txt
> from collections import deque<br>    """There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.<br><br>   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.<br><br>Return _the ordering of courses you should take to finish all courses_. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.<br><br>Example 1:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\]\]<br>Output: \[0,1\]<br>Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \[0,1\].<br><br>Example 2:<br><br>Input: numCourses = 4, prerequisites = \[\[1,0\],\[2,0\],\[3,1\],\[3,2\]\]<br>Output: \[0,2,1,3\]<br>Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.<br>So one correct course order is \[0,1,2,3\]. Another correct ordering is \[0,2,1,3\].<br><br>Example 3:<br><br>Input: numCourses = 1, prerequisites = \[\]<br>Output: \[0\]<br><br>Constraints:<br><br>   `1 <= numCourses <= 2000`<br>   `0 <= prerequisites.length <= numCourses  (numCourses - 1)`<br>   `prerequisites[i].length == 2`<br>   `0 <= ai, bi < numCourses`<br>   `ai != bi`<br>   All the pairs `[ai, bi]` are distinct."""<br><br><br>def findOrder(numCourses, prerequisites):<br>    in_degree = [0]  numCourses<br>    adj_list = [[] for _ in range(numCourses)]<br>    <br>    for p in prerequisites:<br>        adj_list[p[1]].append(p[0])<br>        in_degree[p[0]] += 1<br>    <br>    q = deque([i for i in range(numCourses) if in_degree[i] == 0])<br>    order = []<br>    <br>    while q:<br>        curr = q.popleft()<br>        order.append(curr)<br>        for next in adj_list[curr]:<br>            in_degree[next] -= 1<br>            if in_degree[next] == 0:<br>                q.append(next)<br>    <br>    return order if len(order) == numCourses else []

### GROUND TRUTH 2, ranked 5, leetcode/leetcode_2603.txt
> from collections import defaultdict<br>    """There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.<br><br>Initially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:<br><br>   Collect all the coins that are at a distance of at most `2` from the current vertex, or<br>   Move to any adjacent vertex in the tree.<br><br>Find _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.<br><br>Note that if you pass an edge several times, you need to count it into the answer several times.<br><br>Example 1:<br><br>Input: coins = \[1,0,0,0,0,1\], edges = \[\[0,1\],\[1,2\],\[2,3\],\[3,4\],\[4,5\]\]<br>Output: 2<br>Explanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.<br><br>Example 2:<br><br>Input: coins = \[0,0,0,1,1,0,0,1\], edges = \[\[0,1\],\[0,2\],\[1,3\],\[1,4\],\[2,5\],\[5,6\],\[5,7\]\]<br>Output: 2<br>Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.<br><br>Constraints:<br><br>   `n == coins.length`<br>   `1 <= n <= 3  104`<br>   `0 <= coins[i] <= 1`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree."""<br><br><br>def min_edges_to_collect_coins(coins, edges):<br>    adj = defaultdict(list)<br>    for a, b in edges:<br>        adj[a].append(b)<br>        adj[b].append(a)<br>    return dfs(adj, coins, 0, -1)[1] // 2<br><br>def dfs(adj, coins, node, parent):<br>    sum_coins = coins[node]<br>    distance = 0<br>    for neighbor in adj[node]:<br>        if neighbor != parent:<br>            result = dfs(adj, coins, neighbor, node)<br>            sum_coins += result[0]<br>            distance += 2  result[0] + result[1]<br>    return (sum_coins, distance)
