# Query `132`

## Original Question

*You are given a string of length `5` called `time`, representing the current time on a digital clock in the format `"hh:mm "`. The earliest possible time is `"00:00 "` and the latest possible time is `"23:59 "`.

In the string `time`, the digits represented by the `?` symbol are unknown, and must be replaced with a digit from `0` to `9`.

Return _an integer_ `answer`_, the number of valid clock times that can be created by replacing every_ `?` _with a digit from_ `0` _to_ `9`.

Example 1:

Input: time =  "?5:00 "
Output: 2
Explanation: We can replace the ? with either a 0 or 1, producing  "05:00 " or  "15:00 ". Note that we cannot replace it with a 2, since the time  "25:00 " is invalid. In total, we have two choices.

Example 2:

Input: time =  "0?:0? "
Output: 100
Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.

Example 3:

Input: time =  "??:?? "
Output: 1440
Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 \ 60 = 1440 choices.

Constraints:

   `time` is a valid string of length `5` in the format `"hh:mm "`.
   `"00 " <= hh <= "23 "`
   `"00 " <= mm <= "59 "`
   Some of the digits might be replaced with `'?'` and need to be replaced with digits from `0` to `9`.*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.4000
P_10: 0.2000
P_25: 0.0800
P_50: 0.0400
P_100: 0.0200
recall_1: 0.5000
recall_5: 1.0000
recall_10: 1.0000
recall_25: 1.0000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 1.0000
ndcg_cut_10: 1.0000
ndcg_cut_25: 1.0000
ndcg_cut_50: 1.0000
ndcg_cut_100: 1.0000
map_cut_1: 0.5000
map_cut_5: 1.0000
map_cut_10: 1.0000
map_cut_25: 1.0000
map_cut_50: 1.0000
map_cut_100: 1.0000
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_949.txt
> from collections import deque<br>    """Given an array `arr` of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.<br><br>24-hour times are formatted as `"HH:MM "`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.<br><br>Return _the latest 24-hour time in `"HH:MM "` format_. If no valid time can be made, return an empty string.<br><br>Example 1:<br><br>Input: arr = \[1,2,3,4\]<br>Output:  "23:41 "<br>Explanation: The valid 24-hour times are  "12:34 ",  "12:43 ",  "13:24 ",  "13:42 ",  "14:23 ",  "14:32 ",  "21:34 ",  "21:43 ",  "23:14 ", and  "23:41 ". Of these times,  "23:41 " is the latest.<br><br>Example 2:<br><br>Input: arr = \[5,5,5,5\]<br>Output:  " "<br>Explanation: There are no valid 24-hour times as  "55:55 " is not valid.<br><br>Constraints:<br><br>   `arr.length == 4`<br>   `0 <= arr[i] <= 9`"""<br><br><br>def catMouseGame(graph):<br>    n = len(graph)<br>    status = [[[0]3 for _ in range(n)] for _ in range(n)]<br><br>    for i in range(1, n):<br>        status[i][i][1] = 2<br>        status[i][i][2] = 2<br>    queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)])<br><br>    while queue:<br>        pos_m, pos_c, t_type, t_result = queue.popleft()<br><br>        for prev in graph[pos_m if t_type == 1 else pos_c]:<br>            if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]):<br>                continue<br>            if status[prev][pos_c][3 - t_type]:<br>                continue<br>            queue.append((pos_c, prev, 3 - t_type, 3 - t_result))<br>            status[prev][pos_c][3 - t_type] = 3 - t_result<br><br>    return status[1][2][1]

### DOC[2] (GROUND TRUTH) leetcode/leetcode_1736.txt
> def maximumTime(time: str) - str:<br>    """You are given a string `time` in the form of `hh:mm`, where some of the digits in the string are hidden (represented by `?`).<br><br>The valid times are those inclusively between `00:00` and `23:59`.<br><br>Return _the latest valid time you can get from_ `time` _by replacing the hidden_ _digits_.<br><br>Example 1:<br><br>Input: time =  "2?:?0 "<br>Output:  "23:50 "<br>Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.<br><br>Example 2:<br><br>Input: time =  "0?:3? "<br>Output:  "09:39 "<br><br>Example 3:<br><br>Input: time =  "1?:22 "<br>Output:  "19:22 "<br><br>Constraints:<br><br>   `time` is in the format `hh:mm`.<br>   It is guaranteed that you can produce a valid time from the given string."""<br><br>    time_list = list(time)<br>    if time_list[0] == '?':<br>        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'<br>    if time_list[1] == '?':<br>        time_list[1] = '3' if time_list[0] == '2' else '9'<br>    if time_list[3] == '?':<br>        time_list[3] = '5'<br>    if time_list[4] == '?':<br>        time_list[4] = '9'<br>    return "".join(time_list)

### DOC[3] (IRRELEVANT) leetcode/leetcode_401.txt
> def readBinaryWatch(turnedOn: int):<br>    """A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.<br><br>   For example, the below binary watch reads `"4:51 "`.<br><br>Given an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in any order.<br><br>The hour must not contain a leading zero.<br><br>   For example, `"01:00 "` is not valid. It should be `"1:00 "`.<br><br>The minute must be consist of two digits and may contain a leading zero.<br><br>   For example, `"10:2 "` is not valid. It should be `"10:02 "`.<br><br>Example 1:<br><br>Input: turnedOn = 1<br>Output: \["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"\]<br><br>Example 2:<br><br>Input: turnedOn = 9<br>Output: \[\]<br><br>Constraints:<br><br>   `0 <= turnedOn <= 10`"""<br><br>    def count_bits(n):<br>        return bin(n).count('1')<br><br>    times = []<br>    for h in range(12):<br>        for m in range(60):<br>            if count_bits(h) + count_bits(m) == turnedOn:<br>                times.append(f"{h}:{m:02d}")<br>    return times

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_203255.txt
> def str_to_datetime(s, context='datetime'):<br>    """Set timestamp from an W3C Datetime Last-Modified value.<br><br>    The sitemaps.org specification says that <lastmod values<br>    must comply with the W3C Datetime format<br>    (http://www.w3.org/TR/NOTE-datetime). This is a restricted<br>    subset of ISO8601. In particular, all forms that include a<br>    time must include a timezone indication so there is no<br>    notion of local time (which would be tricky on the web). The<br>    forms allowed are:<br><br>        Year:<br>          YYYY (eg 1997)<br>        Year and month:<br>          YYYY-MM (eg 1997-07)<br>        Complete date:<br>          YYYY-MM-DD (eg 1997-07-16)<br>        Complete date plus hours and minutes:<br>          YYYY-MM-DDThh:mmTZD (eg 1997-07-16T19:20+01:00)<br>        Complete date plus hours, minutes and seconds:<br>          YYYY-MM-DDThh:mm:ssTZD (eg 1997-07-16T19:20:30+01:00)<br>        Complete date plus hours, minutes, seconds and a decimal fraction<br>        of a second<br>          YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45+01:00)<br>        where:<br>          TZD  = time zone designator (Z or +hh:mm or -hh:mm)<br><br>    We do not anticipate the YYYY and YYYY-MM forms being used but<br>    interpret them as YYYY-01-01 and YYYY-MM-01 respectively. All<br>    dates are interpreted as having time 00:00:00.0 UTC.<br><br>    Datetimes not specified to the level of seconds are intepreted<br>    as 00.0 seconds.<br>    """<br>    t = None<br>    if (s is None):<br>        return(t)<br>    if (s == ''):<br>        raise ValueError('Attempt to set empty %s' % (context))<br>    # Make a date into a full datetime<br>    m = re.match(r"\d\d\d\d(\-\d\d(\-\d\d)?)?$", s)<br>    if (m is not None):<br>        if (m.group(1) is None):<br>            s += '-01-01'<br>        elif (m.group(2) is None):<br>            s += '-01'<br>        s += 'T00:00:00Z'<br>    # Now have datetime with timezone info<br>    m = re.match(r"(.\d{2}:\d{2}:\d{2})(\.\d+)([^\d].)?$", s)<br>    # Chop out fractional seconds if present<br>    fractional_seconds = 0<br>    if (m is not None):<br>        s = m.group(1)<br>        if (m.group(3) is not None):<br>            s += m.group(3)<br>        fractional_seconds = float(m.group(2))<br>    # Now check that only allowed formats supplied (the parse<br>    # function in dateutil is rather lax) and separate out<br>    # timezone information to be handled separately<br>    #<br>    # Seems that one should be able to handle timezone offset<br>    # with dt.tzinfo module but this has variation in behavior<br>    # between python 2.6 and 2.7... so do here for now<br>    m = re.match(r"(\d\d\d\d\-\d\d\-\d\dT\d\d:\d\d(:\d\d)?)(Z|([+-])"<br>                 "(\d\d):(\d\d))$", s)<br>    if (m is None):<br>        raise ValueError("Bad datetime format (%s)" % s)<br>    str = m.group(1) + 'Z'<br>    dt = dateutil_parser.parse(str)<br>    offset_seconds = 0<br>    if (m.group(3) != 'Z'):<br>        hh = int(m.group(5))<br>        mm = int(m.group(6))<br>        if (hh  23 or mm  59):<br>            raise ValueError("Bad timezone offset (%s)" % s)<br>        offset_seconds = hh  3600 + mm  60<br>        if (m.group(4) == '-'):<br>            offset_seconds = -offset_seconds<br>    # timetuple() ignores timezone information so we have to add in<br>    # the offset here, and any fractional component of the seconds<br>    return(timegm(dt.timetuple()) + offset_seconds + fractional_seconds)

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_386993.txt
> def getDisplaySize(data_type_oid, type_modifier):<br>    """<br>    Returns the column display size for the given Vertica type with<br>    consideration of the type modifier.<br><br>    The display size of a column is the maximum number of characters needed to<br>    display data in character form.<br>    """<br><br>    if data_type_oid == VerticaType.BOOL:<br>        # T or F<br>        return 1<br>    elif data_type_oid == VerticaType.INT8:<br>        # a sign and 19 digits if signed or 20 digits if unsigned<br>        return 20<br>    elif data_type_oid == VerticaType.FLOAT8:<br>        # a sign, 15 digits, a decimal point, the letter E, a sign, and 3 digits<br>        return 22<br>    elif data_type_oid == VerticaType.NUMERIC:<br>        # a sign, precision digits, and a decimal point<br>        return getPrecision(data_type_oid, type_modifier) + 2<br>    elif data_type_oid == VerticaType.DATE:<br>        # yyyy-mm-dd, a space, and the calendar era (BC)<br>        return 13<br>    elif data_type_oid == VerticaType.TIME:<br>        seconds_precision = getPrecision(data_type_oid, type_modifier)<br>        if seconds_precision == 0:<br>            # hh:mm:ss<br>            return 8<br>        else:<br>            # hh:mm:ss.[fff...]<br>            return 9 + seconds_precision<br>    elif data_type_oid == VerticaType.TIMETZ:<br>        seconds_precision = getPrecision(data_type_oid, type_modifier)<br>        if seconds_precision == 0:<br>            # hh:mm:ss, a sign, hh:mm<br>            return 14<br>        else:<br>            # hh:mm:ss.[fff...], a sign, hh:mm<br>            return 15 + seconds_precision<br>    elif data_type_oid == VerticaType.TIMESTAMP:<br>        seconds_precision = getPrecision(data_type_oid, type_modifier)<br>        if seconds_precision == 0:<br>            # yyyy-mm-dd hh:mm:ss, a space, and the calendar era (BC)<br>            return 22<br>        else:<br>            # yyyy-mm-dd hh:mm:ss[.fff...], a space, and the calendar era (BC)<br>            return 23 + seconds_precision<br>    elif data_type_oid == VerticaType.TIMESTAMPTZ:<br>        seconds_precision = getPrecision(data_type_oid, type_modifier)<br>        if seconds_precision == 0:<br>            # yyyy-mm-dd hh:mm:ss, a sign, hh:mm, a space, and the calendar era (BC)<br>            return 28<br>        else:<br>            # yyyy-mm-dd hh:mm:ss.[fff...], a sign, hh:mm, a space, and the calendar era (BC)<br>            return 29 + seconds_precision<br>    elif data_type_oid in (VerticaType.INTERVAL, VerticaType.INTERVALYM):<br>        leading_precision = getIntervalLeadingPrecision(data_type_oid, type_modifier)<br>        seconds_precision = getPrecision(data_type_oid, type_modifier)<br>        interval_range = getIntervalRange(data_type_oid, type_modifier)<br>        if interval_range in ("Year", "Month", "Day", "Hour", "Minute"):<br>            # a sign, [range...]<br>            return 1 + leading_precision<br>        elif interval_range in ("Day to Hour", "Year to Month", "Hour to Minute"):<br>            # a sign, [dd...] hh; a sign, [yy...]-mm; a sign, [hh...]:mm<br>            return 1 + leading_precision + 3<br>        elif interval_range == "Day to Minute":<br>            # a sign, [dd...] hh:mm<br>            return 1 + leading_precision + 6<br>        elif interval_range == "Second":<br>            if seconds_precision == 0:<br>                # a sign, [ss...]<br>                return 1 + leading_precision<br>            else:<br>                # a sign, [ss...].[fff...]<br>                return 1 + leading_precision + 1 + seconds_precision<br>        elif interval_range == "Day to Second":<br>            if seconds_precision == 0:<br>                # a sign, [dd...] hh:mm:ss<br>                return 1 + leading_precision + 9<br>            else:<br>                # a sign, [dd...] hh:mm:ss.[fff...]<br>                return 1 + leading_precision + 10 + seconds_precision<br>        elif interval_range == "Hour to Second":<br>            if seconds_precision == 0:<br>                # a sign, [hh...]:mm:ss<br>                return 1 + leading_precision + 6<br>            else:<br>                # a sign, [hh...]:mm:ss.[fff...]<br>                return 1 + leading_precision + 7 + seconds_precision<br>        elif interval_range == "Minute to Second":<br>            if seconds_precision == 0:<br>                # a sign, [mm...]:ss<br>                return 1 + leading_precision + 3<br>            else:<br>                # a sign, [mm...]:ss.[fff...]<br>                return 1 + leading_precision + 4 + seconds_precision<br>    elif data_type_oid == VerticaType.UUID:<br>        # aaaaaaaa-bbbb-cccc-dddd-eeeeeeeeeeee<br>        return 36<br>    elif data_type_oid in (VerticaType.CHAR,<br>                           VerticaType.VARCHAR,<br>                           VerticaType.BINARY,<br>                           VerticaType.VARBINARY,<br>                           VerticaType.UNKNOWN):<br>        # the defined maximum octet length of the column<br>        return MAX_STRING_LEN if type_modifier <= -1 else (type_modifier - 4)<br>    elif data_type_oid in (VerticaType.LONGVARCHAR,<br>                           VerticaType.LONGVARBINARY):<br>        return MAX_LONG_STRING_LEN if type_modifier <= -1 else (type_modifier - 4)<br>    else:<br>        return None


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_949.txt
> from collections import deque<br>    """Given an array `arr` of 4 digits, find the latest 24-hour time that can be made using each digit exactly once.<br><br>24-hour times are formatted as `"HH:MM "`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.<br><br>Return _the latest 24-hour time in `"HH:MM "` format_. If no valid time can be made, return an empty string.<br><br>Example 1:<br><br>Input: arr = \[1,2,3,4\]<br>Output:  "23:41 "<br>Explanation: The valid 24-hour times are  "12:34 ",  "12:43 ",  "13:24 ",  "13:42 ",  "14:23 ",  "14:32 ",  "21:34 ",  "21:43 ",  "23:14 ", and  "23:41 ". Of these times,  "23:41 " is the latest.<br><br>Example 2:<br><br>Input: arr = \[5,5,5,5\]<br>Output:  " "<br>Explanation: There are no valid 24-hour times as  "55:55 " is not valid.<br><br>Constraints:<br><br>   `arr.length == 4`<br>   `0 <= arr[i] <= 9`"""<br><br><br>def catMouseGame(graph):<br>    n = len(graph)<br>    status = [[[0]3 for _ in range(n)] for _ in range(n)]<br><br>    for i in range(1, n):<br>        status[i][i][1] = 2<br>        status[i][i][2] = 2<br>    queue = deque([(i, i, t, 2) for i in range(1, n) for t in (1, 2)])<br><br>    while queue:<br>        pos_m, pos_c, t_type, t_result = queue.popleft()<br><br>        for prev in graph[pos_m if t_type == 1 else pos_c]:<br>            if (t_type == 2 and prev == 0) or (t_result == 2 and status[prev][pos_c][3 - t_type]):<br>                continue<br>            if status[prev][pos_c][3 - t_type]:<br>                continue<br>            queue.append((pos_c, prev, 3 - t_type, 3 - t_result))<br>            status[prev][pos_c][3 - t_type] = 3 - t_result<br><br>    return status[1][2][1]

### GROUND TRUTH 1, ranked 1, leetcode/leetcode_1736.txt
> def maximumTime(time: str) - str:<br>    """You are given a string `time` in the form of `hh:mm`, where some of the digits in the string are hidden (represented by `?`).<br><br>The valid times are those inclusively between `00:00` and `23:59`.<br><br>Return _the latest valid time you can get from_ `time` _by replacing the hidden_ _digits_.<br><br>Example 1:<br><br>Input: time =  "2?:?0 "<br>Output:  "23:50 "<br>Explanation: The latest hour beginning with the digit '2' is 23 and the latest minute ending with the digit '0' is 50.<br><br>Example 2:<br><br>Input: time =  "0?:3? "<br>Output:  "09:39 "<br><br>Example 3:<br><br>Input: time =  "1?:22 "<br>Output:  "19:22 "<br><br>Constraints:<br><br>   `time` is in the format `hh:mm`.<br>   It is guaranteed that you can produce a valid time from the given string."""<br><br>    time_list = list(time)<br>    if time_list[0] == '?':<br>        time_list[0] = '2' if time_list[1] <= '3' or time_list[1] == '?' else '1'<br>    if time_list[1] == '?':<br>        time_list[1] = '3' if time_list[0] == '2' else '9'<br>    if time_list[3] == '?':<br>        time_list[3] = '5'<br>    if time_list[4] == '?':<br>        time_list[4] = '9'<br>    return "".join(time_list)
