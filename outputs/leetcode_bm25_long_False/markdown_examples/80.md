# Query `80`

## Original Question

*You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.

You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.

Return _the maximum sum of values that you can receive by attending events._

Example 1:

Input: events = \[\[1,2,4\],\[3,4,3\],\[2,3,1\]\], k = 2
Output: 7
Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.

Example 2:

Input: events = \[\[1,2,4\],\[3,4,3\],\[2,3,10\]\], k = 2
Output: 10
Explanation: Choose event 2 for a total value of 10.
Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.

Example 3:

Input: events = \[\[1,1,1\],\[2,2,2\],\[3,3,3\],\[4,4,4\]\], k = 3
Output: 9
Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.

Constraints:

   `1 <= k <= events.length`
   `1 <= k  events.length <= 106`
   `1 <= startDayi <= endDayi <= 109`
   `1 <= valuei <= 106`*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.4000
P_10: 0.2000
P_25: 0.0800
P_50: 0.0600
P_100: 0.0300
recall_1: 0.2500
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.7500
recall_100: 0.7500
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.6367
ndcg_cut_10: 0.6367
ndcg_cut_25: 0.6367
ndcg_cut_50: 0.7091
ndcg_cut_100: 0.7091
map_cut_1: 0.2500
map_cut_5: 0.5000
map_cut_10: 0.5000
map_cut_25: 0.5000
map_cut_50: 0.5183
map_cut_100: 0.5183
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_1353.txt
> import heapq<br>    """You are given an array of `events` where `events[i] = [startDayi, endDayi]`. Every event `i` starts at `startDayi` and ends at `endDayi`.<br><br>You can attend an event `i` at any day `d` where `startTimei <= d <= endTimei`. You can only attend one event at any time `d`.<br><br>Return _the maximum number of events you can attend_.<br><br>Example 1:<br><br>Input: events = \[\[1,2\],\[2,3\],\[3,4\]\]<br>Output: 3<br>Explanation: You can attend all the three events.<br>One way to attend them all is as shown.<br>Attend the first event on day 1.<br>Attend the second event on day 2.<br>Attend the third event on day 3.<br><br>Example 2:<br><br>Input: events= \[\[1,2\],\[2,3\],\[3,4\],\[1,2\]\]<br>Output: 4<br><br>Constraints:<br><br>   `1 <= events.length <= 105`<br>   `events[i].length == 2`<br>   `1 <= startDayi <= endDayi <= 105`"""<br><br><br>def maxEvents(events: List[List[int]]) - int:<br>    events.sort(key=lambda x: x[0])<br>    min_heap = []<br>    event_count, day = 0, 0<br><br>    for event in events:<br>        while min_heap and min_heap[0] < event[0]:<br>            heapq.heappop(min_heap)<br>        heapq.heappush(min_heap, event[1])<br>        event_count += 1<br>        day += 1<br><br>    return event_count

### DOC[2] (GROUND TRUTH) leetcode/leetcode_2054.txt
> def find_chair(times, target_friend):<br>    """You are given a 0-indexed 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.<br><br>Return _this maximum sum._<br><br>Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.<br><br>Example 1:<br><br>Input: events = \[\[1,3,2\],\[4,5,2\],\[2,4,3\]\]<br>Output: 4<br>Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.<br><br>Example 2:<br><br>Input: events = \[\[1,3,2\],\[4,5,2\],\[1,5,5\]\]<br>Output: 5<br>Explanation: Choose event 2 for a sum of 5.<br><br>Example 3:<br><br>Input: events = \[\[1,5,3\],\[1,5,1\],\[6,6,5\]\]<br>Output: 8<br>Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.<br><br>Constraints:<br><br>   `2 <= events.length <= 105`<br>   `events[i].length == 3`<br>   `1 <= startTimei <= endTimei <= 109`<br>   `1 <= valuei <= 106`"""<br><br>    n = len(times)<br>    events = []<br>    for i, (arrival, leaving) in enumerate(times):<br>        events.append((arrival, i))<br>        events.append((leaving, ~i))<br>    events.sort()<br>    chairs = [-1]  n<br>    available_chairs = sorted(range(n))<br>    for time, friend_id in events:<br>        if friend_id = 0:<br>            chairs[friend_id] = available_chairs.pop(0)<br>            if friend_id == target_friend:<br>                return chairs[friend_id]<br>        else:<br>            available_chairs.append(chairs[~friend_id])<br>            available_chairs.sort()<br>    return -1

### DOC[3] (IRRELEVANT) leetcode/leetcode_453.txt
> def min_moves(nums):<br>    """Given an integer array `nums` of size `n`, return _the minimum number of moves required to make all array elements equal_.<br><br>In one move, you can increment `n - 1` elements of the array by `1`.<br><br>Example 1:<br><br>Input: nums = \[1,2,3\]<br>Output: 3<br>Explanation: Only three moves are needed (remember each move increments two elements):<br>\[1,2,3\]  =  \[2,3,3\]  =  \[3,4,3\]  =  \[4,4,4\]<br><br>Example 2:<br><br>Input: nums = \[1,1,1\]<br>Output: 0<br><br>Constraints:<br><br>   `n == nums.length`<br>   `1 <= nums.length <= 105`<br>   `-109 <= nums[i] <= 109`<br>   The answer is guaranteed to fit in a 32-bit integer."""<br><br>    min_element = min(nums)<br>    moves = sum(num - min_element for num in nums)<br>    return moves

### DOC[4] (IRRELEVANT) leetcode/leetcode_1807.txt
> def minPartitions(n: str) - int:<br>    """You are given a string `s` that contains some bracket pairs, with each pair containing a non-empty key.<br><br>   For example, in the string `"(name)is(age)yearsold "`, there are two bracket pairs that contain the keys `"name "` and `"age "`.<br><br>You know the values of a wide range of keys. This is represented by a 2D string array `knowledge` where each `knowledge[i] = [keyi, valuei]` indicates that key `keyi` has a value of `valuei`.<br><br>You are tasked to evaluate all of the bracket pairs. When you evaluate a bracket pair that contains some key `keyi`, you will:<br><br>   Replace `keyi` and the bracket pair with the key's corresponding `valuei`.<br>   If you do not know the value of the key, you will replace `keyi` and the bracket pair with a question mark `"? "` (without the quotation marks).<br><br>Each key will appear at most once in your `knowledge`. There will not be any nested brackets in `s`.<br><br>Return _the resulting string after evaluating all of the bracket pairs._<br><br>Example 1:<br><br>Input: s =  "(name)is(age)yearsold ", knowledge = \[\[ "name ", "bob "\],\[ "age ", "two "\]\]<br>Output:  "bobistwoyearsold "<br>Explanation:<br>The key  "name " has a value of  "bob ", so replace  "(name) " with  "bob ".<br>The key  "age " has a value of  "two ", so replace  "(age) " with  "two ".<br><br>Example 2:<br><br>Input: s =  "hi(name) ", knowledge = \[\[ "a ", "b "\]\]<br>Output:  "hi? "<br>Explanation: As you do not know the value of the key  "name ", replace  "(name) " with  "? ".<br><br>Example 3:<br><br>Input: s =  "(a)(a)(a)aaa ", knowledge = \[\[ "a ", "yes "\]\]<br>Output:  "yesyesyesaaa "<br>Explanation: The same key can appear multiple times.<br>The key  "a " has a value of  "yes ", so replace all occurrences of  "(a) " with  "yes ".<br>Notice that the  "a "s not in a bracket pair are not evaluated.<br><br>Constraints:<br><br>   `1 <= s.length <= 105`<br>   `0 <= knowledge.length <= 105`<br>   `knowledge[i].length == 2`<br>   `1 <= keyi.length, valuei.length <= 10`<br>   `s` consists of lowercase English letters and round brackets `'('` and `')'`.<br>   Every open bracket `'('` in `s` will have a corresponding close bracket `')'`.<br>   The key in each bracket pair of `s` will be non-empty.<br>   There will not be any nested bracket pairs in `s`.<br>   `keyi` and `valuei` consist of lowercase English letters.<br>   Each `keyi` in `knowledge` is unique."""<br><br>    max_digit = 0<br>    for c in n:<br>        max_digit = max(max_digit, int(c))<br>        if max_digit == 9:<br>            break<br>    return max_digit

### DOC[5] (IRRELEVANT) leetcode/leetcode_552.txt
> def checkRecord(n: int) - int:<br>    """An attendance record for a student can be represented as a string where each character signifies whether the student was absent, late, or present on that day. The record only contains the following three characters:<br><br>   `'A'`: Absent.<br>   `'L'`: Late.<br>   `'P'`: Present.<br><br>Any student is eligible for an attendance award if they meet both of the following criteria:<br><br>   The student was absent (`'A'`) for strictly fewer than 2 days total.<br>   The student was never late (`'L'`) for 3 or more consecutive days.<br><br>Given an integer `n`, return _the number of possible attendance records of length_ `n` _that make a student eligible for an attendance award. The answer may be very large, so return it modulo_ `109 + 7`.<br><br>Example 1:<br><br>Input: n = 2<br>Output: 8<br>Explanation: There are 8 records with length 2 that are eligible for an award:<br> "PP ",  "AP ",  "PA ",  "LP ",  "PL ",  "AL ",  "LA ",  "LL "<br>Only  "AA " is not eligible because there are 2 absences (there need to be fewer than 2).<br><br>Example 2:<br><br>Input: n = 1<br>Output: 3<br><br>Example 3:<br><br>Input: n = 10101<br>Output: 183236316<br><br>Constraints:<br><br>   `1 <= n <= 105`"""<br><br>    M = 1000000007<br>    dp = [1]  6  # [latent state 0, latent state 1, ..., latent state 5]<br>    while n:<br>        next_dp = [0]  6<br>        next_dp[0] = (dp[0] + dp[1] + dp[2]) % M<br>        next_dp[1] = dp[0]<br>        next_dp[2] = dp[1]<br>        next_dp[3] = (dp[3] + dp[4] + dp[5]) % M<br>        next_dp[4] = dp[3]<br>        next_dp[5] = dp[4]<br>        dp = next_dp<br>        n -= 1<br>    return sum(dp) % M


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_1353.txt
> import heapq<br>    """You are given an array of `events` where `events[i] = [startDayi, endDayi]`. Every event `i` starts at `startDayi` and ends at `endDayi`.<br><br>You can attend an event `i` at any day `d` where `startTimei <= d <= endTimei`. You can only attend one event at any time `d`.<br><br>Return _the maximum number of events you can attend_.<br><br>Example 1:<br><br>Input: events = \[\[1,2\],\[2,3\],\[3,4\]\]<br>Output: 3<br>Explanation: You can attend all the three events.<br>One way to attend them all is as shown.<br>Attend the first event on day 1.<br>Attend the second event on day 2.<br>Attend the third event on day 3.<br><br>Example 2:<br><br>Input: events= \[\[1,2\],\[2,3\],\[3,4\],\[1,2\]\]<br>Output: 4<br><br>Constraints:<br><br>   `1 <= events.length <= 105`<br>   `events[i].length == 2`<br>   `1 <= startDayi <= endDayi <= 105`"""<br><br><br>def maxEvents(events: List[List[int]]) - int:<br>    events.sort(key=lambda x: x[0])<br>    min_heap = []<br>    event_count, day = 0, 0<br><br>    for event in events:<br>        while min_heap and min_heap[0] < event[0]:<br>            heapq.heappop(min_heap)<br>        heapq.heappush(min_heap, event[1])<br>        event_count += 1<br>        day += 1<br><br>    return event_count

### GROUND TRUTH 1, ranked 40, leetcode/leetcode_2008.txt
> def minOperationsToFlip(expression: str) - int:<br>    """There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi.<br><br>The passengers are represented by a 0-indexed 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip.<br><br>For each passenger `i` you pick up, you earn `endi - starti + tipi` dollars. You may only drive at most one passenger at a time.<br><br>Given `n` and `rides`, return _the maximum number of dollars you can earn by picking up the passengers optimally._<br><br>Note: You may drop off a passenger and pick up a different passenger at the same point.<br><br>Example 1:<br><br>Input: n = 5, rides = \[\[2,5,4\],\[1,5,1\]\]<br>Output: 7<br>Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.<br><br>Example 2:<br><br>Input: n = 20, rides = \[\[1,6,1\],\[3,10,2\],\[10,12,3\],\[11,12,2\],\[12,15,2\],\[13,18,1\]\]<br>Output: 20<br>Explanation: We will pick up the following passengers:<br>- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.<br>- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.<br>- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.<br>We earn 9 + 5 + 6 = 20 dollars in total.<br><br>Constraints:<br><br>   `1 <= n <= 105`<br>   `1 <= rides.length <= 3  104`<br>   `rides[i].length == 3`<br>   `1 <= starti < endi <= n`<br>   `1 <= tipi <= 105`"""<br><br>    zero, one, op = [0], [0], []<br>    for c in expression:<br>        if c == '&':<br>            op.append(1)<br>        elif c == '|':<br>            op.append(2)<br>        elif c.isdigit():<br>            if c == '0':<br>                one.append(1)<br>                zero.append(0)<br>            else:<br>                zero.append(1)<br>                one.append(0)<br>        elif c == ')':<br>            cur_op = op.pop()<br>            x = zero.pop()<br>            y = one.pop() + 1<br>            if cur_op == 1:<br>                new_zero = max(x, y)<br>                new_one = one[-1] + min(x, zero[-1])<br>            else:<br>                new_zero = zero[-1] + min(x, one[-1])<br>                new_one = max(y, one[-1])<br>            zero.pop()<br>            one.pop()<br>            zero.append(new_zero)<br>            one.append(new_one)<br>    return zero[-1] + 1

### GROUND TRUTH 2, ranked 1, leetcode/leetcode_2054.txt
> def find_chair(times, target_friend):<br>    """You are given a 0-indexed 2D integer array of `events` where `events[i] = [startTimei, endTimei, valuei]`. The `ith` event starts at `startTimei` and ends at `endTimei`, and if you attend this event, you will receive a value of `valuei`. You can choose at most two non-overlapping events to attend such that the sum of their values is maximized.<br><br>Return _this maximum sum._<br><br>Note that the start time and end time is inclusive: that is, you cannot attend two events where one of them starts and the other ends at the same time. More specifically, if you attend an event with end time `t`, the next event must start at or after `t + 1`.<br><br>Example 1:<br><br>Input: events = \[\[1,3,2\],\[4,5,2\],\[2,4,3\]\]<br>Output: 4<br>Explanation: Choose the green events, 0 and 1 for a sum of 2 + 2 = 4.<br><br>Example 2:<br><br>Input: events = \[\[1,3,2\],\[4,5,2\],\[1,5,5\]\]<br>Output: 5<br>Explanation: Choose event 2 for a sum of 5.<br><br>Example 3:<br><br>Input: events = \[\[1,5,3\],\[1,5,1\],\[6,6,5\]\]<br>Output: 8<br>Explanation: Choose events 0 and 2 for a sum of 3 + 5 = 8.<br><br>Constraints:<br><br>   `2 <= events.length <= 105`<br>   `events[i].length == 3`<br>   `1 <= startTimei <= endTimei <= 109`<br>   `1 <= valuei <= 106`"""<br><br>    n = len(times)<br>    events = []<br>    for i, (arrival, leaving) in enumerate(times):<br>        events.append((arrival, i))<br>        events.append((leaving, ~i))<br>    events.sort()<br>    chairs = [-1]  n<br>    available_chairs = sorted(range(n))<br>    for time, friend_id in events:<br>        if friend_id = 0:<br>            chairs[friend_id] = available_chairs.pop(0)<br>            if friend_id == target_friend:<br>                return chairs[friend_id]<br>        else:<br>            available_chairs.append(chairs[~friend_id])<br>            available_chairs.sort()<br>    return -1

### GROUND TRUTH 3, ranked not in top 100, leetcode/leetcode_2402.txt
> import heapq<br>    """You are given an integer `n`. There are `n` rooms numbered from `0` to `n - 1`.<br><br>You are given a 2D integer array `meetings` where `meetings[i] = [starti, endi]` means that a meeting will be held during the half-closed time interval `[starti, endi)`. All the values of `starti` are unique.<br><br>Meetings are allocated to rooms in the following manner:<br><br>1.  Each meeting will take place in the unused room with the lowest number.<br>2.  If there are no available rooms, the meeting will be delayed until a room becomes free. The delayed meeting should have the same duration as the original meeting.<br>3.  When a room becomes unused, meetings that have an earlier original start time should be given the room.<br><br>Return _the number of the room that held the most meetings._ If there are multiple rooms, return _the room with the lowest number._<br><br>A half-closed interval `[a, b)` is the interval between `a` and `b` including `a` and not including `b`.<br><br>Example 1:<br><br>Input: n = 2, meetings = \[\[0,10\],\[1,5\],\[2,7\],\[3,4\]\]<br>Output: 0<br>Explanation:<br>- At time 0, both rooms are not being used. The first meeting starts in room 0.<br>- At time 1, only room 1 is not being used. The second meeting starts in room 1.<br>- At time 2, both rooms are being used. The third meeting is delayed.<br>- At time 3, both rooms are being used. The fourth meeting is delayed.<br>- At time 5, the meeting in room 1 finishes. The third meeting starts in room 1 for the time period \[5,10).<br>- At time 10, the meetings in both rooms finish. The fourth meeting starts in room 0 for the time period \[10,11).<br>Both rooms 0 and 1 held 2 meetings, so we return 0. <br><br>Example 2:<br><br>Input: n = 3, meetings = \[\[1,20\],\[2,10\],\[3,5\],\[4,9\],\[6,8\]\]<br>Output: 1<br>Explanation:<br>- At time 1, all three rooms are not being used. The first meeting starts in room 0.<br>- At time 2, rooms 1 and 2 are not being used. The second meeting starts in room 1.<br>- At time 3, only room 2 is not being used. The third meeting starts in room 2.<br>- At time 4, all three rooms are being used. The fourth meeting is delayed.<br>- At time 5, the meeting in room 2 finishes. The fourth meeting starts in room 2 for the time period \[5,10).<br>- At time 6, all three rooms are being used. The fifth meeting is delayed.<br>- At time 10, the meetings in rooms 1 and 2 finish. The fifth meeting starts in room 1 for the time period \[10,12).<br>Room 0 held 1 meeting while rooms 1 and 2 each held 2 meetings, so we return 1. <br><br>Constraints:<br><br>   `1 <= n <= 100`<br>   `1 <= meetings.length <= 105`<br>   `meetings[i].length == 2`<br>   `0 <= starti < endi <= 5  105`<br>   All the values of `starti` are unique."""<br><br><br>def most_visited_room(n, meetings):<br>    meetings.sort()<br>    pq = []<br>    rooms = [0]  n<br>    <br>    for start, end in meetings:<br>        while pq and pq[0][0] <= start:<br>            _, room = heapq.heappop(pq)<br>            rooms[room] += 1<br>        heapq.heappush(pq, (end, len(pq) % n))<br>    <br>    return rooms.index(max(rooms))
