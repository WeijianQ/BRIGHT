# Query `54`

## Original Question

*You are given an `m x n` `grid` where each cell can have one of three values:

   `0` representing an empty cell,
   `1` representing a fresh orange, or
   `2` representing a rotten orange.

Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return _the minimum number of minutes that must elapse until no cell has a fresh orange_. If _this is impossible, return_ `-1`.

Example 1:

Input: grid = \[\[2,1,1\],\[1,1,0\],\[0,1,1\]\]
Output: 4

Example 2:

Input: grid = \[\[2,1,1\],\[0,1,1\],\[1,0,1\]\]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.

Example 3:

Input: grid = \[\[0,2\]\]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.

Constraints:

   `m == grid.length`
   `n == grid[i].length`
   `1 <= m, n <= 10`
   `grid[i][j]` is `0`, `1`, or `2`.*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0400
P_100: 0.0200
recall_1: 0.5000
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.6131
ndcg_cut_10: 0.6131
ndcg_cut_25: 0.6131
ndcg_cut_50: 0.7358
ndcg_cut_100: 0.7358
map_cut_1: 0.5000
map_cut_5: 0.5000
map_cut_10: 0.5000
map_cut_25: 0.5000
map_cut_50: 0.5323
map_cut_100: 0.5323
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2258.txt
> from collections import deque<br>    """You are given a 0-indexed 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:<br><br>   `0` represents grass,<br>   `1` represents fire,<br>   `2` represents a wall that you and fire cannot pass through.<br><br>You are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.<br><br>Return _the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can always reach the safehouse regardless of the minutes stayed, return `109`.<br><br>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.<br><br>A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).<br><br>Example 1:<br><br>Input: grid = \[\[0,2,0,0,0,0,0\],\[0,0,0,2,2,1,0\],\[0,2,0,0,1,2,0\],\[0,0,2,2,2,0,2\],\[0,0,0,0,0,0,0\]\]<br>Output: 3<br>Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.<br>You will still be able to safely reach the safehouse.<br>Staying for more than 3 minutes will not allow you to safely reach the safehouse.<br><br>Example 2:<br><br>Input: grid = \[\[0,0,0,0\],\[0,1,2,0\],\[0,2,0,0\]\]<br>Output: -1<br>Explanation: The figure above shows the scenario where you immediately move towards the safehouse.<br>Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.<br>Thus, -1 is returned.<br><br>Example 3:<br><br>Input: grid = \[\[0,0,0\],\[2,2,0\],\[1,2,0\]\]<br>Output: 1000000000<br>Explanation: The figure above shows the initial grid.<br>Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.<br>Thus, 109 is returned.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `2 <= m, n <= 300`<br>   `4 <= m  n <= 2  104`<br>   `grid[i][j]` is either `0`, `1`, or `2`.<br>   `grid[0][0] == grid[m - 1][n - 1] == 0`"""<br><br><br>dx = [0, 1, 0, -1]<br>dy = [1, 0, -1, 0]<br><br>def getMaxSafeMinutes(grid):<br>    m, n = len(grid), len(grid[0])<br>    dist = [[-1 for _ in range(n)] for _ in range(m)]<br>    q = deque()<br><br>    if grid[m - 1][n - 1] != 1:<br>        dist[m - 1][n - 1] = 0<br>        q.append((m - 1, n - 1))<br><br>    while q:<br>        x, y = q.popleft()<br>        for d in range(4):<br>            nx, ny = x + dx[d], y + dy[d]<br>            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:<br>                dist[nx][ny] = dist[x][y] + 1<br>                q.append((nx, ny))<br><br>    if dist[0][0] == -1:<br>        return -1<br><br>    res = 0<br>    for test in range(dist[0][0], int(1e9)):<br>        ok = True<br>        for x in range(m):<br>            for y in range(n):<br>                if grid[x][y] == 1:<br>                    for d in range(4):<br>                        nx, ny = x + dx[d], y + dy[d]<br>                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:<br>                            break<br>                    else:<br>                        ok = False<br>                        break<br>        if ok:<br>            res = test<br>        else:<br>            break<br>    return res

### DOC[2] (IRRELEVANT) leetcode/leetcode_928.txt
> def surfaceArea(grid):<br>    """You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.<br><br>Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.<br><br>Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops.<br><br>We will remove exactly one node from `initial`, completely removing it and any connections from this node to any other node.<br><br>Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.<br><br>Example 1:<br><br>Input: graph = \[\[1,1,0\],\[1,1,0\],\[0,0,1\]\], initial = \[0,1\]<br>Output: 0<br><br>Example 2:<br><br>Input: graph = \[\[1,1,0\],\[1,1,1\],\[0,1,1\]\], initial = \[0,1\]<br>Output: 1<br><br>Example 3:<br><br>Input: graph = \[\[1,1,0,0\],\[1,1,1,0\],\[0,1,1,1\],\[0,0,1,1\]\], initial = \[0,1\]<br>Output: 1<br><br>Constraints:<br><br>   `n == graph.length`<br>   `n == graph[i].length`<br>   `2 <= n <= 300`<br>   `graph[i][j]` is `0` or `1`.<br>   `graph[i][j] == graph[j][i]`<br>   `graph[i][i] == 1`<br>   `1 <= initial.length < n`<br>   `0 <= initial[i] <= n - 1`<br>   All the integers in `initial` are unique."""<br><br>    n = len(grid)<br>    area = 0<br><br>    for i in range(n):<br>        for j in range(n):<br>            if grid[i][j]:<br>                area += 4  grid[i][j] + 2<br>                if i  0:<br>                    area -= 2  min(grid[i][j], grid[i - 1][j])<br>                if j  0:<br>                    area -= 2  min(grid[i][j], grid[i][j - 1])<br><br>    return area

### DOC[3] (IRRELEVANT) leetcode/leetcode_1411.txt
> class ListNode:<br>    """You have a `grid` of size `n x 3` and you want to paint each cell of the grid with exactly one of the three colors: Red, Yellow, or Green while making sure that no two adjacent cells have the same color (i.e., no two cells that share vertical or horizontal sides have the same color).<br><br>Given `n` the number of rows of the grid, return _the number of ways_ you can paint this `grid`. As the answer may grow large, the answer must be computed modulo `109 + 7`.<br><br>Example 1:<br><br>Input: n = 1<br>Output: 12<br>Explanation: There are 12 possible way to paint the grid as shown.<br><br>Example 2:<br><br>Input: n = 5000<br>Output: 30228214<br><br>Constraints:<br><br>   `n == grid.length`<br>   `1 <= n <= 5000`"""<br><br>    def __init__(self, val=0, next=None):<br>        self.val = val<br>        self.next = next<br><br>def getDecimalValue(head: ListNode) - int:<br>    num = 0<br>    while head:<br>        num = (num << 1) | head.val<br>        head = head.next<br>    return num

### DOC[4] (IRRELEVANT) leetcode/leetcode_2203.txt
> from heapq import heappop, heappush<br>    """You are given an integer `n` denoting the number of nodes of a weighted directed graph. The nodes are numbered from `0` to `n - 1`.<br><br>You are also given a 2D integer array `edges` where `edges[i] = [fromi, toi, weighti]` denotes that there exists a directed edge from `fromi` to `toi` with weight `weighti`.<br><br>Lastly, you are given three distinct integers `src1`, `src2`, and `dest` denoting three distinct nodes of the graph.<br><br>Return _the minimum weight of a subgraph of the graph such that it is possible to reach_ `dest` _from both_ `src1` _and_ `src2` _via a set of edges of this subgraph_. In case such a subgraph does not exist, return `-1`.<br><br>A subgraph is a graph whose vertices and edges are subsets of the original graph. The weight of a subgraph is the sum of weights of its constituent edges.<br><br>Example 1:<br><br>Input: n = 6, edges = \[\[0,2,2\],\[0,5,6\],\[1,0,3\],\[1,4,5\],\[2,1,1\],\[2,3,3\],\[2,3,4\],\[3,4,2\],\[4,5,1\]\], src1 = 0, src2 = 1, dest = 5<br>Output: 9<br>Explanation:<br>The above figure represents the input graph.<br>The blue edges represent one of the subgraphs that yield the optimal answer.<br>Note that the subgraph \[\[1,0,3\],\[0,5,6\]\] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.<br><br>Example 2:<br><br>Input: n = 3, edges = \[\[0,1,1\],\[2,1,1\]\], src1 = 0, src2 = 1, dest = 2<br>Output: -1<br>Explanation:<br>The above figure represents the input graph.<br>It can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.<br><br>Constraints:<br><br>   `3 <= n <= 105`<br>   `0 <= edges.length <= 105`<br>   `edges[i].length == 3`<br>   `0 <= fromi, toi, src1, src2, dest <= n - 1`<br>   `fromi != toi`<br>   `src1`, `src2`, and `dest` are pairwise distinct.<br>   `1 <= weight[i] <= 105`"""<br><br>from sys import maxsize<br><br>def dijkstra(src, adj):<br>    dist = [maxsize]  len(adj)<br>    dist[src] = 0<br>    pq = [(0, src)]<br><br>    while pq:<br>        d, u = heappop(pq)<br>        if d != dist[u]:<br>            continue<br>        for v, w in adj[u]:<br>            if d + w < dist[v]:<br>                dist[v] = d + w<br>                heappush(pq, (dist[v], v))<br><br>    return dist<br><br>def min_weight_subgraph(n, edges, src1, src2, dest):<br>    adj = [[] for _ in range(n)]<br>    for u, v, w in edges:<br>        adj[u].append((v, w))<br><br>    dist1 = dijkstra(src1, adj)<br>    dist2 = dijkstra(src2, adj)<br><br>    res = dist1[dest] + dist2[dest]<br>    for u, v, w in edges:<br>        res = min(res, dist1[u] + dist2[v] + w)<br>        res = min(res, dist1[v] + dist2[u] + w)<br><br>    return res if res != maxsize else -1

### DOC[5] (IRRELEVANT) leetcode/leetcode_1947.txt
> def count_different_subsequence_GCDs(nums):<br>    """There is a survey that consists of `n` questions where each question's answer is either `0` (no) or `1` (yes).<br><br>The survey was given to `m` students numbered from `0` to `m - 1` and `m` mentors numbered from `0` to `m - 1`. The answers of the students are represented by a 2D integer array `students` where `students[i]` is an integer array that contains the answers of the `ith` student (0-indexed). The answers of the mentors are represented by a 2D integer array `mentors` where `mentors[j]` is an integer array that contains the answers of the `jth` mentor (0-indexed).<br><br>Each student will be assigned to one mentor, and each mentor will have one student assigned to them. The compatibility score of a student-mentor pair is the number of answers that are the same for both the student and the mentor.<br><br>   For example, if the student's answers were `[1, 0, 1]` and the mentor's answers were `[0, 0, 1]`, then their compatibility score is 2 because only the second and the third answers are the same.<br><br>You are tasked with finding the optimal student-mentor pairings to maximize the sum of the compatibility scores.<br><br>Given `students` and `mentors`, return _the maximum compatibility score sum that can be achieved._<br><br>Example 1:<br><br>Input: students = \[\[1,1,0\],\[1,0,1\],\[0,0,1\]\], mentors = \[\[1,0,0\],\[0,0,1\],\[1,1,0\]\]<br>Output: 8<br>Explanation: We assign students to mentors in the following way:<br>- student 0 to mentor 2 with a compatibility score of 3.<br>- student 1 to mentor 0 with a compatibility score of 2.<br>- student 2 to mentor 1 with a compatibility score of 3.<br>The compatibility score sum is 3 + 2 + 3 = 8.<br><br>Example 2:<br><br>Input: students = \[\[0,0\],\[0,0\],\[0,0\]\], mentors = \[\[1,1\],\[1,1\],\[1,1\]\]<br>Output: 0<br>Explanation: The compatibility score of any student-mentor pair is 0.<br><br>Constraints:<br><br>   `m == students.length == mentors.length`<br>   `n == students[i].length == mentors[j].length`<br>   `1 <= m, n <= 8`<br>   `students[i][k]` is either `0` or `1`.<br>   `mentors[j][k]` is either `0` or `1`."""<br><br>    maximum = max(nums)<br>    gcd_count = [0]  (maximum + 1)<br>    <br>    for num in nums:<br>        for i in range(1, int(num0.5) + 1):<br>            if num % i == 0:<br>                gcd_count[i] += 1<br>                if i  i != num:<br>                    gcd_count[num // i] += 1<br>                    <br>    different_GCDs = sum(1 for count in gcd_count if count  0)<br>    <br>    return different_GCDs


## Ground Truth

### GROUND TRUTH 0, ranked 30, leetcode/leetcode_2101.txt
> def can_reach_bottom(grid, row, col):<br>    """You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.<br><br>The bombs are represented by a 0-indexed 2D integer array `bombs` where `bombs[i] = [xi, yi, ri]`. `xi` and `yi` denote the X-coordinate and Y-coordinate of the location of the `ith` bomb, whereas `ri` denotes the radius of its range.<br><br>You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.<br><br>Given the list of `bombs`, return _the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb_.<br><br>Example 1:<br><br>Input: bombs = \[\[2,1,3\],\[6,1,4\]\]<br>Output: 2<br>Explanation:<br>The above figure shows the positions and ranges of the 2 bombs.<br>If we detonate the left bomb, the right bomb will not be affected.<br>But if we detonate the right bomb, both bombs will be detonated.<br>So the maximum bombs that can be detonated is max(1, 2) = 2.<br><br>Example 2:<br><br>Input: bombs = \[\[1,1,5\],\[10,10,5\]\]<br>Output: 1<br>Explanation:<br>Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.<br><br>Example 3:<br><br>Input: bombs = \[\[1,2,3\],\[2,3,1\],\[3,4,2\],\[4,5,3\],\[5,6,4\]\]<br>Output: 5<br>Explanation:<br>The best bomb to detonate is bomb 0 because:<br>- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.<br>- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.<br>- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.<br>Thus all 5 bombs are detonated.<br><br>Constraints:<br><br>   `1 <= bombs.length <= 100`<br>   `bombs[i].length == 3`<br>   `1 <= xi, yi, ri <= 105`"""<br><br>    if row == len(grid) - 1:<br>        return True<br>    grid[row][col] = 1<br><br>    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]<br><br>    for dr, dc in directions:<br>        nr, nc = row + dr, col + dc<br>        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:<br>            if can_reach_bottom(grid, nr, nc):<br>                return True<br><br>    return False<br><br>def latestDayToCross(row, col, cells):<br>    grid = [[0]  col for _ in range(row)]<br>    ans = 0<br><br>    for day, cell in enumerate(cells):<br>        grid[cell[0] - 1][cell[1] - 1] = 1<br><br>        found = False<br>        for j in range(col):<br>            if grid[0][j] == 0 and can_reach_bottom(grid, 0, j):<br>                found = True<br>                break<br><br>        if not found:<br>            ans = day<br>            break<br><br>    return ans

### GROUND TRUTH 1, ranked 0, leetcode/leetcode_2258.txt
> from collections import deque<br>    """You are given a 0-indexed 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:<br><br>   `0` represents grass,<br>   `1` represents fire,<br>   `2` represents a wall that you and fire cannot pass through.<br><br>You are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.<br><br>Return _the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can always reach the safehouse regardless of the minutes stayed, return `109`.<br><br>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.<br><br>A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).<br><br>Example 1:<br><br>Input: grid = \[\[0,2,0,0,0,0,0\],\[0,0,0,2,2,1,0\],\[0,2,0,0,1,2,0\],\[0,0,2,2,2,0,2\],\[0,0,0,0,0,0,0\]\]<br>Output: 3<br>Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.<br>You will still be able to safely reach the safehouse.<br>Staying for more than 3 minutes will not allow you to safely reach the safehouse.<br><br>Example 2:<br><br>Input: grid = \[\[0,0,0,0\],\[0,1,2,0\],\[0,2,0,0\]\]<br>Output: -1<br>Explanation: The figure above shows the scenario where you immediately move towards the safehouse.<br>Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.<br>Thus, -1 is returned.<br><br>Example 3:<br><br>Input: grid = \[\[0,0,0\],\[2,2,0\],\[1,2,0\]\]<br>Output: 1000000000<br>Explanation: The figure above shows the initial grid.<br>Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.<br>Thus, 109 is returned.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `2 <= m, n <= 300`<br>   `4 <= m  n <= 2  104`<br>   `grid[i][j]` is either `0`, `1`, or `2`.<br>   `grid[0][0] == grid[m - 1][n - 1] == 0`"""<br><br><br>dx = [0, 1, 0, -1]<br>dy = [1, 0, -1, 0]<br><br>def getMaxSafeMinutes(grid):<br>    m, n = len(grid), len(grid[0])<br>    dist = [[-1 for _ in range(n)] for _ in range(m)]<br>    q = deque()<br><br>    if grid[m - 1][n - 1] != 1:<br>        dist[m - 1][n - 1] = 0<br>        q.append((m - 1, n - 1))<br><br>    while q:<br>        x, y = q.popleft()<br>        for d in range(4):<br>            nx, ny = x + dx[d], y + dy[d]<br>            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:<br>                dist[nx][ny] = dist[x][y] + 1<br>                q.append((nx, ny))<br><br>    if dist[0][0] == -1:<br>        return -1<br><br>    res = 0<br>    for test in range(dist[0][0], int(1e9)):<br>        ok = True<br>        for x in range(m):<br>            for y in range(n):<br>                if grid[x][y] == 1:<br>                    for d in range(4):<br>                        nx, ny = x + dx[d], y + dy[d]<br>                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:<br>                            break<br>                    else:<br>                        ok = False<br>                        break<br>        if ok:<br>            res = test<br>        else:<br>            break<br>    return res
