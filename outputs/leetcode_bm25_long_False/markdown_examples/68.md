# Query `68`

## Original Question

*Given a wooden stick of length `n` units. The stick is labelled from `0` to `n`. For example, a stick of length 6 is labelled as follows:

Given an integer array `cuts` where `cuts[i]` denotes a position you should perform a cut at.

You should perform the cuts in order, you can change the order of the cuts as you wish.

The cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.

Return _the minimum total cost_ of the cuts.

Example 1:

Input: n = 7, cuts = \[1,3,4,5\]
Output: 16
Explanation: Using cuts order = \[1, 3, 4, 5\] as in the input leads to the following scenario:
 
The first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.
Rearranging the cuts to be \[3, 5, 1, 4\] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).

Example 2:

Input: n = 9, cuts = \[5,6,1,4,2\]
Output: 22
Explanation: If you try the given cuts ordering the cost will be 25.
There are much ordering with total cost <= 25, for example, the order \[4, 6, 5, 2, 1\] has total cost = 22 which is the minimum possible.

Constraints:

   `2 <= n <= 106`
   `1 <= cuts.length <= min(n - 1, 100)`
   `1 <= cuts[i] <= n - 1`
   All the integers in `cuts` array are distinct.*


### Metrics

```
recip_rank: 0.0018
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2103.txt
> def findFarmland(land):<br>    """There are `n` rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from `0` to `9`.<br><br>You are given a string `rings` of length `2n` that describes the `n` rings that are placed onto the rods. Every two characters in `rings` forms a color-position pair that is used to describe each ring where:<br><br>   The first character of the `ith` pair denotes the `ith` ring's color (`'R'`, `'G'`, `'B'`).<br>   The second character of the `ith` pair denotes the rod that the `ith` ring is placed on (`'0'` to `'9'`).<br><br>For example, `"R3G2B1 "` describes `n == 3` rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.<br><br>Return _the number of rods that have all three colors of rings on them._<br><br>Example 1:<br><br>Input: rings =  "B0B6G0R6R0R6G9 "<br>Output: 1<br>Explanation: <br>- The rod labeled 0 holds 3 rings with all colors: red, green, and blue.<br>- The rod labeled 6 holds 3 rings, but it only has red and blue.<br>- The rod labeled 9 holds only a green ring.<br>Thus, the number of rods with all three colors is 1.<br><br>Example 2:<br><br>Input: rings =  "B0R0G0R9R0B0G0 "<br>Output: 1<br>Explanation: <br>- The rod labeled 0 holds 6 rings with all colors: red, green, and blue.<br>- The rod labeled 9 holds only a red ring.<br>Thus, the number of rods with all three colors is 1.<br><br>Example 3:<br><br>Input: rings =  "G4 "<br>Output: 0<br>Explanation: <br>Only one ring is given. Thus, no rods have all three colors.<br><br>Constraints:<br><br>   `rings.length == 2  n`<br>   `1 <= n <= 100`<br>   `rings[i]` where `i` is even is either `'R'`, `'G'`, or `'B'` (0-indexed).<br>   `rings[i]` where `i` is odd is a digit from `'0'` to `'9'` (0-indexed)."""<br><br>    m, n = len(land), len(land[0])<br>    res = []<br>    <br>    for i in range(m):<br>        for j in range(n):<br>            if land[i][j] == 1:<br>                r, c = i, j<br>                while r < m and land[r][j] == 1: r += 1<br>                while c < n and land[i][c] == 1: c += 1<br>                for x in range(i, r):<br>                    for y in range(j,c):<br>                        land[x][y] = 0<br>                res.append([i, j, r - 1, c - 1])<br><br>    return res

### DOC[2] (IRRELEVANT) leetcode/leetcode_1900.txt
> def closest_cost(base_costs, topping_costs, target):<br>    """There is a tournament where `n` players are participating. The players are standing in a single row and are numbered from `1` to `n` based on their initial standing position (player `1` is the first player in the row, player `2` is the second player in the row, etc.).<br><br>The tournament consists of multiple rounds (starting from round number `1`). In each round, the `ith` player from the front of the row competes against the `ith` player from the end of the row, and the winner advances to the next round. When the number of players is odd for the current round, the player in the middle automatically advances to the next round.<br><br>   For example, if the row consists of players `1, 2, 4, 6, 7`<br>       Player `1` competes against player `7`.<br>       Player `2` competes against player `6`.<br>       Player `4` automatically advances to the next round.<br><br>After each round is over, the winners are lined back up in the row based on the original ordering assigned to them initially (ascending order).<br><br>The players numbered `firstPlayer` and `secondPlayer` are the best in the tournament. They can win against any other player before they compete against each other. If any two other players compete against each other, either of them might win, and thus you may choose the outcome of this round.<br><br>Given the integers `n`, `firstPlayer`, and `secondPlayer`, return _an integer array containing two values, the earliest possible round number and the latest possible round number in which these two players will compete against each other, respectively_.<br><br>Example 1:<br><br>Input: n = 11, firstPlayer = 2, secondPlayer = 4<br>Output: \[3,4\]<br>Explanation:<br>One possible scenario which leads to the earliest round number:<br>First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11<br>Second round: 2, 3, 4, 5, 6, 11<br>Third round: 2, 3, 4<br>One possible scenario which leads to the latest round number:<br>First round: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11<br>Second round: 1, 2, 3, 4, 5, 6<br>Third round: 1, 2, 4<br>Fourth round: 2, 4<br><br>Example 2:<br><br>Input: n = 5, firstPlayer = 1, secondPlayer = 5<br>Output: \[1,1\]<br>Explanation: The players numbered 1 and 5 compete in the first round.<br>There is no way to make them compete in any other round.<br><br>Constraints:<br><br>   `2 <= n <= 28`<br>   `1 <= firstPlayer < secondPlayer <= n`"""<br><br>    closest = base_costs[0]<br>    <br>    for base in base_costs:<br>        cost = base<br>        <br>        for i in range(1 << (len(topping_costs)  2)):<br>            bit_mask = i<br>            <br>            for j, topping_cost in enumerate(topping_costs):<br>                cost += (bit_mask & 3)  topping_cost<br>                bit_mask = 2<br>                <br>            if abs(target - cost) < abs(target - closest):<br>                closest = cost<br>            elif abs(target - cost) == abs(target - closest) and cost < closest:<br>                closest = cost<br>                <br>            cost = base<br>            <br>    return closest

### DOC[3] (IRRELEVANT) leetcode/leetcode_2281.txt
> mod = 1000000007<br>    """As the ruler of a kingdom, you have an army of wizards at your command.<br><br>You are given a 0-indexed integer array `strength`, where `strength[i]` denotes the strength of the `ith` wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of `strength`), the total strength is defined as the product of the following two values:<br><br>   The strength of the weakest wizard in the group.<br>   The total of all the individual strengths of the wizards in the group.<br><br>Return _the sum of the total strengths of all contiguous groups of wizards_. Since the answer may be very large, return it modulo `109 + 7`.<br><br>A subarray is a contiguous non-empty sequence of elements within an array.<br><br>Example 1:<br><br>Input: strength = \[1,3,1,2\]<br>Output: 44<br>Explanation: The following are all the contiguous groups of wizards:<br>- \[1\] from \[1,3,1,2\] has a total strength of min(\[1\]) \ sum(\[1\]) = 1 \ 1 = 1<br>- \[3\] from \[1,3,1,2\] has a total strength of min(\[3\]) \ sum(\[3\]) = 3 \ 3 = 9<br>- \[1\] from \[1,3,1,2\] has a total strength of min(\[1\]) \ sum(\[1\]) = 1 \ 1 = 1<br>- \[2\] from \[1,3,1,2\] has a total strength of min(\[2\]) \ sum(\[2\]) = 2 \ 2 = 4<br>- \[1,3\] from \[1,3,1,2\] has a total strength of min(\[1,3\]) \ sum(\[1,3\]) = 1 \ 4 = 4<br>- \[3,1\] from \[1,3,1,2\] has a total strength of min(\[3,1\]) \ sum(\[3,1\]) = 1 \ 4 = 4<br>- \[1,2\] from \[1,3,1,2\] has a total strength of min(\[1,2\]) \ sum(\[1,2\]) = 1 \ 3 = 3<br>- \[1,3,1\] from \[1,3,1,2\] has a total strength of min(\[1,3,1\]) \ sum(\[1,3,1\]) = 1 \ 5 = 5<br>- \[3,1,2\] from \[1,3,1,2\] has a total strength of min(\[3,1,2\]) \ sum(\[3,1,2\]) = 1 \ 6 = 6<br>- \[1,3,1,2\] from \[1,3,1,2\] has a total strength of min(\[1,3,1,2\]) \ sum(\[1,3,1,2\]) = 1 \ 7 = 7<br>The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.<br><br>Example 2:<br><br>Input: strength = \[5,4,6\]<br>Output: 213<br>Explanation: The following are all the contiguous groups of wizards: <br>- \[5\] from \[5,4,6\] has a total strength of min(\[5\]) \ sum(\[5\]) = 5 \ 5 = 25<br>- \[4\] from \[5,4,6\] has a total strength of min(\[4\]) \ sum(\[4\]) = 4 \ 4 = 16<br>- \[6\] from \[5,4,6\] has a total strength of min(\[6\]) \ sum(\[6\]) = 6 \ 6 = 36<br>- \[5,4\] from \[5,4,6\] has a total strength of min(\[5,4\]) \ sum(\[5,4\]) = 4 \ 9 = 36<br>- \[4,6\] from \[5,4,6\] has a total strength of min(\[4,6\]) \ sum(\[4,6\]) = 4 \ 10 = 40<br>- \[5,4,6\] from \[5,4,6\] has a total strength of min(\[5,4,6\]) \ sum(\[5,4,6\]) = 4 \ 15 = 60<br>The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.<br><br>Constraints:<br><br>   `1 <= strength.length <= 105`<br>   `1 <= strength[i] <= 109`"""<br><br>def sum_of_strength(strength):<br>    res, strength_len = 0, len(strength)<br>    for i in range(strength_len):<br>        minimum = total = strength[i]<br>        for j in range(i, strength_len):<br>            minimum = min(minimum, strength[j])<br>            total += strength[j]<br>            res = (res + minimum  total % mod) % mod<br>    return res

### DOC[4] (IRRELEVANT) leetcode/leetcode_2398.txt
> def max_consecutive_robots(charge_times, running_costs, budget):<br>    """You have `n` robots. You are given two 0-indexed integer arrays, `chargeTimes` and `runningCosts`, both of length `n`. The `ith` robot costs `chargeTimes[i]` units to charge and costs `runningCosts[i]` units to run. You are also given an integer `budget`.<br><br>The total cost of running `k` chosen robots is equal to `max(chargeTimes) + k  sum(runningCosts)`, where `max(chargeTimes)` is the largest charge cost among the `k` robots and `sum(runningCosts)` is the sum of running costs among the `k` robots.<br><br>Return _the maximum number of consecutive robots you can run such that the total cost does not exceed_ `budget`.<br><br>Example 1:<br><br>Input: chargeTimes = \[3,6,1,3,4\], runningCosts = \[2,1,3,4,5\], budget = 25<br>Output: 3<br>Explanation: <br>It is possible to run all individual and consecutive pairs of robots within budget.<br>To obtain answer 3, consider the first 3 robots. The total cost will be max(3,6,1) + 3 \ sum(2,1,3) = 6 + 3 \ 6 = 24 which is less than 25.<br>It can be shown that it is not possible to run more than 3 consecutive robots within budget, so we return 3.<br><br>Example 2:<br><br>Input: chargeTimes = \[11,12,19\], runningCosts = \[10,8,7\], budget = 19<br>Output: 0<br>Explanation: No robot can be run that does not exceed the budget, so we return 0.<br><br>Constraints:<br><br>   `chargeTimes.length == runningCosts.length == n`<br>   `1 <= n <= 5  104`<br>   `1 <= chargeTimes[i], runningCosts[i] <= 105`<br>   `1 <= budget <= 1015`"""<br><br>    n = len(charge_times)<br>    max_robots = 0<br>    for i in range(n):<br>        max_charge = 0<br>        running_sum = 0<br>        for j in range(i, n):<br>            max_charge = max(max_charge, charge_times[j])<br>            running_sum += running_costs[j]<br>            cost = max_charge + running_sum  (j - i + 1)<br>            if cost <= budget:<br>                max_robots = max(max_robots, j - i + 1)<br>            else:<br>                break<br>    return max_robots

### DOC[5] (IRRELEVANT) leetcode/leetcode_375.txt
> def getMoneyAmount(n: int) - int:<br>    """We are playing the Guessing Game. The game will work as follows:<br><br>1.  I pick a number between `1` and `n`.<br>2.  You guess a number.<br>3.  If you guess the right number, you win the game.<br>4.  If you guess the wrong number, then I will tell you whether the number I picked is higher or lower, and you will continue guessing.<br>5.  Every time you guess a wrong number `x`, you will pay `x` dollars. If you run out of money, you lose the game.<br><br>Given a particular `n`, return _the minimum amount of money you need to guarantee a win regardless of what number I pick_.<br><br>Example 1:<br><br>Input: n = 10<br>Output: 16<br>Explanation: The winning strategy is as follows:<br>- The range is \[1,10\]. Guess 7.<br>    - If this is my number, your total is $0. Otherwise, you pay $7.<br>    - If my number is higher, the range is \[8,10\]. Guess 9.<br>        - If this is my number, your total is $7. Otherwise, you pay $9.<br>        - If my number is higher, it must be 10. Guess 10. Your total is $7 + $9 = $16.<br>        - If my number is lower, it must be 8. Guess 8. Your total is $7 + $9 = $16.<br>    - If my number is lower, the range is \[1,6\]. Guess 3.<br>        - If this is my number, your total is $7. Otherwise, you pay $3.<br>        - If my number is higher, the range is \[4,6\]. Guess 5.<br>            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $5.<br>            - If my number is higher, it must be 6. Guess 6. Your total is $7 + $3 + $5 = $15.<br>            - If my number is lower, it must be 4. Guess 4. Your total is $7 + $3 + $5 = $15.<br>        - If my number is lower, the range is \[1,2\]. Guess 1.<br>            - If this is my number, your total is $7 + $3 = $10. Otherwise, you pay $1.<br>            - If my number is higher, it must be 2. Guess 2. Your total is $7 + $3 + $1 = $11.<br>The worst case in all these scenarios is that you pay $16. Hence, you only need $16 to guarantee a win.<br><br>Example 2:<br><br>Input: n = 1<br>Output: 0<br>Explanation: There is only one possible number, so you can guess 1 and not have to pay anything.<br><br>Example 3:<br><br>Input: n = 2<br>Output: 1<br>Explanation: There are two possible numbers, 1 and 2.<br>- Guess 1.<br>    - If this is my number, your total is $0. Otherwise, you pay $1.<br>    - If my number is higher, it must be 2. Guess 2. Your total is $1.<br>The worst case is that you pay $1.<br><br>Constraints:<br><br>   `1 <= n <= 200`"""<br><br>    dp = [[0]  (n + 1) for _ in range(n + 1)]<br>    for i in range(n - 1, 0, -1):<br>        for j in range(i + 1, n + 1):<br>            min_cost = float("inf")<br>            for k in range(i, j):<br>                cost = k + max(dp[i][k - 1], dp[k + 1][j])<br>                min_cost = min(min_cost, cost)<br>            dp[i][j] = min_cost<br>    return dp[1][n]


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2147.txt
> def sum_of_points(s, answers):<br>    """Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string `corridor` of length `n` consisting of letters `'S'` and `'P'` where each `'S'` represents a seat and each `'P'` represents a plant.<br><br>One room divider has already been installed to the left of index `0`, and another to the right of index `n - 1`. Additional room dividers can be installed. For each position between indices `i - 1` and `i` (`1 <= i <= n - 1`), at most one divider can be installed.<br><br>Divide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.<br><br>Return _the number of ways to divide the corridor_. Since the answer may be very large, return it modulo `109 + 7`. If there is no way, return `0`.<br><br>Example 1:<br><br>Input: corridor =  "SSPPSPS "<br>Output: 3<br>Explanation: There are 3 different ways to divide the corridor.<br>The black bars in the above image indicate the two room dividers already installed.<br>Note that in each of the ways, each section has exactly two seats.<br><br>Example 2:<br><br>Input: corridor =  "PPSPSP "<br>Output: 1<br>Explanation: There is only 1 way to divide the corridor, by not installing any additional dividers.<br>Installing any would create some section that does not have exactly two seats.<br><br>Example 3:<br><br>Input: corridor =  "S "<br>Output: 0<br>Explanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.<br><br>Constraints:<br><br>   `n == corridor.length`<br>   `1 <= n <= 105`<br>   `corridor[i]` is either `'S'` or `'P'`."""<br><br>    total_points = 0<br>    result = 0<br>    term = 1<br>    sign = "+"<br><br>    for char in s:<br>        if char.isdigit():<br>            number = int(char)<br>            if sign == "+":<br>                result += term<br>                term = number<br>            elif sign == "":<br>                term = number<br>        else:<br>            sign = char<br><br>    result += term<br><br>    for ans in answers:<br>        total_points += (ans == result)<br><br>    return total_points
