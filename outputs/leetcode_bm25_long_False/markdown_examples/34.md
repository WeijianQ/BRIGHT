# Query `34`

## Original Question

*You are given an `m x n` binary matrix `grid`. An island is a group of `1`'s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.

The area of an island is the number of cells with a value `1` in the island.

Return _the maximum area of an island in_ `grid`. If there is no island, return `0`.

Example 1:

Input: grid = \[\[0,0,1,0,0,0,0,1,0,0,0,0,0\],\[0,0,0,0,0,0,0,1,1,1,0,0,0\],\[0,1,1,0,1,0,0,0,0,0,0,0,0\],\[0,1,0,0,1,1,0,0,1,0,1,0,0\],\[0,1,0,0,1,1,0,0,1,1,1,0,0\],\[0,0,0,0,0,0,0,0,0,0,1,0,0\],\[0,0,0,0,0,0,0,1,1,1,0,0,0\],\[0,0,0,0,0,0,0,1,1,0,0,0,0\]\]
Output: 6
Explanation: The answer is not 11, because the island must be connected 4-directionally.

Example 2:

Input: grid = \[\[0,0,0,0,0,0,0,0\]\]
Output: 0

Constraints:

   `m == grid.length`
   `n == grid[i].length`
   `1 <= m, n <= 50`
   `grid[i][j]` is either `0` or `1`.*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0600
P_100: 0.0300
recall_1: 0.3333
recall_5: 0.3333
recall_10: 0.3333
recall_25: 0.3333
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.4693
ndcg_cut_10: 0.4693
ndcg_cut_25: 0.4693
ndcg_cut_50: 0.6591
ndcg_cut_100: 0.6591
map_cut_1: 0.3333
map_cut_5: 0.3333
map_cut_10: 0.3333
map_cut_25: 0.3333
map_cut_50: 0.3883
map_cut_100: 0.3883
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_463.txt
> def islandPerimeter(grid):<br>    """You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.<br><br>Grid cells are connected horizontally/vertically (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).<br><br>The island doesn't have "lakes ", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.<br><br>Example 1:<br><br>Input: grid = \[\[0,1,0,0\],\[1,1,1,0\],\[0,1,0,0\],\[1,1,0,0\]\]<br>Output: 16<br>Explanation: The perimeter is the 16 yellow stripes in the image above.<br><br>Example 2:<br><br>Input: grid = \[\[1\]\]<br>Output: 4<br><br>Example 3:<br><br>Input: grid = \[\[1,0\]\]<br>Output: 4<br><br>Constraints:<br><br>   `row == grid.length`<br>   `col == grid[i].length`<br>   `1 <= row, col <= 100`<br>   `grid[i][j]` is `0` or `1`.<br>   There is exactly one island in `grid`."""<br><br>    perimeter = 0<br>    for row in range(len(grid)):<br>        for col in range(len(grid[row])):<br>            if grid[row][col] == 1:<br>                perimeter += 4<br>                if row  0 and grid[row - 1][col] == 1:<br>                    perimeter -= 2<br>                if col  0 and grid[row][col - 1] == 1:<br>                    perimeter -= 2<br>    return perimeter

### DOC[2] (IRRELEVANT) leetcode/leetcode_2088.txt
> def min_time_to_type(word: str) - int:<br>    """A farmer has a rectangular grid of land with `m` rows and `n` columns that can be divided into unit cells. Each cell is either fertile (represented by a `1`) or barren (represented by a `0`). All cells outside the grid are considered barren.<br><br>A pyramidal plot of land can be defined as a set of cells with the following criteria:<br><br>1.  The number of cells in the set has to be greater than `1` and all cells must be fertile.<br>2.  The apex of a pyramid is the topmost cell of the pyramid. The height of a pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r <= i <= r + h - 1` and `c - (i - r) <= j <= c + (i - r)`.<br><br>An inverse pyramidal plot of land can be defined as a set of cells with similar criteria:<br><br>1.  The number of cells in the set has to be greater than `1` and all cells must be fertile.<br>2.  The apex of an inverse pyramid is the bottommost cell of the inverse pyramid. The height of an inverse pyramid is the number of rows it covers. Let `(r, c)` be the apex of the pyramid, and its height be `h`. Then, the plot comprises of cells `(i, j)` where `r - h + 1 <= i <= r` and `c - (r - i) <= j <= c + (r - i)`.<br><br>Some examples of valid and invalid pyramidal (and inverse pyramidal) plots are shown below. Black cells indicate fertile cells.<br><br>Given a 0-indexed `m x n` binary matrix `grid` representing the farmland, return _the total number of pyramidal and inverse pyramidal plots that can be found in_ `grid`.<br><br>Example 1:<br><br>Input: grid = \[\[0,1,1,0\],\[1,1,1,1\]\]<br>Output: 2<br>Explanation: The 2 possible pyramidal plots are shown in blue and red respectively.<br>There are no inverse pyramidal plots in this grid. <br>Hence total number of pyramidal and inverse pyramidal plots is 2 + 0 = 2.<br><br>Example 2:<br><br>Input: grid = \[\[1,1,1\],\[1,1,1\]\]<br>Output: 2<br>Explanation: The pyramidal plot is shown in blue, and the inverse pyramidal plot is shown in red. <br>Hence the total number of plots is 1 + 1 = 2.<br><br>Example 3:<br><br>Input: grid = \[\[1,1,1,1,0\],\[1,1,1,1,1\],\[1,1,1,1,1\],\[0,1,0,0,1\]\]<br>Output: 13<br>Explanation: There are 7 pyramidal plots, 3 of which are shown in the 2nd and 3rd figures.<br>There are 6 inverse pyramidal plots, 2 of which are shown in the last figure.<br>The total number of plots is 7 + 6 = 13.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `1 <= m, n <= 1000`<br>   `1 <= m  n <= 105`<br>   `grid[i][j]` is either `0` or `1`."""<br><br>    time, prev = 0, 0<br>    for c in word:<br>        pos = ord(c) - ord('a')<br>        time += min(abs(pos - prev), 26 - abs(pos - prev)) + 1<br>        prev = pos<br>    return time

### DOC[3] (IRRELEVANT) leetcode/leetcode_2245.txt
> def can_destroy_all_asteroids(mass, asteroids):<br>    """You are given a 2D integer array `grid` of size `m x n`, where each cell contains a positive integer.<br><br>A cornered path is defined as a set of adjacent cells with at most one turn. More specifically, the path should exclusively move either horizontally or vertically up to the turn (if there is one), without returning to a previously visited cell. After the turn, the path will then move exclusively in the alternate direction: move vertically if it moved horizontally, and vice versa, also without returning to a previously visited cell.<br><br>The product of a path is defined as the product of all the values in the path.<br><br>Return _the maximum number of trailing zeros in the product of a cornered path found in_ `grid`.<br><br>Note:<br><br>   Horizontal movement means moving in either the left or right direction.<br>   Vertical movement means moving in either the up or down direction.<br><br>Example 1:<br><br>Input: grid = \[\[23,17,15,3,20\],\[8,1,20,27,11\],\[9,4,6,2,21\],\[40,9,1,10,6\],\[22,7,4,5,3\]\]<br>Output: 3<br>Explanation: The grid on the left shows a valid cornered path.<br>It has a product of 15 \ 20 \ 6 \ 1 \ 10 = 18000 which has 3 trailing zeros.<br>It can be shown that this is the maximum trailing zeros in the product of a cornered path.<br><br>The grid in the middle is not a cornered path as it has more than one turn.<br>The grid on the right is not a cornered path as it requires a return to a previously visited cell.<br><br>Example 2:<br><br>Input: grid = \[\[4,3,2\],\[7,6,1\],\[8,8,8\]\]<br>Output: 0<br>Explanation: The grid is shown in the figure above.<br>There are no cornered paths in the grid that result in a product with a trailing zero.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `1 <= m, n <= 105`<br>   `1 <= m  n <= 105`<br>   `1 <= grid[i][j] <= 1000`"""<br><br>    asteroids.sort()<br>    for asteroid in asteroids:<br>        if mass = asteroid:<br>            mass += asteroid<br>        else:<br>            return False<br>    return True

### DOC[4] (IRRELEVANT) leetcode/leetcode_1878.txt
> def check(nums):<br>    """You are given an `m x n` integer matrix `grid`​​​.<br><br>A rhombus sum is the sum of the elements that form the border of a regular rhombus shape in `grid`​​​. The rhombus must have the shape of a square rotated 45 degrees with each of the corners centered in a grid cell. Below is an image of four valid rhombus shapes with the corresponding colored cells that should be included in each rhombus sum:<br><br>Note that the rhombus can have an area of 0, which is depicted by the purple rhombus in the bottom right corner.<br><br>Return _the biggest three distinct rhombus sums in the_ `grid` _in descending order__. If there are less than three distinct values, return all of them_.<br><br>Example 1:<br><br>Input: grid = \[\[3,4,5,1,3\],\[3,3,4,2,3\],\[20,30,200,40,10\],\[1,5,5,4,1\],\[4,3,2,2,5\]\]<br>Output: \[228,216,211\]<br>Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.<br>- Blue: 20 + 3 + 200 + 5 = 228<br>- Red: 200 + 2 + 10 + 4 = 216<br>- Green: 5 + 200 + 4 + 2 = 211<br><br>Example 2:<br><br>Input: grid = \[\[1,2,3\],\[4,5,6\],\[7,8,9\]\]<br>Output: \[20,9,8\]<br>Explanation: The rhombus shapes for the three biggest distinct rhombus sums are depicted above.<br>- Blue: 4 + 2 + 6 + 8 = 20<br>- Red: 9 (area 0 rhombus in the bottom right corner)<br>- Green: 8 (area 0 rhombus in the bottom middle)<br><br>Example 3:<br><br>Input: grid = \[\[7,7,7\]\]<br>Output: \[7\]<br>Explanation: All three possible rhombus sums are the same, so return \[7\].<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `1 <= m, n <= 50`<br>   `1 <= grid[i][j] <= 105`"""<br><br>    count = 0<br>    for i in range(1, len(nums)):<br>        if nums[i] < nums[i - 1]:<br>            count += 1<br>        if count  1:<br>            return False<br>    return count == 1 or nums[0] = nums[-1]

### DOC[5] (IRRELEVANT) leetcode/leetcode_1351.txt
> def balanced_string(s):<br>    """Given a `m x n` matrix `grid` which is sorted in non-increasing order both row-wise and column-wise, return _the number of negative numbers in_ `grid`.<br><br>Example 1:<br><br>Input: grid = \[\[4,3,2,-1\],\[3,2,1,-1\],\[1,1,-1,-2\],\[-1,-1,-2,-3\]\]<br>Output: 8<br>Explanation: There are 8 negatives number in the matrix.<br><br>Example 2:<br><br>Input: grid = \[\[3,2\],\[1,0\]\]<br>Output: 0<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `1 <= m, n <= 100`<br>   `-100 <= grid[i][j] <= 100`<br><br>Follow up: Could you find an `O(n + m)` solution?"""<br><br>    n = len(s)<br>    freq_map = {}<br>    for c in s:<br>        freq_map[c] = freq_map.get(c, 0) + 1<br>    <br>    i = 0<br>    result = n<br>    for j in range(n):<br>        freq_map[s[j]] -= 1<br>        while i < n and all(freq_map.get(c, 0) <= n // 4 for c in "QWER"):<br>            result = min(result, j - i + 1)<br>            freq_map[s[i]] += 1<br>            i += 1<br>    <br>    return result


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_463.txt
> def islandPerimeter(grid):<br>    """You are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.<br><br>Grid cells are connected horizontally/vertically (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).<br><br>The island doesn't have "lakes ", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.<br><br>Example 1:<br><br>Input: grid = \[\[0,1,0,0\],\[1,1,1,0\],\[0,1,0,0\],\[1,1,0,0\]\]<br>Output: 16<br>Explanation: The perimeter is the 16 yellow stripes in the image above.<br><br>Example 2:<br><br>Input: grid = \[\[1\]\]<br>Output: 4<br><br>Example 3:<br><br>Input: grid = \[\[1,0\]\]<br>Output: 4<br><br>Constraints:<br><br>   `row == grid.length`<br>   `col == grid[i].length`<br>   `1 <= row, col <= 100`<br>   `grid[i][j]` is `0` or `1`.<br>   There is exactly one island in `grid`."""<br><br>    perimeter = 0<br>    for row in range(len(grid)):<br>        for col in range(len(grid[row])):<br>            if grid[row][col] == 1:<br>                perimeter += 4<br>                if row  0 and grid[row - 1][col] == 1:<br>                    perimeter -= 2<br>                if col  0 and grid[row][col - 1] == 1:<br>                    perimeter -= 2<br>    return perimeter

### GROUND TRUTH 1, ranked 26, leetcode/leetcode_1727.txt
> def canMouseWin(grid: List[List[str]], catJump: int, mouseJump: int) - bool:<br>    """You are given a binary matrix `matrix` of size `m x n`, and you are allowed to rearrange the columns of the `matrix` in any order.<br><br>Return _the area of the largest submatrix within_ `matrix` _where every element of the submatrix is_ `1` _after reordering the columns optimally._<br><br>Example 1:<br><br>Input: matrix = \[\[0,0,1\],\[1,1,1\],\[1,0,1\]\]<br>Output: 4<br>Explanation: You can rearrange the columns as shown above.<br>The largest submatrix of 1s, in bold, has an area of 4.<br><br>Example 2:<br><br>Input: matrix = \[\[1,0,1,0,1\]\]<br>Output: 3<br>Explanation: You can rearrange the columns as shown above.<br>The largest submatrix of 1s, in bold, has an area of 3.<br><br>Example 3:<br><br>Input: matrix = \[\[1,1,0\],\[1,0,1\]\]<br>Output: 2<br>Explanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.<br><br>Constraints:<br><br>   `m == matrix.length`<br>   `n == matrix[i].length`<br>   `1 <= m  n <= 105`<br>   `matrix[i][j]` is either `0` or `1`."""<br><br>    rows, cols = len(grid), len(grid[0])<br>    cat_r = cat_c = mouse_r = mouse_c = 0<br><br>    for r in range(rows):<br>        for c in range(cols):<br>            if grid[r][c] == 'C':<br>                cat_r, cat_c = r, c<br>            elif grid[r][c] == 'M':<br>                mouse_r, mouse_c = r, c<br><br>    dirs = [-1, 0, 1, 0, -1]<br><br>    def dfs(r_m, c_m, r_c, c_c, cnt, dst_m_c):<br>        if cnt = 100:<br>            return False<br>        if r_m < 0 or r_m = rows or c_m < 0 or c_m = cols:<br>            return False<br>        if r_c < 0 or r_c = rows or c_c < 0 or c_c = cols:<br>            return True<br>        if grid[r_m][c_m] == 'F' or cnt != dst_m_c:<br>            return True<br>        elif grid[r_m][c_m] == '#' or cnt + 1 == dst_m_c:<br>            return False<br><br>        res = False<br>        for i in range(4):<br>            jump = catJump if dst_m_c == cnt else mouseJump<br>            res |= not dfs(r_m + jump  dirs[i], c_m + jump  dirs[i + 1], r_c + dirs[i]  dirs[(i + 2) % 4], c_c + dirs[i+1]  dirs[(i + 3) % 4], cnt + 1, dst_m_c)<br>            if jump == 1:<br>                break<br><br>        return res<br><br>    return dfs(mouse_r, mouse_c, cat_r, cat_c, 0, abs(cat_r - mouse_r) + abs(cat_c - mouse_c))

### GROUND TRUTH 2, ranked 32, leetcode/leetcode_2101.txt
> def can_reach_bottom(grid, row, col):<br>    """You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.<br><br>The bombs are represented by a 0-indexed 2D integer array `bombs` where `bombs[i] = [xi, yi, ri]`. `xi` and `yi` denote the X-coordinate and Y-coordinate of the location of the `ith` bomb, whereas `ri` denotes the radius of its range.<br><br>You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.<br><br>Given the list of `bombs`, return _the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb_.<br><br>Example 1:<br><br>Input: bombs = \[\[2,1,3\],\[6,1,4\]\]<br>Output: 2<br>Explanation:<br>The above figure shows the positions and ranges of the 2 bombs.<br>If we detonate the left bomb, the right bomb will not be affected.<br>But if we detonate the right bomb, both bombs will be detonated.<br>So the maximum bombs that can be detonated is max(1, 2) = 2.<br><br>Example 2:<br><br>Input: bombs = \[\[1,1,5\],\[10,10,5\]\]<br>Output: 1<br>Explanation:<br>Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.<br><br>Example 3:<br><br>Input: bombs = \[\[1,2,3\],\[2,3,1\],\[3,4,2\],\[4,5,3\],\[5,6,4\]\]<br>Output: 5<br>Explanation:<br>The best bomb to detonate is bomb 0 because:<br>- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.<br>- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.<br>- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.<br>Thus all 5 bombs are detonated.<br><br>Constraints:<br><br>   `1 <= bombs.length <= 100`<br>   `bombs[i].length == 3`<br>   `1 <= xi, yi, ri <= 105`"""<br><br>    if row == len(grid) - 1:<br>        return True<br>    grid[row][col] = 1<br><br>    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]<br><br>    for dr, dc in directions:<br>        nr, nc = row + dr, col + dc<br>        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:<br>            if can_reach_bottom(grid, nr, nc):<br>                return True<br><br>    return False<br><br>def latestDayToCross(row, col, cells):<br>    grid = [[0]  col for _ in range(row)]<br>    ans = 0<br><br>    for day, cell in enumerate(cells):<br>        grid[cell[0] - 1][cell[1] - 1] = 1<br><br>        found = False<br>        for j in range(col):<br>            if grid[0][j] == 0 and can_reach_bottom(grid, 0, j):<br>                found = True<br>                break<br><br>        if not found:<br>            ans = day<br>            break<br><br>    return ans
