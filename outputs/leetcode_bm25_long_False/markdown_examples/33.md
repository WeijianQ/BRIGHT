# Query `33`

## Original Question

*In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.

Return _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.

Example 1:

Input: edges = \[\[1,2\],\[1,3\],\[2,3\]\]
Output: \[2,3\]

Example 2:

Input: edges = \[\[1,2\],\[2,3\],\[3,4\],\[1,4\],\[1,5\]\]
Output: \[1,4\]

Constraints:

   `n == edges.length`
   `3 <= n <= 1000`
   `edges[i].length == 2`
   `1 <= ai < bi <= edges.length`
   `ai != bi`
   There are no repeated edges.
   The given graph is connected.*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0800
P_50: 0.0400
P_100: 0.0200
recall_1: 0.2500
recall_5: 0.2500
recall_10: 0.2500
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.3904
ndcg_cut_10: 0.3904
ndcg_cut_25: 0.4903
ndcg_cut_50: 0.4903
ndcg_cut_100: 0.4903
map_cut_1: 0.2500
map_cut_5: 0.2500
map_cut_10: 0.2500
map_cut_25: 0.2857
map_cut_50: 0.2857
map_cut_100: 0.2857
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_685.txt
> def findRedundantDirectedConnection(edges):<br>    """In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.<br><br>The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.<br><br>The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.<br><br>Return _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.<br><br>Example 1:<br><br>Input: edges = \[\[1,2\],\[1,3\],\[2,3\]\]<br>Output: \[2,3\]<br><br>Example 2:<br><br>Input: edges = \[\[1,2\],\[2,3\],\[3,4\],\[4,1\],\[1,5\]\]<br>Output: \[4,1\]<br><br>Constraints:<br><br>   `n == edges.length`<br>   `3 <= n <= 1000`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`"""<br><br>    parent = [0]  (len(edges) + 1)<br>    candidateA = candidateB = None<br><br>    for u, v in edges:<br>        if parent[v]  0:<br>            candidateA = [parent[v], v]<br>            candidateB = [u, v]<br>        else:<br>            parent[v] = u<br><br>    for i in range(1, len(edges) + 1):<br>        cycle = i<br>        steps = len(edges)<br>        while parent[cycle] != 0 and steps  0:<br>            cycle = parent[cycle]<br>            steps -= 1<br>        if steps == 0:<br>            if not candidateA:<br>                return [parent[i], i]<br>            else:<br>                return candidateA<br><br>    return candidateB

### DOC[2] (IRRELEVANT) leetcode/leetcode_2508.txt
> from collections import defaultdict<br>    """There is an undirected graph consisting of `n` nodes numbered from `1` to `n`. You are given the integer `n` and a 2D array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi`. The graph can be disconnected.<br><br>You can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.<br><br>Return `true` _if it is possible to make the degree of each node in the graph even, otherwise return_ `false`_._<br><br>The degree of a node is the number of edges connected to it.<br><br>Example 1:<br><br>Input: n = 5, edges = \[\[1,2\],\[2,3\],\[3,4\],\[4,2\],\[1,4\],\[2,5\]\]<br>Output: true<br>Explanation: The above diagram shows a valid way of adding an edge.<br>Every node in the resulting graph is connected to an even number of edges.<br><br>Example 2:<br><br>Input: n = 4, edges = \[\[1,2\],\[3,4\]\]<br>Output: true<br>Explanation: The above diagram shows a valid way of adding two edges.<br><br>Example 3:<br><br>Input: n = 4, edges = \[\[1,2\],\[1,3\],\[1,4\]\]<br>Output: false<br>Explanation: It is not possible to obtain a valid graph with adding at most 2 edges.<br><br>Constraints:<br><br>   `3 <= n <= 105`<br>   `2 <= edges.length <= 105`<br>   `edges[i].length == 2`<br>   `1 <= ai, bi <= n`<br>   `ai != bi`<br>   There are no repeated edges."""<br><br><br>def possible_degree_even(n, edges):<br>    degrees = defaultdict(int)<br>    for a, b in edges:<br>        degrees[a] += 1<br>        degrees[b] += 1<br><br>    odd_degrees = sum(1 for d in range(1, n + 1) if degrees[d] % 2 != 0)<br>    return odd_degrees == 0 or odd_degrees == 2

### DOC[3] (IRRELEVANT) leetcode/leetcode_2603.txt
> from collections import defaultdict<br>    """There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.<br><br>Initially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:<br><br>   Collect all the coins that are at a distance of at most `2` from the current vertex, or<br>   Move to any adjacent vertex in the tree.<br><br>Find _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.<br><br>Note that if you pass an edge several times, you need to count it into the answer several times.<br><br>Example 1:<br><br>Input: coins = \[1,0,0,0,0,1\], edges = \[\[0,1\],\[1,2\],\[2,3\],\[3,4\],\[4,5\]\]<br>Output: 2<br>Explanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.<br><br>Example 2:<br><br>Input: coins = \[0,0,0,1,1,0,0,1\], edges = \[\[0,1\],\[0,2\],\[1,3\],\[1,4\],\[2,5\],\[5,6\],\[5,7\]\]<br>Output: 2<br>Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.<br><br>Constraints:<br><br>   `n == coins.length`<br>   `1 <= n <= 3  104`<br>   `0 <= coins[i] <= 1`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree."""<br><br><br>def min_edges_to_collect_coins(coins, edges):<br>    adj = defaultdict(list)<br>    for a, b in edges:<br>        adj[a].append(b)<br>        adj[b].append(a)<br>    return dfs(adj, coins, 0, -1)[1] // 2<br><br>def dfs(adj, coins, node, parent):<br>    sum_coins = coins[node]<br>    distance = 0<br>    for neighbor in adj[node]:<br>        if neighbor != parent:<br>            result = dfs(adj, coins, neighbor, node)<br>            sum_coins += result[0]<br>            distance += 2  result[0] + result[1]<br>    return (sum_coins, distance)

### DOC[4] (IRRELEVANT) leetcode/leetcode_1782.txt
> def get_smallest_string(n: int, k: int) - str:<br>    """You are given an undirected graph defined by an integer `n`, the number of nodes, and a 2D integer array `edges`, the edges in the graph, where `edges[i] = [ui, vi]` indicates that there is an undirected edge between `ui` and `vi`. You are also given an integer array `queries`.<br><br>Let `incident(a, b)` be defined as the number of edges that are connected to either node `a` or `b`.<br><br>The answer to the `jth` query is the number of pairs of nodes `(a, b)` that satisfy both of the following conditions:<br><br>   `a < b`<br>   `incident(a, b)  queries[j]`<br><br>Return _an array_ `answers` _such that_ `answers.length == queries.length` _and_ `answers[j]` _is the answer of the_ `jth` _query_.<br><br>Note that there can be multiple edges between the same two nodes.<br><br>Example 1:<br><br>Input: n = 4, edges = \[\[1,2\],\[2,4\],\[1,3\],\[2,3\],\[2,1\]\], queries = \[2,3\]<br>Output: \[6,5\]<br>Explanation: The calculations for incident(a, b) are shown in the table above.<br>The answers for each of the queries are as follows:<br>- answers\[0\] = 6. All the pairs have an incident(a, b) value greater than 2.<br>- answers\[1\] = 5. All the pairs except (3, 4) have an incident(a, b) value greater than 3.<br><br>Example 2:<br><br>Input: n = 5, edges = \[\[1,5\],\[1,5\],\[3,4\],\[2,5\],\[1,3\],\[5,1\],\[2,3\],\[2,5\]\], queries = \[1,2,3,4,5\]<br>Output: \[10,10,9,8,6\]<br><br>Constraints:<br><br>   `2 <= n <= 2  104`<br>   `1 <= edges.length <= 105`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`<br>   `1 <= queries.length <= 20`<br>   `0 <= queries[j] < edges.length`"""<br><br>    result = ['a']  n<br>    k -= n<br>    idx = n - 1<br>    while k  0:<br>        value = min(k, 25)<br>        result[idx] = chr(ord(result[idx]) + value)<br>        k -= value<br>        idx -= 1<br>    return ''.join(result)

### DOC[5] (IRRELEVANT) leetcode/leetcode_2242.txt
> def maxScore(scores, edges):<br>    """There is an undirected graph with `n` nodes, numbered from `0` to `n - 1`.<br><br>You are given a 0-indexed integer array `scores` of length `n` where `scores[i]` denotes the score of node `i`. You are also given a 2D integer array `edges` where `edges[i] = [ai, bi]` denotes that there exists an undirected edge connecting nodes `ai` and `bi`.<br><br>A node sequence is valid if it meets the following conditions:<br><br>   There is an edge connecting every pair of adjacent nodes in the sequence.<br>   No node appears more than once in the sequence.<br><br>The score of a node sequence is defined as the sum of the scores of the nodes in the sequence.<br><br>Return _the maximum score of a valid node sequence with a length of_ `4`_._ If no such sequence exists, return `-1`.<br><br>Example 1:<br><br>Input: scores = \[5,2,9,8,4\], edges = \[\[0,1\],\[1,2\],\[2,3\],\[0,2\],\[1,3\],\[2,4\]\]<br>Output: 24<br>Explanation: The figure above shows the graph and the chosen node sequence \[0,1,2,3\].<br>The score of the node sequence is 5 + 2 + 9 + 8 = 24.<br>It can be shown that no other node sequence has a score of more than 24.<br>Note that the sequences \[3,1,2,0\] and \[1,0,2,3\] are also valid and have a score of 24.<br>The sequence \[0,3,2,4\] is not valid since no edge connects nodes 0 and 3.<br><br>Example 2:<br><br>Input: scores = \[9,20,6,4,11,12\], edges = \[\[0,3\],\[5,3\],\[2,4\],\[1,3\]\]<br>Output: -1<br>Explanation: The figure above shows the graph.<br>There are no valid node sequences of length 4, so we return -1.<br><br>Constraints:<br><br>   `n == scores.length`<br>   `4 <= n <= 5  104`<br>   `1 <= scores[i] <= 108`<br>   `0 <= edges.length <= 5  104`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi <= n - 1`<br>   `ai != bi`<br>   There are no duplicate edges."""<br><br>    adj_list = [[] for _ in range(len(scores))]<br>    result = -1<br><br>    for edge in edges:<br>        adj_list[edge[0]].append(edge[1])<br>        adj_list[edge[1]].append(edge[0])<br><br>    for edge in edges:<br>        for neighbor in adj_list[edge[0]]:<br>            for next in adj_list[edge[1]]:<br>                if next != neighbor and next != edge[0]:<br>                    result = max(result, scores[edge[0]] + scores[edge[1]] + scores[neighbor] + scores[next])<br><br>    return result


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_685.txt
> def findRedundantDirectedConnection(edges):<br>    """In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.<br><br>The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.<br><br>The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.<br><br>Return _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.<br><br>Example 1:<br><br>Input: edges = \[\[1,2\],\[1,3\],\[2,3\]\]<br>Output: \[2,3\]<br><br>Example 2:<br><br>Input: edges = \[\[1,2\],\[2,3\],\[3,4\],\[4,1\],\[1,5\]\]<br>Output: \[4,1\]<br><br>Constraints:<br><br>   `n == edges.length`<br>   `3 <= n <= 1000`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`"""<br><br>    parent = [0]  (len(edges) + 1)<br>    candidateA = candidateB = None<br><br>    for u, v in edges:<br>        if parent[v]  0:<br>            candidateA = [parent[v], v]<br>            candidateB = [u, v]<br>        else:<br>            parent[v] = u<br><br>    for i in range(1, len(edges) + 1):<br>        cycle = i<br>        steps = len(edges)<br>        while parent[cycle] != 0 and steps  0:<br>            cycle = parent[cycle]<br>            steps -= 1<br>        if steps == 0:<br>            if not candidateA:<br>                return [parent[i], i]<br>            else:<br>                return candidateA<br><br>    return candidateB

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_721.txt
> from collections import defaultdict<br>    """Given a list of `accounts` where each element `accounts[i]` is a list of strings, where the first element `accounts[i][0]` is a name, and the rest of the elements are emails representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.<br><br>Example 1:<br><br>Input: accounts = \[\[ "John ", "johnsmith@mail.com ", "john\_newyork@mail.com "\],\[ "John ", "johnsmith@mail.com ", "john00@mail.com "\],\[ "Mary ", "mary@mail.com "\],\[ "John ", "johnnybravo@mail.com "\]\]<br>Output: \[\[ "John ", "john00@mail.com ", "john\_newyork@mail.com ", "johnsmith@mail.com "\],\[ "Mary ", "mary@mail.com "\],\[ "John ", "johnnybravo@mail.com "\]\]<br>Explanation:<br>The first and second John's are the same person as they have the common email  "johnsmith@mail.com ".<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer \[\['Mary', 'mary@mail.com'\], \['John', 'johnnybravo@mail.com'\], <br>\['John', 'john00@mail.com', 'john\_newyork@mail.com', 'johnsmith@mail.com'\]\] would still be accepted.<br><br>Example 2:<br><br>Input: accounts = \[\[ "Gabe ", "Gabe0@m.co ", "Gabe3@m.co ", "Gabe1@m.co "\],\[ "Kevin ", "Kevin3@m.co ", "Kevin5@m.co ", "Kevin0@m.co "\],\[ "Ethan ", "Ethan5@m.co ", "Ethan4@m.co ", "Ethan0@m.co "\],\[ "Hanzo ", "Hanzo3@m.co ", "Hanzo1@m.co ", "Hanzo0@m.co "\],\[ "Fern ", "Fern5@m.co ", "Fern1@m.co ", "Fern0@m.co "\]\]<br>Output: \[\[ "Ethan ", "Ethan0@m.co ", "Ethan4@m.co ", "Ethan5@m.co "\],\[ "Gabe ", "Gabe0@m.co ", "Gabe1@m.co ", "Gabe3@m.co "\],\[ "Hanzo ", "Hanzo0@m.co ", "Hanzo1@m.co ", "Hanzo3@m.co "\],\[ "Kevin ", "Kevin0@m.co ", "Kevin3@m.co ", "Kevin5@m.co "\],\[ "Fern ", "Fern0@m.co ", "Fern1@m.co ", "Fern5@m.co "\]\]<br><br>Constraints:<br><br>   `1 <= accounts.length <= 1000`<br>   `2 <= accounts[i].length <= 10`<br>   `1 <= accounts[i][j].length <= 30`<br>   `accounts[i][0]` consists of English letters.<br>   `accounts[i][j] (for j  0)` is a valid email."""<br><br><br>def accountsMerge(accounts):<br>    def dfs(id, visited, merged_emails):<br>        if id in visited:<br>            return<br>        visited.add(id)<br>        for email in accounts[id][1:]:<br>            merged_emails.add(email)<br>            dfs(email_to_id[email], visited, merged_emails)<br><br>    email_to_id = {}<br>    for i, account in enumerate(accounts):<br>        for email in account[1:]:<br>            email_to_id[email] = i<br><br>    result = []<br>    visited = set()<br>    for i, account in enumerate(accounts):<br>        if i not in visited:<br>            merged_emails = set()<br>            dfs(i, visited, merged_emails)<br>            result.append([account[0]] + sorted(merged_emails))<br>    return result

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_2127.txt
> def max_invited(favorite):<br>    """A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.<br><br>The employees are numbered from `0` to `n - 1`. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.<br><br>Given a 0-indexed integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the maximum number of employees that can be invited to the meeting_.<br><br>Example 1:<br><br>Input: favorite = \[2,2,1,2\]<br>Output: 3<br>Explanation:<br>The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.<br>All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.<br>Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.<br>The maximum number of employees that can be invited to the meeting is 3. <br><br>Example 2:<br><br>Input: favorite = \[1,2,0\]<br>Output: 3<br>Explanation: <br>Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.<br>The seating arrangement will be the same as that in the figure given in example 1:<br>- Employee 0 will sit between employees 2 and 1.<br>- Employee 1 will sit between employees 0 and 2.<br>- Employee 2 will sit between employees 1 and 0.<br>The maximum number of employees that can be invited to the meeting is 3.<br><br>Example 3:<br><br>Input: favorite = \[3,0,1,4,1\]<br>Output: 4<br>Explanation:<br>The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.<br>Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.<br>So the company leaves them out of the meeting.<br>The maximum number of employees that can be invited to the meeting is 4.<br><br>Constraints:<br><br>   `n == favorite.length`<br>   `2 <= n <= 105`<br>   `0 <= favorite[i] <= n - 1`<br>   `favorite[i] != i`"""<br><br>    in_degree = [0]  len(favorite)<br>    for fav in favorite:<br>        in_degree[fav] += 1<br>    result = 0<br>    for degree in in_degree:<br>        result += max(degree - 1, 0)<br>    return min(result + 2, len(favorite))

### GROUND TRUTH 3, ranked 13, leetcode/leetcode_2608.txt
> from collections import deque<br>    """There is a bi-directional graph with `n` vertices, where each vertex is labeled from `0` to `n - 1`. The edges in the graph are represented by a given 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes an edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.<br><br>Return _the length of the shortest cycle in the graph_. If no cycle exists, return `-1`.<br><br>A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.<br><br>Example 1:<br><br>Input: n = 7, edges = \[\[0,1\],\[1,2\],\[2,0\],\[3,4\],\[4,5\],\[5,6\],\[6,3\]\]<br>Output: 3<br>Explanation: The cycle with the smallest length is : 0 - 1 - 2 - 0 <br><br>Example 2:<br><br>Input: n = 4, edges = \[\[0,1\],\[0,2\]\]<br>Output: -1<br>Explanation: There are no cycles in this graph.<br><br>Constraints:<br><br>   `2 <= n <= 1000`<br>   `1 <= edges.length <= 1000`<br>   `edges[i].length == 2`<br>   `0 <= ui, vi < n`<br>   `ui != vi`<br>   There are no repeated edges."""<br><br><br>def shortest_cycle_length(n, edges):<br>    graph = [[] for _ in range(n)]<br>    for u, v in edges:<br>        graph[u].append(v)<br>        graph[v].append(u)<br>        <br>    shortest_cycle = n + 1<br>    for start in range(n):<br>        dist = [n + 1]  n<br>        dist[start] = 0<br>        queue = deque([start])<br>        <br>        while queue:<br>            cur = queue.popleft()<br>            for neigh in graph[cur]:<br>                if dist[neigh] == n + 1:<br>                    dist[neigh] = dist[cur] + 1<br>                    queue.append(neigh)<br>                elif dist[neigh] = dist[cur] - 1:<br>                    shortest_cycle = min(shortest_cycle, dist[cur] + dist[neigh] + 1)<br>                    <br>    return -1 if shortest_cycle == n + 1 else shortest_cycle
