# Query `129`

## Original Question

*Alice and Bob are traveling to Rome for separate business meetings.

You are given 4 strings `arriveAlice`, `leaveAlice`, `arriveBob`, and `leaveBob`. Alice will be in the city from the dates `arriveAlice` to `leaveAlice` (inclusive), while Bob will be in the city from the dates `arriveBob` to `leaveBob` (inclusive). Each will be a 5-character string in the format `"MM-DD "`, corresponding to the month and day of the date.

Return _the total number of days that Alice and Bob are in Rome together._

You can assume that all dates occur in the same calendar year, which is not a leap year. Note that the number of days per month can be represented as: `[31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]`.

Example 1:

Input: arriveAlice =  "08-15 ", leaveAlice =  "08-18 ", arriveBob =  "08-16 ", leaveBob =  "08-19 "
Output: 3
Explanation: Alice will be in Rome from August 15 to August 18. Bob will be in Rome from August 16 to August 19. They are both in Rome together on August 16th, 17th, and 18th, so the answer is 3.

Example 2:

Input: arriveAlice =  "10-01 ", leaveAlice =  "10-31 ", arriveBob =  "11-01 ", leaveBob =  "12-31 "
Output: 0
Explanation: There is no day when Alice and Bob are in Rome together, so we return 0.

Constraints:

   All dates are provided in the format `"MM-DD "`.
   Alice and Bob's arrival dates are earlier than or equal to their leaving dates.
   The given dates are valid dates of a non-leap year.*


### Metrics

```
recip_rank: 0.0588
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0200
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 1.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.1470
ndcg_cut_50: 0.1470
ndcg_cut_100: 0.2492
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0294
map_cut_50: 0.0294
map_cut_100: 0.0453
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2212.txt
> def min_deletions(nums):<br>    """Alice and Bob are opponents in an archery competition. The competition has set the following rules:<br><br>1.  Alice first shoots `numArrows` arrows and then Bob shoots `numArrows` arrows.<br>2.  The points are then calculated as follows:<br>    1.  The target has integer scoring sections ranging from `0` to `11` inclusive.<br>    2.  For each section of the target with score `k` (in between `0` to `11`), say Alice and Bob have shot `ak` and `bk` arrows on that section respectively. If `ak = bk`, then Alice takes `k` points. If `ak < bk`, then Bob takes `k` points.<br>    3.  However, if `ak == bk == 0`, then nobody takes `k` points.<br><br>   For example, if Alice and Bob both shot `2` arrows on the section with score `11`, then Alice takes `11` points. On the other hand, if Alice shot `0` arrows on the section with score `11` and Bob shot `2` arrows on that same section, then Bob takes `11` points.<br>    <br><br>You are given the integer `numArrows` and an integer array `aliceArrows` of size `12`, which represents the number of arrows Alice shot on each scoring section from `0` to `11`. Now, Bob wants to maximize the total number of points he can obtain.<br><br>Return _the array_ `bobArrows` _which represents the number of arrows Bob shot on each scoring section from_ `0` _to_ `11`. The sum of the values in `bobArrows` should equal `numArrows`.<br><br>If there are multiple ways for Bob to earn the maximum total points, return any one of them.<br><br>Example 1:<br><br>Input: numArrows = 9, aliceArrows = \[1,1,0,1,0,0,2,1,0,1,2,0\]<br>Output: \[0,0,0,0,1,1,0,0,1,2,3,1\]<br>Explanation: The table above shows how the competition is scored. <br>Bob earns a total point of 4 + 5 + 8 + 9 + 10 + 11 = 47.<br>It can be shown that Bob cannot obtain a score higher than 47 points.<br><br>Example 2:<br><br>Input: numArrows = 3, aliceArrows = \[0,0,1,0,0,0,0,0,0,0,0,2\]<br>Output: \[0,0,0,0,0,0,0,0,1,1,1,0\]<br>Explanation: The table above shows how the competition is scored.<br>Bob earns a total point of 8 + 9 + 10 = 27.<br>It can be shown that Bob cannot obtain a score higher than 27 points.<br><br>Constraints:<br><br>   `1 <= numArrows <= 105`<br>   `aliceArrows.length == bobArrows.length == 12`<br>   `0 <= aliceArrows[i], bobArrows[i] <= numArrows`<br>   `sum(aliceArrows[i]) == numArrows`"""<br><br>    n = len(nums)<br>    if n <= 2:<br>        return 0<br>        <br>    min_idx, max_idx = 0, 0<br><br>    for i in range(1, n):<br>        if nums[i] < nums[min_idx]:<br>            min_idx = i<br>        if nums[i]  nums[max_idx]:<br>            max_idx = i<br><br>    return min(max(min_idx, max_idx), n - min(min_idx, max_idx) - 1, min_idx + n - max_idx - 1)

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_247208.txt
> def _calculate_solar_geometry(self, datetime):<br>        """Calculate Solar geometry for an hour of the year.<br><br>        Attributes:<br>            datetime: A Ladybug datetime<br><br>        Returns:<br>            Solar declination: Solar declination in radians<br>            eq_of_time: Equation of time as minutes<br>        """<br>        month = datetime.month<br>        day = datetime.day<br>        hour = datetime.hour<br>        minute = datetime.minute<br>        year = 2016 if self.is_leap_year else 2017<br><br>        def find_fraction_of_24(hour, minute):<br>            """<br>            This function calculates the fraction of the 24 hour<br>            the provided time represents<br>            1440 is total the number of minutes in a 24 hour cycle.<br>            args<br>                hour: Integer. Hour between 0 - 23<br>                minute: Integer. Minute between 0 - 59<br>            return: Float.<br>                The fraction of the 24 hours the provided time represents<br>            """<br>            return round((minute + hour  60) / 1440.0, 2)<br><br>        def days_from_010119(year, month, day):<br>            """<br>            This function calculates the number of days from 01-01-1900 \<br>            to the provided date<br>            args :<br>                year: Integer. The year in the date<br>                month: Integer. The month in the date<br>                day: Integer. The date<br>            return: The number of days from 01-01-1900 to the date provided<br>            """<br><br>            # Making a list of years from the year 1900<br>            years = range(1900, year)<br><br>            def is_leap_year(year):<br>                """Determine whether a year is a leap year."""<br>                return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)<br><br>            # Number of days in a year are 366 if it is a leap year<br>            days_in_year = []<br>            for item in years:<br>                if is_leap_year(item):<br>                    days_in_year.append(366)<br>                else:<br>                    days_in_year.append(365)<br><br>            # Making the total of all the days in preceding years<br>            days_in_precending_years = 0<br>            for days in days_in_year:<br>                days_in_precending_years += days<br><br>            if is_leap_year(year):<br>                month_dict = {1: 31, 2: 29, 3: 31, 4: 30, 5: 31, 6: 30,<br>                              7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}<br>            else:<br>                month_dict = {1: 31, 2: 28, 3: 31, 4: 30, 5: 31, 6: 30,<br>                              7: 31, 8: 31, 9: 30, 10: 31, 11: 30, 12: 31}<br><br>            """Making the total of all the days in preceding months\<br>            in the same year"""<br>            keys = tuple(month_dict.keys())<br>            days_in_precending_months = 0<br>            for i in range(month - 1):<br>                days_in_precending_months += month_dict[keys[i]]<br><br>            return days_in_precending_years + days_in_precending_months + day + 1<br><br>        julian_day = days_from_010119(year, month, day) + 2415018.5 + \<br>            find_fraction_of_24(hour, minute) - (float(self.time_zone) / 24)<br><br>        julian_century = (julian_day - 2451545) / 36525<br><br>        # degrees<br>        geom_mean_long_sun = (280.46646 + julian_century <br>                              (36000.76983 + julian_century  0.0003032)<br>                              ) % 360<br>        # degrees<br>        geom_mean_anom_sun = 357.52911 + julian_century  \<br>            (35999.05029 - 0.0001537  julian_century)<br><br>        eccent_orbit = 0.016708634 - julian_century  \<br>            (0.000042037 + 0.0000001267  julian_century)<br><br>        sun_eq_of_ctr = math.sin(<br>            math.radians(geom_mean_anom_sun))  \<br>            (1.914602 - julian_century  (0.004817 + 0.000014  julian_century)<br>             ) +\<br>            math.sin(math.radians(2  geom_mean_anom_sun))  \<br>            (0.019993 - 0.000101  julian_century) + \<br>            math.sin(math.radians(3  geom_mean_anom_sun))  \<br>            0.000289<br><br>        # degrees<br>        sun_true_long = geom_mean_long_sun + sun_eq_of_ctr<br><br>        # degrees<br>        sun_app_long = sun_true_long - 0.00569 - 0.00478  \<br>            math.sin(math.radians(125.04 - 1934.136  julian_century))<br><br>        # degrees<br>        mean_obliq_ecliptic = 23 + \<br>            (26 + ((21.448 - julian_century  (46.815 + julian_century <br>                                               (0.00059 - julian_century <br>                                                0.001813)))) / 60) / 60<br><br>        # degrees<br>        oblique_corr = mean_obliq_ecliptic + 0.00256  \<br>            math.cos(math.radians(125.04 - 1934.136  julian_century))<br><br>        # RADIANS<br>        sol_dec = math.degrees(math.asin(math.sin(math.radians(oblique_corr)) <br>                                         math.sin(math.radians(sun_app_long))))<br><br>        var_y = math.tan(math.radians(oblique_corr / 2))  \<br>            math.tan(math.radians(oblique_corr / 2))<br><br>        # minutes<br>        eq_of_time = 4 \<br>             math.degrees(<br>                var_y  math.sin(2  math.radians(geom_mean_long_sun)) -<br>                2  eccent_orbit  math.sin(math.radians(geom_mean_anom_sun)) +<br>                4  eccent_orbit  var_y <br>                math.sin(math.radians(geom_mean_anom_sun)) <br>                math.cos(2  math.radians(geom_mean_long_sun)) -<br>                0.5  (var_y  2) <br>                math.sin(4  math.radians(geom_mean_long_sun)) -<br>                1.25  (eccent_orbit  2) <br>                math.sin(2  math.radians(geom_mean_anom_sun))<br>            )<br><br>        return sol_dec, eq_of_time

### DOC[3] (IRRELEVANT) leetcode/leetcode_2105.txt
> def numberOfGoodSubsets(nums: list[int]) - int:<br>    """Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`.<br><br>Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:<br><br>   Alice waters the plants in order from left to right, starting from the `0th` plant. Bob waters the plants in order from right to left, starting from the `(n - 1)th` plant. They begin watering the plants simultaneously.<br>   It takes the same amount of time to water each plant regardless of how much water it needs.<br>   Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.<br>   In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.<br><br>Given a 0-indexed integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the number of times they have to refill to water all the plants_.<br><br>Example 1:<br><br>Input: plants = \[2,2,3,3\], capacityA = 5, capacityB = 5<br>Output: 1<br>Explanation:<br>- Initially, Alice and Bob have 5 units of water each in their watering cans.<br>- Alice waters plant 0, Bob waters plant 3.<br>- Alice and Bob now have 3 units and 2 units of water respectively.<br>- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.<br>So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.<br><br>Example 2:<br><br>Input: plants = \[2,2,3,3\], capacityA = 3, capacityB = 4<br>Output: 2<br>Explanation:<br>- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.<br>- Alice waters plant 0, Bob waters plant 3.<br>- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.<br>- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.<br>So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.<br><br>Example 3:<br><br>Input: plants = \[5\], capacityA = 10, capacityB = 8<br>Output: 0<br>Explanation:<br>- There is only one plant.<br>- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.<br>So, the total number of times they have to refill is 0.<br><br>Constraints:<br><br>   `n == plants.length`<br>   `1 <= n <= 105`<br>   `1 <= plants[i] <= 106`<br>   `max(plants[i]) <= capacityA, capacityB <= 109`"""<br><br>    MOD = 109 + 7<br><br>    def is_prime(n: int) - bool:<br>        if n <= 1:<br>            return False<br>        for i in range(2, int(n0.5) + 1):<br>            if n % i == 0:<br>                return False<br>        return True<br><br>    primes = [i for i in range(2, 91) if is_prime(i)]<br>    cnt = [0]  100<br>    for n in nums:<br>        cnt[n] += 1<br><br>    dp = [0]  (1 << 20)<br>    dp[0] = 1<br>    <br>    for i in range(30, 0, -1):<br>        if cnt[i] == 0:<br>            continue<br>        mask = [j for j in primes if i % j == 0]<br>        i = i // j<br>        if i  1:<br>            continue<br><br>        m = 0<br>        for j in mask:<br>            m |= 1 << (j - 2)<br><br>        for j in range(len(dp)-1, -1, -1):<br>            if dp[j] == 0:<br>                continue<br>            cur = 1<br>            for k in range(cnt[m]):<br>                cur = (cur  2) % MOD<br>                dp[j | m] = (dp[j | m] + dp[j]  cur) % MOD<br><br>    ans = sum(dp) % MOD<br>    ans = (ans - dp[0] + MOD) % MOD<br>    return (ans  (1 << (cnt[1] - 1))) % MOD

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_43834.txt
> def gcal2jd(year, month, day):<br>    """Gregorian calendar date to Julian date.<br><br>    The input and output are for the proleptic Gregorian calendar,<br>    i.e., no consideration of historical usage of the calendar is<br>    made.<br><br>    Parameters<br>    ----------<br>    year : int<br>        Year as an integer.<br>    month : int<br>        Month as an integer.<br>    day : int<br>        Day as an integer.<br><br>    Returns<br>    -------<br>    jd1, jd2: 2-element tuple of floats<br>        When added together, the numbers give the Julian date for the<br>        given Gregorian calendar date. The first number is always<br>        MJD_0 i.e., 2451545.5. So the second is the MJD.<br><br>    Examples<br>    --------<br>     gcal2jd(2000,1,1)<br>    (2400000.5, 51544.0)<br>     2400000.5 + 51544.0 + 0.5<br>    2451545.0<br>     year = [-4699, -2114, -1050, -123, -1, 0, 1, 123, 1678.0, 2000,<br>    ....: 2012, 2245]<br>     month = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]<br>     day = [1, 12, 23, 14, 25, 16, 27, 8, 9, 10, 11, 31]<br>     x = [gcal2jd(y, m, d) for y, m, d in zip(year, month, day)]<br>     for i in x: print i<br>    (2400000.5, -2395215.0)<br>    (2400000.5, -1451021.0)<br>    (2400000.5, -1062364.0)<br>    (2400000.5, -723762.0)<br>    (2400000.5, -679162.0)<br>    (2400000.5, -678774.0)<br>    (2400000.5, -678368.0)<br>    (2400000.5, -633797.0)<br>    (2400000.5, -65812.0)<br>    (2400000.5, 51827.0)<br>    (2400000.5, 56242.0)<br>    (2400000.5, 141393.0)<br><br>    Negative months and days are valid. For example, 2000/-2/-4 =<br>    1999/+12-2/-4 = 1999/10/-4 = 1999/9/30-4 = 1999/9/26.<br><br>     gcal2jd(2000, -2, -4)<br>    (2400000.5, 51447.0)<br>     gcal2jd(1999, 9, 26)<br>    (2400000.5, 51447.0)<br><br>     gcal2jd(2000, 2, -1)<br>    (2400000.5, 51573.0)<br>     gcal2jd(2000, 1, 30)<br>    (2400000.5, 51573.0)<br><br>     gcal2jd(2000, 3, -1)<br>    (2400000.5, 51602.0)<br>     gcal2jd(2000, 2, 28)<br>    (2400000.5, 51602.0)<br><br>    Month 0 becomes previous month.<br><br>     gcal2jd(2000, 0, 1)<br>    (2400000.5, 51513.0)<br>     gcal2jd(1999, 12, 1)<br>    (2400000.5, 51513.0)<br><br>    Day number 0 becomes last day of previous month.<br><br>     gcal2jd(2000, 3, 0)<br>    (2400000.5, 51603.0)<br>     gcal2jd(2000, 2, 29)<br>    (2400000.5, 51603.0)<br><br>    If `day` is greater than the number of days in `month`, then it<br>    gets carried over to the next month.<br><br>     gcal2jd(2000,2,30)<br>    (2400000.5, 51604.0)<br>     gcal2jd(2000,3,1)<br>    (2400000.5, 51604.0)<br><br>     gcal2jd(2001,2,30)<br>    (2400000.5, 51970.0)<br>     gcal2jd(2001,3,2)<br>    (2400000.5, 51970.0)<br><br>    Notes<br>    -----<br>    The returned Julian date is for mid-night of the given date. To<br>    find the Julian date for any time of the day, simply add time as a<br>    fraction of a day. For example Julian date for mid-day can be<br>    obtained by adding 0.5 to either the first part or the second<br>    part. The latter is preferable, since it will give the MJD for the<br>    date and time.<br><br>    BC dates should be given as -(BC - 1) where BC is the year. For<br>    example 1 BC == 0, 2 BC == -1, and so on.<br><br>    Negative numbers can be used for `month` and `day`. For example<br>    2000, -1, 1 is the same as 1999, 11, 1.<br><br>    The Julian dates are proleptic Julian dates, i.e., values are<br>    returned without considering if Gregorian dates are valid for the<br>    given date.<br><br>    The input values are truncated to integers.<br><br>    """<br>    year = int(year)<br>    month = int(month)<br>    day = int(day)<br><br>    a = ipart((month - 14) / 12.0)<br>    jd = ipart((1461  (year + 4800 + a)) / 4.0)<br>    jd += ipart((367  (month - 2 - 12  a)) / 12.0)<br>    x = ipart((year + 4900 + a) / 100.0)<br>    jd -= ipart((3  x) / 4.0)<br>    jd += day - 2432075.5  # was 32075; add 2400000.5<br><br>    jd -= 0.5  # 0 hours; above JD is for midday, switch to midnight.<br><br>    return MJD_0, jd

### DOC[5] (IRRELEVANT) leetcode/leetcode_2467.txt
> from collections import defaultdict<br>    """There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>At every node `i`, there is a gate. You are also given an array of even integers `amount`, where `amount[i]` represents:<br><br>   the price needed to open the gate at node `i`, if `amount[i]` is negative, or,<br>   the cash reward obtained on opening the gate at node `i`, otherwise.<br><br>The game goes on as follows:<br><br>   Initially, Alice is at node `0` and Bob is at node `bob`.<br>   At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node `0`.<br>   For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:<br>       If the gate is already open, no price will be required, nor will there be any cash reward.<br>       If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.<br>   If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are independent of each other.<br><br>Return _the maximum net income Alice can have if she travels towards the optimal leaf node._<br><br>Example 1:<br><br>Input: edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\]\], bob = 3, amount = \[-2,4,2,-4,6\]<br>Output: 6<br>Explanation: <br>The above diagram represents the given tree. The game goes as follows:<br>- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.<br>  Alice's net income is now -2.<br>- Both Alice and Bob move to node 1. <br>  Since they reach here simultaneously, they open the gate together and share the reward.<br>  Alice's net income becomes -2 + (4 / 2) = 0.<br>- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.<br>  Bob moves on to node 0, and stops moving.<br>- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.<br>Now, neither Alice nor Bob can make any further moves, and the game ends.<br>It is not possible for Alice to get a higher net income.<br><br>Example 2:<br><br>Input: edges = \[\[0,1\]\], bob = 1, amount = \[-7280,2350\]<br>Output: -7280<br>Explanation: <br>Alice follows the path 0-1 whereas Bob follows the path 1-0.<br>Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. <br><br>Constraints:<br><br>   `2 <= n <= 105`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree.<br>   `1 <= bob < n`<br>   `amount.length == n`<br>   `amount[i]` is an even integer in the range `[-104, 104]`."""<br><br><br>def dfs(node, parent, bob, time, alice_income, res, amount, tree):<br>    if time < bob or amount[node] = 0:<br>        alice_income += amount[node]<br>    else:<br>        alice_income += amount[node] // 2<br>    amount[node] = 0<br>    is_leaf = True<br>    for child in tree[node]:<br>        if child != parent:<br>            is_leaf = False<br>            dfs(child, node, bob, time + 1, alice_income, res, amount, tree)<br>    if is_leaf:<br>        res[0] = max(res[0], alice_income)<br><br>def maxNetIncome(edges, bob, amount):<br>    tree = defaultdict(list)<br>    for edge in edges:<br>        tree[edge[0]].append(edge[1])<br>        tree[edge[1]].append(edge[0])<br>    res = [-100000]<br>    dfs(0, -1, bob, 0, 0, res, amount, tree)<br>    return res[0]


## Ground Truth

### GROUND TRUTH 0, ranked 16, leetcode/leetcode_1360.txt
> def maxLength(arr):<br>    """Write a program to count the number of days between two dates.<br><br>The two dates are given as strings, their format is `YYYY-MM-DD` as shown in the examples.<br><br>Example 1:<br><br>Input: date1 = "2019-06-29", date2 = "2019-06-30"<br>Output: 1<br><br>Example 2:<br><br>Input: date1 = "2020-01-15", date2 = "2019-12-31"<br>Output: 15<br><br>Constraints:<br><br>   The given dates are valid dates between the years `1971` and `2100`."""<br><br>    dp = ['']<br>    maxLen = 0<br><br>    for s in arr:<br>        if len(set(s)) < len(s): continue<br>        for i in range(len(dp) - 1, -1, -1):<br>            tmp = dp[i] + s<br>            if len(set(tmp)) == len(tmp):<br>                dp.append(tmp)<br>                maxLen = max(maxLen, len(tmp))<br>                <br>    return maxLen

### GROUND TRUTH 1, ranked 62, leetcode/leetcode_2224.txt
> def minimum_operations(current: str, correct: str) - int:<br>    """You are given two strings `current` and `correct` representing two 24-hour times.<br><br>24-hour times are formatted as `"HH:MM "`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.<br><br>In one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation any number of times.<br><br>Return _the minimum number of operations needed to convert_ `current` _to_ `correct`.<br><br>Example 1:<br><br>Input: current =  "02:30 ", correct =  "04:35 "<br>Output: 3<br>Explanation:<br>We can convert current to correct in 3 operations as follows:<br>- Add 60 minutes to current. current becomes  "03:30 ".<br>- Add 60 minutes to current. current becomes  "04:30 ".<br>- Add 5 minutes to current. current becomes  "04:35 ".<br>It can be proven that it is not possible to convert current to correct in fewer than 3 operations.<br><br>Example 2:<br><br>Input: current =  "11:00 ", correct =  "11:01 "<br>Output: 1<br>Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.<br><br>Constraints:<br><br>   `current` and `correct` are in the format `"HH:MM "`<br>   `current <= correct`"""<br><br>    ch, cm = map(int, current.split(':'))<br>    th, tm = map(int, correct.split(':'))<br>    ct = ch  60 + cm<br>    tt = th  60 + tm<br><br>    operations = 0<br>    while ct < tt:<br>        if tt - ct = 60:<br>            ct += 60<br>        elif tt - ct = 15:<br>            ct += 15<br>        elif tt - ct = 5:<br>            ct += 5<br>        else:<br>            ct += 1<br><br>        operations += 1<br><br>    return operations
