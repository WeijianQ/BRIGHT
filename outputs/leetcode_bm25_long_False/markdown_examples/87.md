# Query `87`

## Original Question

*There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in left to right order. You are given an array `heights` of distinct integers where `heights[i]` represents the height of the `ith` person.

A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`.

Return _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the number of people the_ `ith` _person can see to their right in the queue_.

Example 1:

Input: heights = \[10,6,8,5,11,9\]
Output: \[3,1,2,1,1,0\]
Explanation:
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.

Example 2:

Input: heights = \[5,1,2,3,10\]
Output: \[4,1,1,1,0\]

Constraints:

   `n == heights.length`
   `1 <= n <= 105`
   `1 <= heights[i] <= 105`
   All the values of `heights` are unique.*


### Metrics

```
recip_rank: 0.0035
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2251.txt
> MOD = 109 + 7<br>    """You are given a 0-indexed 2D integer array `flowers`, where `flowers[i] = [starti, endi]` means the `ith` flower will be in full bloom from `starti` to `endi` (inclusive). You are also given a 0-indexed integer array `people` of size `n`, where `poeple[i]` is the time that the `ith` person will arrive to see the flowers.<br><br>Return _an integer array_ `answer` _of size_ `n`_, where_ `answer[i]` _is the number of flowers that are in full bloom when the_ `ith` _person arrives._<br><br>Example 1:<br><br>Input: flowers = \[\[1,6\],\[3,7\],\[9,12\],\[4,13\]\], poeple = \[2,3,7,11\]<br>Output: \[1,2,2,2\]<br>Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.<br>For each person, we return the number of flowers in full bloom during their arrival.<br><br>Example 2:<br><br>Input: flowers = \[\[1,10\],\[3,3\]\], poeple = \[3,3,2\]<br>Output: \[2,2,1\]<br>Explanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.<br>For each person, we return the number of flowers in full bloom during their arrival.<br><br>Constraints:<br><br>   `1 <= flowers.length <= 5  104`<br>   `flowers[i].length == 2`<br>   `1 <= starti <= endi <= 109`<br>   `1 <= people.length <= 5  104`<br>   `1 <= people[i] <= 109`"""<br><br><br>def corridor_ways(corridor):<br>    n = len(corridor)<br>    dp = [0]  (n + 1)<br>    dp[0] = 1<br><br>    seats = 0<br>    for i in range(n):<br>        if corridor[i] == 'S':<br>            seats += 1<br>            if seats % 2 == 0:<br>                dp[i + 1] = dp[max(0, i - 1)]<br>            dp[i + 1] = (dp[i] + dp[i + 1]) % MOD<br>        else:<br>            dp[i + 1] = dp[i]<br><br>    return dp[n]

### DOC[2] (IRRELEVANT) leetcode/leetcode_2300.txt
> def repeat_limited_string(s, repeat_limit):<br>    """You are given two positive integer arrays `spells` and `potions`, of length `n` and `m` respectively, where `spells[i]` represents the strength of the `ith` spell and `potions[j]` represents the strength of the `jth` potion.<br><br>You are also given an integer `success`. A spell and potion pair is considered successful if the product of their strengths is at least `success`.<br><br>Return _an integer array_ `pairs` _of length_ `n` _where_ `pairs[i]` _is the number of potions that will form a successful pair with the_ `ith` _spell._<br><br>Example 1:<br><br>Input: spells = \[5,1,3\], potions = \[1,2,3,4,5\], success = 7<br>Output: \[4,0,3\]<br>Explanation:<br>- 0th spell: 5 \ \[1,2,3,4,5\] = \[5,10,15,20,25\]. 4 pairs are successful.<br>- 1st spell: 1 \ \[1,2,3,4,5\] = \[1,2,3,4,5\]. 0 pairs are successful.<br>- 2nd spell: 3 \ \[1,2,3,4,5\] = \[3,6,9,12,15\]. 3 pairs are successful.<br>Thus, \[4,0,3\] is returned.<br><br>Example 2:<br><br>Input: spells = \[3,1,2\], potions = \[8,5,8\], success = 16<br>Output: \[2,0,2\]<br>Explanation:<br>- 0th spell: 3 \ \[8,5,8\] = \[24,15,24\]. 2 pairs are successful.<br>- 1st spell: 1 \ \[8,5,8\] = \[8,5,8\]. 0 pairs are successful. <br>- 2nd spell: 2 \ \[8,5,8\] = \[16,10,16\]. 2 pairs are successful. <br>Thus, \[2,0,2\] is returned.<br><br>Constraints:<br><br>   `n == spells.length`<br>   `m == potions.length`<br>   `1 <= n, m <= 105`<br>   `1 <= spells[i], potions[i] <= 105`<br>   `1 <= success <= 1010`"""<br><br>    result = []<br>    sorted_s = sorted(s, reverse=True)<br>    <br>    for c in sorted_s:<br>        pos = result.count(c)<br>        <br>        if pos < repeat_limit:<br>            result.insert(pos, c)<br><br>    return "".join(result)

### DOC[3] (IRRELEVANT) leetcode/leetcode_2250.txt
> from heapq import heappush, heappop<br>    """You are given a 2D integer array `rectangles` where `rectangles[i] = [li, hi]` indicates that `ith` rectangle has a length of `li` and a height of `hi`. You are also given a 2D integer array `points` where `points[j] = [xj, yj]` is a point with coordinates `(xj, yj)`.<br><br>The `ith` rectangle has its bottom-left corner point at the coordinates `(0, 0)` and its top-right corner point at `(li, hi)`.<br><br>Return _an integer array_ `count` _of length_ `points.length` _where_ `count[j]` _is the number of rectangles that contain the_ `jth` _point._<br><br>The `ith` rectangle contains the `jth` point if `0 <= xj <= li` and `0 <= yj <= hi`. Note that points that lie on the edges of a rectangle are also considered to be contained by that rectangle.<br><br>Example 1:<br><br>Input: rectangles = \[\[1,2\],\[2,3\],\[2,5\]\], points = \[\[2,1\],\[1,4\]\]<br>Output: \[2,1\]<br>Explanation: <br>The first rectangle contains no points.<br>The second rectangle contains only the point (2, 1).<br>The third rectangle contains the points (2, 1) and (1, 4).<br>The number of rectangles that contain the point (2, 1) is 2.<br>The number of rectangles that contain the point (1, 4) is 1.<br>Therefore, we return \[2, 1\].<br><br>Example 2:<br><br>Input: rectangles = \[\[1,1\],\[2,2\],\[3,3\]\], points = \[\[1,3\],\[1,1\]\]<br>Output: \[1,3\]<br>Explanation:<br>The first rectangle contains only the point (1, 1).<br>The second rectangle contains only the point (1, 1).<br>The third rectangle contains the points (1, 3) and (1, 1).<br>The number of rectangles that contain the point (1, 3) is 1.<br>The number of rectangles that contain the point (1, 1) is 3.<br>Therefore, we return \[1, 3\].<br><br>Constraints:<br><br>   `1 <= rectangles.length, points.length <= 5  104`<br>   `rectangles[i].length == points[j].length == 2`<br>   `1 <= li, xj <= 109`<br>   `1 <= hi, yj <= 100`<br>   All the `rectangles` are unique.<br>   All the `points` are unique."""<br><br><br>def kHighestRankedItems(grid, pricing, start, k):<br>    m, n = len(grid), len(grid[0])<br>    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]<br>    res = []<br>    pq = []<br>    visited = [[False for _ in range(n)] for _ in range(m)]<br><br>    heappush(pq, (0, -grid[start[0]][start[1]], start[0], start[1]))<br>    visited[start[0]][start[1]] = True<br><br>    while pq and k  0:<br>        size = len(pq)<br>        for _ in range(size):<br>            curr = heappop(pq)<br>            steps, price, row, col = curr<br><br>            if pricing[0] <= -price <= pricing[1]:<br>                res.append([row, col])<br>                k -= 1<br><br>            for dr, dc in directions:<br>                newRow, newCol = row + dr, col + dc<br>                if 0 <= newRow < m and 0 <= newCol < n and not visited[newRow][newCol]:<br>                    visited[newRow][newCol] = True<br>                    heappush(pq, (steps + 1, -grid[newRow][newCol], newRow, newCol))<br><br>    return res

### DOC[4] (IRRELEVANT) leetcode/leetcode_2070.txt
> from bisect import bisect_right<br>    """You are given a 2D integer array `items` where `items[i] = [pricei, beautyi]` denotes the price and beauty of an item respectively.<br><br>You are also given a 0-indexed integer array `queries`. For each `queries[j]`, you want to determine the maximum beauty of an item whose price is less than or equal to `queries[j]`. If no such item exists, then the answer to this query is `0`.<br><br>Return _an array_ `answer` _of the same length as_ `queries` _where_ `answer[j]` _is the answer to the_ `jth` _query_.<br><br>Example 1:<br><br>Input: items = \[\[1,2\],\[3,2\],\[2,4\],\[5,6\],\[3,5\]\], queries = \[1,2,3,4,5,6\]<br>Output: \[2,4,5,5,6,6\]<br>Explanation:<br>- For queries\[0\]=1, \[1,2\] is the only item which has price <= 1. Hence, the answer for this query is 2.<br>- For queries\[1\]=2, the items which can be considered are \[1,2\] and \[2,4\]. <br>  The maximum beauty among them is 4.<br>- For queries\[2\]=3 and queries\[3\]=4, the items which can be considered are \[1,2\], \[3,2\], \[2,4\], and \[3,5\].<br>  The maximum beauty among them is 5.<br>- For queries\[4\]=5 and queries\[5\]=6, all items can be considered.<br>  Hence, the answer for them is the maximum beauty of all items, i.e., 6.<br><br>Example 2:<br><br>Input: items = \[\[1,2\],\[1,2\],\[1,3\],\[1,4\]\], queries = \[1\]<br>Output: \[4\]<br>Explanation: <br>The price of every item is equal to 1, so we choose the item with the maximum beauty 4. <br>Note that multiple items can have the same price and/or beauty.  <br><br>Example 3:<br><br>Input: items = \[\[10,1000\]\], queries = \[5\]<br>Output: \[0\]<br>Explanation:<br>No item has a price less than or equal to 5, so no item can be chosen.<br>Hence, the answer to the query is 0.<br><br>Constraints:<br><br>   `1 <= items.length, queries.length <= 105`<br>   `items[i].length == 2`<br>   `1 <= pricei, beautyi, queries[j] <= 109`"""<br><br><br>def maxPrices(items, queries):<br>    answer = []<br>    sorted_items = [item[0] for item in items]<br>    sorted_items.sort()<br><br>    max_beauty = 0<br>    for i, price in enumerate(sorted_items):<br>        max_beauty = max(max_beauty, items[i][1])<br>        sorted_items[i] = max_beauty<br><br>    for query in queries:<br>        idx = bisect_right(sorted_items, query) - 1<br>        answer.append(sorted_items[idx] if idx = 0 else 0)<br><br>    return answer

### DOC[5] (IRRELEVANT) leetcode/leetcode_851.txt
> def to_goat_latin(sentence: str) - str:<br>    """There is a group of `n` people labeled from `0` to `n - 1` where each person has a different amount of money and a different level of quietness.<br><br>You are given an array `richer` where `richer[i] = [ai, bi]` indicates that `ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is the quietness of the `ith` person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where `x` is richer than `y` and `y` is richer than `x` at the same time).<br><br>Return _an integer array_ `answer` _where_ `answer[x] = y` _if_ `y` _is the least quiet person (that is, the person_ `y` _with the smallest value of_ `quiet[y]`_) among all people who definitely have equal to or more money than the person_ `x`.<br><br>Example 1:<br><br>Input: richer = \[\[1,0\],\[2,1\],\[3,1\],\[3,7\],\[4,3\],\[5,3\],\[6,3\]\], quiet = \[3,2,5,4,6,1,7,0\]<br>Output: \[5,5,2,5,4,5,6,7\]<br>Explanation: <br>answer\[0\] = 5.<br>Person 5 has more money than 3, which has more money than 1, which has more money than 0.<br>The only person who is quieter (has lower quiet\[x\]) is person 7, but it is not clear if they have more money than person 0.<br>answer\[7\] = 7.<br>Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet\[x\]) is person 7.<br>The other answers can be filled out with similar reasoning.<br><br>Example 2:<br><br>Input: richer = \[\], quiet = \[0\]<br>Output: \[0\]<br><br>Constraints:<br><br>   `n == quiet.length`<br>   `1 <= n <= 500`<br>   `0 <= quiet[i] < n`<br>   All the values of `quiet` are unique.<br>   `0 <= richer.length <= n  (n - 1) / 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   All the pairs of `richer` are unique.<br>   The observations in `richer` are all logically consistent."""<br><br>    words = sentence.split()<br>    vowels = set("AEIOUaeiou")<br>    result = []<br><br>    for i, word in enumerate(words):<br>        if word[0] not in vowels:<br>            word = word[1:] + word[0]<br>        result.append(word + "ma" + "a"  (i + 1))<br><br>    return ' '.join(result)


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2104.txt
> from collections import defaultdict<br>    """You are given an integer array `nums`. The range of a subarray of `nums` is the difference between the largest and smallest element in the subarray.<br><br>Return _the sum of all subarray ranges of_ `nums`_._<br><br>A subarray is a contiguous non-empty sequence of elements within an array.<br><br>Example 1:<br><br>Input: nums = \[1,2,3\]<br>Output: 4<br>Explanation: The 6 subarrays of nums are the following:<br>\[1\], range = largest - smallest = 1 - 1 = 0 <br>\[2\], range = 2 - 2 = 0<br>\[3\], range = 3 - 3 = 0<br>\[1,2\], range = 2 - 1 = 1<br>\[2,3\], range = 3 - 2 = 1<br>\[1,2,3\], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.<br><br>Example 2:<br><br>Input: nums = \[1,3,3\]<br>Output: 4<br>Explanation: The 6 subarrays of nums are the following:<br>\[1\], range = largest - smallest = 1 - 1 = 0<br>\[3\], range = 3 - 3 = 0<br>\[3\], range = 3 - 3 = 0<br>\[1,3\], range = 3 - 1 = 2<br>\[3,3\], range = 3 - 3 = 0<br>\[1,3,3\], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.<br><br>Example 3:<br><br>Input: nums = \[4,-2,-3,4,1\]<br>Output: 59<br>Explanation: The sum of all subarray ranges of nums is 59.<br><br>Constraints:<br><br>   `1 <= nums.length <= 1000`<br>   `-109 <= nums[i] <= 109`<br><br>Follow-up: Could you find a solution with `O(n)` time complexity?"""<br><br><br>class LockingTree:<br><br>    def __init__(self, parent):<br>        self.parent = parent<br>        self.children = defaultdict(set)<br>        self.locks = [-1]  len(parent)<br>        for i in range(1, len(parent)):<br>            self.children[parent[i]].add(i)<br>    <br>    def lock(self, num, user):<br>        if self.locks[num] == -1:<br>            self.locks[num] = user<br>            return True<br>        return False<br>    <br>    def unlock(self, num, user):<br>        if self.locks[num] == user:<br>            self.locks[num] = -1<br>            return True<br>        return False<br>    <br>    def upgrade(self, num, user):<br>        if self.locks[num] != -1: return False<br>        <br>        cur = num<br>        while cur != -1:<br>            if self.locks[cur] != -1: return False<br>            cur = self.parent[cur]<br>        <br>        locked_descendant = self._has_locked_descendants(num)<br>        if locked_descendant:<br>            self.locks[num] = user<br>        return locked_descendant<br>    <br>    def _has_locked_descendants(self, node):<br>        locked_descendant = False<br>        for child in self.children[node]:<br>            if self.locks[child] != -1:<br>                locked_descendant = True<br>                self.locks[child] = -1<br>            locked_descendant |= self._has_locked_descendants(child)<br>        return locked_descendant

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_2281.txt
> mod = 1000000007<br>    """As the ruler of a kingdom, you have an army of wizards at your command.<br><br>You are given a 0-indexed integer array `strength`, where `strength[i]` denotes the strength of the `ith` wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of `strength`), the total strength is defined as the product of the following two values:<br><br>   The strength of the weakest wizard in the group.<br>   The total of all the individual strengths of the wizards in the group.<br><br>Return _the sum of the total strengths of all contiguous groups of wizards_. Since the answer may be very large, return it modulo `109 + 7`.<br><br>A subarray is a contiguous non-empty sequence of elements within an array.<br><br>Example 1:<br><br>Input: strength = \[1,3,1,2\]<br>Output: 44<br>Explanation: The following are all the contiguous groups of wizards:<br>- \[1\] from \[1,3,1,2\] has a total strength of min(\[1\]) \ sum(\[1\]) = 1 \ 1 = 1<br>- \[3\] from \[1,3,1,2\] has a total strength of min(\[3\]) \ sum(\[3\]) = 3 \ 3 = 9<br>- \[1\] from \[1,3,1,2\] has a total strength of min(\[1\]) \ sum(\[1\]) = 1 \ 1 = 1<br>- \[2\] from \[1,3,1,2\] has a total strength of min(\[2\]) \ sum(\[2\]) = 2 \ 2 = 4<br>- \[1,3\] from \[1,3,1,2\] has a total strength of min(\[1,3\]) \ sum(\[1,3\]) = 1 \ 4 = 4<br>- \[3,1\] from \[1,3,1,2\] has a total strength of min(\[3,1\]) \ sum(\[3,1\]) = 1 \ 4 = 4<br>- \[1,2\] from \[1,3,1,2\] has a total strength of min(\[1,2\]) \ sum(\[1,2\]) = 1 \ 3 = 3<br>- \[1,3,1\] from \[1,3,1,2\] has a total strength of min(\[1,3,1\]) \ sum(\[1,3,1\]) = 1 \ 5 = 5<br>- \[3,1,2\] from \[1,3,1,2\] has a total strength of min(\[3,1,2\]) \ sum(\[3,1,2\]) = 1 \ 6 = 6<br>- \[1,3,1,2\] from \[1,3,1,2\] has a total strength of min(\[1,3,1,2\]) \ sum(\[1,3,1,2\]) = 1 \ 7 = 7<br>The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.<br><br>Example 2:<br><br>Input: strength = \[5,4,6\]<br>Output: 213<br>Explanation: The following are all the contiguous groups of wizards: <br>- \[5\] from \[5,4,6\] has a total strength of min(\[5\]) \ sum(\[5\]) = 5 \ 5 = 25<br>- \[4\] from \[5,4,6\] has a total strength of min(\[4\]) \ sum(\[4\]) = 4 \ 4 = 16<br>- \[6\] from \[5,4,6\] has a total strength of min(\[6\]) \ sum(\[6\]) = 6 \ 6 = 36<br>- \[5,4\] from \[5,4,6\] has a total strength of min(\[5,4\]) \ sum(\[5,4\]) = 4 \ 9 = 36<br>- \[4,6\] from \[5,4,6\] has a total strength of min(\[4,6\]) \ sum(\[4,6\]) = 4 \ 10 = 40<br>- \[5,4,6\] from \[5,4,6\] has a total strength of min(\[5,4,6\]) \ sum(\[5,4,6\]) = 4 \ 15 = 60<br>The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.<br><br>Constraints:<br><br>   `1 <= strength.length <= 105`<br>   `1 <= strength[i] <= 109`"""<br><br>def sum_of_strength(strength):<br>    res, strength_len = 0, len(strength)<br>    for i in range(strength_len):<br>        minimum = total = strength[i]<br>        for j in range(i, strength_len):<br>            minimum = min(minimum, strength[j])<br>            total += strength[j]<br>            res = (res + minimum  total % mod) % mod<br>    return res
