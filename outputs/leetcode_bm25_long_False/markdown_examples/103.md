# Query `103`

## Original Question

*Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`.

Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:

   Alice waters the plants in order from left to right, starting from the `0th` plant. Bob waters the plants in order from right to left, starting from the `(n - 1)th` plant. They begin watering the plants simultaneously.
   It takes the same amount of time to water each plant regardless of how much water it needs.
   Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.
   In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.

Given a 0-indexed integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the number of times they have to refill to water all the plants_.

Example 1:

Input: plants = \[2,2,3,3\], capacityA = 5, capacityB = 5
Output: 1
Explanation:
- Initially, Alice and Bob have 5 units of water each in their watering cans.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 3 units and 2 units of water respectively.
- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.
So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.

Example 2:

Input: plants = \[2,2,3,3\], capacityA = 3, capacityB = 4
Output: 2
Explanation:
- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.
- Alice waters plant 0, Bob waters plant 3.
- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.
- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.
So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.

Example 3:

Input: plants = \[5\], capacityA = 10, capacityB = 8
Output: 0
Explanation:
- There is only one plant.
- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.
So, the total number of times they have to refill is 0.

Constraints:

   `n == plants.length`
   `1 <= n <= 105`
   `1 <= plants[i] <= 106`
   `max(plants[i]) <= capacityA, capacityB <= 109`*


### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 1.0000
recall_5: 1.0000
recall_10: 1.0000
recall_25: 1.0000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 1.0000
ndcg_cut_10: 1.0000
ndcg_cut_25: 1.0000
ndcg_cut_50: 1.0000
ndcg_cut_100: 1.0000
map_cut_1: 1.0000
map_cut_5: 1.0000
map_cut_10: 1.0000
map_cut_25: 1.0000
map_cut_50: 1.0000
map_cut_100: 1.0000
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2079.txt
> from collections import defaultdict<br>    """You want to water `n` plants in your garden with a watering can. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`. There is a river at `x = -1` that you can refill your watering can at.<br><br>Each plant needs a specific amount of water. You will water the plants in the following way:<br><br>   Water the plants in order from left to right.<br>   After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.<br>   You cannot refill the watering can early.<br><br>You are initially at the river (i.e., `x = -1`). It takes one step to move one unit on the x-axis.<br><br>Given a 0-indexed integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and an integer `capacity` representing the watering can capacity, return _the number of steps needed to water all the plants_.<br><br>Example 1:<br><br>Input: plants = \[2,2,3,3\], capacity = 5<br>Output: 14<br>Explanation: Start at the river with a full watering can:<br>- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.<br>- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.<br>- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).<br>- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.<br>- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).<br>- Walk to plant 3 (4 steps) and water it.<br>Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.<br><br>Example 2:<br><br>Input: plants = \[1,1,1,4,2,3\], capacity = 4<br>Output: 30<br>Explanation: Start at the river with a full watering can:<br>- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).<br>- Water plant 3 (4 steps). Return to river (4 steps).<br>- Water plant 4 (5 steps). Return to river (5 steps).<br>- Water plant 5 (6 steps).<br>Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.<br><br>Example 3:<br><br>Input: plants = \[7,7,7,7,7,7,7\], capacity = 8<br>Output: 49<br>Explanation: You have to refill before watering each plant.<br>Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.<br><br>Constraints:<br><br>   `n == plants.length`<br>   `1 <= n <= 1000`<br>   `1 <= plants[i] <= 106`<br>   `max(plants[i]) <= capacity <= 109`"""<br><br><br>def deleteDuplicateFolder(paths):<br>    graph = defaultdict(set)<br>    count = defaultdict(int)<br><br>    for path in paths:<br>        serialized_path = ""<br>        for folder in path:<br>            serialized_path += "/" + folder<br>            graph[serialized_path].add(folder)<br><br>    for value in graph.values():<br>        count[str(value)] += 1<br><br>    ans = []<br>    for path in paths:<br>        serialized_path = ""<br>        duplicate = False<br>        for folder in path:<br>            serialized_path += "/" + folder<br>            if count[str(graph[serialized_path])]  1:<br>                duplicate = True<br>                break<br>        if not duplicate:<br>            ans.append(path)<br><br>    return ans

### DOC[2] (IRRELEVANT) leetcode/leetcode_2467.txt
> from collections import defaultdict<br>    """There is an undirected tree with `n` nodes labeled from `0` to `n - 1`, rooted at node `0`. You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>At every node `i`, there is a gate. You are also given an array of even integers `amount`, where `amount[i]` represents:<br><br>   the price needed to open the gate at node `i`, if `amount[i]` is negative, or,<br>   the cash reward obtained on opening the gate at node `i`, otherwise.<br><br>The game goes on as follows:<br><br>   Initially, Alice is at node `0` and Bob is at node `bob`.<br>   At every second, Alice and Bob each move to an adjacent node. Alice moves towards some leaf node, while Bob moves towards node `0`.<br>   For every node along their path, Alice and Bob either spend money to open the gate at that node, or accept the reward. Note that:<br>       If the gate is already open, no price will be required, nor will there be any cash reward.<br>       If Alice and Bob reach the node simultaneously, they share the price/reward for opening the gate there. In other words, if the price to open the gate is `c`, then both Alice and Bob pay `c / 2` each. Similarly, if the reward at the gate is `c`, both of them receive `c / 2` each.<br>   If Alice reaches a leaf node, she stops moving. Similarly, if Bob reaches node `0`, he stops moving. Note that these events are independent of each other.<br><br>Return _the maximum net income Alice can have if she travels towards the optimal leaf node._<br><br>Example 1:<br><br>Input: edges = \[\[0,1\],\[1,2\],\[1,3\],\[3,4\]\], bob = 3, amount = \[-2,4,2,-4,6\]<br>Output: 6<br>Explanation: <br>The above diagram represents the given tree. The game goes as follows:<br>- Alice is initially on node 0, Bob on node 3. They open the gates of their respective nodes.<br>  Alice's net income is now -2.<br>- Both Alice and Bob move to node 1. <br>  Since they reach here simultaneously, they open the gate together and share the reward.<br>  Alice's net income becomes -2 + (4 / 2) = 0.<br>- Alice moves on to node 3. Since Bob already opened its gate, Alice's income remains unchanged.<br>  Bob moves on to node 0, and stops moving.<br>- Alice moves on to node 4 and opens the gate there. Her net income becomes 0 + 6 = 6.<br>Now, neither Alice nor Bob can make any further moves, and the game ends.<br>It is not possible for Alice to get a higher net income.<br><br>Example 2:<br><br>Input: edges = \[\[0,1\]\], bob = 1, amount = \[-7280,2350\]<br>Output: -7280<br>Explanation: <br>Alice follows the path 0-1 whereas Bob follows the path 1-0.<br>Thus, Alice opens the gate at node 0 only. Hence, her net income is -7280. <br><br>Constraints:<br><br>   `2 <= n <= 105`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree.<br>   `1 <= bob < n`<br>   `amount.length == n`<br>   `amount[i]` is an even integer in the range `[-104, 104]`."""<br><br><br>def dfs(node, parent, bob, time, alice_income, res, amount, tree):<br>    if time < bob or amount[node] = 0:<br>        alice_income += amount[node]<br>    else:<br>        alice_income += amount[node] // 2<br>    amount[node] = 0<br>    is_leaf = True<br>    for child in tree[node]:<br>        if child != parent:<br>            is_leaf = False<br>            dfs(child, node, bob, time + 1, alice_income, res, amount, tree)<br>    if is_leaf:<br>        res[0] = max(res[0], alice_income)<br><br>def maxNetIncome(edges, bob, amount):<br>    tree = defaultdict(list)<br>    for edge in edges:<br>        tree[edge[0]].append(edge[1])<br>        tree[edge[1]].append(edge[0])<br>    res = [-100000]<br>    dfs(0, -1, bob, 0, 0, res, amount, tree)<br>    return res[0]

### DOC[3] (IRRELEVANT) leetcode/leetcode_2038.txt
> from collections import deque<br>    """There are `n` pieces arranged in a line, and each piece is colored either by `'A'` or by `'B'`. You are given a string `colors` of length `n` where `colors[i]` is the color of the `ith` piece.<br><br>Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.<br><br>   Alice is only allowed to remove a piece colored `'A'` if both its neighbors are also colored `'A'`. She is not allowed to remove pieces that are colored `'B'`.<br>   Bob is only allowed to remove a piece colored `'B'` if both its neighbors are also colored `'B'`. He is not allowed to remove pieces that are colored `'A'`.<br>   Alice and Bob cannot remove pieces from the edge of the line.<br>   If a player cannot make a move on their turn, that player loses and the other player wins.<br><br>Assuming Alice and Bob play optimally, return `true` _if Alice wins, or return_ `false` _if Bob wins_.<br><br>Example 1:<br><br>Input: colors =  "AAABABB "<br>Output: true<br>Explanation:<br>AAABABB - AABABB<br>Alice moves first.<br>She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.<br><br>Now it's Bob's turn.<br>Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.<br>Thus, Alice wins, so return true.<br><br>Example 2:<br><br>Input: colors =  "AA "<br>Output: false<br>Explanation:<br>Alice has her turn first.<br>There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.<br>Thus, Bob wins, so return false.<br><br>Example 3:<br><br>Input: colors =  "ABBBBBBBAAA "<br>Output: false<br>Explanation:<br>ABBBBBBBAAA - ABBBBBBBAA<br>Alice moves first.<br>Her only option is to remove the second to last 'A' from the right.<br><br>ABBBBBBBAA - ABBBBBBAA<br>Next is Bob's turn.<br>He has many options for which 'B' piece to remove. He can pick any.<br><br>On Alice's second turn, she has no more pieces that she can remove.<br>Thus, Bob wins, so return false.<br><br>Constraints:<br><br>   `1 <= colors.length <= 105`<br>   `colors` consists of only the letters `'A'` and `'B'`"""<br><br><br>def nearest_exit(maze, entrance):<br>    m, n = len(maze), len(maze[0])<br>    directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]<br>    q = deque()<br>    maze[entrance[0]][entrance[1]] = '+'<br>    q.append((entrance[0], entrance[1]))<br>    steps = 0<br><br>    while q:<br>        size = len(q)<br>        for _ in range(size):<br>            x, y = q.popleft()<br>            if (x == 0 or x == m - 1 or y == 0 or y == n - 1) and (x != entrance[0] or y != entrance[1]):<br>                return steps<br><br>            for dir in directions:<br>                xx, yy = x + dir[0], y + dir[1]<br>                if 0 <= xx < m and 0 <= yy < n and maze[xx][yy] == '.':<br>                    maze[xx][yy] = '+'<br>                    q.append((xx, yy))<br>        steps += 1<br><br>    return -1

### DOC[4] (IRRELEVANT) leetcode/leetcode_1872.txt
> def can_eat(candiesCount, queries):<br>    """Alice and Bob take turns playing a game, with Alice starting first.<br><br>There are `n` stones arranged in a row. On each player's turn, while the number of stones is more than one, they will do the following:<br><br>1.  Choose an integer `x  1`, and remove the leftmost `x` stones from the row.<br>2.  Add the sum of the removed stones' values to the player's score.<br>3.  Place a new stone, whose value is equal to that sum, on the left side of the row.<br><br>The game stops when only one stone is left in the row.<br><br>The score difference between Alice and Bob is `(Alice's score - Bob's score)`. Alice's goal is to maximize the score difference, and Bob's goal is the minimize the score difference.<br><br>Given an integer array `stones` of length `n` where `stones[i]` represents the value of the `ith` stone from the left, return _the score difference between Alice and Bob if they both play optimally._<br><br>Example 1:<br><br>Input: stones = \[-1,2,-3,4,-5\]<br>Output: 5<br>Explanation:<br>- Alice removes the first 4 stones, adds (-1) + 2 + (-3) + 4 = 2 to her score, and places a stone of<br>  value 2 on the left. stones = \[2,-5\].<br>- Bob removes the first 2 stones, adds 2 + (-5) = -3 to his score, and places a stone of value -3 on<br>  the left. stones = \[-3\].<br>The difference between their scores is 2 - (-3) = 5.<br><br>Example 2:<br><br>Input: stones = \[7,-6,5,10,5,-2,-6\]<br>Output: 13<br>Explanation:<br>- Alice removes all stones, adds 7 + (-6) + 5 + 10 + 5 + (-2) + (-6) = 13 to her score, and places a<br>  stone of value 13 on the left. stones = \[13\].<br>The difference between their scores is 13 - 0 = 13.<br><br>Example 3:<br><br>Input: stones = \[-10,-12\]<br>Output: -22<br>Explanation:<br>- Alice can only make one move, which is to remove both stones. She adds (-10) + (-12) = -22 to her<br>  score and places a stone of value -22 on the left. stones = \[-22\].<br>The difference between their scores is (-22) - 0 = -22.<br><br>Constraints:<br><br>   `n == stones.length`<br>   `2 <= n <= 105`<br>   `-104 <= stones[i] <= 104`"""<br><br>    prefix_sum = [0]  (len(candiesCount) + 1)<br>    for i in range(len(candiesCount)):<br>        prefix_sum[i + 1] = prefix_sum[i] + candiesCount[i]<br><br>    result = [False]  len(queries)<br>    for i in range(len(queries)):<br>        favoriteType, favoriteDay, dailyCap = queries[i]<br>        x1 = favoriteDay + 1<br>        y1 = (favoriteDay + 1)  dailyCap<br><br>        x2 = prefix_sum[favoriteType] + 1<br>        y2 = prefix_sum[favoriteType + 1]<br><br>        result[i] = not (x1  y2 or y1 < x2)<br><br>    return result

### DOC[5] (IRRELEVANT) leetcode/leetcode_1406.txt
> def stoneGameIII(stoneValue):<br>    """Alice and Bob continue their games with piles of stones. There are several stones arranged in a row, and each stone has an associated value which is an integer given in the array `stoneValue`.<br><br>Alice and Bob take turns, with Alice starting first. On each player's turn, that player can take `1`, `2`, or `3` stones from the first remaining stones in the row.<br><br>The score of each player is the sum of the values of the stones taken. The score of each player is `0` initially.<br><br>The objective of the game is to end with the highest score, and the winner is the player with the highest score and there could be a tie. The game continues until all the stones have been taken.<br><br>Assume Alice and Bob play optimally.<br><br>Return `"Alice "` _if Alice will win,_ `"Bob "` _if Bob will win, or_ `"Tie "` _if they will end the game with the same score_.<br><br>Example 1:<br><br>Input: values = \[1,2,3,7\]<br>Output:  "Bob "<br>Explanation: Alice will always lose. Her best move will be to take three piles and the score become 6. Now the score of Bob is 7 and Bob wins.<br><br>Example 2:<br><br>Input: values = \[1,2,3,-9\]<br>Output:  "Alice "<br>Explanation: Alice must choose all the three piles at the first move to win and leave Bob with negative score.<br>If Alice chooses one pile her score will be 1 and the next move Bob's score becomes 5. In the next move, Alice will take the pile with value = -9 and lose.<br>If Alice chooses two piles her score will be 3 and the next move Bob's score becomes 3. In the next move, Alice will take the pile with value = -9 and also lose.<br>Remember that both play optimally so here Alice will choose the scenario that makes her win.<br><br>Example 3:<br><br>Input: values = \[1,2,3,6\]<br>Output:  "Tie "<br>Explanation: Alice cannot win this game. She can end the game in a draw if she decided to choose all the first three piles, otherwise she will lose.<br><br>Constraints:<br><br>   `1 <= stoneValue.length <= 5  104`<br>   `-1000 <= stoneValue[i] <= 1000`"""<br><br>    n = len(stoneValue)<br>    dp = [float("-inf")]  (n + 1)<br>    dp[n] = 0<br>    <br>    for i in range(n - 1, -1, -1):<br>        curr = 0<br>        for j in range(3):<br>            if i + j < n:<br>                curr += stoneValue[i + j]<br>                dp[i] = max(dp[i], curr - dp[i + j + 1])<br>                <br>    return "Tie " if dp[0] == 0 else "Alice " if dp[0]  0 else "Bob "


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_2079.txt
> from collections import defaultdict<br>    """You want to water `n` plants in your garden with a watering can. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`. There is a river at `x = -1` that you can refill your watering can at.<br><br>Each plant needs a specific amount of water. You will water the plants in the following way:<br><br>   Water the plants in order from left to right.<br>   After watering the current plant, if you do not have enough water to completely water the next plant, return to the river to fully refill the watering can.<br>   You cannot refill the watering can early.<br><br>You are initially at the river (i.e., `x = -1`). It takes one step to move one unit on the x-axis.<br><br>Given a 0-indexed integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and an integer `capacity` representing the watering can capacity, return _the number of steps needed to water all the plants_.<br><br>Example 1:<br><br>Input: plants = \[2,2,3,3\], capacity = 5<br>Output: 14<br>Explanation: Start at the river with a full watering can:<br>- Walk to plant 0 (1 step) and water it. Watering can has 3 units of water.<br>- Walk to plant 1 (1 step) and water it. Watering can has 1 unit of water.<br>- Since you cannot completely water plant 2, walk back to the river to refill (2 steps).<br>- Walk to plant 2 (3 steps) and water it. Watering can has 2 units of water.<br>- Since you cannot completely water plant 3, walk back to the river to refill (3 steps).<br>- Walk to plant 3 (4 steps) and water it.<br>Steps needed = 1 + 1 + 2 + 3 + 3 + 4 = 14.<br><br>Example 2:<br><br>Input: plants = \[1,1,1,4,2,3\], capacity = 4<br>Output: 30<br>Explanation: Start at the river with a full watering can:<br>- Water plants 0, 1, and 2 (3 steps). Return to river (3 steps).<br>- Water plant 3 (4 steps). Return to river (4 steps).<br>- Water plant 4 (5 steps). Return to river (5 steps).<br>- Water plant 5 (6 steps).<br>Steps needed = 3 + 3 + 4 + 4 + 5 + 5 + 6 = 30.<br><br>Example 3:<br><br>Input: plants = \[7,7,7,7,7,7,7\], capacity = 8<br>Output: 49<br>Explanation: You have to refill before watering each plant.<br>Steps needed = 1 + 1 + 2 + 2 + 3 + 3 + 4 + 4 + 5 + 5 + 6 + 6 + 7 = 49.<br><br>Constraints:<br><br>   `n == plants.length`<br>   `1 <= n <= 1000`<br>   `1 <= plants[i] <= 106`<br>   `max(plants[i]) <= capacity <= 109`"""<br><br><br>def deleteDuplicateFolder(paths):<br>    graph = defaultdict(set)<br>    count = defaultdict(int)<br><br>    for path in paths:<br>        serialized_path = ""<br>        for folder in path:<br>            serialized_path += "/" + folder<br>            graph[serialized_path].add(folder)<br><br>    for value in graph.values():<br>        count[str(value)] += 1<br><br>    ans = []<br>    for path in paths:<br>        serialized_path = ""<br>        duplicate = False<br>        for folder in path:<br>            serialized_path += "/" + folder<br>            if count[str(graph[serialized_path])]  1:<br>                duplicate = True<br>                break<br>        if not duplicate:<br>            ans.append(path)<br><br>    return ans
