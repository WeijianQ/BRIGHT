# Query `130`

## Original Question

*You are given an array of strings `names`, and an array `heights` that consists of distinct positive integers. Both arrays are of length `n`.

For each index `i`, `names[i]` and `heights[i]` denote the name and height of the `ith` person.

Return `names` _sorted in descending order by the people's heights_.

Example 1:

Input: names = \[ "Mary ", "John ", "Emma "\], heights = \[180,165,170\]
Output: \[ "Mary ", "Emma ", "John "\]
Explanation: Mary is the tallest, followed by Emma and John.

Example 2:

Input: names = \[ "Alice ", "Bob ", "Bob "\], heights = \[155,185,150\]
Output: \[ "Bob ", "Alice ", "Bob "\]
Explanation: The first Bob is the tallest, followed by Alice and the second Bob.

Constraints:

   `n == names.length == heights.length`
   `1 <= n <= 103`
   `1 <= names[i].length <= 20`
   `1 <= heights[i] <= 105`
   `names[i]` consists of lower and upper case English letters.
   All the values of `heights` are distinct.*


### Metrics

```
recip_rank: 0.0400
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.1304
ndcg_cut_50: 0.1304
ndcg_cut_100: 0.1304
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0200
map_cut_50: 0.0200
map_cut_100: 0.0200
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1944.txt
> def truncate_sentence(s, k):<br>    """There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in left to right order. You are given an array `heights` of distinct integers where `heights[i]` represents the height of the `ith` person.<br><br>A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j])  max(heights[i+1], heights[i+2], ..., heights[j-1])`.<br><br>Return _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the number of people the_ `ith` _person can see to their right in the queue_.<br><br>Example 1:<br><br>Input: heights = \[10,6,8,5,11,9\]<br>Output: \[3,1,2,1,1,0\]<br>Explanation:<br>Person 0 can see person 1, 2, and 4.<br>Person 1 can see person 2.<br>Person 2 can see person 3 and 4.<br>Person 3 can see person 4.<br>Person 4 can see person 5.<br>Person 5 can see no one since nobody is to the right of them.<br><br>Example 2:<br><br>Input: heights = \[5,1,2,3,10\]<br>Output: \[4,1,1,1,0\]<br><br>Constraints:<br><br>   `n == heights.length`<br>   `1 <= n <= 105`<br>   `1 <= heights[i] <= 105`<br>   All the values of `heights` are unique."""<br><br>    words = s.split(' ')<br>    return ' '.join(words[:k])

### DOC[2] (IRRELEVANT) leetcode/leetcode_2038.txt
> from collections import deque<br>    """There are `n` pieces arranged in a line, and each piece is colored either by `'A'` or by `'B'`. You are given a string `colors` of length `n` where `colors[i]` is the color of the `ith` piece.<br><br>Alice and Bob are playing a game where they take alternating turns removing pieces from the line. In this game, Alice moves first.<br><br>   Alice is only allowed to remove a piece colored `'A'` if both its neighbors are also colored `'A'`. She is not allowed to remove pieces that are colored `'B'`.<br>   Bob is only allowed to remove a piece colored `'B'` if both its neighbors are also colored `'B'`. He is not allowed to remove pieces that are colored `'A'`.<br>   Alice and Bob cannot remove pieces from the edge of the line.<br>   If a player cannot make a move on their turn, that player loses and the other player wins.<br><br>Assuming Alice and Bob play optimally, return `true` _if Alice wins, or return_ `false` _if Bob wins_.<br><br>Example 1:<br><br>Input: colors =  "AAABABB "<br>Output: true<br>Explanation:<br>AAABABB - AABABB<br>Alice moves first.<br>She removes the second 'A' from the left since that is the only 'A' whose neighbors are both 'A'.<br><br>Now it's Bob's turn.<br>Bob cannot make a move on his turn since there are no 'B's whose neighbors are both 'B'.<br>Thus, Alice wins, so return true.<br><br>Example 2:<br><br>Input: colors =  "AA "<br>Output: false<br>Explanation:<br>Alice has her turn first.<br>There are only two 'A's and both are on the edge of the line, so she cannot move on her turn.<br>Thus, Bob wins, so return false.<br><br>Example 3:<br><br>Input: colors =  "ABBBBBBBAAA "<br>Output: false<br>Explanation:<br>ABBBBBBBAAA - ABBBBBBBAA<br>Alice moves first.<br>Her only option is to remove the second to last 'A' from the right.<br><br>ABBBBBBBAA - ABBBBBBAA<br>Next is Bob's turn.<br>He has many options for which 'B' piece to remove. He can pick any.<br><br>On Alice's second turn, she has no more pieces that she can remove.<br>Thus, Bob wins, so return false.<br><br>Constraints:<br><br>   `1 <= colors.length <= 105`<br>   `colors` consists of only the letters `'A'` and `'B'`"""<br><br><br>def nearest_exit(maze, entrance):<br>    m, n = len(maze), len(maze[0])<br>    directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]<br>    q = deque()<br>    maze[entrance[0]][entrance[1]] = '+'<br>    q.append((entrance[0], entrance[1]))<br>    steps = 0<br><br>    while q:<br>        size = len(q)<br>        for _ in range(size):<br>            x, y = q.popleft()<br>            if (x == 0 or x == m - 1 or y == 0 or y == n - 1) and (x != entrance[0] or y != entrance[1]):<br>                return steps<br><br>            for dir in directions:<br>                xx, yy = x + dir[0], y + dir[1]<br>                if 0 <= xx < m and 0 <= yy < n and maze[xx][yy] == '.':<br>                    maze[xx][yy] = '+'<br>                    q.append((xx, yy))<br>        steps += 1<br><br>    return -1

### DOC[3] (IRRELEVANT) leetcode/leetcode_2029.txt
> def stoneGameIX(stones: List[int]) - bool:<br>    """Alice and Bob continue their games with stones. There is a row of n stones, and each stone has an associated value. You are given an integer array `stones`, where `stones[i]` is the value of the `ith` stone.<br><br>Alice and Bob take turns, with Alice starting first. On each turn, the player may remove any stone from `stones`. The player who removes a stone loses if the sum of the values of all removed stones is divisible by `3`. Bob will win automatically if there are no remaining stones (even if it is Alice's turn).<br><br>Assuming both players play optimally, return `true` _if Alice wins and_ `false` _if Bob wins_.<br><br>Example 1:<br><br>Input: stones = \[2,1\]<br>Output: true<br>Explanation: The game will be played as follows:<br>- Turn 1: Alice can remove either stone.<br>- Turn 2: Bob removes the remaining stone. <br>The sum of the removed stones is 1 + 2 = 3 and is divisible by 3. Therefore, Bob loses and Alice wins the game.<br><br>Example 2:<br><br>Input: stones = \[2\]<br>Output: false<br>Explanation: Alice will remove the only stone, and the sum of the values on the removed stones is 2. <br>Since all the stones are removed and the sum of values is not divisible by 3, Bob wins the game.<br><br>Example 3:<br><br>Input: stones = \[5,1,2,4,3\]<br>Output: false<br>Explanation: Bob will always win. One possible way for Bob to win is shown below:<br>- Turn 1: Alice can remove the second stone with value 1. Sum of removed stones = 1.<br>- Turn 2: Bob removes the fifth stone with value 3. Sum of removed stones = 1 + 3 = 4.<br>- Turn 3: Alices removes the fourth stone with value 4. Sum of removed stones = 1 + 3 + 4 = 8.<br>- Turn 4: Bob removes the third stone with value 2. Sum of removed stones = 1 + 3 + 4 + 2 = 10.<br>- Turn 5: Alice removes the first stone with value 5. Sum of removed stones = 1 + 3 + 4 + 2 + 5 = 15.<br>Alice loses the game because the sum of the removed stones (15) is divisible by 3. Bob wins the game.<br><br>Constraints:<br><br>   `1 <= stones.length <= 105`<br>   `1 <= stones[i] <= 104`"""<br><br>    cnt = [0, 0, 0]<br>    for s in stones:<br>        cnt[s % 3] += 1<br>    return (cnt[1] and cnt[2]) or (cnt[1]  cnt[2] if cnt[1]  cnt[2] + 2 else cnt[2]  cnt[1] + 1)

### DOC[4] (IRRELEVANT) leetcode/leetcode_2105.txt
> def numberOfGoodSubsets(nums: list[int]) - int:<br>    """Alice and Bob want to water `n` plants in their garden. The plants are arranged in a row and are labeled from `0` to `n - 1` from left to right where the `ith` plant is located at `x = i`.<br><br>Each plant needs a specific amount of water. Alice and Bob have a watering can each, initially full. They water the plants in the following way:<br><br>   Alice waters the plants in order from left to right, starting from the `0th` plant. Bob waters the plants in order from right to left, starting from the `(n - 1)th` plant. They begin watering the plants simultaneously.<br>   It takes the same amount of time to water each plant regardless of how much water it needs.<br>   Alice/Bob must water the plant if they have enough in their can to fully water it. Otherwise, they first refill their can (instantaneously) then water the plant.<br>   In case both Alice and Bob reach the same plant, the one with more water currently in his/her watering can should water this plant. If they have the same amount of water, then Alice should water this plant.<br><br>Given a 0-indexed integer array `plants` of `n` integers, where `plants[i]` is the amount of water the `ith` plant needs, and two integers `capacityA` and `capacityB` representing the capacities of Alice's and Bob's watering cans respectively, return _the number of times they have to refill to water all the plants_.<br><br>Example 1:<br><br>Input: plants = \[2,2,3,3\], capacityA = 5, capacityB = 5<br>Output: 1<br>Explanation:<br>- Initially, Alice and Bob have 5 units of water each in their watering cans.<br>- Alice waters plant 0, Bob waters plant 3.<br>- Alice and Bob now have 3 units and 2 units of water respectively.<br>- Alice has enough water for plant 1, so she waters it. Bob does not have enough water for plant 2, so he refills his can then waters it.<br>So, the total number of times they have to refill to water all the plants is 0 + 0 + 1 + 0 = 1.<br><br>Example 2:<br><br>Input: plants = \[2,2,3,3\], capacityA = 3, capacityB = 4<br>Output: 2<br>Explanation:<br>- Initially, Alice and Bob have 3 units and 4 units of water in their watering cans respectively.<br>- Alice waters plant 0, Bob waters plant 3.<br>- Alice and Bob now have 1 unit of water each, and need to water plants 1 and 2 respectively.<br>- Since neither of them have enough water for their current plants, they refill their cans and then water the plants.<br>So, the total number of times they have to refill to water all the plants is 0 + 1 + 1 + 0 = 2.<br><br>Example 3:<br><br>Input: plants = \[5\], capacityA = 10, capacityB = 8<br>Output: 0<br>Explanation:<br>- There is only one plant.<br>- Alice's watering can has 10 units of water, whereas Bob's can has 8 units. Since Alice has more water in her can, she waters this plant.<br>So, the total number of times they have to refill is 0.<br><br>Constraints:<br><br>   `n == plants.length`<br>   `1 <= n <= 105`<br>   `1 <= plants[i] <= 106`<br>   `max(plants[i]) <= capacityA, capacityB <= 109`"""<br><br>    MOD = 109 + 7<br><br>    def is_prime(n: int) - bool:<br>        if n <= 1:<br>            return False<br>        for i in range(2, int(n0.5) + 1):<br>            if n % i == 0:<br>                return False<br>        return True<br><br>    primes = [i for i in range(2, 91) if is_prime(i)]<br>    cnt = [0]  100<br>    for n in nums:<br>        cnt[n] += 1<br><br>    dp = [0]  (1 << 20)<br>    dp[0] = 1<br>    <br>    for i in range(30, 0, -1):<br>        if cnt[i] == 0:<br>            continue<br>        mask = [j for j in primes if i % j == 0]<br>        i = i // j<br>        if i  1:<br>            continue<br><br>        m = 0<br>        for j in mask:<br>            m |= 1 << (j - 2)<br><br>        for j in range(len(dp)-1, -1, -1):<br>            if dp[j] == 0:<br>                continue<br>            cur = 1<br>            for k in range(cnt[m]):<br>                cur = (cur  2) % MOD<br>                dp[j | m] = (dp[j | m] + dp[j]  cur) % MOD<br><br>    ans = sum(dp) % MOD<br>    ans = (ans - dp[0] + MOD) % MOD<br>    return (ans  (1 << (cnt[1] - 1))) % MOD

### DOC[5] (IRRELEVANT) leetcode/leetcode_1927.txt
> def max_ascending_sum(nums):<br>    """Alice and Bob take turns playing a game, with Alice starting first.<br><br>You are given a string `num` of even length consisting of digits and `'?'` characters. On each turn, a player will do the following if there is still at least one `'?'` in `num`:<br><br>1.  Choose an index `i` where `num[i] == '?'`.<br>2.  Replace `num[i]` with any digit between `'0'` and `'9'`.<br><br>The game ends when there are no more `'?'` characters in `num`.<br><br>For Bob to win, the sum of the digits in the first half of `num` must be equal to the sum of the digits in the second half. For Alice to win, the sums must not be equal.<br><br>   For example, if the game ended with `num = "243801 "`, then Bob wins because `2+4+3 = 8+0+1`. If the game ended with `num = "243803 "`, then Alice wins because `2+4+3 != 8+0+3`.<br><br>Assuming Alice and Bob play optimally, return `true` _if Alice will win and_ `false` _if Bob will win_.<br><br>Example 1:<br><br>Input: num =  "5023 "<br>Output: false<br>Explanation: There are no moves to be made.<br>The sum of the first half is equal to the sum of the second half: 5 + 0 = 2 + 3.<br><br>Example 2:<br><br>Input: num =  "25?? "<br>Output: true<br>Explanation: Alice can replace one of the '?'s with '9' and it will be impossible for Bob to make the sums equal.<br><br>Example 3:<br><br>Input: num =  "?3295??? "<br>Output: false<br>Explanation: It can be proven that Bob will always win. One possible outcome is:<br>- Alice replaces the first '?' with '9'. num =  "93295??? ".<br>- Bob replaces one of the '?' in the right half with '9'. num =  "932959?? ".<br>- Alice replaces one of the '?' in the right half with '2'. num =  "9329592? ".<br>- Bob replaces the last '?' in the right half with '7'. num =  "93295927 ".<br>Bob wins because 9 + 3 + 2 + 9 = 5 + 9 + 2 + 7.<br><br>Constraints:<br><br>   `2 <= num.length <= 105`<br>   `num.length` is even.<br>   `num` consists of only digits and `'?'`."""<br><br>    max_sum = current_sum = nums[0]<br><br>    for i in range(1, len(nums)):<br>        if nums[i]  nums[i - 1]:<br>            current_sum += nums[i]<br>        else:<br>            max_sum = max(max_sum, current_sum)<br>            current_sum = nums[i]<br><br>    return max(max_sum, current_sum)


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_1636.txt
> def num_sub(s: str) - int:<br>    """Given an array of integers `nums`, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.<br><br>Return the _sorted array_.<br><br>Example 1:<br><br>Input: nums = \[1,1,2,2,2,3\]<br>Output: \[3,1,1,2,2,2\]<br>Explanation: '3' has a frequency of 1, '1' has a frequency of 2, and '2' has a frequency of 3.<br><br>Example 2:<br><br>Input: nums = \[2,3,1,3,2\]<br>Output: \[1,3,3,2,2\]<br>Explanation: '2' and '3' both have a frequency of 2, so they are sorted in decreasing order.<br><br>Example 3:<br><br>Input: nums = \[-1,1,-6,4,5,-6,1,4,1\]<br>Output: \[5,-1,4,4,-6,-6,1,1,1\]<br><br>Constraints:<br><br>   `1 <= nums.length <= 100`<br>   `-100 <= nums[i] <= 100`"""<br><br>    mod = 1000000007<br>    result = 0<br>    count = 0<br>    for c in s:<br>        count = count + 1 if c == '1' else 0<br>        result = (result + count) % mod<br>    return result

### GROUND TRUTH 1, ranked 24, leetcode/leetcode_2545.txt
> def sort_students(score, k):<br>    """There is a class with `m` students and `n` exams. You are given a 0-indexed `m x n` integer matrix `score`, where each row represents one student and `score[i][j]` denotes the score the `ith` student got in the `jth` exam. The matrix `score` contains distinct integers only.<br><br>You are also given an integer `k`. Sort the students (i.e., the rows of the matrix) by their scores in the `kth` (0-indexed) exam from the highest to the lowest.<br><br>Return _the matrix after sorting it._<br><br>Example 1:<br><br>Input: score = \[\[10,6,9,1\],\[7,5,11,2\],\[4,8,3,15\]\], k = 2<br>Output: \[\[7,5,11,2\],\[10,6,9,1\],\[4,8,3,15\]\]<br>Explanation: In the above diagram, S denotes the student, while E denotes the exam.<br>- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.<br>- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.<br>- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.<br><br>Example 2:<br><br>Input: score = \[\[3,4\],\[5,6\]\], k = 0<br>Output: \[\[5,6\],\[3,4\]\]<br>Explanation: In the above diagram, S denotes the student, while E denotes the exam.<br>- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.<br>- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.<br><br>Constraints:<br><br>   `m == score.length`<br>   `n == score[i].length`<br>   `1 <= m, n <= 250`<br>   `1 <= score[i][j] <= 105`<br>   `score` consists of distinct integers.<br>   `0 <= k < n`"""<br><br>    score.sort(key=lambda x: x[k], reverse=True)<br>    return score
