# Query `20`

## Original Question

*You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with exactly `ki` other people in front who have a height greater than or equal to `hi`.

Reconstruct and return _the queue that is represented by the input array_ `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).

Example 1:

Input: people = \[\[7,0\],\[4,4\],\[7,1\],\[5,0\],\[6,1\],\[5,2\]\]
Output: \[\[5,0\],\[7,0\],\[5,2\],\[6,1\],\[4,4\],\[7,1\]\]
Explanation:
Person 0 has height 5 with no other people taller or the same height in front.
Person 1 has height 7 with no other people taller or the same height in front.
Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.
Person 3 has height 6 with one person taller or the same height in front, which is person 1.
Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.
Person 5 has height 7 with one person taller or the same height in front, which is person 1.
Hence \[\[5,0\],\[7,0\],\[5,2\],\[6,1\],\[4,4\],\[7,1\]\] is the reconstructed queue.

Example 2:

Input: people = \[\[6,0\],\[5,0\],\[4,0\],\[3,2\],\[2,2\],\[1,4\]\]
Output: \[\[4,0\],\[5,0\],\[2,2\],\[3,2\],\[1,4\],\[6,0\]\]

Constraints:

   `1 <= people.length <= 2000`
   `0 <= hi <= 106`
   `0 <= ki < people.length`
   It is guaranteed that the queue can be reconstructed.*


### Metrics

```
recip_rank: 0.0022
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_381461.txt
> def calculate_ethinca_metric_comps(metricParams, ethincaParams, mass1, mass2,<br>                                   spin1z=0., spin2z=0., full_ethinca=True):<br>    """<br>    Calculate the Gamma components needed to use the ethinca metric.<br>    At present this outputs the standard TaylorF2 metric over the end time<br>    and chirp times \tau_0 and \tau_3.<br>    A desirable upgrade might be to use the \chi coordinates [defined WHERE?]<br>    for metric distance instead of \tau_0 and \tau_3.<br>    The lower frequency cutoff is currently hard-coded to be the same as the<br>    bank layout options fLow and f0 (which must be the same as each other).<br><br>    Parameters<br>    -----------<br>    metricParams : metricParameters instance<br>        Structure holding all the options for construction of the metric<br>        and the eigenvalues, eigenvectors and covariance matrix<br>        needed to manipulate the space.<br>    ethincaParams : ethincaParameters instance<br>        Structure holding options relevant to the ethinca metric computation.<br>    mass1 : float<br>        Mass of the heavier body in the considered template.<br>    mass2 : float<br>        Mass of the lighter body in the considered template.<br>    spin1z : float (optional, default=0)<br>        Spin of the heavier body in the considered template.<br>    spin2z : float (optional, default=0)<br>        Spin of the lighter body in the considered template.<br>    full_ethinca : boolean (optional, default=True)<br>        If True calculate the ethinca components in all 3 directions (mass1,<br>        mass2 and time). If False calculate only the time component (which is<br>        stored in Gamma0).<br>    Returns<br>    --------<br>    fMax_theor : float<br>        Value of the upper frequency cutoff given by the template parameters<br>        and the cutoff formula requested.<br><br>    gammaVals : numpy_array<br>        Array holding 6 independent metric components in<br>        (end_time, tau_0, tau_3) coordinates to be stored in the Gamma0-5<br>        slots of a SnglInspiral object.<br>    """<br>    if (float(spin1z) != 0. or float(spin2z) != 0.) and full_ethinca:<br>        raise NotImplementedError("Ethinca cannot at present be calculated "<br>                                  "for nonzero component spins!")<br>    f0 = metricParams.f0<br>    if f0 != metricParams.fLow:<br>        raise ValueError("If calculating ethinca the bank f0 value must be "<br>                         "equal to f-low!")<br>    if ethincaParams.fLow is not None and (<br>        ethincaParams.fLow != metricParams.fLow):<br>        raise NotImplementedError("An ethinca metric f-low different from the"<br>                                  " bank metric f-low is not supported!")<br><br>    twicePNOrder = ethinca_order_from_string(ethincaParams.pnOrder)<br><br>    piFl = PI  f0<br>    totalMass, eta = pnutils.mass1_mass2_to_mtotal_eta(mass1, mass2)<br>    totalMass = totalMass  MTSUN_SI<br>    v0cube = totalMasspiFl<br>    v0 = v0cube(1./3.)<br><br>    # Get theoretical cutoff frequency and work out the closest<br>    # frequency for which moments were calculated<br>    fMax_theor = pnutils.frequency_cutoff_from_name(<br>        ethincaParams.cutoff, mass1, mass2, spin1z, spin2z)<br>    fMaxes = metricParams.moments['J4'].keys()<br>    fMaxIdx = abs(numpy.array(fMaxes,dtype=float) - fMax_theor).argmin()<br>    fMax = fMaxes[fMaxIdx]<br><br>    # Set the appropriate moments<br>    Js = numpy.zeros([18,3],dtype=float)<br>    for i in range(18):<br>        Js[i,0] = metricParams.moments['J%d'%(i)][fMax]<br>        Js[i,1] = metricParams.moments['log%d'%(i)][fMax]<br>        Js[i,2] = metricParams.moments['loglog%d'%(i)][fMax]<br><br>    # Compute the time-dependent metric term.<br>    two_pi_flower_sq = TWOPI  f0  TWOPI  f0<br>    gammaVals = numpy.zeros([6],dtype=float)<br>    gammaVals[0] = 0.5  two_pi_flower_sq  \<br>                    ( Js[(1,0)] - (Js[(4,0)]Js[(4,0)]) )<br><br>    # If mass terms not required stop here<br>    if not full_ethinca:<br>        return fMax_theor, gammaVals<br><br>    # 3pN is a mess, so split it into pieces<br>    a0 = 11583231236531/200286535680 - 5PIPI - 107GAMMA/14<br>    a1 = (-15737765635/130056192 + 2255PIPI/512)eta<br>    a2 = (76055/73728)etaeta<br>    a3 = (-127825/55296)etaetaeta<br>    alog = numpy.log(4v0) # Log terms are tricky - be careful<br><br>    # Get the Psi coefficients<br>    Psi = [{},{}] #Psi = numpy.zeros([2,8,2],dtype=float)<br>    Psi[0][0,0] = 3/5<br>    Psi[0][2,0] = (743/756 + 11eta/3)v0v0<br>    Psi[0][3,0] = 0.<br>    Psi[0][4,0] = (-3058673/508032 + 5429eta/504 + 617etaeta/24)\<br>                    v0cubev0<br>    Psi[0][5,1] = (-7729PI/126)v0cubev0v0/3<br>    Psi[0][6,0] = (128/15)(-3a0 - a1 + a2 + 3a3 + 107(1+3alog)/14)\<br>                    v0cubev0cube<br>    Psi[0][6,1] = (6848/35)v0cubev0cube/3<br>    Psi[0][7,0] = (-15419335/63504 - 75703eta/756)PIv0cubev0cubev0<br><br>    Psi[1][0,0] = 0.<br>    Psi[1][2,0] = (3715/12096 - 55eta/96)/PI/v0;<br>    Psi[1][3,0] = -3/2<br>    Psi[1][4,0] = (15293365/4064256 - 27145eta/16128 - 3085etaeta/384)\<br>                    v0/PI<br>    Psi[1][5,1] = (193225/8064)v0v0/3<br>    Psi[1][6,0] = (4/PI)(2a0 + a1/3 - 4a2/3 - 3a3 -107(1+6alog)/42)\<br>                    v0cube<br>    Psi[1][6,1] = (-428/PI/7)v0cube/3<br>    Psi[1][7,0] = (77096675/1161216 + 378515eta/24192 + 74045etaeta/8064)\<br>                    v0cubev0<br><br>    # Set the appropriate moments<br>    Js = numpy.zeros([18,3],dtype=float)<br>    for i in range(18):<br>        Js[i,0] = metricParams.moments['J%d'%(i)][fMax]<br>        Js[i,1] = metricParams.moments['log%d'%(i)][fMax]<br>        Js[i,2] = metricParams.moments['loglog%d'%(i)][fMax]<br><br>    # Calculate the g matrix<br>    PNterms = [(0,0),(2,0),(3,0),(4,0),(5,1),(6,0),(6,1),(7,0)]<br>    PNterms = [term for term in PNterms if term[0] <= twicePNOrder]<br><br>    # Now can compute the mass-dependent gamma values<br>    for m in [0, 1]:<br>        for k in PNterms:<br>            gammaVals[1+m] += 0.5  two_pi_flower_sq  Psi[m][k]  \<br>                                ( Js[(9-k[0],k[1])]<br>                                - Js[(12-k[0],k[1])]  Js[(4,0)] )<br><br>    g = numpy.zeros([2,2],dtype=float)<br>    for (m,n) in [(0,0),(0,1),(1,1)]:<br>        for k in PNterms:<br>            for l in PNterms:<br>                g[m,n] += Psi[m][k]  Psi[n][l]  \<br>                        ( Js[(17-k[0]-l[0], k[1]+l[1])]<br>                        - Js[(12-k[0],k[1])]  Js[(12-l[0],l[1])] )<br>        g[m,n] = 0.5  two_pi_flower_sq  g[m,n]<br>        g[n,m] = g[m,n]<br><br>    gammaVals[3] = g[0,0]<br>    gammaVals[4] = g[0,1]<br>    gammaVals[5] = g[1,1]<br><br>    return fMax_theor, gammaVals

### DOC[2] (IRRELEVANT) leetcode/leetcode_1735.txt
> MOD = 109 + 7<br>    """You are given a 2D integer array, `queries`. For each `queries[i]`, where `queries[i] = [ni, ki]`, find the number of different ways you can place positive integers into an array of size `ni` such that the product of the integers is `ki`. As the number of ways may be too large, the answer to the `ith` query is the number of ways modulo `109 + 7`.<br><br>Return _an integer array_ `answer` _where_ `answer.length == queries.length`_, and_ `answer[i]` _is the answer to the_ `ith` _query._<br><br>Example 1:<br><br>Input: queries = \[\[2,6\],\[5,1\],\[73,660\]\]<br>Output: \[4,1,50734910\]<br>Explanation: Each query is independent.<br>\[2,6\]: There are 4 ways to fill an array of size 2 that multiply to 6: \[1,6\], \[2,3\], \[3,2\], \[6,1\].<br>\[5,1\]: There is 1 way to fill an array of size 5 that multiply to 1: \[1,1,1,1,1\].<br>\[73,660\]: There are 1050734917 ways to fill an array of size 73 that multiply to 660. 1050734917 modulo 109 + 7 = 50734910.<br><br>Example 2:<br><br>Input: queries = \[\[1,1\],\[2,2\],\[3,3\],\[4,4\],\[5,5\]\]<br>Output: \[1,2,3,10,5\]<br><br>Constraints:<br><br>   `1 <= queries.length <= 104`<br>   `1 <= ni, ki <= 104`"""<br><br><br>def mul(a, b):<br>    return (a  b) % MOD<br><br>def ways(n, k, mem):<br>    if n == 1:<br>        return k<br>    if (n_tuple := (n, k)) in mem:<br>        return mem[n_tuple]<br>    if k == 1:<br>        mem[n_tuple] = 1<br>        return 1<br>    if n  k:<br>        mem[n_tuple] = 0<br>        return 0<br>    res = mul(ways(n, k - 1, mem), n)<br>    res = (res - mul(n - 1, ways(n - 1, k - 1, mem)) + MOD) % MOD<br>    mem[n_tuple] = res<br>    return res<br><br>def waysToFillArray(queries):<br>    mem = {}<br>    ans = []<br>    for q in queries:<br>        ans.append(ways(q[0], q[1], mem))<br>    return ans

### DOC[3] (IRRELEVANT) leetcode/leetcode_1944.txt
> def truncate_sentence(s, k):<br>    """There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in left to right order. You are given an array `heights` of distinct integers where `heights[i]` represents the height of the `ith` person.<br><br>A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j])  max(heights[i+1], heights[i+2], ..., heights[j-1])`.<br><br>Return _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the number of people the_ `ith` _person can see to their right in the queue_.<br><br>Example 1:<br><br>Input: heights = \[10,6,8,5,11,9\]<br>Output: \[3,1,2,1,1,0\]<br>Explanation:<br>Person 0 can see person 1, 2, and 4.<br>Person 1 can see person 2.<br>Person 2 can see person 3 and 4.<br>Person 3 can see person 4.<br>Person 4 can see person 5.<br>Person 5 can see no one since nobody is to the right of them.<br><br>Example 2:<br><br>Input: heights = \[5,1,2,3,10\]<br>Output: \[4,1,1,1,0\]<br><br>Constraints:<br><br>   `n == heights.length`<br>   `1 <= n <= 105`<br>   `1 <= heights[i] <= 105`<br>   All the values of `heights` are unique."""<br><br>    words = s.split(' ')<br>    return ' '.join(words[:k])

### DOC[4] (IRRELEVANT) leetcode/leetcode_1584.txt
> def average(salary):<br>    """You are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.<br><br>The cost of connecting two points `[xi, yi]` and `[xj, yj]` is the manhattan distance between them: `|xi - xj| + |yi - yj|`, where `|val|` denotes the absolute value of `val`.<br><br>Return _the minimum cost to make all points connected._ All points are connected if there is exactly one simple path between any two points.<br><br>Example 1:<br><br>Input: points = \[\[0,0\],\[2,2\],\[3,10\],\[5,2\],\[7,0\]\]<br>Output: 20<br>Explanation: <br> <br>We can connect the points as shown above to get the minimum cost of 20.<br>Notice that there is a unique path between every pair of points.<br><br>Example 2:<br><br>Input: points = \[\[3,12\],\[-2,5\],\[-4,1\]\]<br>Output: 18<br><br>Constraints:<br><br>   `1 <= points.length <= 1000`<br>   `-106 <= xi, yi <= 106`<br>   All pairs `(xi, yi)` are distinct."""<br><br>    min_salary = min(salary)<br>    max_salary = max(salary)<br>    sum_salaries = sum(salary)<br>    sum_salaries -= (min_salary + max_salary)<br>    return sum_salaries / (len(salary) - 2)

### DOC[5] (IRRELEVANT) leetcode/leetcode_851.txt
> def to_goat_latin(sentence: str) - str:<br>    """There is a group of `n` people labeled from `0` to `n - 1` where each person has a different amount of money and a different level of quietness.<br><br>You are given an array `richer` where `richer[i] = [ai, bi]` indicates that `ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is the quietness of the `ith` person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where `x` is richer than `y` and `y` is richer than `x` at the same time).<br><br>Return _an integer array_ `answer` _where_ `answer[x] = y` _if_ `y` _is the least quiet person (that is, the person_ `y` _with the smallest value of_ `quiet[y]`_) among all people who definitely have equal to or more money than the person_ `x`.<br><br>Example 1:<br><br>Input: richer = \[\[1,0\],\[2,1\],\[3,1\],\[3,7\],\[4,3\],\[5,3\],\[6,3\]\], quiet = \[3,2,5,4,6,1,7,0\]<br>Output: \[5,5,2,5,4,5,6,7\]<br>Explanation: <br>answer\[0\] = 5.<br>Person 5 has more money than 3, which has more money than 1, which has more money than 0.<br>The only person who is quieter (has lower quiet\[x\]) is person 7, but it is not clear if they have more money than person 0.<br>answer\[7\] = 7.<br>Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet\[x\]) is person 7.<br>The other answers can be filled out with similar reasoning.<br><br>Example 2:<br><br>Input: richer = \[\], quiet = \[0\]<br>Output: \[0\]<br><br>Constraints:<br><br>   `n == quiet.length`<br>   `1 <= n <= 500`<br>   `0 <= quiet[i] < n`<br>   All the values of `quiet` are unique.<br>   `0 <= richer.length <= n  (n - 1) / 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   All the pairs of `richer` are unique.<br>   The observations in `richer` are all logically consistent."""<br><br>    words = sentence.split()<br>    vowels = set("AEIOUaeiou")<br>    result = []<br><br>    for i, word in enumerate(words):<br>        if word[0] not in vowels:<br>            word = word[1:] + word[0]<br>        result.append(word + "ma" + "a"  (i + 1))<br><br>    return ' '.join(result)


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_315.txt
> def countSmaller(nums):<br>    """Given an integer array `nums`, return _an integer array_ `counts` _where_ `counts[i]` _is the number of smaller elements to the right of_ `nums[i]`.<br><br>Example 1:<br><br>Input: nums = \[5,2,6,1\]<br>Output: \[2,1,1,0\]<br>Explanation:<br>To the right of 5 there are 2 smaller elements (2 and 1).<br>To the right of 2 there is only 1 smaller element (1).<br>To the right of 6 there is 1 smaller element (1).<br>To the right of 1 there is 0 smaller element.<br><br>Example 2:<br><br>Input: nums = \[-1\]<br>Output: \[0\]<br><br>Example 3:<br><br>Input: nums = \[-1,-1\]<br>Output: \[0,0\]<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `-104 <= nums[i] <= 104`"""<br><br>    def merge_sort(indices):<br>        if len(indices) <= 1:<br>            return indices<br>        mid = len(indices) // 2<br>        left = merge_sort(indices[:mid])<br>        right = merge_sort(indices[mid:])<br>        return merge(left, right)<br><br>    def merge(left, right):<br>        merged, count = [], 0<br>        while left and right:<br>            if nums[left[0]] <= nums[right[0]]:<br>                counts[left[0]] += count<br>                merged.append(left.pop(0))<br>            else:<br>                count += len(left)<br>                merged.append(right.pop(0))<br>        for i in left:<br>            counts[i] += count<br>        return merged + left + right<br><br>    counts = [0]  len(nums)<br>    merge_sort(list(range(len(nums))))<br>    return counts

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_2512.txt
> def top_k_students(positive_feedback, negative_feedback, report, student_id, k):<br>    """You are given two string arrays `positive_feedback` and `negative_feedback`, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.<br><br>Initially every student has `0` points. Each positive word in a feedback report increases the points of a student by `3`, whereas each negative word decreases the points by `1`.<br><br>You are given `n` feedback reports, represented by a 0-indexed string array `report` and a 0-indexed integer array `student_id`, where `student_id[i]` represents the ID of the student who has received the feedback report `report[i]`. The ID of each student is unique.<br><br>Given an integer `k`, return _the top_ `k` _students after ranking them in non-increasing order by their points_. In case more than one student has the same points, the one with the lower ID ranks higher.<br><br>Example 1:<br><br>Input: positive\_feedback = \[ "smart ", "brilliant ", "studious "\], negative\_feedback = \[ "not "\], report = \[ "this student is studious ", "the student is smart "\], student\_id = \[1,2\], k = 2<br>Output: \[1,2\]<br>Explanation: <br>Both the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.<br><br>Example 2:<br><br>Input: positive\_feedback = \[ "smart ", "brilliant ", "studious "\], negative\_feedback = \[ "not "\], report = \[ "this student is not studious ", "the student is smart "\], student\_id = \[1,2\], k = 2<br>Output: \[2,1\]<br>Explanation: <br>- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. <br>- The student with ID 2 has 1 positive feedback, so he has 3 points. <br>Since student 2 has more points, \[2,1\] is returned.<br><br>Constraints:<br><br>   `1 <= positive_feedback.length, negative_feedback.length <= 104`<br>   `1 <= positive_feedback[i].length, negative_feedback[j].length <= 100`<br>   Both `positive_feedback[i]` and `negative_feedback[j]` consists of lowercase English letters.<br>   No word is present in both `positive_feedback` and `negative_feedback`.<br>   `n == report.length == student_id.length`<br>   `1 <= n <= 104`<br>   `report[i]` consists of lowercase English letters and spaces `' '`.<br>   There is a single space between consecutive words of `report[i]`.<br>   `1 <= report[i].length <= 100`<br>   `1 <= student_id[i] <= 109`<br>   All the values of `student_id[i]` are unique.<br>   `1 <= k <= n`"""<br><br>    points = {}<br>    for i in range(len(report)):<br>        pos_count, neg_count = 0, 0<br>        for pos in positive_feedback:<br>            pos_index = report[i].find(pos)<br>            while pos_index != -1:<br>                pos_count += 1<br>                pos_index = report[i].find(pos, pos_index + len(pos))<br>        for neg in negative_feedback:<br>            neg_index = report[i].find(neg)<br>            while neg_index != -1:<br>                neg_count += 1<br>                neg_index = report[i].find(neg, neg_index + len(neg))<br>        <br>        points[student_id[i]] = points.get(student_id[i], 0) + 3  pos_count - neg_count<br><br>    students = sorted(student_id, key=lambda x: (-points[x], x))<br>    return students[:k]
