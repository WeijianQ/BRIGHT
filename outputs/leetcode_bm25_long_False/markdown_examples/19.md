# Query `19`

## Original Question

*A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.

   For example, the below binary watch reads `"4:51 "`.

Given an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in any order.

The hour must not contain a leading zero.

   For example, `"01:00 "` is not valid. It should be `"1:00 "`.

The minute must be consist of two digits and may contain a leading zero.

   For example, `"10:2 "` is not valid. It should be `"10:02 "`.

Example 1:

Input: turnedOn = 1
Output: \["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"\]

Example 2:

Input: turnedOn = 9
Output: \[\]

Constraints:

   `0 <= turnedOn <= 10`*


### Metrics

```
recip_rank: 0.0063
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2224.txt
> def minimum_operations(current: str, correct: str) - int:<br>    """You are given two strings `current` and `correct` representing two 24-hour times.<br><br>24-hour times are formatted as `"HH:MM "`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.<br><br>In one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation any number of times.<br><br>Return _the minimum number of operations needed to convert_ `current` _to_ `correct`.<br><br>Example 1:<br><br>Input: current =  "02:30 ", correct =  "04:35 "<br>Output: 3<br>Explanation:<br>We can convert current to correct in 3 operations as follows:<br>- Add 60 minutes to current. current becomes  "03:30 ".<br>- Add 60 minutes to current. current becomes  "04:30 ".<br>- Add 5 minutes to current. current becomes  "04:35 ".<br>It can be proven that it is not possible to convert current to correct in fewer than 3 operations.<br><br>Example 2:<br><br>Input: current =  "11:00 ", correct =  "11:01 "<br>Output: 1<br>Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.<br><br>Constraints:<br><br>   `current` and `correct` are in the format `"HH:MM "`<br>   `current <= correct`"""<br><br>    ch, cm = map(int, current.split(':'))<br>    th, tm = map(int, correct.split(':'))<br>    ct = ch  60 + cm<br>    tt = th  60 + tm<br><br>    operations = 0<br>    while ct < tt:<br>        if tt - ct = 60:<br>            ct += 60<br>        elif tt - ct = 15:<br>            ct += 15<br>        elif tt - ct = 5:<br>            ct += 5<br>        else:<br>            ct += 1<br><br>        operations += 1<br><br>    return operations

### DOC[2] (IRRELEVANT) leetcode/leetcode_2437.txt
> def count_valid_times(time: str) - int:<br>    """You are given a string of length `5` called `time`, representing the current time on a digital clock in the format `"hh:mm "`. The earliest possible time is `"00:00 "` and the latest possible time is `"23:59 "`.<br><br>In the string `time`, the digits represented by the `?` symbol are unknown, and must be replaced with a digit from `0` to `9`.<br><br>Return _an integer_ `answer`_, the number of valid clock times that can be created by replacing every_ `?` _with a digit from_ `0` _to_ `9`.<br><br>Example 1:<br><br>Input: time =  "?5:00 "<br>Output: 2<br>Explanation: We can replace the ? with either a 0 or 1, producing  "05:00 " or  "15:00 ". Note that we cannot replace it with a 2, since the time  "25:00 " is invalid. In total, we have two choices.<br><br>Example 2:<br><br>Input: time =  "0?:0? "<br>Output: 100<br>Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.<br><br>Example 3:<br><br>Input: time =  "??:?? "<br>Output: 1440<br>Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 \ 60 = 1440 choices.<br><br>Constraints:<br><br>   `time` is a valid string of length `5` in the format `"hh:mm "`.<br>   `"00 " <= hh <= "23 "`<br>   `"00 " <= mm <= "59 "`<br>   Some of the digits might be replaced with `'?'` and need to be replaced with digits from `0` to `9`."""<br><br>    count = 1<br>    if time[0] == '?':<br>        count = 3 if time[1] == '?' or time[1] < '4' else 2<br>    if time[1] == '?':<br>        count = 4 if time[0] == '2' else 10<br>    if time[3] == '?':<br>        count = 6<br>    if time[4] == '?':<br>        count = 10<br>    return count

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_1975.txt
> def resample(self, rule, how=None, axis=0, fill_method=None, closed=None,<br>                 label=None, convention='start', kind=None, loffset=None,<br>                 limit=None, base=0, on=None, level=None):<br>        """<br>        Resample time-series data.<br><br>        Convenience method for frequency conversion and resampling of time<br>        series. Object must have a datetime-like index (`DatetimeIndex`,<br>        `PeriodIndex`, or `TimedeltaIndex`), or pass datetime-like values<br>        to the `on` or `level` keyword.<br><br>        Parameters<br>        ----------<br>        rule : str<br>            The offset string or object representing target conversion.<br>        how : str<br>            Method for down/re-sampling, default to 'mean' for downsampling.<br><br>            .. deprecated:: 0.18.0<br>               The new syntax is ``.resample(...).mean()``, or<br>               ``.resample(...).apply(<func)``<br>        axis : {0 or 'index', 1 or 'columns'}, default 0<br>            Which axis to use for up- or down-sampling. For `Series` this<br>            will default to 0, i.e. along the rows. Must be<br>            `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`.<br>        fill_method : str, default None<br>            Filling method for upsampling.<br><br>            .. deprecated:: 0.18.0<br>               The new syntax is ``.resample(...).<func()``,<br>               e.g. ``.resample(...).pad()``<br>        closed : {'right', 'left'}, default None<br>            Which side of bin interval is closed. The default is 'left'<br>            for all frequency offsets except for 'M', 'A', 'Q', 'BM',<br>            'BA', 'BQ', and 'W' which all have a default of 'right'.<br>        label : {'right', 'left'}, default None<br>            Which bin edge label to label bucket with. The default is 'left'<br>            for all frequency offsets except for 'M', 'A', 'Q', 'BM',<br>            'BA', 'BQ', and 'W' which all have a default of 'right'.<br>        convention : {'start', 'end', 's', 'e'}, default 'start'<br>            For `PeriodIndex` only, controls whether to use the start or<br>            end of `rule`.<br>        kind : {'timestamp', 'period'}, optional, default None<br>            Pass 'timestamp' to convert the resulting index to a<br>            `DateTimeIndex` or 'period' to convert it to a `PeriodIndex`.<br>            By default the input representation is retained.<br>        loffset : timedelta, default None<br>            Adjust the resampled time labels.<br>        limit : int, default None<br>            Maximum size gap when reindexing with `fill_method`.<br><br>            .. deprecated:: 0.18.0<br>        base : int, default 0<br>            For frequencies that evenly subdivide 1 day, the "origin" of the<br>            aggregated intervals. For example, for '5min' frequency, base could<br>            range from 0 through 4. Defaults to 0.<br>        on : str, optional<br>            For a DataFrame, column to use instead of index for resampling.<br>            Column must be datetime-like.<br><br>            .. versionadded:: 0.19.0<br><br>        level : str or int, optional<br>            For a MultiIndex, level (name or number) to use for<br>            resampling. `level` must be datetime-like.<br><br>            .. versionadded:: 0.19.0<br><br>        Returns<br>        -------<br>        Resampler object<br><br>        See Also<br>        --------<br>        groupby : Group by mapping, function, label, or list of labels.<br>        Series.resample : Resample a Series.<br>        DataFrame.resample: Resample a DataFrame.<br><br>        Notes<br>        -----<br>        See the `user guide<br>        <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#resampling`_<br>        for more.<br><br>        To learn more about the offset strings, please see `this link<br>        <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases`__.<br><br>        Examples<br>        --------<br><br>        Start by creating a series with 9 one minute timestamps.<br><br>         index = pd.date_range('1/1/2000', periods=9, freq='T')<br>         series = pd.Series(range(9), index=index)<br>         series<br>        2000-01-01 00:00:00    0<br>        2000-01-01 00:01:00    1<br>        2000-01-01 00:02:00    2<br>        2000-01-01 00:03:00    3<br>        2000-01-01 00:04:00    4<br>        2000-01-01 00:05:00    5<br>        2000-01-01 00:06:00    6<br>        2000-01-01 00:07:00    7<br>        2000-01-01 00:08:00    8<br>        Freq: T, dtype: int64<br><br>        Downsample the series into 3 minute bins and sum the values<br>        of the timestamps falling into a bin.<br><br>         series.resample('3T').sum()<br>        2000-01-01 00:00:00     3<br>        2000-01-01 00:03:00    12<br>        2000-01-01 00:06:00    21<br>        Freq: 3T, dtype: int64<br><br>        Downsample the series into 3 minute bins as above, but label each<br>        bin using the right edge instead of the left. Please note that the<br>        value in the bucket used as the label is not included in the bucket,<br>        which it labels. For example, in the original series the<br>        bucket ``2000-01-01 00:03:00`` contains the value 3, but the summed<br>        value in the resampled bucket with the label ``2000-01-01 00:03:00``<br>        does not include 3 (if it did, the summed value would be 6, not 3).<br>        To include this value close the right side of the bin interval as<br>        illustrated in the example below this one.<br><br>         series.resample('3T', label='right').sum()<br>        2000-01-01 00:03:00     3<br>        2000-01-01 00:06:00    12<br>        2000-01-01 00:09:00    21<br>        Freq: 3T, dtype: int64<br><br>        Downsample the series into 3 minute bins as above, but close the right<br>        side of the bin interval.<br><br>         series.resample('3T', label='right', closed='right').sum()<br>        2000-01-01 00:00:00     0<br>        2000-01-01 00:03:00     6<br>        2000-01-01 00:06:00    15<br>        2000-01-01 00:09:00    15<br>        Freq: 3T, dtype: int64<br><br>        Upsample the series into 30 second bins.<br><br>         series.resample('30S').asfreq()[0:5]   # Select first 5 rows<br>        2000-01-01 00:00:00   0.0<br>        2000-01-01 00:00:30   NaN<br>        2000-01-01 00:01:00   1.0<br>        2000-01-01 00:01:30   NaN<br>        2000-01-01 00:02:00   2.0<br>        Freq: 30S, dtype: float64<br><br>        Upsample the series into 30 second bins and fill the ``NaN``<br>        values using the ``pad`` method.<br><br>         series.resample('30S').pad()[0:5]<br>        2000-01-01 00:00:00    0<br>        2000-01-01 00:00:30    0<br>        2000-01-01 00:01:00    1<br>        2000-01-01 00:01:30    1<br>        2000-01-01 00:02:00    2<br>        Freq: 30S, dtype: int64<br><br>        Upsample the series into 30 second bins and fill the<br>        ``NaN`` values using the ``bfill`` method.<br><br>         series.resample('30S').bfill()[0:5]<br>        2000-01-01 00:00:00    0<br>        2000-01-01 00:00:30    1<br>        2000-01-01 00:01:00    1<br>        2000-01-01 00:01:30    2<br>        2000-01-01 00:02:00    2<br>        Freq: 30S, dtype: int64<br><br>        Pass a custom function via ``apply``<br><br>         def custom_resampler(array_like):<br>        ...     return np.sum(array_like) + 5<br>        ...<br>         series.resample('3T').apply(custom_resampler)<br>        2000-01-01 00:00:00     8<br>        2000-01-01 00:03:00    17<br>        2000-01-01 00:06:00    26<br>        Freq: 3T, dtype: int64<br><br>        For a Series with a PeriodIndex, the keyword `convention` can be<br>        used to control whether to use the start or end of `rule`.<br><br>        Resample a year by quarter using 'start' `convention`. Values are<br>        assigned to the first quarter of the period.<br><br>         s = pd.Series([1, 2], index=pd.period_range('2012-01-01',<br>        ...                                             freq='A',<br>        ...                                             periods=2))<br>         s<br>        2012    1<br>        2013    2<br>        Freq: A-DEC, dtype: int64<br>         s.resample('Q', convention='start').asfreq()<br>        2012Q1    1.0<br>        2012Q2    NaN<br>        2012Q3    NaN<br>        2012Q4    NaN<br>        2013Q1    2.0<br>        2013Q2    NaN<br>        2013Q3    NaN<br>        2013Q4    NaN<br>        Freq: Q-DEC, dtype: float64<br><br>        Resample quarters by month using 'end' `convention`. Values are<br>        assigned to the last month of the period.<br><br>         q = pd.Series([1, 2, 3, 4], index=pd.period_range('2018-01-01',<br>        ...                                                   freq='Q',<br>        ...                                                   periods=4))<br>         q<br>        2018Q1    1<br>        2018Q2    2<br>        2018Q3    3<br>        2018Q4    4<br>        Freq: Q-DEC, dtype: int64<br>         q.resample('M', convention='end').asfreq()<br>        2018-03    1.0<br>        2018-04    NaN<br>        2018-05    NaN<br>        2018-06    2.0<br>        2018-07    NaN<br>        2018-08    NaN<br>        2018-09    3.0<br>        2018-10    NaN<br>        2018-11    NaN<br>        2018-12    4.0<br>        Freq: M, dtype: float64<br><br>        For DataFrame objects, the keyword `on` can be used to specify the<br>        column instead of the index for resampling.<br><br>         d = dict({'price': [10, 11, 9, 13, 14, 18, 17, 19],<br>        ...           'volume': [50, 60, 40, 100, 50, 100, 40, 50]})<br>         df = pd.DataFrame(d)<br>         df['week_starting'] = pd.date_range('01/01/2018',<br>        ...                                     periods=8,<br>        ...                                     freq='W')<br>         df<br>           price  volume week_starting<br>        0     10      50    2018-01-07<br>        1     11      60    2018-01-14<br>        2      9      40    2018-01-21<br>        3     13     100    2018-01-28<br>        4     14      50    2018-02-04<br>        5     18     100    2018-02-11<br>        6     17      40    2018-02-18<br>        7     19      50    2018-02-25<br>         df.resample('M', on='week_starting').mean()<br>                       price  volume<br>        week_starting<br>        2018-01-31     10.75    62.5<br>        2018-02-28     17.00    60.0<br><br>        For a DataFrame with MultiIndex, the keyword `level` can be used to<br>        specify on which level the resampling needs to take place.<br><br>         days = pd.date_range('1/1/2000', periods=4, freq='D')<br>         d2 = dict({'price': [10, 11, 9, 13, 14, 18, 17, 19],<br>        ...            'volume': [50, 60, 40, 100, 50, 100, 40, 50]})<br>         df2 = pd.DataFrame(d2,<br>        ...                    index=pd.MultiIndex.from_product([days,<br>        ...                                                     ['morning',<br>        ...                                                      'afternoon']]<br>        ...                                                     ))<br>         df2<br>                              price  volume<br>        2000-01-01 morning       10      50<br>                   afternoon     11      60<br>        2000-01-02 morning        9      40<br>                   afternoon     13     100<br>        2000-01-03 morning       14      50<br>                   afternoon     18     100<br>        2000-01-04 morning       17      40<br>                   afternoon     19      50<br>         df2.resample('D', level=0).sum()<br>                    price  volume<br>        2000-01-01     21     110<br>        2000-01-02     22     140<br>        2000-01-03     32     150<br>        2000-01-04     36      90<br>        """<br><br>        from pandas.core.resample import (resample,<br>                                          _maybe_process_deprecations)<br>        axis = self._get_axis_number(axis)<br>        r = resample(self, freq=rule, label=label, closed=closed,<br>                     axis=axis, kind=kind, loffset=loffset,<br>                     convention=convention,<br>                     base=base, key=on, level=level)<br>        return _maybe_process_deprecations(r,<br>                                           how=how,<br>                                           fill_method=fill_method,<br>                                           limit=limit)

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_286067.txt
> def parse_timestamp(timestamp, zone='UTC', timestamp_format=None):<br>    r"""<br>    pip install delorean<br><br>    Args:<br>        timestamp (str): timestampe string<br>        zone (bool): assumes input is zone (only if not specified) and gives<br>            output in zone.<br><br>    CommandLine:<br>        python -m utool.util_time --test-parse_timestamp<br>        python -m utool.util_time parse_timestamp<br><br>    Example0:<br>         # ENABLE_DOCTEST<br>         from utool.util_time import   # NOQA<br>         import utool as ut<br>         utc = True<br>         timestampe_format = None<br>         timestamps = [<br>             ('2015:04:01 00:00:00',),<br>             ('2005-10-27T14:35:20+02:00',),<br>             ('2000-01-01T09:00:00-05:00', 'UTC'),<br>             ('2000-01-01T09:00:00-05:00', 'EST'),<br>             ('2000-01-01T09:00:00', 'EST'),<br>             ('2000-01-01T09:00:00', 'UTC'),<br>             ('6:35:01\x002006:03:19 1',),<br>             ('2016/08/18 10:51:02 EST',),<br>             ('2016-08-18T10:51:02-05:00',),<br>         ]<br>         timestamp = timestamps[-1][0]<br>         dn_list = [parse_timestamp(args) for args in timestamps]<br>         result = ut.NEWLINE.join([str(dn) for dn in dn_list])<br>         print(result)<br>        2015-04-01 00:00:00+00:00<br>        2005-10-27 12:35:20+00:00<br>        2000-01-01 14:00:00+00:00<br>        2000-01-01 09:00:00-05:00<br>        2000-01-01 09:00:00-05:00<br>        2000-01-01 09:00:00+00:00<br>        2006-03-19 06:35:01+00:00<br>        2016-08-18 15:51:02+00:00<br>        2016-08-18 15:51:02+00:00<br>    """<br>    if timestamp is None:<br>        return None<br><br>    use_delorean = True or six.PY2<br>    if use_delorean:<br>        import delorean<br>        ## customize delorean string method<br>        #def __str__(self):<br>        #    return str(self.datetime)<br>        #    #return str(self.datetime) + ' ' + str(self.timezone)<br>        #delorean.Delorean.__str__ = __str__<br>        ## method types must be injected into the class<br>        ##ut.inject_func_as_method(dn, __str__, '__repr__', override=True)<br><br>    if not isinstance(timestamp, six.string_types):<br>        raise NotImplementedError('Unknown format: timestamp=%r' % (timestamp,))<br><br>    # Normal format, or non-standard year first data<br>    if timestamp_format is None:<br>        # dont warn because we will take care of utc<br>        timefmt = determine_timestamp_format(timestamp, warn=False)<br>    else:<br>        timefmt = timestamp_format<br>    if timefmt is None or not isinstance(timefmt, six.string_types):<br>        raise AssertionError('unknown timestamp_format=%r' % (timestamp_format,))<br><br>    # Fixup timestamp<br>    utc_offset = None<br>    if len(timestamp) == 20 and '\x00' in timestamp:<br>        timestamp_ = timestamp.replace('\x00', ' ').strip(';').strip()<br>    elif use_delorean and len(timestamp)  19:<br>        timestamp_ = timestamp[:19].strip(';').strip()<br>        utc_offset = timestamp[19:]<br>    else:<br>        timestamp_ = timestamp<br><br>    dt_ = datetime.datetime.strptime(timestamp_, timefmt)<br>    if use_delorean:<br>        #if utc and utc_offset is not None:<br>        #if utc:<br>        #    dn_ = delorean.Delorean(dt_, 'UTC')<br>        #else:<br>        if zone is None:<br>            zone = time.tzname[0]<br>        if zone == 'local':<br>            zone = time.tzname[0]<br>        dn_ = delorean.Delorean(dt_, zone)<br>    else:<br>        dn_ = dt_<br><br>    if utc_offset is not None and zone == 'UTC':<br>        if use_delorean:<br>            # Python 2.7 does not account for timezones<br>            if ':' in utc_offset:<br>                sign = {' ': +1, '+': +1, '-': -1}[utc_offset[0]]<br>                hours, seconds = utc_offset[1:].split(':')<br>                delta_ = datetime.timedelta(hours=int(hours), seconds=int(seconds))<br>                delta = sign  delta_<br>            else:<br>                import pytz<br>                tzname = utc_offset.strip()<br>                delta = pytz.timezone(tzname).utcoffset(dt_)<br>            # Move back to utc<br>            dn = dn_ - delta<br>        else:<br>            raise AssertionError('python3 should take care of timezone')<br>    else:<br>        dn = dn_<br><br>    if use_delorean:<br>        if not zone != 'UTC':<br>            dn.shift(zone)<br>        return dn.datetime

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_139778.txt
> def timedelta_to_str(value: datetime.timedelta, fmt: str = None) - str:<br>    """Display the timedelta formatted according to the given string.<br><br>    You should use global setting ``TIMEDELTA_FORMAT`` to specify default<br>    format to this function there (like ``DATE_FORMAT`` for builtin ``date``<br>    template filter).<br><br>    Default value for ``TIMEDELTA_FORMAT`` is ``'G:i'``.<br><br>    Format uses the same policy as Django ``date`` template filter or<br>    PHP ``date`` function with several differences.<br><br>    Available format strings:<br><br>    +------------------+-----------------------------+------------------------+<br>    | Format character | Description                 | Example output         |<br>    +==================+=============================+========================+<br>    | ``a``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``A``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``b``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``B``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``c``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``d``            | Total days, 2 digits with   | ``'01'``, ``'41'``     |<br>    |                  | leading zeros. Do not       |                        |<br>    |                  | combine with ``w`` format.  |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``D``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``f``            | Magic "full" format with    | ``'2w 4d 1:28:07'``    |<br>    |                  | short labels.               |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``F``            | Magic "full" format with    | ``'2 weeks, 4 days,    |<br>    |                  | normal labels.              | 1:28:07'``             |<br>    +------------------+-----------------------------+------------------------+<br>    | ``g``            | Day, not total, hours       | ``'0'`` to ``'23'``    |<br>    |                  | without leading zeros. To   |                        |<br>    |                  | use with ``d``, ``j``, or   |                        |<br>    |                  | ``w``.                      |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``G``            | Total hours without         | ``'1'``, ``'433'``     |<br>    |                  | leading zeros. Do not       |                        |<br>    |                  | combine with ``g`` or       |                        |<br>    |                  | ``h`` formats.              |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``h``            | Day, not total, hours with  | ``'00'`` to ``'23'``   |<br>    |                  | leading zeros. To use with  |                        |<br>    |                  | ``d`` or ``w``.             |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``H``            | Total hours with leading    | ``'01', ``'433'``      |<br>    |                  | zeros. Do not combine with  |                        |<br>    |                  | ``g`` or ``h`` formats.     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``i``            | Hour, not total, minutes, 2 | ``00`` to ``'59'``     |<br>    |                  | digits with leading zeros   |                        |<br>    |                  | To use with ``g``, ``G``,   |                        |<br>    |                  | ``h`` or ``H`` formats.     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``I``            | Total minutes, 2 digits or  | ``'01'``, ``'433'``    |<br>    |                  | more with leading zeros. Do |                        |<br>    |                  | not combine with ``i``      |                        |<br>    |                  | format.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``j``            | Total days, one or 2 digits | ``'1'``, ``'41'``      |<br>    |                  | without leading zeros. Do   |                        |<br>    |                  | not combine with ``w``      |                        |<br>    |                  | format.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``J``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``l``            | Days long label.            | ``'day'`` or           |<br>    |                  | Pluralized and localized.   | ``'days'``             |<br>    +------------------+-----------------------------+------------------------+<br>    | ``L``            | Weeks long label.           | ``'week'`` or          |<br>    |                  | Pluralized and localized.   | ``'weeks'``            |<br>    +------------------+-----------------------------+------------------------+<br>    | ``m``            | Week days long label.       | ``'day'`` or           |<br>    |                  | Pluralized and localized.   | ``'days'``             |<br>    +------------------+-----------------------------+------------------------+<br>    | ``M``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``n``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``N``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``O``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``P``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``r``            | Standart Python timedelta   | ``'18 d 1:28:07'``     |<br>    |                  | representation with short   |                        |<br>    |                  | labels.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``R``            | Standart Python timedelta   | ``'18 days, 1:28:07'`` |<br>    |                  | representation with normal  |                        |<br>    |                  | labels.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``s``            | Minute, not total, seconds, | ``'00'`` to ``'59'``   |<br>    |                  | 2 digits with leading       |                        |<br>    |                  | zeros. To use with ``i`` or |                        |<br>    |                  | ``I``.                      |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``S``            | Total seconds. 2 digits or  | ``'00'``, ``'433'``    |<br>    |                  | more with leading zeros. Do |                        |<br>    |                  | not combine with ``s``      |                        |<br>    |                  | format.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``t``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``T``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``u``            | Second, not total,          | ``0`` to ``999999``    |<br>    |                  | microseconds.               |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``U``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``w``            | Week, not total, days, one  | ``0`` to ``6``         |<br>    |                  | digit without leading       |                        |<br>    |                  | zeros. To use with ``W``.   |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``W``            | Total weeks, one or more    | ``'1'``, ``'41'``      |<br>    |                  | digits without leading      |                        |<br>    |                  | zeros.                      |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``y``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``Y``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``z``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``Z``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br><br>    For example,<br><br>    ::<br><br>         import datetime<br>         from rororo.timedelta import timedelta_to_str<br>         delta = datetime.timedelta(seconds=99660)<br>         timedelta_to_str(delta)<br>        ... '27:41'<br>         timedelta_to_str(delta, 'r')<br>        ... '1d 3:41:00'<br>         timedelta_to_str(delta, 'f')<br>        ... '1d 3:41'<br>         timedelta_to_str(delta, 'W L, w l, H:i:s')<br>        ... '0 weeks, 1 day, 03:41:00'<br><br>    Couple words about magic "full" formats. These formats show weeks number<br>    with week label, days number with day label and seconds only if weeks<br>    number, days number or seconds greater that zero.<br><br>    For example,<br><br>    ::<br><br>         import datetime<br>         from rororo.timedelta import timedelta_to_str<br>         delta = datetime.timedelta(hours=12)<br>         timedelta_to_str(delta, 'f')<br>        ... '12:00'<br>         timedelta_to_str(delta, 'F')<br>        ... '12:00'<br>         delta = datetime.timedelta(hours=12, seconds=30)<br>         timedelta_to_str(delta, 'f')<br>        ... '12:00:30'<br>         timedelta_to_str(delta, 'F')<br>        ... '12:00:30'<br>         delta = datetime.timedelta(hours=168)<br>         timedelta_to_str(delta, 'f')<br>        ... '1w 0:00'<br>         timedelta_to_str(delta, 'F')<br>        ... '1 week, 0:00'<br><br>    :param value: Timedelta instance to convert to string.<br>    :param fmt: Format to use for conversion.<br>    """<br>    # Only ``datetime.timedelta`` instances allowed for this function<br>    if not isinstance(value, datetime.timedelta):<br>        raise ValueError(<br>            'Value should be a "datetime.timedelta" instance. You use {0}.'<br>            .format(type(value)))<br><br>    # Generate total data<br>    days = value.days<br>    microseconds = value.microseconds<br>    seconds = timedelta_seconds(value)<br><br>    hours = seconds // 3600<br>    minutes = seconds // 60<br>    weeks = days // 7<br><br>    # Generate collapsed data<br>    day_hours = hours - days  24<br>    hour_minutes = minutes - hours  60<br>    minute_seconds = seconds - minutes  60<br>    week_days = days - weeks  7<br><br>    days_label = 'day' if days % 10 == 1 else 'days'<br>    short_days_label = 'd'<br>    short_week_days_label = 'd'<br>    short_weeks_label = 'w'<br>    week_days_label = 'day' if week_days % 10 == 1 else 'days'<br>    weeks_label = 'week' if weeks % 10 == 1 else 'weeks'<br><br>    # Collect data<br>    data = locals()<br><br>    fmt = fmt or TIMEDELTA_FORMAT<br>    processed = ''<br><br>    for part in fmt:<br>        if part in TIMEDELTA_FORMATS:<br>            is_full_part = part in ('f', 'F')<br>            is_repr_part = part in ('r', 'R')<br><br>            part = TIMEDELTA_FORMATS[part][0]<br><br>            if is_full_part or is_repr_part:<br>                if is_repr_part and not days:<br>                    part = part.replace('%(days)d', '')<br>                    part = part.replace('%(days_label)s,', '')<br>                    part = part.replace('%(short_days_label)s', '')<br><br>                if is_full_part and not minute_seconds:<br>                    part = part.replace(':%(minute_seconds)02d', '')<br><br>                if is_full_part and not weeks:<br>                    part = part.replace('%(weeks)d', '')<br>                    part = part.replace('%(short_weeks_label)s', '')<br>                    part = part.replace('%(weeks_label)s,', '')<br><br>                if is_full_part and not week_days:<br>                    part = part.replace('%(week_days)d', '')<br>                    part = part.replace('%(short_week_days_label)s', '')<br>                    part = part.replace('%(week_days_label)s,', '')<br><br>                part = part.strip()<br>                part = ' '.join(part.split())<br><br>        processed += part<br><br>    return processed % data


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_17.txt
> def letter_combinations(digits: str):<br>    """Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.<br><br>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br><br>Example 1:<br><br>Input: digits =  "23 "<br>Output: \[ "ad ", "ae ", "af ", "bd ", "be ", "bf ", "cd ", "ce ", "cf "\]<br><br>Example 2:<br><br>Input: digits =  " "<br>Output: \[\]<br><br>Example 3:<br><br>Input: digits =  "2 "<br>Output: \[ "a ", "b ", "c "\]<br><br>Constraints:<br><br>   `0 <= digits.length <= 4`<br>   `digits[i]` is a digit in the range `['2', '9']`."""<br><br>    if not digits: return []<br>    phone = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]<br>    result = [""]<br><br>    for digit in digits:<br>        temp = []<br>        for s in result:<br>            for c in phone[int(digit) - 2]:<br>                temp.append(s + c)<br>        result = temp<br><br>    return result
