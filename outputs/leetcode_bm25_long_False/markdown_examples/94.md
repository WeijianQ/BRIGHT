# Query `94`

## Original Question

*There are `n` points on a road you are driving your taxi on. The `n` points on the road are labeled from `1` to `n` in the direction you are going, and you want to drive from point `1` to point `n` to make money by picking up passengers. You cannot change the direction of the taxi.

The passengers are represented by a 0-indexed 2D integer array `rides`, where `rides[i] = [starti, endi, tipi]` denotes the `ith` passenger requesting a ride from point `starti` to point `endi` who is willing to give a `tipi` dollar tip.

For each passenger `i` you pick up, you earn `endi - starti + tipi` dollars. You may only drive at most one passenger at a time.

Given `n` and `rides`, return _the maximum number of dollars you can earn by picking up the passengers optimally._

Note: You may drop off a passenger and pick up a different passenger at the same point.

Example 1:

Input: n = 5, rides = \[\[2,5,4\],\[1,5,1\]\]
Output: 7
Explanation: We can pick up passenger 0 to earn 5 - 2 + 4 = 7 dollars.

Example 2:

Input: n = 20, rides = \[\[1,6,1\],\[3,10,2\],\[10,12,3\],\[11,12,2\],\[12,15,2\],\[13,18,1\]\]
Output: 20
Explanation: We will pick up the following passengers:
- Drive passenger 1 from point 3 to point 10 for a profit of 10 - 3 + 2 = 9 dollars.
- Drive passenger 2 from point 10 to point 12 for a profit of 12 - 10 + 3 = 5 dollars.
- Drive passenger 5 from point 13 to point 18 for a profit of 18 - 13 + 1 = 6 dollars.
We earn 9 + 5 + 6 = 20 dollars in total.

Constraints:

   `1 <= n <= 105`
   `1 <= rides.length <= 3  104`
   `rides[i].length == 3`
   `1 <= starti < endi <= n`
   `1 <= tipi <= 105`*


### Metrics

```
recip_rank: 0.0175
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0200
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.6667
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.1507
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0126
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1589.txt
> def maxSumRangeQuery(nums, requests):<br>    """We have an array of integers, `nums`, and an array of `requests` where `requests[i] = [starti, endi]`. The `ith` request asks for the sum of `nums[starti] + nums[starti + 1] + ... + nums[endi - 1] + nums[endi]`. Both `starti` and `endi` are _0-indexed_.<br><br>Return _the maximum total sum of all requests among all permutations of_ `nums`.<br><br>Since the answer may be too large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: nums = \[1,2,3,4,5\], requests = \[\[1,3\],\[0,1\]\]<br>Output: 19<br>Explanation: One permutation of nums is \[2,1,3,4,5\] with the following result: <br>requests\[0\] - nums\[1\] + nums\[2\] + nums\[3\] = 1 + 3 + 4 = 8<br>requests\[1\] - nums\[0\] + nums\[1\] = 2 + 1 = 3<br>Total sum: 8 + 3 = 11.<br>A permutation with a higher total sum is \[3,5,4,2,1\] with the following result:<br>requests\[0\] - nums\[1\] + nums\[2\] + nums\[3\] = 5 + 4 + 2 = 11<br>requests\[1\] - nums\[0\] + nums\[1\] = 3 + 5  = 8<br>Total sum: 11 + 8 = 19, which is the best that you can do.<br><br>Example 2:<br><br>Input: nums = \[1,2,3,4,5,6\], requests = \[\[0,1\]\]<br>Output: 11<br>Explanation: A permutation with the max total sum is \[6,5,4,3,2,1\] with request sums \[11\].<br><br>Example 3:<br><br>Input: nums = \[1,2,3,4,5,10\], requests = \[\[0,2\],\[1,3\],\[1,1\]\]<br>Output: 47<br>Explanation: A permutation with the max total sum is \[4,10,5,3,2,1\] with request sums \[19,18,10\].<br><br>Constraints:<br><br>   `n == nums.length`<br>   `1 <= n <= 105`<br>   `0 <= nums[i] <= 105`<br>   `1 <= requests.length <= 105`<br>   `requests[i].length == 2`<br>   `0 <= starti <= endi < n`"""<br><br>    n = len(nums)<br>    count = [0]  n<br>    for request in requests:<br>        count[request[0]] += 1<br>        if request[1] + 1 < n:<br>            count[request[1] + 1] -= 1<br>    for i in range(1, n):<br>        count[i] += count[i - 1]<br><br>    nums.sort()<br>    count.sort()<br><br>    ans = 0<br>    for i in range(n):<br>        ans = (ans + nums[i]  count[i]) % 1000000007<br>    return ans

### DOC[2] (IRRELEVANT) leetcode/leetcode_2303.txt
> def tax_amount(brackets, income):<br>    """You are given a 0-indexed 2D integer array `brackets` where `brackets[i] = [upperi, percenti]` means that the `ith` tax bracket has an upper bound of `upperi` and is taxed at a rate of `percenti`. The brackets are sorted by upper bound (i.e. `upperi-1 < upperi` for `0 < i < brackets.length`).<br><br>Tax is calculated as follows:<br><br>   The first `upper0` dollars earned are taxed at a rate of `percent0`.<br>   The next `upper1 - upper0` dollars earned are taxed at a rate of `percent1`.<br>   The next `upper2 - upper1` dollars earned are taxed at a rate of `percent2`.<br>   And so on.<br><br>You are given an integer `income` representing the amount of money you earned. Return _the amount of money that you have to pay in taxes._ Answers within `10-5` of the actual answer will be accepted.<br><br>Example 1:<br><br>Input: brackets = \[\[3,50\],\[7,10\],\[12,25\]\], income = 10<br>Output: 2.65000<br>Explanation:<br>Based on your income, you have 3 dollars in the 1st tax bracket, 4 dollars in the 2nd tax bracket, and 3 dollars in the 3rd tax bracket.<br>The tax rate for the three tax brackets is 50%, 10%, and 25%, respectively.<br>In total, you pay $3 \ 50% + $4 \ 10% + $3 \ 25% = $2.65 in taxes.<br><br>Example 2:<br><br>Input: brackets = \[\[1,0\],\[4,25\],\[5,50\]\], income = 2<br>Output: 0.25000<br>Explanation:<br>Based on your income, you have 1 dollar in the 1st tax bracket and 1 dollar in the 2nd tax bracket.<br>The tax rate for the two tax brackets is 0% and 25%, respectively.<br>In total, you pay $1 \ 0% + $1 \ 25% = $0.25 in taxes.<br><br>Example 3:<br><br>Input: brackets = \[\[2,50\]\], income = 0<br>Output: 0.00000<br>Explanation:<br>You have no income to tax, so you have to pay a total of $0 in taxes.<br><br>Constraints:<br><br>   `1 <= brackets.length <= 100`<br>   `1 <= upperi <= 1000`<br>   `0 <= percenti <= 100`<br>   `0 <= income <= 1000`<br>   `upperi` is sorted in ascending order.<br>   All the values of `upperi` are unique.<br>   The upper bound of the last tax bracket is greater than or equal to `income`."""<br><br>    tax = 0<br>    prev_upper = 0<br>    for upper, percent in brackets:<br>        tax += (min(upper, income) - prev_upper)  (percent / 100)<br>        prev_upper = upper<br>        if income <= upper:<br>            break<br>    return tax

### DOC[3] (IRRELEVANT) leetcode/leetcode_1599.txt
> def minOperationsMaxProfit(customers, boardingCost, runningCost):<br>    """You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you `runningCost` dollars.<br><br>You are given an array `customers` of length `n` where `customers[i]` is the number of new customers arriving just before the `ith` rotation (0-indexed). This means you must rotate the wheel `i` times before the `customers[i]` customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays `boardingCost` dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.<br><br>You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.<br><br>Return _the minimum number of rotations you need to perform to maximize your profit._ If there is no scenario where the profit is positive, return `-1`.<br><br>Example 1:<br><br>Input: customers = \[8,3\], boardingCost = 5, runningCost = 6<br>Output: 3<br>Explanation: The numbers written on the gondolas are the number of people currently there.<br>1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 \ $5 - 1 \ $6 = $14.<br>2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 \ $5 - 2 \ $6 = $28.<br>3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 \ $5 - 3 \ $6 = $37.<br>The highest profit was $37 after rotating the wheel 3 times.<br><br>Example 2:<br><br>Input: customers = \[10,9,6\], boardingCost = 6, runningCost = 4<br>Output: 7<br>Explanation:<br>1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 \ $6 - 1 \ $4 = $20.<br>2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 \ $6 - 2 \ $4 = $40.<br>3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 \ $6 - 3 \ $4 = $60.<br>4. 4 board and 9 wait, the wheel rotates. Current profit is 16 \ $6 - 4 \ $4 = $80.<br>5. 4 board and 5 wait, the wheel rotates. Current profit is 20 \ $6 - 5 \ $4 = $100.<br>6. 4 board and 1 waits, the wheel rotates. Current profit is 24 \ $6 - 6 \ $4 = $120.<br>7. 1 boards, the wheel rotates. Current profit is 25 \ $6 - 7 \ $4 = $122.<br>The highest profit was $122 after rotating the wheel 7 times.<br><br>Example 3:<br><br>Input: customers = \[3,4,0,5,1\], boardingCost = 1, runningCost = 92<br>Output: -1<br>Explanation:<br>1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 \ $1 - 1 \ $92 = -$89.<br>2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 \ $1 - 2 \ $92 = -$177.<br>3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 \ $1 - 3 \ $92 = -$269.<br>4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 \ $1 - 4 \ $92 = -$357.<br>5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 \ $1 - 5 \ $92 = -$447.<br>The profit was never positive, so return -1.<br><br>Constraints:<br><br>   `n == customers.length`<br>   `1 <= n <= 105`<br>   `0 <= customers[i] <= 50`<br>   `1 <= boardingCost, runningCost <= 100`"""<br><br>    waiting = 0<br>    profit = 0<br>    max_profit = 0<br>    rotations = 0<br>    result = -1<br><br>    for i in range(len(customers) + sum(customers)):<br>        if i < len(customers):<br>            waiting += customers[i]<br>        boarding = min(waiting, 4)<br>        waiting -= boarding<br>        profit += boarding  boardingCost - runningCost<br><br>        if profit  max_profit:<br>            max_profit = profit<br>            result = rotations + 1<br>        rotations += 1<br>    <br>    return result

### DOC[4] (IRRELEVANT) leetcode/leetcode_2312.txt
> def max_count_target(nums, key):<br>    """You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.<br><br>To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.<br><br>Return _the maximum money you can earn after cutting an_ `m x n` _piece of wood_.<br><br>Note that you can cut the piece of wood as many times as you want.<br><br>Example 1:<br><br>Input: m = 3, n = 5, prices = \[\[1,4,2\],\[2,2,7\],\[2,1,3\]\]<br>Output: 19<br>Explanation: The diagram above shows a possible scenario. It consists of:<br>- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \ 7 = 14.<br>- 1 piece of wood shaped 2 x 1, selling for a price of 1 \ 3 = 3.<br>- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.<br>This obtains a total of 14 + 3 + 2 = 19 money earned.<br>It can be shown that 19 is the maximum amount of money that can be earned.<br><br>Example 2:<br><br>Input: m = 4, n = 6, prices = \[\[3,2,10\],\[1,4,2\],\[4,1,3\]\]<br>Output: 32<br>Explanation: The diagram above shows a possible scenario. It consists of:<br>- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \ 10 = 30.<br>- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.<br>This obtains a total of 30 + 2 = 32 money earned.<br>It can be shown that 32 is the maximum amount of money that can be earned.<br>Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.<br><br>Constraints:<br><br>   `1 <= m, n <= 200`<br>   `1 <= prices.length <= 2  104`<br>   `prices[i].length == 3`<br>   `1 <= hi <= m`<br>   `1 <= wi <= n`<br>   `1 <= pricei <= 106`<br>   All the shapes of wood `(hi, wi)` are pairwise distinct."""<br><br>    count = {}<br>    max_count = 0<br>    max_target = -1<br>    for i in range(1, len(nums)):<br>        if nums[i - 1] == key:<br>            count[nums[i]] = count.get(nums[i], 0) + 1<br>            if count[nums[i]]  max_count:<br>                max_count = count[nums[i]]<br>                max_target = nums[i]<br>    return max_target

### DOC[5] (IRRELEVANT) leetcode/leetcode_2580.txt
> def total_ways_to_split_ranges(ranges):<br>    """You are given a 2D integer array `ranges` where `ranges[i] = [starti, endi]` denotes that all integers between `starti` and `endi` (both inclusive) are contained in the `ith` range.<br><br>You are to split `ranges` into two (possibly empty) groups such that:<br><br>   Each range belongs to exactly one group.<br>   Any two overlapping ranges must belong to the same group.<br><br>Two ranges are said to be overlapping if there exists at least one integer that is present in both ranges.<br><br>   For example, `[1, 3]` and `[2, 5]` are overlapping because `2` and `3` occur in both ranges.<br><br>Return _the total number of ways to split_ `ranges` _into two groups_. Since the answer may be very large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: ranges = \[\[6,10\],\[5,15\]\]<br>Output: 2<br>Explanation: <br>The two ranges are overlapping, so they must be in the same group.<br>Thus, there are two possible ways:<br>- Put both the ranges together in group 1.<br>- Put both the ranges together in group 2.<br><br>Example 2:<br><br>Input: ranges = \[\[1,3\],\[10,20\],\[2,5\],\[4,8\]\]<br>Output: 4<br>Explanation: <br>Ranges \[1,3\], and \[2,5\] are overlapping. So, they must be in the same group.<br>Again, ranges \[2,5\] and \[4,8\] are also overlapping. So, they must also be in the same group. <br>Thus, there are four possible ways to group them:<br>- All the ranges in group 1.<br>- All the ranges in group 2.<br>- Ranges \[1,3\], \[2,5\], and \[4,8\] in group 1 and \[10,20\] in group 2.<br>- Ranges \[1,3\], \[2,5\], and \[4,8\] in group 2 and \[10,20\] in group 1.<br><br>Constraints:<br><br>   `1 <= ranges.length <= 105`<br>   `ranges[i].length == 2`<br>   `0 <= starti <= endi <= 109`"""<br><br>    MOD = 109 + 7<br>    ranges.sort(key=lambda x: x[1])<br>    overlapping, non_overlapping, prev_end = 0, 1, -1<br><br>    for start, end in ranges:<br>        if start <= prev_end:<br>            overlapping += 1<br>        else:<br>            non_overlapping += 1<br>        prev_end = max(prev_end, end)<br><br>    result = 1<br>    for i in range(1, overlapping + 1):<br>        result = (result  2) % MOD<br><br>    return result


## Ground Truth

### GROUND TRUTH 0, ranked 56, leetcode/leetcode_1235.txt
> from bisect import bisect_left<br>    """We have `n` jobs, where every job is scheduled to be done from `startTime[i]` to `endTime[i]`, obtaining a profit of `profit[i]`.<br><br>You're given the `startTime`, `endTime` and `profit` arrays, return the maximum profit you can take such that there are no two jobs in the subset with overlapping time range.<br><br>If you choose a job that ends at time `X` you will be able to start another job that starts at time `X`.<br><br>Example 1:<br><br>Input: startTime = \[1,2,3,3\], endTime = \[3,4,5,6\], profit = \[50,10,40,70\]<br>Output: 120<br>Explanation: The subset chosen is the first and fourth job. <br>Time range \[1-3\]+\[3-6\] , we get profit of 120 = 50 + 70.<br><br>Example 2:<br><br>Input: startTime = \[1,2,3,4,6\], endTime = \[3,5,10,6,9\], profit = \[20,20,100,70,60\]<br>Output: 150<br>Explanation: The subset chosen is the first, fourth and fifth job. <br>Profit obtained 150 = 20 + 70 + 60.<br><br>Example 3:<br><br>Input: startTime = \[1,1,1\], endTime = \[2,3,4\], profit = \[5,6,4\]<br>Output: 6<br><br>Constraints:<br><br>   `1 <= startTime.length == endTime.length == profit.length <= 5  104`<br>   `1 <= startTime[i] < endTime[i] <= 109`<br>   `1 <= profit[i] <= 104`"""<br><br><br>def jobScheduling(startTime, endTime, profit):<br>    jobs = sorted(zip(endTime, startTime, profit))<br>    dp = [jobs[0][2]]<br>    <br>    def latestNonConflict(index):<br>        startTimeToFind = jobs[index][1]<br>        index = bisect_left([job[0] for job in jobs], startTimeToFind)<br>        if index:<br>            return index - 1<br>        return -1<br><br>    for i in range(1, len(jobs)):<br>        L = latestNonConflict(i)<br>        dp.append(max(dp[-1], (0 if L == -1 else dp[L]) + jobs[i][2]))<br><br>    return dp[-1]

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_1353.txt
> import heapq<br>    """You are given an array of `events` where `events[i] = [startDayi, endDayi]`. Every event `i` starts at `startDayi` and ends at `endDayi`.<br><br>You can attend an event `i` at any day `d` where `startTimei <= d <= endTimei`. You can only attend one event at any time `d`.<br><br>Return _the maximum number of events you can attend_.<br><br>Example 1:<br><br>Input: events = \[\[1,2\],\[2,3\],\[3,4\]\]<br>Output: 3<br>Explanation: You can attend all the three events.<br>One way to attend them all is as shown.<br>Attend the first event on day 1.<br>Attend the second event on day 2.<br>Attend the third event on day 3.<br><br>Example 2:<br><br>Input: events= \[\[1,2\],\[2,3\],\[3,4\],\[1,2\]\]<br>Output: 4<br><br>Constraints:<br><br>   `1 <= events.length <= 105`<br>   `events[i].length == 2`<br>   `1 <= startDayi <= endDayi <= 105`"""<br><br><br>def maxEvents(events: List[List[int]]) - int:<br>    events.sort(key=lambda x: x[0])<br>    min_heap = []<br>    event_count, day = 0, 0<br><br>    for event in events:<br>        while min_heap and min_heap[0] < event[0]:<br>            heapq.heappop(min_heap)<br>        heapq.heappush(min_heap, event[1])<br>        event_count += 1<br>        day += 1<br><br>    return event_count

### GROUND TRUTH 2, ranked 98, leetcode/leetcode_1751.txt
> def slowestKey(releaseTimes, keysPressed):<br>    """You are given an array of `events` where `events[i] = [startDayi, endDayi, valuei]`. The `ith` event starts at `startDayi` and ends at `endDayi`, and if you attend this event, you will receive a value of `valuei`. You are also given an integer `k` which represents the maximum number of events you can attend.<br><br>You can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.<br><br>Return _the maximum sum of values that you can receive by attending events._<br><br>Example 1:<br><br>Input: events = \[\[1,2,4\],\[3,4,3\],\[2,3,1\]\], k = 2<br>Output: 7<br>Explanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.<br><br>Example 2:<br><br>Input: events = \[\[1,2,4\],\[3,4,3\],\[2,3,10\]\], k = 2<br>Output: 10<br>Explanation: Choose event 2 for a total value of 10.<br>Notice that you cannot attend any other event as they overlap, and that you do not have to attend k events.<br><br>Example 3:<br><br>Input: events = \[\[1,1,1\],\[2,2,2\],\[3,3,3\],\[4,4,4\]\], k = 3<br>Output: 9<br>Explanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.<br><br>Constraints:<br><br>   `1 <= k <= events.length`<br>   `1 <= k  events.length <= 106`<br>   `1 <= startDayi <= endDayi <= 109`<br>   `1 <= valuei <= 106`"""<br><br>    max_key = keysPressed[0]<br>    max_duration = releaseTimes[0]<br>    for i in range(1, len(releaseTimes)):<br>        duration = releaseTimes[i] - releaseTimes[i - 1]<br>        if duration  max_duration or (duration == max_duration and keysPressed[i]  max_key):<br>            max_key = keysPressed[i]<br>            max_duration = duration<br>    return max_key
