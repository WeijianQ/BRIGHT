# Query `33`

## Original Question

*In this problem, a tree is an undirected graph that is connected and has no cycles.

You are given a graph that started as a tree with `n` nodes labeled from `1` to `n`, with one additional edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed. The graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the graph.

Return _an edge that can be removed so that the resulting graph is a tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the input.

Example 1:

Input: edges = \[\[1,2\],\[1,3\],\[2,3\]\]
Output: \[2,3\]

Example 2:

Input: edges = \[\[1,2\],\[2,3\],\[3,4\],\[1,4\],\[1,5\]\]
Output: \[1,4\]

Constraints:

   `n == edges.length`
   `3 <= n <= 1000`
   `edges[i].length == 2`
   `1 <= ai < bi <= edges.length`
   `ai != bi`
   There are no repeated edges.
   The given graph is connected.*

## gpt4 Reasoning

```markdown
The essential problem here is to find an edge that, when removed, converts the given graph into a tree. The graph initially was a tree but became a cyclic graph due to the addition of one extra edge. Since a tree is an acyclic connected graph, the added edge is the one that created a cycle. The task is to identify and return this edge, with a preference for the edge that appears last in the input array if multiple solutions exist.

### Step-by-Step Solution

1. **Understand Trees and Graphs**: A tree is a special type of graph that is connected and acyclic. Adding an extra edge to a tree inevitably creates a cycle because there was initially exactly one path between any two nodes. The added edge creates an alternative path, forming a loop.

2. **Identify the Cycle**: The problem can be solved by identifying the cycle that was introduced by the extra edge. Since the graph was a tree before adding the edge, only one cycle exists.

3. **Use Union-Find Algorithm**: A practical way to detect cycles in an undirected graph is by using the Union-Find algorithm (also known as Disjoint Set Union). This algorithm helps in determining if adding an edge creates a cycle, by checking if the two nodes connected by the edge are already in the same set (indicating they are connected in some way, hence adding this edge would create a cycle).

4. **Algorithm Steps**:
   - **Initialization**: Start by initializing all nodes as their own parents to indicate that they are in separate sets.
   - **Iterate Through Edges**: Go through each edge in the given graph.
     - For each edge, use the Find operation to check if the two nodes (vertices) of the edge are part of the same set.
     - If they are in the same set, it means adding this edge would form a cycle (or this edge is part of the existing cycle), making it the candidate for removal.
     - If they are not in the same set, use the Union operation to merge the sets, indicating that they are now connected by an edge.
   - **Edge to Remove**: The edge that forms a cycle (i.e., the nodes are already in the same set) is the one to remove. If multiple edges are found (theoretically, due to the way we iterate, this shouldn't happen in this problem as we stop at the first instance), the last such edge in the input order is the answer.

5. **Implementation Details**:
   - The Union-Find operations can be optimized using techniques like path compression and union by rank to improve efficiency.
   - Since the problem specifies to return the edge that occurs last in the input if multiple answers exist, we can simply iterate from the start and return the first edge we encounter that meets the criteria, as the input is already given in a specific order.

6. **Conclusion**: By using the Union-Find algorithm, we can efficiently identify and return the edge that, when removed, converts the cyclic graph back into a tree. This edge is essentially the one that introduces a cycle in the graph, making it no longer a tree.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0200
recall_1: 0.2500
recall_5: 0.2500
recall_10: 0.2500
recall_25: 0.2500
recall_50: 0.2500
recall_100: 0.5000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.3904
ndcg_cut_10: 0.3904
ndcg_cut_25: 0.3904
ndcg_cut_50: 0.3904
ndcg_cut_100: 0.4550
map_cut_1: 0.2500
map_cut_5: 0.2500
map_cut_10: 0.2500
map_cut_25: 0.2500
map_cut_50: 0.2500
map_cut_100: 0.2577
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_685.txt
> def findRedundantDirectedConnection(edges):<br>    """In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.<br><br>The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.<br><br>The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.<br><br>Return _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.<br><br>Example 1:<br><br>Input: edges = \[\[1,2\],\[1,3\],\[2,3\]\]<br>Output: \[2,3\]<br><br>Example 2:<br><br>Input: edges = \[\[1,2\],\[2,3\],\[3,4\],\[4,1\],\[1,5\]\]<br>Output: \[4,1\]<br><br>Constraints:<br><br>   `n == edges.length`<br>   `3 <= n <= 1000`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`"""<br><br>    parent = [0]  (len(edges) + 1)<br>    candidateA = candidateB = None<br><br>    for u, v in edges:<br>        if parent[v]  0:<br>            candidateA = [parent[v], v]<br>            candidateB = [u, v]<br>        else:<br>            parent[v] = u<br><br>    for i in range(1, len(edges) + 1):<br>        cycle = i<br>        steps = len(edges)<br>        while parent[cycle] != 0 and steps  0:<br>            cycle = parent[cycle]<br>            steps -= 1<br>        if steps == 0:<br>            if not candidateA:<br>                return [parent[i], i]<br>            else:<br>                return candidateA<br><br>    return candidateB

### DOC[2] (IRRELEVANT) leetcode/leetcode_2509.txt
> def length_of_cycle(n, queries):<br>    """You are given an integer `n`. There is a complete binary tree with `2n - 1` nodes. The root of that tree is the node with the value `1`, and every node with a value `val` in the range `[1, 2n - 1 - 1]` has two children where:<br><br>   The left node has the value `2  val`, and<br>   The right node has the value `2  val + 1`.<br><br>You are also given a 2D integer array `queries` of length `m`, where `queries[i] = [ai, bi]`. For each query, solve the following problem:<br><br>1.  Add an edge between the nodes with values `ai` and `bi`.<br>2.  Find the length of the cycle in the graph.<br>3.  Remove the added edge between nodes with values `ai` and `bi`.<br><br>Note that:<br><br>   A cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.<br>   The length of a cycle is the number of edges visited in the cycle.<br>   There could be multiple edges between two nodes in the tree after adding the edge of the query.<br><br>Return _an array_ `answer` _of length_ `m` _where_ `answer[i]` _is the answer to the_ `ith` _query._<br><br>Example 1:<br><br>Input: n = 3, queries = \[\[5,3\],\[4,7\],\[2,3\]\]<br>Output: \[4,5,3\]<br>Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.<br>- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes \[5,2,1,3\]. Thus answer to the first query is 4. We delete the added edge and process the next query.<br>- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes \[4,2,1,3,7\]. Thus answer to the second query is 5. We delete the added edge and process the next query.<br>- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes \[2,1,3\]. Thus answer to the third query is 3. We delete the added edge.<br><br>Example 2:<br><br>Input: n = 2, queries = \[\[1,2\]\]<br>Output: \[2\]<br>Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.<br>- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes \[2,1\]. Thus answer for the first query is 2. We delete the added edge.<br><br>Constraints:<br><br>   `2 <= n <= 30`<br>   `m == queries.length`<br>   `1 <= m <= 105`<br>   `queries[i].length == 2`<br>   `1 <= ai, bi <= 2n - 1`<br>   `ai != bi`"""<br><br>    result = []<br>    for A, B in queries:<br>        depth_A, depth_B = 0, 0<br>        while A != B:<br>            if A < B:<br>                A, B = B, A<br>            A = 1<br>            depth_A += 1<br>        result.append(depth_A + depth_B)<br>    return result

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_38648.txt
> def _validate_pending_children(self):<br>        """<br>        Validate the content of the pending_children set. Assert if an<br>        internal error is found.<br><br>        This function is used strictly for debugging the taskmaster by<br>        checking that no invariants are violated. It is not used in<br>        normal operation.<br><br>        The pending_children set is used to detect cycles in the<br>        dependency graph. We call a "pending child" a child that is<br>        found in the "pending" state when checking the dependencies of<br>        its parent node.<br><br>        A pending child can occur when the Taskmaster completes a loop<br>        through a cycle. For example, let's imagine a graph made of<br>        three nodes (A, B and C) making a cycle. The evaluation starts<br>        at node A. The Taskmaster first considers whether node A's<br>        child B is up-to-date. Then, recursively, node B needs to<br>        check whether node C is up-to-date. This leaves us with a<br>        dependency graph looking like::<br><br>                                          Next candidate \<br>                                                          \<br>            Node A (Pending) -- Node B(Pending) -- Node C (NoState)<br>                    ^                                     |<br>                    |                                     |<br>                    +-------------------------------------+<br><br>        Now, when the Taskmaster examines the Node C's child Node A,<br>        it finds that Node A is in the "pending" state. Therefore,<br>        Node A is a pending child of node C.<br><br>        Pending children indicate that the Taskmaster has potentially<br>        loop back through a cycle. We say potentially because it could<br>        also occur when a DAG is evaluated in parallel. For example,<br>        consider the following graph::<br><br>            Node A (Pending) -- Node B(Pending) -- Node C (Pending) -- ...<br>                    |                                     ^<br>                    |                                     |<br>                    +---------- Node D (NoState) --------+<br>                                      /<br>                      Next candidate /<br><br>        The Taskmaster first evaluates the nodes A, B, and C and<br>        starts building some children of node C. Assuming, that the<br>        maximum parallel level has not been reached, the Taskmaster<br>        will examine Node D. It will find that Node C is a pending<br>        child of Node D.<br><br>        In summary, evaluating a graph with a cycle will always<br>        involve a pending child at one point. A pending child might<br>        indicate either a cycle or a diamond-shaped DAG. Only a<br>        fraction of the nodes ends-up being a "pending child" of<br>        another node. This keeps the pending_children set small in<br>        practice.<br><br>        We can differentiate between the two cases if we wait until<br>        the end of the build. At this point, all the pending children<br>        nodes due to a diamond-shaped DAG will have been properly<br>        built (or will have failed to build). But, the pending<br>        children involved in a cycle will still be in the pending<br>        state.<br><br>        The taskmaster removes nodes from the pending_children set as<br>        soon as a pending_children node moves out of the pending<br>        state. This also helps to keep the pending_children set small.<br>        """<br><br>        for n in self.pending_children:<br>            assert n.state in (NODE_PENDING, NODE_EXECUTING), \<br>                (str(n), StateString[n.state])<br>            assert len(n.waiting_parents) != 0, (str(n), len(n.waiting_parents))<br>            for p in n.waiting_parents:<br>                assert p.ref_count  0, (str(n), str(p), p.ref_count)

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_287848.txt
> def explore_max_children_lp(self, G, tier, I, known_winners, stats, f_scc = 0):<br>        """<br>        Computes the maximal children of G when tier is added<br>        :param G: DiGraph, A directed graph<br>        :param tier: list of tuples which correspond to multiple edges with same max weight.<br>                    e.g. edges = [x for x in wmg2.keys() if wmg2[x] == max_weight]<br>        :param I: all nodes in G<br>        :param known_winners: PUT-winners found so far by RP<br>        :param stats: Stats object<br>        :param f_scc: set to 1 if the G and tier being considered are an SCC of the full graph due to SCC decomposition<br>        :return: set of graphs which correspond to maximum children of given parent: G<br>        """<br><br>        # self.output_graph(G)<br>        # self.output_graph(nx.DiGraph(tier))<br><br>        max_children = []<br>        cstack = []<br><br>        # print("start mc:", time.perf_counter() - self.BEGIN)<br><br>        hashtable = set()<br><br>        if self.debug_mode = 1:<br>            print("Exploring max children")<br>            print("G:", G.edges())<br>            print("Tier:", tier)<br>            print("Known winners:", known_winners)<br>            print("---------------------------")<br><br>        in_deg = G.in_degree()<br>        nodes_with_no_incoming = set()<br>        for x in in_deg:<br>            if x[1] == 0:<br>                nodes_with_no_incoming.add(x[0])<br>        for x in I:<br>            if x not in G.nodes():<br>                nodes_with_no_incoming.add(x)<br><br>        root = Node(value=(self.edges2string(G.edges(), I), self.edges2string(tier, I), nodes_with_no_incoming))<br>        cstack.append(root)<br><br>        END = self.BEGIN + self.TIMEOUT<br><br>        while cstack:<br>            node = cstack.pop()<br>            (G_str, T_str, no_incoming) = node.value<br><br>            if time.perf_counter()  END:<br>                print("TIMEOUT")<br>                return max_children<br><br>            # Check hash. Doesn't ever happen if the below hash is included<br>            hash_G = hash(G_str)<br>            if hash_G in hashtable:<br>                stats.num_hashes += 1<br>                print('hash')<br>                if self.debug_mode = 2:<br>                    print("hashed in hashtable")<br>                continue<br>            hashtable.add(hash_G)<br><br>            stats.num_nodes += 1<br><br>            G = nx.DiGraph(self.string2edges(G_str, I))<br>            T = self.string2edges(T_str, I)<br>            G.add_nodes_from(I)<br><br>            if self.debug_mode == 3:<br>                print("popped")<br>                print("G: ", G.edges())<br>                print("T: ", T)<br><br>            # goal state 2: if current G's possible winners is subset of known winners,<br>            # then directly ignore it.<br>            if no_incoming <= known_winners and not f_scc:<br>                stats.stop_condition_hits[2] += 1<br>                if self.debug_mode = 3:<br>                    print("MC goal state 2: pruned")<br>                continue<br><br>            # goal state 1: if there are no edges to be added, then add the G_<br>            if len(T) == 0:<br>                max_children.append(G.copy())<br>                if self.debug_mode = 2:<br>                    print("MC goal state 1: no more edges in tier")<br>                    print("max child: ", G.edges())<br>                continue<br><br>            # goal state 3: if current G has exactly one cand with in degree 0, it is a PUT-winner<br>            if len(no_incoming) == 1 and not f_scc:<br>                stats.stop_condition_hits[3] += 1<br>                if self.debug_mode = 2:<br>                    print("MC goal state 3: only one cand in degree 0")<br>                    print("max child:", G.edges())<br>                self.add_winners(G, I, known_winners, stats, no_incoming)<br>                continue<br><br>            # goal state 4: if union of current G and edges is acyclic,<br>            # then directly add it to the max_children_set<br>            Gc = G.copy()<br>            Gc.add_edges_from(T)<br>            if nx.is_directed_acyclic_graph(Gc):<br>                stats.stop_condition_hits[4] += 1<br><br>                hash_temp_G = hash(self.edges2string(Gc.edges(), I))<br>                if hash_temp_G not in hashtable:<br>                    hashtable.add(hash_temp_G)<br>                    max_children.append(Gc)<br><br>                    if self.debug_mode = 2:<br>                        print("MC goal state 4: G U T is acyclic")<br>                        print("max child:", Gc.edges())<br>                else:<br>                    stats.num_hashes += 1<br>                continue<br><br>            # Perform reductions every step:<br><br>            # Compute "bridge edges" which are not in any cycle<br>            Gc = G.copy()<br>            Gc.add_edges_from(T)<br>            scc = [list(g.edges()) for g in nx.strongly_connected_component_subgraphs(Gc, copy=True) if<br>                   len(g.edges()) != 0]<br>            bridges = set(Gc.edges()) - set(itertools.chain(scc))<br>            G.add_edges_from(bridges)<br>            T = list(set(T) - bridges)<br><br>            G_tc = nx.transitive_closure(G)<br><br>            # Remove "inconsistent edges" that cannot be added to G without causing cycle<br>            reverse_G = nx.DiGraph.reverse(G_tc)<br>            T = list(set(T) - set(reverse_G.edges()))<br><br>            # Remove "redundant edges": if there is already path from e[0] to e[1], can immediately add e<br>            redundant_edges = set()<br>            for e in T:<br>                if G_tc.has_edge(e[0], e[1]):<br>                    redundant_edges.add(e)<br>                    G.add_edges_from([e])<br>            stats.num_redundant_edges += len(redundant_edges)<br>            T = list(set(T) - redundant_edges)<br><br>            # Flag for whether adding any edge from T causes G to remain acyclic<br>            f_isAcyclic = 0<br><br>            children = dict()<br><br>            # Used to break ties<br>            index = 0<br>            T = sorted(T)<br>            for e in T:<br>                G.add_edges_from([e])<br>                Gc_str = self.edges2string(G.edges(), I)<br>                if hash(Gc_str) in hashtable:<br>                    f_isAcyclic = 1<br><br>                    stats.num_hashes += 1<br>                    G.remove_edges_from([e])<br>                    continue<br><br>                if not nx.has_path(G, source=e[1], target=e[0]):<br>                    f_isAcyclic = 1<br><br>                    Tc = copy.deepcopy(T)<br>                    Tc.remove(e)<br><br>                    # Remove the head of the edge if it had no incoming edges previously<br>                    no_incoming_c = no_incoming.copy()<br>                    no_incoming_c.discard(e[1])<br><br>                    child = Node(value=(Gc_str, self.edges2string(Tc, I), no_incoming_c))<br><br>                    priority = len(no_incoming_c - known_winners)<br><br>                    children[child] = (priority, index)<br>                    index = index + 1<br><br>                    if self.debug_mode == 3:<br>                        print("add new child with edge ", e, " and priority ", priority)<br><br>                G.remove_edges_from([e])<br><br>            children_items = sorted(children.items(), key=lambda x: (x[1][0], x[1][1]))<br>            sorted_children = [key for key, value in children_items]<br>            cstack += sorted_children<br><br>            # goal state 5: adding all edges in T individually cause G to be cyclic<br>            if f_isAcyclic == 0:<br>                max_children.append(G.copy())<br><br>                if self.debug_mode = 2:<br>                    print("MC goal state 5 - found max child")<br>                    print("max child: ", G.edges())<br>                continue<br><br>        if self.debug_mode = 1:<br>            print("finished exploring max children")<br>            print("num max children:", len(max_children))<br>            print("PUT-winners:", known_winners)<br><br>        return max_children

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_6387.txt
> def chu_liu_edmonds(length: int,<br>                    score_matrix: numpy.ndarray,<br>                    current_nodes: List[bool],<br>                    final_edges: Dict[int, int],<br>                    old_input: numpy.ndarray,<br>                    old_output: numpy.ndarray,<br>                    representatives: List[Set[int]]):<br>    """<br>    Applies the chu-liu-edmonds algorithm recursively<br>    to a graph with edge weights defined by score_matrix.<br><br>    Note that this function operates in place, so variables<br>    will be modified.<br><br>    Parameters<br>    ----------<br>    length : ``int``, required.<br>        The number of nodes.<br>    score_matrix : ``numpy.ndarray``, required.<br>        The score matrix representing the scores for pairs<br>        of nodes.<br>    current_nodes : ``List[bool]``, required.<br>        The nodes which are representatives in the graph.<br>        A representative at it's most basic represents a node,<br>        but as the algorithm progresses, individual nodes will<br>        represent collapsed cycles in the graph.<br>    final_edges: ``Dict[int, int]``, required.<br>        An empty dictionary which will be populated with the<br>        nodes which are connected in the maximum spanning tree.<br>    old_input: ``numpy.ndarray``, required.<br>    old_output: ``numpy.ndarray``, required.<br>    representatives : ``List[Set[int]]``, required.<br>        A list containing the nodes that a particular node<br>        is representing at this iteration in the graph.<br><br>    Returns<br>    -------<br>    Nothing - all variables are modified in place.<br><br>    """<br>    # Set the initial graph to be the greedy best one.<br>    parents = [-1]<br>    for node1 in range(1, length):<br>        parents.append(0)<br>        if current_nodes[node1]:<br>            max_score = score_matrix[0, node1]<br>            for node2 in range(1, length):<br>                if node2 == node1 or not current_nodes[node2]:<br>                    continue<br><br>                new_score = score_matrix[node2, node1]<br>                if new_score  max_score:<br>                    max_score = new_score<br>                    parents[node1] = node2<br><br>    # Check if this solution has a cycle.<br>    has_cycle, cycle = _find_cycle(parents, length, current_nodes)<br>    # If there are no cycles, find all edges and return.<br>    if not has_cycle:<br>        final_edges[0] = -1<br>        for node in range(1, length):<br>            if not current_nodes[node]:<br>                continue<br><br>            parent = old_input[parents[node], node]<br>            child = old_output[parents[node], node]<br>            final_edges[child] = parent<br>        return<br><br>    # Otherwise, we have a cycle so we need to remove an edge.<br>    # From here until the recursive call is the contraction stage of the algorithm.<br>    cycle_weight = 0.0<br>    # Find the weight of the cycle.<br>    index = 0<br>    for node in cycle:<br>        index += 1<br>        cycle_weight += score_matrix[parents[node], node]<br><br>    # For each node in the graph, find the maximum weight incoming<br>    # and outgoing edge into the cycle.<br>    cycle_representative = cycle[0]<br>    for node in range(length):<br>        if not current_nodes[node] or node in cycle:<br>            continue<br><br>        in_edge_weight = float("-inf")<br>        in_edge = -1<br>        out_edge_weight = float("-inf")<br>        out_edge = -1<br><br>        for node_in_cycle in cycle:<br>            if score_matrix[node_in_cycle, node]  in_edge_weight:<br>                in_edge_weight = score_matrix[node_in_cycle, node]<br>                in_edge = node_in_cycle<br><br>            # Add the new edge score to the cycle weight<br>            # and subtract the edge we're considering removing.<br>            score = (cycle_weight +<br>                     score_matrix[node, node_in_cycle] -<br>                     score_matrix[parents[node_in_cycle], node_in_cycle])<br><br>            if score  out_edge_weight:<br>                out_edge_weight = score<br>                out_edge = node_in_cycle<br><br>        score_matrix[cycle_representative, node] = in_edge_weight<br>        old_input[cycle_representative, node] = old_input[in_edge, node]<br>        old_output[cycle_representative, node] = old_output[in_edge, node]<br><br>        score_matrix[node, cycle_representative] = out_edge_weight<br>        old_output[node, cycle_representative] = old_output[node, out_edge]<br>        old_input[node, cycle_representative] = old_input[node, out_edge]<br><br>    # For the next recursive iteration, we want to consider the cycle as a<br>    # single node. Here we collapse the cycle into the first node in the<br>    # cycle (first node is arbitrary), set all the other nodes not be<br>    # considered in the next iteration. We also keep track of which<br>    # representatives we are considering this iteration because we need<br>    # them below to check if we're done.<br>    considered_representatives: List[Set[int]] = []<br>    for i, node_in_cycle in enumerate(cycle):<br>        considered_representatives.append(set())<br>        if i  0:<br>            # We need to consider at least one<br>            # node in the cycle, arbitrarily choose<br>            # the first.<br>            current_nodes[node_in_cycle] = False<br><br>        for node in representatives[node_in_cycle]:<br>            considered_representatives[i].add(node)<br>            if i  0:<br>                representatives[cycle_representative].add(node)<br><br>    chu_liu_edmonds(length, score_matrix, current_nodes, final_edges, old_input, old_output, representatives)<br><br>    # Expansion stage.<br>    # check each node in cycle, if one of its representatives<br>    # is a key in the final_edges, it is the one we need.<br>    found = False<br>    key_node = -1<br>    for i, node in enumerate(cycle):<br>        for cycle_rep in considered_representatives[i]:<br>            if cycle_rep in final_edges:<br>                key_node = node<br>                found = True<br>                break<br>        if found:<br>            break<br><br>    previous = parents[key_node]<br>    while previous != key_node:<br>        child = old_output[parents[previous], previous]<br>        parent = old_input[parents[previous], previous]<br>        final_edges[child] = parent<br>        previous = parents[previous]


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_685.txt
> def findRedundantDirectedConnection(edges):<br>    """In this problem, a rooted tree is a directed graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.<br><br>The given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.<br><br>The resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a directed edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.<br><br>Return _an edge that can be removed so that the resulting graph is a rooted tree of_ `n` _nodes_. If there are multiple answers, return the answer that occurs last in the given 2D-array.<br><br>Example 1:<br><br>Input: edges = \[\[1,2\],\[1,3\],\[2,3\]\]<br>Output: \[2,3\]<br><br>Example 2:<br><br>Input: edges = \[\[1,2\],\[2,3\],\[3,4\],\[4,1\],\[1,5\]\]<br>Output: \[4,1\]<br><br>Constraints:<br><br>   `n == edges.length`<br>   `3 <= n <= 1000`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`"""<br><br>    parent = [0]  (len(edges) + 1)<br>    candidateA = candidateB = None<br><br>    for u, v in edges:<br>        if parent[v]  0:<br>            candidateA = [parent[v], v]<br>            candidateB = [u, v]<br>        else:<br>            parent[v] = u<br><br>    for i in range(1, len(edges) + 1):<br>        cycle = i<br>        steps = len(edges)<br>        while parent[cycle] != 0 and steps  0:<br>            cycle = parent[cycle]<br>            steps -= 1<br>        if steps == 0:<br>            if not candidateA:<br>                return [parent[i], i]<br>            else:<br>                return candidateA<br><br>    return candidateB

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_721.txt
> from collections import defaultdict<br>    """Given a list of `accounts` where each element `accounts[i]` is a list of strings, where the first element `accounts[i][0]` is a name, and the rest of the elements are emails representing emails of the account.<br><br>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.<br><br>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.<br><br>Example 1:<br><br>Input: accounts = \[\[ "John ", "johnsmith@mail.com ", "john\_newyork@mail.com "\],\[ "John ", "johnsmith@mail.com ", "john00@mail.com "\],\[ "Mary ", "mary@mail.com "\],\[ "John ", "johnnybravo@mail.com "\]\]<br>Output: \[\[ "John ", "john00@mail.com ", "john\_newyork@mail.com ", "johnsmith@mail.com "\],\[ "Mary ", "mary@mail.com "\],\[ "John ", "johnnybravo@mail.com "\]\]<br>Explanation:<br>The first and second John's are the same person as they have the common email  "johnsmith@mail.com ".<br>The third John and Mary are different people as none of their email addresses are used by other accounts.<br>We could return these lists in any order, for example the answer \[\['Mary', 'mary@mail.com'\], \['John', 'johnnybravo@mail.com'\], <br>\['John', 'john00@mail.com', 'john\_newyork@mail.com', 'johnsmith@mail.com'\]\] would still be accepted.<br><br>Example 2:<br><br>Input: accounts = \[\[ "Gabe ", "Gabe0@m.co ", "Gabe3@m.co ", "Gabe1@m.co "\],\[ "Kevin ", "Kevin3@m.co ", "Kevin5@m.co ", "Kevin0@m.co "\],\[ "Ethan ", "Ethan5@m.co ", "Ethan4@m.co ", "Ethan0@m.co "\],\[ "Hanzo ", "Hanzo3@m.co ", "Hanzo1@m.co ", "Hanzo0@m.co "\],\[ "Fern ", "Fern5@m.co ", "Fern1@m.co ", "Fern0@m.co "\]\]<br>Output: \[\[ "Ethan ", "Ethan0@m.co ", "Ethan4@m.co ", "Ethan5@m.co "\],\[ "Gabe ", "Gabe0@m.co ", "Gabe1@m.co ", "Gabe3@m.co "\],\[ "Hanzo ", "Hanzo0@m.co ", "Hanzo1@m.co ", "Hanzo3@m.co "\],\[ "Kevin ", "Kevin0@m.co ", "Kevin3@m.co ", "Kevin5@m.co "\],\[ "Fern ", "Fern0@m.co ", "Fern1@m.co ", "Fern5@m.co "\]\]<br><br>Constraints:<br><br>   `1 <= accounts.length <= 1000`<br>   `2 <= accounts[i].length <= 10`<br>   `1 <= accounts[i][j].length <= 30`<br>   `accounts[i][0]` consists of English letters.<br>   `accounts[i][j] (for j  0)` is a valid email."""<br><br><br>def accountsMerge(accounts):<br>    def dfs(id, visited, merged_emails):<br>        if id in visited:<br>            return<br>        visited.add(id)<br>        for email in accounts[id][1:]:<br>            merged_emails.add(email)<br>            dfs(email_to_id[email], visited, merged_emails)<br><br>    email_to_id = {}<br>    for i, account in enumerate(accounts):<br>        for email in account[1:]:<br>            email_to_id[email] = i<br><br>    result = []<br>    visited = set()<br>    for i, account in enumerate(accounts):<br>        if i not in visited:<br>            merged_emails = set()<br>            dfs(i, visited, merged_emails)<br>            result.append([account[0]] + sorted(merged_emails))<br>    return result

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_2127.txt
> def max_invited(favorite):<br>    """A company is organizing a meeting and has a list of `n` employees, waiting to be invited. They have arranged for a large circular table, capable of seating any number of employees.<br><br>The employees are numbered from `0` to `n - 1`. Each employee has a favorite person and they will attend the meeting only if they can sit next to their favorite person at the table. The favorite person of an employee is not themself.<br><br>Given a 0-indexed integer array `favorite`, where `favorite[i]` denotes the favorite person of the `ith` employee, return _the maximum number of employees that can be invited to the meeting_.<br><br>Example 1:<br><br>Input: favorite = \[2,2,1,2\]<br>Output: 3<br>Explanation:<br>The above figure shows how the company can invite employees 0, 1, and 2, and seat them at the round table.<br>All employees cannot be invited because employee 2 cannot sit beside employees 0, 1, and 3, simultaneously.<br>Note that the company can also invite employees 1, 2, and 3, and give them their desired seats.<br>The maximum number of employees that can be invited to the meeting is 3. <br><br>Example 2:<br><br>Input: favorite = \[1,2,0\]<br>Output: 3<br>Explanation: <br>Each employee is the favorite person of at least one other employee, and the only way the company can invite them is if they invite every employee.<br>The seating arrangement will be the same as that in the figure given in example 1:<br>- Employee 0 will sit between employees 2 and 1.<br>- Employee 1 will sit between employees 0 and 2.<br>- Employee 2 will sit between employees 1 and 0.<br>The maximum number of employees that can be invited to the meeting is 3.<br><br>Example 3:<br><br>Input: favorite = \[3,0,1,4,1\]<br>Output: 4<br>Explanation:<br>The above figure shows how the company will invite employees 0, 1, 3, and 4, and seat them at the round table.<br>Employee 2 cannot be invited because the two spots next to their favorite employee 1 are taken.<br>So the company leaves them out of the meeting.<br>The maximum number of employees that can be invited to the meeting is 4.<br><br>Constraints:<br><br>   `n == favorite.length`<br>   `2 <= n <= 105`<br>   `0 <= favorite[i] <= n - 1`<br>   `favorite[i] != i`"""<br><br>    in_degree = [0]  len(favorite)<br>    for fav in favorite:<br>        in_degree[fav] += 1<br>    result = 0<br>    for degree in in_degree:<br>        result += max(degree - 1, 0)<br>    return min(result + 2, len(favorite))

### GROUND TRUTH 3, ranked 64, leetcode/leetcode_2608.txt
> from collections import deque<br>    """There is a bi-directional graph with `n` vertices, where each vertex is labeled from `0` to `n - 1`. The edges in the graph are represented by a given 2D integer array `edges`, where `edges[i] = [ui, vi]` denotes an edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.<br><br>Return _the length of the shortest cycle in the graph_. If no cycle exists, return `-1`.<br><br>A cycle is a path that starts and ends at the same node, and each edge in the path is used only once.<br><br>Example 1:<br><br>Input: n = 7, edges = \[\[0,1\],\[1,2\],\[2,0\],\[3,4\],\[4,5\],\[5,6\],\[6,3\]\]<br>Output: 3<br>Explanation: The cycle with the smallest length is : 0 - 1 - 2 - 0 <br><br>Example 2:<br><br>Input: n = 4, edges = \[\[0,1\],\[0,2\]\]<br>Output: -1<br>Explanation: There are no cycles in this graph.<br><br>Constraints:<br><br>   `2 <= n <= 1000`<br>   `1 <= edges.length <= 1000`<br>   `edges[i].length == 2`<br>   `0 <= ui, vi < n`<br>   `ui != vi`<br>   There are no repeated edges."""<br><br><br>def shortest_cycle_length(n, edges):<br>    graph = [[] for _ in range(n)]<br>    for u, v in edges:<br>        graph[u].append(v)<br>        graph[v].append(u)<br>        <br>    shortest_cycle = n + 1<br>    for start in range(n):<br>        dist = [n + 1]  n<br>        dist[start] = 0<br>        queue = deque([start])<br>        <br>        while queue:<br>            cur = queue.popleft()<br>            for neigh in graph[cur]:<br>                if dist[neigh] == n + 1:<br>                    dist[neigh] = dist[cur] + 1<br>                    queue.append(neigh)<br>                elif dist[neigh] = dist[cur] - 1:<br>                    shortest_cycle = min(shortest_cycle, dist[cur] + dist[neigh] + 1)<br>                    <br>    return -1 if shortest_cycle == n + 1 else shortest_cycle
