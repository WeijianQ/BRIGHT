# Query `90`

## Original Question

*You are in a city that consists of `n` intersections numbered from `0` to `n - 1` with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.

You are given an integer `n` and a 2D integer array `roads` where `roads[i] = [ui, vi, timei]` means that there is a road between intersections `ui` and `vi` that takes `timei` minutes to travel. You want to know in how many ways you can travel from intersection `0` to intersection `n - 1` in the shortest amount of time.

Return _the number of ways you can arrive at your destination in the shortest amount of time_. Since the answer may be large, return it modulo `109 + 7`.

Example 1:

Input: n = 7, roads = \[\[0,6,7\],\[0,1,2\],\[1,2,3\],\[1,3,3\],\[6,3,3\],\[3,5,1\],\[6,5,1\],\[2,5,1\],\[0,4,5\],\[4,6,2\]\]
Output: 4
Explanation: The shortest amount of time it takes to go from intersection 0 to intersection 6 is 7 minutes.
The four ways to get there in 7 minutes are:
- 0 ➝ 6
- 0 ➝ 4 ➝ 6
- 0 ➝ 1 ➝ 2 ➝ 5 ➝ 6
- 0 ➝ 1 ➝ 3 ➝ 5 ➝ 6

Example 2:

Input: n = 2, roads = \[\[1,0,10\]\]
Output: 1
Explanation: There is only one way to go from intersection 0 to intersection 1, and it takes 10 minutes.

Constraints:

   `1 <= n <= 200`
   `n - 1 <= roads.length <= n  (n - 1) / 2`
   `roads[i].length == 3`
   `0 <= ui, vi <= n - 1`
   `1 <= timei <= 109`
   `ui != vi`
   There is at most one road connecting any two intersections.
   You can reach any intersection from any other intersection.*

## gpt4 Reasoning

```markdown
The essential problem here is to find the number of shortest paths from a source node (intersection 0) to a destination node (intersection n-1) in a graph. This graph is represented by `n` nodes and a list of edges (`roads`) where each edge has an associated time to traverse it. The goal is to compute these paths in such a way that the total traversal time is minimized, and then count how many such minimal paths exist.

To tackle this problem, we can use a combination of Dijkstra's algorithm to find the shortest path from the source to all other nodes in terms of time, and dynamic programming (DP) to count the number of ways to reach each node in the shortest amount of time. Here's a step-by-step approach:

1. **Initialization**: Create a graph representation from the `roads` input. This can be an adjacency list where each node points to its neighbors and the corresponding travel times. Also, initialize two arrays, `times` and `ways`, both of size `n`. `times[i]` will store the shortest time to reach node `i` from the source, and `ways[i]` will store the number of shortest ways to reach node `i`. Set all values in `times` to infinity (or a very large number) except for the source node (`times[0] = 0`), and set `ways[0] = 1` since there's only one way to start from the source.

2. **Finding Shortest Paths (Dijkstra's Algorithm)**: Use Dijkstra's algorithm to find the shortest paths from the source node to all other nodes. For each node, update the `times` array with the minimum time needed to reach it. A priority queue can be used to efficiently select the next node to process based on the current shortest time.

3. **Counting Ways**: While running Dijkstra's algorithm, whenever you find a shorter path to a node `v` through a node `u`, you should also update the number of ways to reach `v`. If the new path to `v` is shorter than the previously known path, set `ways[v] = ways[u]` because all ways to reach `u` are now ways to reach `v`. If the new path to `v` has the same length as the previously known shortest path, add `ways[u]` to `ways[v]` (`ways[v] += ways[u]`), since you've found an additional set of shortest paths to `v` via `u`.

4. **Handling Edge Cases**: Since the number of ways can be very large, every time you update `ways[v]`, take the modulo `10^9 + 7` to keep the number within the limits required by the problem statement.

5. **Return the Result**: After processing all nodes, the `ways[n-1]` will contain the number of shortest ways to reach the destination node from the source. This value, modulo `10^9 + 7`, is the final answer.

**Key Points**:
- Efficient graph representation and traversal are crucial.
- Dijkstra's algorithm is modified not just to find the shortest path but also to count the number of such paths.
- Dynamic programming is used to update the count of paths based on the paths leading to the current node.
- Modulo operation ensures the result stays within the required bounds.

This approach efficiently combines graph theory and dynamic programming to solve the problem of finding and counting the shortest paths in a weighted graph.
```

### Metrics

```
recip_rank: 0.0588
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.3333
recall_50: 0.3333
recall_100: 0.3333
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.1125
ndcg_cut_50: 0.1125
ndcg_cut_100: 0.1125
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0196
map_cut_50: 0.0196
map_cut_100: 0.0196
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_310734.txt
> def distance_wei(G):<br>    '''<br>    The distance matrix contains lengths of shortest paths between all<br>    pairs of nodes. An entry (u,v) represents the length of shortest path<br>    from node u to node v. The average shortest path length is the<br>    characteristic path length of the network.<br><br>    Parameters<br>    ----------<br>    L : NxN np.ndarray<br>        Directed/undirected connection-length matrix.<br>        NB L is not the adjacency matrix. See below.<br><br>    Returns<br>    -------<br>    D : NxN np.ndarray<br>        distance (shortest weighted path) matrix<br>    B : NxN np.ndarray<br>        matrix of number of edges in shortest weighted path<br><br>    Notes<br>    -----<br>       The input matrix must be a connection-length matrix, typically<br>    obtained via a mapping from weight to length. For instance, in a<br>    weighted correlation network higher correlations are more naturally<br>    interpreted as shorter distances and the input matrix should<br>    consequently be some inverse of the connectivity matrix.<br>       The number of edges in shortest weighted paths may in general<br>    exceed the number of edges in shortest binary paths (i.e. shortest<br>    paths computed on the binarized connectivity matrix), because shortest<br>    weighted paths have the minimal weighted distance, but not necessarily<br>    the minimal number of edges.<br>       Lengths between disconnected nodes are set to Inf.<br>       Lengths on the main diagonal are set to 0.<br><br>    Algorithm: Dijkstra's algorithm.<br>    '''<br>    n = len(G)<br>    D = np.zeros((n, n))  # distance matrix<br>    D[np.logical_not(np.eye(n))] = np.inf<br>    B = np.zeros((n, n))  # number of edges matrix<br><br>    for u in range(n):<br>        # distance permanence (true is temporary)<br>        S = np.ones((n,), dtype=bool)<br>        G1 = G.copy()<br>        V = [u]<br>        while True:<br>            S[V] = 0  # distance u-V is now permanent<br>            G1[:, V] = 0  # no in-edges as already shortest<br>            for v in V:<br>                W, = np.where(G1[v, :])  # neighbors of shortest nodes<br><br>                td = np.array(<br>                    [D[u, W].flatten(), (D[u, v] + G1[v, W]).flatten()])<br>                d = np.min(td, axis=0)<br>                wi = np.argmin(td, axis=0)<br><br>                D[u, W] = d  # smallest of old/new path lengths<br>                ind = W[np.where(wi == 1)]  # indices of lengthened paths<br>                # increment nr_edges for lengthened paths<br>                B[u, ind] = B[u, v] + 1<br><br>            if D[u, S].size == 0:  # all nodes reached<br>                break<br>            minD = np.min(D[u, S])<br>            if np.isinf(minD):  # some nodes cannot be reached<br>                break<br><br>            V, = np.where(D[u, :] == minD)<br><br>    return D, B

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_327644.txt
> def top_path(sources, sinks, net_flux):<br>    """<br>    Use the Dijkstra algorithm for finding the shortest path<br>    connecting a set of source states from a set of sink states.<br><br>    Parameters<br>    ----------<br>    sources : array_like, int<br>        One-dimensional list of nodes to define the source states.<br>    sinks : array_like, int<br>        One-dimensional list of nodes to define the sink states.<br>    net_flux : np.ndarray, shape = [n_states, n_states]<br>        Net flux of the MSM<br><br>    Returns<br>    -------<br>    top_path : np.ndarray<br>        Array corresponding to the top path between sources and<br>        sinks. It is an array of states visited along the path.<br>    flux : float<br>        Flux traveling through this path -- this is equal to the<br>        minimum flux over edges in the path.<br><br>    See Also<br>    --------<br>    msmbuilder.tpt.paths : function for calculating many high<br>        flux paths through a network.<br><br>    References<br>    ----------<br>    .. [1] Weinan, E. and Vanden-Eijnden, E. Towards a theory of<br>           transition paths. J. Stat. Phys. 123, 503-523 (2006).<br>    .. [2] Metzner, P., Schutte, C. & Vanden-Eijnden, E.<br>           Transition path theory for Markov jump processes.<br>           Multiscale Model. Simul. 7, 1192-1219 (2009).<br>    .. [3] Berezhkovskii, A., Hummer, G. & Szabo, A. Reactive<br>           flux and folding pathways in network models of<br>           coarse-grained protein dynamics. J. Chem. Phys.<br>           130, 205102 (2009).<br>    .. [4] Dijkstra, E. W. A Note on Two Problems in Connexion with Graphs.<br>           Numeriche Mathematik 1, 269-271 (1959).<br>    .. [5] Noe, Frank, et al. "Constructing the equilibrium ensemble of folding<br>           pathways from short off-equilibrium simulations." PNAS 106.45 (2009):<br>           19011-19016.<br>    """<br>    sources = np.array(sources, dtype=np.int).reshape((-1,))<br>    sinks = np.array(sinks, dtype=np.int).reshape((-1,))<br><br>    n_states = net_flux.shape[0]<br><br>    queue = list(sources)<br>    # nodes to check (the "queue")<br>    # going to use list.pop method so I can't keep it as an array<br><br>    visited = np.zeros(n_states).astype(np.bool)<br>    # have we already checked this node?<br><br>    previous_node = np.ones(n_states).astype(np.int)  -1<br>    # what node was found before finding this one<br><br>    min_fluxes = np.ones(n_states)  -1  np.inf<br>    # what is the flux of the highest flux path<br>    # from this node to the source set.<br><br>    min_fluxes[sources] = np.inf<br>    # source states are connected to the source<br>    # so this distance is zero which means the flux is infinite<br><br>    while len(queue)  0: # iterate until there's nothing to check anymore<br><br>        test_node = queue.pop(min_fluxes[queue].argmax())<br>        # find the node in the queue that has the<br>        # highest flux path to it from the source set<br><br>        visited[test_node] = True<br><br>        if np.all(visited[sinks]):<br>            # if we've visited all of the sink states, then we just have to choose<br>            # the path that goes to the sink state that is closest to the source<br>            break<br><br>        # if test_node in sinks: # I think we want to break ... or are there paths we still<br>        # need to check?<br>        # continue<br>        # I think if sinks is more than one state we have to check everything<br><br>        # now update the distances for each neighbor of the test_node:<br>        neighbors = np.where(net_flux[test_node, :]  0)[0]<br>        if len(neighbors) == 0:<br>            continue<br><br>        new_fluxes = net_flux[test_node, neighbors].flatten()<br>        # flux from test_node to each neighbor<br><br>        new_fluxes[np.where(new_fluxes  min_fluxes[test_node])] = min_fluxes[test_node]<br>        # previous step to get to test_node was lower flux, so that is still the path flux<br><br>        ind = np.where((1 - visited[neighbors]) & (new_fluxes  min_fluxes[neighbors]))<br>        min_fluxes[neighbors[ind]] = new_fluxes[ind]<br><br>        previous_node[neighbors[ind]] = test_node<br>        # each of these neighbors came from this test_node<br>        # we don't want to update the nodes that have already been visited<br><br>        queue.extend(neighbors[ind])<br><br>    top_path = []<br>    # populate the path in reverse<br>    top_path.append(int(sinks[min_fluxes[sinks].argmax()]))<br>    # find the closest sink state<br><br>    while previous_node[top_path[-1]] != -1:<br>        top_path.append(previous_node[top_path[-1]])<br><br>    return np.array(top_path[::-1]), min_fluxes[top_path[0]]

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_54952.txt
> def dijkstra(graph, start, end=None):<br>    """<br>    Dijkstra's algorithm for shortest paths<br><br>    `David Eppstein, UC Irvine, 4 April 2002 <http://www.ics.uci.edu/~eppstein/161/python/`_<br><br>    `Python Cookbook Recipe <http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/119466`_<br><br>    Find shortest paths from the  start node to all nodes nearer than or equal to the end node.<br><br>    Dijkstra's algorithm is only guaranteed to work correctly when all edge lengths are positive.<br>    This code does not verify this property for all edges (only the edges examined until the end<br>    vertex is reached), but will correctly compute shortest paths even for some graphs with negative<br>    edges, and will raise an exception if it discovers that a negative edge has caused it to make a mistake.<br><br>    Adapted to altgraph by Istvan Albert, Pennsylvania State University - June, 9 2004<br><br>    """<br>    D = {}    # dictionary of final distances<br>    P = {}    # dictionary of predecessors<br>    Q = _priorityDictionary()    # estimated distances of non-final vertices<br>    Q[start] = 0<br><br>    for v in Q:<br>        D[v] = Q[v]<br>        if v == end: break<br><br>        for w in graph.out_nbrs(v):<br>            edge_id  = graph.edge_by_node(v,w)<br>            vwLength = D[v] + graph.edge_data(edge_id)<br>            if w in D:<br>                if vwLength < D[w]:<br>                    raise GraphError("Dijkstra: found better path to already-final vertex")<br>            elif w not in Q or vwLength < Q[w]:<br>                Q[w] = vwLength<br>                P[w] = v<br><br>    return (D,P)

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_310737.txt
> def efficiency_wei(Gw, local=False):<br>    '''<br>    The global efficiency is the average of inverse shortest path length,<br>    and is inversely related to the characteristic path length.<br><br>    The local efficiency is the global efficiency computed on the<br>    neighborhood of the node, and is related to the clustering coefficient.<br><br>    Parameters<br>    ----------<br>    W : NxN np.ndarray<br>        undirected weighted connection matrix<br>        (all weights in W must be between 0 and 1)<br>    local : bool<br>        If True, computes local efficiency instead of global efficiency.<br>        Default value = False.<br><br>    Returns<br>    -------<br>    Eglob : float<br>        global efficiency, only if local=False<br>    Eloc : Nx1 np.ndarray<br>        local efficiency, only if local=True<br><br>    Notes<br>    -----<br>       The  efficiency is computed using an auxiliary connection-length<br>    matrix L, defined as L_ij = 1/W_ij for all nonzero L_ij; This has an<br>    intuitive interpretation, as higher connection weights intuitively<br>    correspond to shorter lengths.<br>       The weighted local efficiency broadly parallels the weighted<br>    clustering coefficient of Onnela et al. (2005) and distinguishes the<br>    influence of different paths based on connection weights of the<br>    corresponding neighbors to the node in question. In other words, a path<br>    between two neighbors with strong connections to the node in question<br>    contributes more to the local efficiency than a path between two weakly<br>    connected neighbors. Note that this weighted variant of the local<br>    efficiency is hence not a strict generalization of the binary variant.<br><br>    Algorithm:  Dijkstra's algorithm<br>    '''<br>    def distance_inv_wei(G):<br>        n = len(G)<br>        D = np.zeros((n, n))  # distance matrix<br>        D[np.logical_not(np.eye(n))] = np.inf<br><br>        for u in range(n):<br>            # distance permanence (true is temporary)<br>            S = np.ones((n,), dtype=bool)<br>            G1 = G.copy()<br>            V = [u]<br>            while True:<br>                S[V] = 0  # distance u-V is now permanent<br>                G1[:, V] = 0  # no in-edges as already shortest<br>                for v in V:<br>                    W, = np.where(G1[v, :])  # neighbors of smallest nodes<br>                    td = np.array(<br>                        [D[u, W].flatten(), (D[u, v] + G1[v, W]).flatten()])<br>                    D[u, W] = np.min(td, axis=0)<br><br>                if D[u, S].size == 0:  # all nodes reached<br>                    break<br>                minD = np.min(D[u, S])<br>                if np.isinf(minD):  # some nodes cannot be reached<br>                    break<br>                V, = np.where(D[u, :] == minD)<br><br>        np.fill_diagonal(D, 1)<br>        D = 1 / D<br>        np.fill_diagonal(D, 0)<br>        return D<br><br>    n = len(Gw)<br>    Gl = invert(Gw, copy=True)  # connection length matrix<br>    A = np.array((Gw != 0), dtype=int)<br>    if local:<br>        E = np.zeros((n,))  # local efficiency<br>        for u in range(n):<br>            # V,=np.where(Gw[u,:])		#neighbors<br>            # k=len(V)					#degree<br>            # if k=2:					#degree must be at least 2<br>            #	e=(distance_inv_wei(Gl[V].T[V])np.outer(Gw[V,u],Gw[u,V]))1/3<br>            #	E[u]=np.sum(e)/(kk-k)<br><br>            # find pairs of neighbors<br>            V, = np.where(np.logical_or(Gw[u, :], Gw[:, u].T))<br>            # symmetrized vector of weights<br>            sw = cuberoot(Gw[u, V]) + cuberoot(Gw[V, u].T)<br>            # inverse distance matrix<br>            e = distance_inv_wei(Gl[np.ix_(V, V)])<br>            # symmetrized inverse distance matrix<br>            se = cuberoot(e) + cuberoot(e.T)<br><br>            numer = np.sum(np.outer(sw.T, sw)  se) / 2<br>            if numer != 0:<br>                # symmetrized adjacency vector<br>                sa = A[u, V] + A[V, u].T<br>                denom = np.sum(sa)2 - np.sum(sa  sa)<br>                # print numer,denom<br>                E[u] = numer / denom  # local efficiency<br><br>    else:<br>        e = distance_inv_wei(Gl)<br>        E = np.sum(e) / (n  n - n)<br>    return E

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_327647.txt
> def paths(sources, sinks, net_flux, remove_path='subtract',<br>          num_paths=np.inf, flux_cutoff=(1-1E-10)):<br>    """<br>    Get the top N paths by iteratively performing Dijkstra's<br>    algorithm.<br><br>    Parameters<br>    ----------<br>    sources : array_like, int<br>        One-dimensional list of nodes to define the source states.<br>    sinks : array_like, int<br>        One-dimensional list of nodes to define the sink states.<br>    net_flux : np.ndarray<br>        Net flux of the MSM<br>    remove_path : str or callable, optional<br>        Function for removing a path from the net flux matrix.<br>        (if str, one of {'subtract', 'bottleneck'})<br>        See note below for more details.<br>    num_paths : int, optional<br>        Number of paths to find<br>    flux_cutoff : float, optional<br>        Quit looking for paths once the explained flux is greater<br>        than this cutoff (as a percentage of the total).<br><br>    Returns<br>    -------<br>    paths : list<br>        List of paths. Each item is an array of nodes visited<br>        in the path.<br>    fluxes : np.ndarray, shape = [n_paths,]<br>        Flux of each path returned.<br><br>    Notes<br>    -----<br>    The Dijkstra algorithm only allows for computing the<br>    single top flux pathway through the net flux matrix. If<br>    we want many paths, there are many ways of finding the<br>    second highest flux pathway.<br><br>    The algorithm proceeds as follows:<br><br>    1. Using the Djikstra algorithm, find the highest flux<br>       pathway from the sources to the sink states<br>    2. Remove that pathway from the net flux matrix by<br>       some criterion<br>    3. Repeat (1) with the modified net flux matrix<br><br>    Currently, there are two schemes for step (2):<br><br>    - 'subtract' : Remove the path by subtracting the flux<br>      of the path from every edge in the path. This was<br>      suggested by Metzner, Schutte, and Vanden-Eijnden.<br>      Transition Path Theory for Markov Jump Processes.<br>      Multiscale Model. Simul. 7, 1192-1219 (2009).<br>    - 'bottleneck' : Remove the path by only removing<br>      the edge that corresponds to the bottleneck of the<br>      path.<br><br>    If a new scheme is desired, the user may pass a function<br>    that takes the net_flux and the path to remove and returns<br>    the new net flux matrix.<br><br>    See Also<br>    --------<br>    msmbuilder.tpt.top_path : function for computing the single<br>        highest flux pathway through a network.<br><br>    References<br>    ----------<br>    .. [1] Weinan, E. and Vanden-Eijnden, E. Towards a theory of<br>           transition paths. J. Stat. Phys. 123, 503-523 (2006).<br>    .. [2] Metzner, P., Schutte, C. & Vanden-Eijnden, E.<br>           Transition path theory for Markov jump processes.<br>           Multiscale Model. Simul. 7, 1192-1219 (2009).<br>    .. [3] Berezhkovskii, A., Hummer, G. & Szabo, A. Reactive<br>           flux and folding pathways in network models of<br>           coarse-grained protein dynamics. J. Chem. Phys.<br>           130, 205102 (2009).<br>    .. [4] Dijkstra, E. W. A Note on Two Problems in Connexion with Graphs.<br>           Numeriche Mathematik 1, 269-271 (1959).<br>    .. [5] Noe, Frank, et al. "Constructing the equilibrium ensemble of folding<br>           pathways from short off-equilibrium simulations." PNAS 106.45 (2009):<br>           19011-19016.<br>    """<br><br>    if not callable(remove_path):<br>        if remove_path == 'subtract':<br>            remove_path = _subtract_path_flux<br>        elif remove_path == 'bottleneck':<br>            remove_path = _remove_bottleneck<br>        else:<br>            raise ValueError("remove_path_func (%s) must be a callable or one of ['subtract', 'bottleneck']" % str(remove_path))<br><br>    net_flux = copy.copy(net_flux)<br><br>    paths = []<br>    fluxes = []<br><br>    total_flux = net_flux[sources, :].sum()<br>    # total flux is the total flux coming from the sources (or going into the sinks)<br><br>    not_done = True<br>    counter = 0<br>    expl_flux = 0.0<br>    while not_done:<br>        path, flux = top_path(sources, sinks, net_flux)<br>        if np.isinf(flux):<br>            break<br><br>        paths.append(path)<br>        fluxes.append(flux)<br><br>        expl_flux += flux / total_flux<br>        counter += 1<br><br>        if counter = num_paths or expl_flux = flux_cutoff:<br>            break<br><br>        # modify the net_flux matrix<br>        net_flux = remove_path(net_flux, path)<br><br>    fluxes = np.array(fluxes)<br><br>    return paths, fluxes


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_797.txt
> from collections import defaultdict<br>    """Given a directed acyclic graph (DAG) of `n` nodes labeled from `0` to `n - 1`, find all possible paths from node `0` to node `n - 1` and return them in any order.<br><br>The graph is given as follows: `graph[i]` is a list of all nodes you can visit from node `i` (i.e., there is a directed edge from node `i` to node `graph[i][j]`).<br><br>Example 1:<br><br>Input: graph = \[\[1,2\],\[3\],\[3\],\[\]\]<br>Output: \[\[0,1,3\],\[0,2,3\]\]<br>Explanation: There are two paths: 0 - 1 - 3 and 0 - 2 - 3.<br><br>Example 2:<br><br>Input: graph = \[\[4,3,1\],\[3,2,4\],\[3\],\[4\],\[\]\]<br>Output: \[\[0,4\],\[0,3,4\],\[0,1,3,4\],\[0,1,2,3,4\],\[0,1,4\]\]<br><br>Constraints:<br><br>   `n == graph.length`<br>   `2 <= n <= 15`<br>   `0 <= graph[i][j] < n`<br>   `graph[i][j] != i` (i.e., there will be no self-loops).<br>   All the elements of `graph[i]` are unique.<br>   The input graph is guaranteed to be a DAG."""<br><br>def numRabbits(answers):<br>    count = defaultdict(int)<br>    res = 0<br>    for a in answers:<br>        count[a] += 1<br>        if count[a] == 1:<br>            res += (a + 1)<br>        elif count[a]  a + 1:<br>            count[a] = 1<br>            res += (a + 1)<br>    return res

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_1514.txt
> def min_start_value(nums):<br>    """You are given an undirected weighted graph of `n` nodes (0-indexed), represented by an edge list where `edges[i] = [a, b]` is an undirected edge connecting the nodes `a` and `b` with a probability of success of traversing that edge `succProb[i]`.<br><br>Given two nodes `start` and `end`, find the path with the maximum probability of success to go from `start` to `end` and return its success probability.<br><br>If there is no path from `start` to `end`, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.<br><br>Example 1:<br><br>Input: n = 3, edges = \[\[0,1\],\[1,2\],\[0,2\]\], succProb = \[0.5,0.5,0.2\], start = 0, end = 2<br>Output: 0.25000<br>Explanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 \ 0.5 = 0.25.<br><br>Example 2:<br><br>Input: n = 3, edges = \[\[0,1\],\[1,2\],\[0,2\]\], succProb = \[0.5,0.5,0.3\], start = 0, end = 2<br>Output: 0.30000<br><br>Example 3:<br><br>Input: n = 3, edges = \[\[0,1\]\], succProb = \[0.5\], start = 0, end = 2<br>Output: 0.00000<br>Explanation: There is no path between 0 and 2.<br><br>Constraints:<br><br>   `2 <= n <= 10^4`<br>   `0 <= start, end < n`<br>   `start != end`<br>   `0 <= a, b < n`<br>   `a != b`<br>   `0 <= succProb.length == edges.length <= 210^4`<br>   `0 <= succProb[i] <= 1`<br>   There is at most one edge between every two nodes."""<br><br>    min_sum, sum = 0, 0<br>    for num in nums:<br>        sum += num<br>        min_sum = min(min_sum, sum)<br>    return 1 - min_sum

### GROUND TRUTH 2, ranked 16, leetcode/leetcode_2045.txt
> from collections import defaultdict, deque<br>    """A city is represented as a bi-directional connected graph with `n` vertices where each vertex is labeled from `1` to `n` (inclusive). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is `time` minutes.<br><br>Each vertex has a traffic signal which changes its color from green to red and vice versa every `change` minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.<br><br>The second minimum value is defined as the smallest value strictly larger than the minimum value.<br><br>   For example the second minimum value of `[2, 3, 4]` is `3`, and the second minimum value of `[2, 2, 4]` is `4`.<br><br>Given `n`, `edges`, `time`, and `change`, return _the second minimum time it will take to go from vertex_ `1` _to vertex_ `n`.<br><br>Notes:<br><br>   You can go through any vertex any number of times, including `1` and `n`.<br>   You can assume that when the journey starts, all signals have just turned green.<br><br>Example 1:<br><br>       <br><br>Input: n = 5, edges = \[\[1,2\],\[1,3\],\[1,4\],\[3,4\],\[4,5\]\], time = 3, change = 5<br>Output: 13<br>Explanation:<br>The figure on the left shows the given graph.<br>The blue path in the figure on the right is the minimum time path.<br>The time taken is:<br>- Start at 1, time elapsed=0<br>- 1 - 4: 3 minutes, time elapsed=3<br>- 4 - 5: 3 minutes, time elapsed=6<br>Hence the minimum time needed is 6 minutes.<br><br>The red path shows the path to get the second minimum time.<br>- Start at 1, time elapsed=0<br>- 1 - 3: 3 minutes, time elapsed=3<br>- 3 - 4: 3 minutes, time elapsed=6<br>- Wait at 4 for 4 minutes, time elapsed=10<br>- 4 - 5: 3 minutes, time elapsed=13<br>Hence the second minimum time is 13 minutes.      <br><br>Example 2:<br><br>Input: n = 2, edges = \[\[1,2\]\], time = 3, change = 2<br>Output: 11<br>Explanation:<br>The minimum time path is 1 - 2 with time = 3 minutes.<br>The second minimum time path is 1 - 2 - 1 - 2 with time = 11 minutes.<br><br>Constraints:<br><br>   `2 <= n <= 104`<br>   `n - 1 <= edges.length <= min(2  104, n  (n - 1) / 2)`<br>   `edges[i].length == 2`<br>   `1 <= ui, vi <= n`<br>   `ui != vi`<br>   There are no duplicate edges.<br>   Each vertex can be reached directly or indirectly from every other vertex.<br>   `1 <= time, change <= 103`"""<br><br><br>def secondMinimum(n, edges, time, change):<br>    graph = defaultdict(list)<br>    <br>    for u, v in edges:<br>        graph[u].append(v)<br>        graph[v].append(u)<br><br>    dist = [float('inf')]  (n + 1)<br>    dist2 = [float('inf')]  (n + 1)<br>    dist[1] = 0<br><br>    q = deque([1])<br><br>    while q:<br>        cur = q.popleft()<br><br>        nextDist = dist[cur] + time<br>        waitTime = change if (nextDist // change) % 2 == 1 else 0<br>        nextDist += waitTime<br><br>        for next in graph[cur]:<br>            if nextDist < dist[next]:<br>                nextDist, dist[next] = dist[next], nextDist<br>                q.append(next)<br>            if nextDist < dist2[next]:<br>                nextDist, dist2[next] = dist2[next], nextDist<br>                q.append(next)<br><br>    return dist2[n]
