# Query `91`

## Original Question

*You are given a 0-indexed integer array `nums`, where `nums[i]` represents the score of the `ith` student. You are also given an integer `k`.

Pick the scores of any `k` students from the array so that the difference between the highest and the lowest of the `k` scores is minimized.

Return _the minimum possible difference_.

Example 1:

Input: nums = \[90\], k = 1
Output: 0
Explanation: There is one way to pick score(s) of one student:
- \[90\]. The difference between the highest and lowest score is 90 - 90 = 0.
The minimum possible difference is 0.

Example 2:

Input: nums = \[9,4,1,7\], k = 2
Output: 2
Explanation: There are six ways to pick score(s) of two students:
- \[9,4,1,7\]. The difference between the highest and lowest score is 9 - 4 = 5.
- \[9,4,1,7\]. The difference between the highest and lowest score is 9 - 1 = 8.
- \[9,4,1,7\]. The difference between the highest and lowest score is 9 - 7 = 2.
- \[9,4,1,7\]. The difference between the highest and lowest score is 4 - 1 = 3.
- \[9,4,1,7\]. The difference between the highest and lowest score is 7 - 4 = 3.
- \[9,4,1,7\]. The difference between the highest and lowest score is 7 - 1 = 6.
The minimum possible difference is 2.

Constraints:

   `1 <= k <= nums.length <= 1000`
   `0 <= nums[i] <= 105`*

## gpt4 Reasoning

```markdown
The essential problem here is to find the minimum possible difference between the highest and lowest scores among any k students selected from the array `nums`. To achieve this, we need to follow a series of logical steps and utilize specific information from the problem statement. Here's a step-by-step breakdown of how to approach this problem:

### Step 1: Sort the Array
First, sort the array `nums` in non-decreasing order. Sorting is crucial because it lines up all the scores in a sequence where each element is greater than or equal to the previous one. This arrangement makes it easier to find the minimum difference between the highest and lowest scores in any subset of k elements because those elements will be consecutive in the sorted array.

### Step 2: Initialize Variables
After sorting, we need to initialize a variable to keep track of the minimum difference we find. Let's call it `minDiff` and set it to a very high value initially (e.g., `Integer.MAX_VALUE`), assuming the scores do not exceed the range of an integer.

### Step 3: Iterate Through the Array
Now, iterate through the sorted array with a loop. The idea is to look at every possible subset of k elements in this sorted array and calculate the difference between the highest and lowest scores in each subset. Since the array is sorted, for any subset of k elements, the first element will be the lowest score, and the last element will be the highest score.

### Step 4: Calculate Differences and Update `minDiff`
During each iteration of the loop, calculate the difference between the element at the current index + (k-1) and the current element (i.e., `nums[i + k - 1] - nums[i]`). This difference represents the spread (i.e., the difference between the highest and lowest scores) of the current subset of k students. If this difference is smaller than the current `minDiff`, update `minDiff` with this new difference.

### Step 5: Loop Termination Condition
The loop should continue until it's no longer possible to pick k elements. This happens when `i + k - 1` reaches the last index of the array, which is `nums.length - 1`. Therefore, the loop should run while `i <= nums.length - k`.

### Step 6: Return the Result
After the loop finishes, `minDiff` will hold the minimum difference between the highest and lowest scores among any k students. Return `minDiff`.

### Conclusion
This approach leverages sorting to bring potential candidates (scores) into a sequence where checking for the minimum difference between any k elements becomes straightforward. By iterating through the sorted array and calculating the differences between possible subsets of k elements, we efficiently find and return the minimum possible difference.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_5702.txt
> def beam_search(symbols_to_logits_fn,<br>                initial_ids,<br>                beam_size,<br>                decode_length,<br>                vocab_size,<br>                alpha,<br>                states=None,<br>                eos_id=EOS_ID,<br>                stop_early=True,<br>                use_tpu=False,<br>                use_top_k_with_unique=True):<br>  """Beam search with length penalties.<br><br>  Requires a function that can take the currently decoded symbols and return<br>  the logits for the next symbol. The implementation is inspired by<br>  https://arxiv.org/abs/1609.08144.<br><br>  When running, the beam search steps can be visualized by using tfdbg to watch<br>  the operations generating the output ids for each beam step.  These operations<br>  have the pattern:<br>    (alive|finished)_topk_(seq,scores)<br><br>  Operations marked `alive` represent the new beam sequences that will be<br>  processed in the next step.  Operations marked `finished` represent the<br>  completed beam sequences, which may be padded with 0s if no beams finished.<br><br>  Operations marked `seq` store the full beam sequence for the time step.<br>  Operations marked `scores` store the sequence's final log scores.<br><br>  The beam search steps will be processed sequentially in order, so when<br>  capturing observed from these operations, tensors, clients can make<br>  assumptions about which step is being recorded.<br><br>  WARNING: Assumes 2nd dimension of tensors in `states` and not invariant, this<br>  means that the shape of the 2nd dimension of these tensors will not be<br>  available (i.e. set to None) inside symbols_to_logits_fn.<br><br>  Args:<br>    symbols_to_logits_fn: Interface to the model, to provide logits.<br>        Shoud take [batch_size, decoded_ids] and return [batch_size, vocab_size]<br>    initial_ids: Ids to start off the decoding, this will be the first thing<br>        handed to symbols_to_logits_fn (after expanding to beam size)<br>        [batch_size]<br>    beam_size: Size of the beam.<br>    decode_length: Number of steps to decode for.<br>    vocab_size: Size of the vocab, must equal the size of the logits returned by<br>        symbols_to_logits_fn<br>    alpha: alpha for length penalty.<br>    states: dict (possibly nested) of decoding states.<br>    eos_id: ID for end of sentence.<br>    stop_early: a boolean - stop once best sequence is provably determined.<br>    use_tpu: A bool, whether to do beam search on TPU.<br>    use_top_k_with_unique: bool, whether to use a fast (but decreased precision)<br>      top_k during TPU beam search.<br><br>  Returns:<br>    Tuple of<br>    (decoded beams [batch_size, beam_size, decode_length]<br>     decoding probabilities [batch_size, beam_size])<br>  """<br>  batch_size = common_layers.shape_list(initial_ids)[0]<br><br>  # Assume initial_ids are prob 1.0<br>  initial_log_probs = tf.constant([[0.] + [-INF]  (beam_size - 1)])<br>  # Expand to beam_size (batch_size, beam_size)<br>  alive_log_probs = tf.tile(initial_log_probs, [batch_size, 1])<br><br>  # Expand each batch and state to beam_size<br>  alive_seq = _expand_to_beam_size(initial_ids, beam_size)<br>  alive_seq = tf.expand_dims(alive_seq, axis=2)  # (batch_size, beam_size, 1)<br>  if use_tpu:<br>    alive_seq = tf.tile(alive_seq, [1, 1, decode_length + 1])<br>  if states:<br>    states = nest.map_structure(<br>        lambda state: _expand_to_beam_size(state, beam_size), states)<br>  else:<br>    states = {}<br><br>  # Finished will keep track of all the sequences that have finished so far<br>  # Finished log probs will be negative infinity in the beginning<br>  # finished_flags will keep track of booleans<br>  finished_seq = tf.zeros(common_layers.shape_list(alive_seq), tf.int32)<br>  # Setting the scores of the initial to negative infinity.<br>  finished_scores = tf.ones([batch_size, beam_size])  -INF<br>  finished_flags = tf.zeros([batch_size, beam_size], tf.bool)<br><br>  def grow_finished(finished_seq, finished_scores, finished_flags, curr_seq,<br>                    curr_scores, curr_finished):<br>    """Given sequences and scores, will gather the top k=beam size sequences.<br><br>    Args:<br>      finished_seq: Current finished sequences.<br>        [batch_size, beam_size, current_decoded_length]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br>      finished_flags: finished bools for each of these sequences.<br>        [batch_size, beam_size]<br>      curr_seq: current topk sequence that has been grown by one position.<br>        [batch_size, beam_size, current_decoded_length]<br>      curr_scores: scores for each of these sequences. [batch_size, beam_size]<br>      curr_finished: Finished flags for each of these sequences.<br>        [batch_size, beam_size]<br>    Returns:<br>      Tuple of<br>        (Topk sequences based on scores,<br>         log probs of these sequences,<br>         Finished flags of these sequences)<br>    """<br>    if not use_tpu:<br>      # First append a column of 0'ids to finished to make the same length with<br>      # finished scores<br>      finished_seq = tf.concat(<br>          [finished_seq,<br>           tf.zeros([batch_size, beam_size, 1], tf.int32)], axis=2)<br><br>    # Set the scores of the unfinished seq in curr_seq to large negative<br>    # values<br>    curr_scores += (1. - tf.to_float(curr_finished))  -INF<br>    # concatenating the sequences and scores along beam axis<br>    curr_finished_seq = tf.concat([finished_seq, curr_seq], axis=1)<br>    curr_finished_scores = tf.concat([finished_scores, curr_scores], axis=1)<br>    curr_finished_flags = tf.concat([finished_flags, curr_finished], axis=1)<br>    return compute_topk_scores_and_seq(<br>        curr_finished_seq,<br>        curr_finished_scores,<br>        curr_finished_scores,<br>        curr_finished_flags,<br>        beam_size,<br>        batch_size,<br>        "grow_finished",<br>        use_tpu=use_tpu,<br>        use_top_k_with_unique=use_top_k_with_unique)<br><br>  def grow_alive(curr_seq, curr_scores, curr_log_probs, curr_finished, states):<br>    """Given sequences and scores, will gather the top k=beam size sequences.<br><br>    Args:<br>      curr_seq: current topk sequence that has been grown by one position.<br>        [batch_size, beam_size, i+1]<br>      curr_scores: scores for each of these sequences. [batch_size, beam_size]<br>      curr_log_probs: log probs for each of these sequences.<br>        [batch_size, beam_size]<br>      curr_finished: Finished flags for each of these sequences.<br>        [batch_size, beam_size]<br>      states: dict (possibly nested) of decoding states.<br>    Returns:<br>      Tuple of<br>        (Topk sequences based on scores,<br>         log probs of these sequences,<br>         Finished flags of these sequences)<br>    """<br>    # Set the scores of the finished seq in curr_seq to large negative<br>    # values<br>    curr_scores += tf.to_float(curr_finished)  -INF<br>    return compute_topk_scores_and_seq(curr_seq, curr_scores, curr_log_probs,<br>                                       curr_finished, beam_size, batch_size,<br>                                       "grow_alive", states, use_tpu=use_tpu)<br><br>  def grow_topk(i, alive_seq, alive_log_probs, states):<br>    r"""Inner beam search loop.<br><br>    This function takes the current alive sequences, and grows them to topk<br>    sequences where k = 2beam. We use 2beam because, we could have beam_size<br>    number of sequences that might hit <EOS and there will be no alive<br>    sequences to continue. With 2beam_size, this will not happen. This relies<br>    on the assumption the vocab size is  beam size. If this is true, we'll<br>    have at least beam_size non <EOS extensions if we extract the next top<br>    2beam words.<br>    Length penalty is given by = (5+len(decode)/6) ^ -\alpha. Pls refer to<br>    https://arxiv.org/abs/1609.08144.<br><br>    Args:<br>      i: loop index<br>      alive_seq: Topk sequences decoded so far [batch_size, beam_size, i+1]<br>      alive_log_probs: probabilities of these sequences. [batch_size, beam_size]<br>      states: dict (possibly nested) of decoding states.<br>    Returns:<br>      Tuple of<br>        (Topk sequences extended by the next word,<br>         The log probs of these sequences,<br>         The scores with length penalty of these sequences,<br>         Flags indicating which of these sequences have finished decoding,<br>         dict of transformed decoding states)<br>    """<br>    # Get the logits for all the possible next symbols<br>    if use_tpu and states:<br>      flat_ids = tf.reshape(<br>          tf.slice(alive_seq, [0, 0, i], [batch_size, beam_size, 1]),<br>          [batch_size  beam_size, -1])<br>    else:<br>      flat_ids = tf.reshape(alive_seq, [batch_size  beam_size, -1])<br><br>    # (batch_size  beam_size, decoded_length)<br>    if states:<br>      flat_states = nest.map_structure(_merge_beam_dim, states)<br>      flat_logits, flat_states = symbols_to_logits_fn(flat_ids, i, flat_states)<br>      states = nest.map_structure(<br>          lambda t: _unmerge_beam_dim(t, batch_size, beam_size), flat_states)<br>    elif use_tpu:<br>      flat_logits = symbols_to_logits_fn(flat_ids, i)<br>    else:<br>      flat_logits = symbols_to_logits_fn(flat_ids)<br><br>    logits = tf.reshape(flat_logits, [batch_size, beam_size, -1])<br><br>    # Convert logits to normalized log probs<br>    candidate_log_probs = common_layers.log_prob_from_logits(logits)<br><br>    # Multiply the probabilities by the current probabilities of the beam.<br>    # (batch_size, beam_size, vocab_size) + (batch_size, beam_size, 1)<br>    log_probs = candidate_log_probs + tf.expand_dims(alive_log_probs, axis=2)<br><br>    length_penalty = tf.pow(((5. + tf.to_float(i + 1)) / 6.), alpha)<br><br>    curr_scores = log_probs / length_penalty<br>    # Flatten out (beam_size, vocab_size) probs in to a list of possibilities<br>    flat_curr_scores = tf.reshape(curr_scores, [-1, beam_size  vocab_size])<br><br>    if use_tpu and use_top_k_with_unique:<br>      topk_scores, topk_ids = top_k_with_unique(<br>          flat_curr_scores, k=beam_size  2)<br>    else:<br>      topk_scores, topk_ids = tf.nn.top_k(flat_curr_scores, k=beam_size  2)<br><br>    # Recovering the log probs because we will need to send them back<br>    topk_log_probs = topk_scores  length_penalty<br><br>    # Work out what beam the top probs are in.<br>    topk_beam_index = topk_ids // vocab_size<br>    topk_ids %= vocab_size  # Unflatten the ids<br><br>    if not use_tpu:<br>      # The next three steps are to create coordinates for tf.gather_nd to pull<br>      # out the correct sequences from id's that we need to grow.<br>      # We will also use the coordinates to gather the booleans of the beam<br>      # items that survived.<br>      batch_pos = compute_batch_indices(batch_size, beam_size  2)<br><br>      # top beams will give us the actual coordinates to do the gather.<br>      # stacking will create a tensor of dimension batch  beam  2, where the<br>      # last dimension contains the i,j gathering coordinates.<br>      topk_coordinates = tf.stack([batch_pos, topk_beam_index], axis=2)<br><br>      # Gather up the most probable 2beams both for the ids and<br>      # finished_in_alive bools<br>      topk_seq = tf.gather_nd(alive_seq, topk_coordinates)<br>      if states:<br>        states = nest.map_structure(<br>            lambda state: tf.gather_nd(state, topk_coordinates), states)<br><br>      # Append the most probable alive<br>      topk_seq = tf.concat([topk_seq, tf.expand_dims(topk_ids, axis=2)], axis=2)<br>    else:<br>      # Gather up the most probable 2beams both for the ids and<br>      # finished_in_alive bools<br>      topk_seq = fast_tpu_gather(alive_seq, topk_beam_index)<br><br>      if states:<br>        states = nest.map_structure(<br>            lambda state: fast_tpu_gather(state, topk_beam_index), states)<br><br>      # Update the most probable alive<br>      topk_seq = tf.transpose(topk_seq, perm=[2, 0, 1])<br>      topk_seq = inplace_ops.alias_inplace_update(topk_seq, i + 1, topk_ids)<br>      topk_seq = tf.transpose(topk_seq, perm=[1, 2, 0])<br><br>    topk_finished = tf.equal(topk_ids, eos_id)<br><br>    return topk_seq, topk_log_probs, topk_scores, topk_finished, states<br><br>  def inner_loop(i, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>                 finished_flags, states):<br>    """Inner beam search loop.<br><br>    There are three groups of tensors, alive, finished, and topk.<br>    The alive group contains information about the current alive sequences<br>    The topk group contains information about alive + topk current decoded words<br>    the finished group contains information about finished sentences, that is,<br>    the ones that have decoded to <EOS. These are what we return.<br>    The general beam search algorithm is as follows:<br>    While we haven't terminated (pls look at termination condition)<br>      1. Grow the current alive to get beam2 topk sequences<br>      2. Among the topk, keep the top beam_size ones that haven't reached EOS<br>      into alive<br>      3. Among the topk, keep the top beam_size ones have reached EOS into<br>      finished<br>    Repeat<br>    To make things simple with using fixed size tensors, we will end<br>    up inserting unfinished sequences into finished in the beginning. To stop<br>    that we add -ve INF to the score of the unfinished sequence so that when a<br>    true finished sequence does appear, it will have a higher score than all the<br>    unfinished ones.<br><br>    Args:<br>      i: loop index<br>      alive_seq: Topk sequences decoded so far [batch_size, beam_size, i+1]<br>      alive_log_probs: probabilities of the beams. [batch_size, beam_size]<br>      finished_seq: Current finished sequences.<br>        [batch_size, beam_size, i+1]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br>      finished_flags: finished bools for each of these sequences.<br>        [batch_size, beam_size]<br>      states: dict (possibly nested) of decoding states.<br><br>    Returns:<br>      Tuple of<br>        (Incremented loop index<br>         New alive sequences,<br>         Log probs of the alive sequences,<br>         New finished sequences,<br>         Scores of the new finished sequences,<br>         Flags indicating which sequence in finished as reached EOS,<br>         dict of final decoding states)<br>    """<br><br>    # Each inner loop, we carry out three steps:<br>    # 1. Get the current topk items.<br>    # 2. Extract the ones that have finished and haven't finished<br>    # 3. Recompute the contents of finished based on scores.<br>    topk_seq, topk_log_probs, topk_scores, topk_finished, states = grow_topk(<br>        i, alive_seq, alive_log_probs, states)<br>    alive_seq, alive_log_probs, _, states = grow_alive(<br>        topk_seq, topk_scores, topk_log_probs, topk_finished, states)<br>    finished_seq, finished_scores, finished_flags, _ = grow_finished(<br>        finished_seq, finished_scores, finished_flags, topk_seq, topk_scores,<br>        topk_finished)<br><br>    return (i + 1, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>            finished_flags, states)<br><br>  def _is_finished(i, unused_alive_seq, alive_log_probs, unused_finished_seq,<br>                   finished_scores, unused_finished_in_finished, unused_states):<br>    """Checking termination condition.<br><br>    We terminate when we decoded up to decode_length or the lowest scoring item<br>    in finished has a greater score that the highest prob item in alive divided<br>    by the max length penalty<br><br>    Args:<br>      i: loop index<br>      alive_log_probs: probabilities of the beams. [batch_size, beam_size]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br><br>    Returns:<br>      Bool.<br>    """<br>    max_length_penalty = tf.pow(((5. + tf.to_float(decode_length)) / 6.), alpha)<br>    # The best possible score of the most likely alive sequence.<br>    lower_bound_alive_scores = alive_log_probs[:, 0] / max_length_penalty<br><br>    if not stop_early:<br>      # by considering the min score (in the top N beams) we ensure that<br>      # the decoder will keep decoding until there is at least one beam<br>      # (in the top N) that can be improved (w.r.t. the alive beams).<br>      # any unfinished beam will have score -INF - thus the min<br>      # will always be -INF if there is at least one unfinished beam -<br>      # which means the bound_is_met condition cannot be true in this case.<br>      lowest_score_of_finished_in_finished = tf.reduce_min(finished_scores)<br>    else:<br>      # by taking the max score we only care about the first beam;<br>      # as soon as this first beam cannot be beaten from the alive beams<br>      # the beam decoder can stop.<br>      # similarly to the above, if the top beam is not completed, its<br>      # finished_score is -INF, thus it will not activate the<br>      # bound_is_met condition. (i.e., decoder will keep going on).<br>      # note we need to find the max for every sequence eparately - so, we need<br>      # to keep the batch dimension (see axis=1)<br>      lowest_score_of_finished_in_finished = tf.reduce_max(finished_scores,<br>                                                           axis=1)<br><br>    bound_is_met = tf.reduce_all(<br>        tf.greater(lowest_score_of_finished_in_finished,<br>                   lower_bound_alive_scores))<br><br>    return tf.logical_and(<br>        tf.less(i, decode_length), tf.logical_not(bound_is_met))<br><br>  inner_shape = tf.TensorShape([None, None, None])<br>  if use_tpu:<br>    inner_shape = tf.TensorShape([batch_size, beam_size, decode_length + 1])<br>  if use_tpu:<br>    state_struc = nest.map_structure(lambda state: state.get_shape(), states)<br>  else:<br>    state_struc = nest.map_structure(get_state_shape_invariants, states)<br>  (_, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>   finished_flags, states) = tf.while_loop(<br>       _is_finished,<br>       inner_loop, [<br>           tf.constant(0), alive_seq, alive_log_probs, finished_seq,<br>           finished_scores, finished_flags, states<br>       ],<br>       shape_invariants=[<br>           tf.TensorShape([]),<br>           inner_shape,<br>           alive_log_probs.get_shape(),<br>           inner_shape,<br>           finished_scores.get_shape(),<br>           finished_flags.get_shape(),<br>           state_struc<br>       ],<br>       parallel_iterations=1,<br>       back_prop=False)<br><br>  alive_seq.set_shape((None, beam_size, None))<br>  finished_seq.set_shape((None, beam_size, None))<br><br>  # Accounting for corner case: It's possible that no sequence in alive for a<br>  # particular batch item ever reached EOS. In that case, we should just copy<br>  # the contents of alive for that batch item. tf.reduce_any(finished_flags, 1)<br>  # if 0, means that no sequence for that batch index had reached EOS. We need<br>  # to do the same for the scores as well.<br>  finished_seq = tf.where(<br>      tf.reduce_any(finished_flags, 1), finished_seq, alive_seq)<br>  finished_scores = tf.where(<br>      tf.reduce_any(finished_flags, 1), finished_scores, alive_log_probs)<br>  return finished_seq, finished_scores, states

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_103349.txt
> def beam_search(logits_fn,<br>                initial_ids,<br>                alpha,<br>                states=None,<br>                eos_id=EOS_ID,<br>                stop_early=True,<br>                decode_length=None,<br>                use_tpu=True,<br>                dtype=tf.float32,<br>                layout=None,<br>                mesh_shape=None,<br>                num_prefilter=2):<br>  """Beam search with length penalties.<br><br>  Requires a function that can take the currently decoded symbols and return<br>  the logits for the next symbol. The implementation is inspired by<br>  https://arxiv.org/abs/1609.08144.<br><br>  When running, the beam search steps can be visualized by using tfdbg to watch<br>  the operations generating the output ids for each beam step.  These operations<br>  have the pattern:<br>    (alive|finished)_topk_(seq,scores)<br><br>  Operations marked `alive` represent the new beam sequences that will be<br>  processed in the next step.  Operations marked `finished` represent the<br>  completed beam sequences, which may be padded with 0s if no beams finished.<br><br>  Operations marked `seq` store the full beam sequence for the time step.<br>  Operations marked `scores` store the sequence's final log scores.<br><br>  The beam search steps will be processed sequentially in order, so when<br>  capturing observed from these operations, tensors, clients can make<br>  assumptions about which step is being recorded.<br><br>  num_prefilter is a theoretically lossy shortcut around slow performance of<br>  top_k on TPU on large Tensors and large k.  This option should be removed once<br>  better top_k implementations on TPU are avialable.  If num_prefilter is set to<br>  a nonzero value, then at each step we first compute the top num_prefilter<br>  sequences per beam and then compute the top k sequences overall from among<br>  those.  Empirically, there seems to be no quality difference in setting<br>  num_prefilter to 2.<br><br>  Args:<br>    logits_fn: Interface to the model, to provide logits.<br>        Should take:<br>          step_num - mtf Scalar<br>          ids - mtf Tensor with shape [batch, beam, length]<br>        Should return:<br>          logits - [batch, beam, vocab_size], dtype=dtype<br>    initial_ids: a mtf.Tensor with shape [batch_dim, beam_dim, length_dim])<br>    alpha: alpha for length penalty.<br>    states: list of mtf.Tensor<br>    eos_id: ID for end of sentence.<br>    stop_early: a boolean - stop once best sequence is provably determined.<br>    decode_length: a mtf Scalar of dtype tf.int32 - maximum length of decodes<br>    use_tpu: a boolean<br>    dtype: a tf.dtype<br>    layout: an optional string<br>    mesh_shape: an optional string<br>    num_prefilter: an optional integer<br>  Returns:<br>    Tuple of<br>    (decoded beams [batch, beam, length]<br>     decoding probabilities [batch, beam_size])<br>  """<br>  batch_dim, beam_dim, length_dim = initial_ids.shape.dims<br>  batch_and_beam_dim = mtf.Dimension(<br>      batch_dim.name, batch_dim.size  beam_dim.size)<br>  mesh = initial_ids.mesh<br><br>  batch_by_beam = mtf.Shape([batch_dim, beam_dim])<br>  initial_log_probs = mtf.broadcast(<br>      mtf.one_hot(<br>          mtf.constant(mesh, 0, dtype=tf.int32),<br>          beam_dim,<br>          on_value=0.0,<br>          off_value=-INF,<br>          dtype=dtype),<br>      batch_by_beam)<br><br>  length_scalar = mtf.constant(mesh, length_dim.size, dtype=tf.int32)<br>  if decode_length is None:<br>    decode_length = length_scalar<br>  else:<br>    decode_length = mtf.minimum(decode_length, length_scalar)<br><br>  alive_log_probs = initial_log_probs<br>  alive_seq = initial_ids<br><br>  # Finished will keep track of all the sequences that have finished so far<br>  # Finished log probs will be negative infinity in the beginning<br>  # finished_flags will keep track of booleans<br>  finished_seq = initial_ids<br>  finished_scores = mtf.constant(mesh, -INF, batch_by_beam, dtype=dtype)<br><br>  # Setting the scores of the initial to negative infinity.<br>  finished_flags = mtf.constant(mesh, False, batch_by_beam, tf.bool)<br><br>  def grow_finished(finished_seq, finished_scores, finished_flags, curr_seq,<br>                    curr_scores, curr_finished):<br>    """Given sequences and scores, will gather the top k=beam size sequences.<br><br>    Args:<br>      finished_seq: Current finished sequences.<br>        [batch, beam, length]<br>      finished_scores: scores for each of these sequences.<br>        [batch, beam]<br>      finished_flags: finished bools for each of these sequences.<br>        [batch, beam]<br>      curr_seq: current topk sequence that has been grown by one position.<br>        [batch, beam, length]<br>      curr_scores: scores for each of these sequences. [batch, beam]<br>      curr_finished: Finished flags for each of these sequences.<br>        [batch, beam]<br>    Returns:<br>      Tuple of<br>        (Topk sequences based on scores,<br>         log probs of these sequences,<br>         Finished flags of these sequences,<br>         None (no states))<br>    """<br><br>    # Set the scores of the unfinished seq in curr_seq to large negative<br>    # values<br>    curr_scores += (1. - mtf.cast(curr_finished, curr_scores.dtype))  -INF<br>    unused_batch_dim, beam_dim, unused_length_dim = finished_seq.shape.dims<br>    # concatenating the sequences and scores along beam axis<br>    def _my_concat(a, b):<br>      a = mtf.rename_dimension(a, "beam", "triple_beam")<br>      b = mtf.rename_dimension(b, "double_beam", "triple_beam")<br>      return mtf.concat([a, b], "triple_beam")<br><br>    curr_finished_seq = _my_concat(finished_seq, curr_seq)<br>    curr_finished_scores = _my_concat(finished_scores, curr_scores)<br>    curr_finished_flags = _my_concat(finished_flags, curr_finished)<br>    return compute_topk_scores_and_seq(<br>        curr_finished_seq, curr_finished_scores, curr_finished_scores,<br>        curr_finished_flags, beam_dim, "grow_finished")<br><br>  def grow_alive(curr_seq, curr_scores, curr_log_probs, curr_finished):<br>    """Given sequences and scores, will gather the top k=beam size sequences.<br><br>    Args:<br>      curr_seq: current topk sequence that has been grown by one position.<br>        [batch, beam, length]<br>      curr_scores: scores for each of these sequences. [batch_size, beam_size]<br>      curr_log_probs: log probs for each of these sequences.<br>        [batch, beam]<br>      curr_finished: Finished flags for each of these sequences.<br>        [batch, beam]<br>    Returns:<br>      Tuple of<br>        (Topk sequences based on scores,<br>         log probs of these sequences,<br>         Finished flags of these sequences)<br>    """<br>    # Set the scores of the finished seq in curr_seq to large negative<br>    # values<br>    curr_scores += mtf.cast(curr_finished, curr_scores.dtype)  -INF<br>    return compute_topk_scores_and_seq(curr_seq, curr_scores, curr_log_probs,<br>                                       curr_finished, beam_dim,<br>                                       "grow_alive")<br><br>  def grow_topk(i, alive_seq, alive_log_probs, states=None):<br>    r"""Inner beam search loop.<br><br>    This function takes the current alive sequences, and grows them to topk<br>    sequences where k = 2beam. We use 2beam because, we could have beam_size<br>    number of sequences that might hit <EOS and there will be no alive<br>    sequences to continue. With 2beam_size, this will not happen. This relies<br>    on the assumption the vocab size is  beam size. If this is true, we'll<br>    have at least beam_size non <EOS extensions if we extract the next top<br>    2beam words.<br>    Length penalty is given by = (5+len(decode)/6) ^ -\alpha. Pls refer to<br>    https://arxiv.org/abs/1609.08144.<br><br>    Args:<br>      i: loop index<br>      alive_seq: Topk sequences decoded so far [batch, beam, length]<br>      alive_log_probs: probabilities of these sequences. [batch, beam]<br>      states: optional list of mtf.Tensor<br>    Returns:<br>      Tuple of<br>        (Topk sequences extended by the next word,<br>         The log probs of these sequences,<br>         The scores with length penalty of these sequences,<br>         Flags indicating which of these sequences have finished decoding,<br>         list of transformed decoding states)<br>    """<br>    logits, new_states = logits_fn(i, alive_seq, states)<br>    batch_dim, beam_dim, vocab_dim = logits.shape.dims<br><br>    # Convert logits to normalized log probs<br>    candidate_log_probs = mtf.log_softmax(logits, vocab_dim)<br><br>    # Multiply the probabilities by the current probabilities of the beam.<br>    # (batch_size, beam_size, vocab_size) + (batch_size, beam_size, 1)<br>    log_probs = candidate_log_probs + alive_log_probs<br><br>    length_penalty = mtf.pow(((5. + mtf.cast(i + 1, logits.dtype)) / 6.), alpha)<br><br>    # scores have shape [batch, beam, vocab]<br>    curr_scores = log_probs / length_penalty<br><br>    # We find the top 2k sequences to make sure we get k alive sequences.<br>    #<br>    # TODO(noam): This is inefficient.  We should separately compute the k<br>    # finished sequences (previously alive sequences + EOS), and the top k new<br>    # alive sequences.<br>    double_beam = mtf.Dimension("double_beam", beam_dim.size  2)<br><br>    if use_tpu and layout is not None and mesh_shape is not None:<br>      # Do some partial top-k-ing first locally to avoid communication.<br>      # We reshape the logits from:<br>      #   [batch, beam, vocab] to<br>      #   [batch, beam, major_vocab, minor_vocab]<br>      # We first reduce (locally) across the minor_vocab dimension.  This makes<br>      # the thing we need to broadcast smaller.<br>      # This also enables our shortcut of only picking the top num_prefilter<br>      #   sequences per beam per major_vocab in the first pass.<br>      major_vocab_size = mtf.tensor_dim_to_mesh_dim_size(<br>          layout, mesh_shape, vocab_dim)<br>      major_vocab = mtf.Dimension(vocab_dim.name, major_vocab_size)<br>      minor_vocab = mtf.Dimension(<br>          "minor_vocab", vocab_dim.size // major_vocab_size)<br>      curr_scores = mtf.reshape(<br>          curr_scores, [batch_dim, beam_dim, major_vocab, minor_vocab])<br>      prefilter = mtf.Dimension("prefilter", num_prefilter or double_beam.size)<br>      # shape = [batch_dim, beam_dim, major_vocab, prefilter]<br>      top_minor_vocab_ids, top_scores = mtf.top_k(<br>          curr_scores, reduced_dim=minor_vocab, new_dim=prefilter)<br>      combined = mtf.Dimension(<br>          "combined", beam_dim.size  major_vocab.size  prefilter.size)<br>      top_scores = mtf.reshape(top_scores, [batch_dim, combined])<br>      top_minor_vocab_ids = mtf.reshape(<br>          top_minor_vocab_ids, [batch_dim, combined])<br>      # shpae = [batch_dim, double_beam]<br>      # ids are indices representing (beam, major_vocab, prefilter)<br>      top_combined_ids, top_scores = mtf.top_k(<br>          top_scores, reduced_dim=combined, new_dim=double_beam)<br>      top_minor_vocab_ids = mtf.gather(<br>          top_minor_vocab_ids, top_combined_ids, combined,<br>          output_shape=[batch_dim, double_beam])<br>      top_beam_index = top_combined_ids // (major_vocab.size  prefilter.size)<br>      top_combined_ids -= top_beam_index  (major_vocab.size  prefilter.size)<br>      top_major_vocab_ids = top_combined_ids // prefilter.size<br>      top_combined_ids -= top_major_vocab_ids  prefilter.size<br>      top_ids = top_major_vocab_ids  minor_vocab.size + top_minor_vocab_ids<br>    else:<br>      beam_and_vocab_dim = mtf.Dimension(<br>          "beam_and_vocab", beam_dim.size  vocab_dim.size)<br>      flat_shape = mtf.Shape([batch_dim, beam_and_vocab_dim])<br>      # Flatten out (beam_size, vocab_size) probs into a list of possibilities<br>      flat_curr_scores = mtf.reshape(<br>          curr_scores, flat_shape, name="flatten_scores")<br>      top_ids, top_scores = mtf.top_k(<br>          flat_curr_scores, reduced_dim=beam_and_vocab_dim, new_dim=double_beam)<br>      # Work out what beam the top probs are in.<br>      top_beam_index = top_ids // vocab_dim.size<br>      top_ids %= vocab_dim.size  # Unflatten the ids<br><br>    # Recovering the log probs because we will need to send them back<br>    top_log_probs = top_scores  length_penalty<br><br>    selector = mtf.one_hot(top_beam_index, beam_dim, dtype=tf.float32)<br><br>    def my_gather(tensor):<br>      return mtf.gather(<br>          tensor, top_beam_index, beam_dim,<br>          output_shape=mtf.Shape(<br>              [double_beam if d == beam_dim else d for d in tensor.shape.dims]))<br><br>    # Gather up the most probable 2beams both for the ids and finished_in_alive<br>    # bools<br>    top_seq = my_gather(alive_seq)<br><br>    # Append the most probable alive<br>    top_seq += top_ids  mtf.one_hot(i, length_dim, dtype=tf.int32)<br>    top_finished = mtf.equal(top_ids, eos_id)<br><br>    return (<br>        top_seq, top_log_probs, top_scores, top_finished, new_states, selector)<br><br>  def inner_loop(i, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>                 finished_flags, states):<br>    """Inner beam search loop.<br><br>    There are three groups of tensors, alive, finished, and topk.<br>    The alive group contains information about the current alive sequences<br>    The topk group contains information about alive + topk current decoded words<br>    the finished group contains information about finished sentences, that is,<br>    the ones that have decoded to <EOS. These are what we return.<br>    The general beam search algorithm is as follows:<br>    While we haven't terminated (pls look at termination condition)<br>      1. Grow the current alive to get beam2 topk sequences<br>      2. Among the topk, keep the top beam_size ones that haven't reached EOS<br>      into alive<br>      3. Among the topk, keep the top beam_size ones have reached EOS into<br>      finished<br>    Repeat<br>    To make things simple with using fixed size tensors, we will end<br>    up inserting unfinished sequences into finished in the beginning. To stop<br>    that we add -ve INF to the score of the unfinished sequence so that when a<br>    true finished sequence does appear, it will have a higher score than all the<br>    unfinished ones.<br><br>    Args:<br>      i: loop index<br>      alive_seq: Topk sequences decoded so far [batch_size, beam_size, i+1]<br>      alive_log_probs: probabilities of the beams. [batch_size, beam_size]<br>      finished_seq: Current finished sequences.<br>        [batch_size, beam_size, i+1]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br>      finished_flags: finished bools for each of these sequences.<br>        [batch_size, beam_size]<br>      states: mtf Tensors<br><br>    Returns:<br>      Tuple of<br>        (Incremented loop index<br>         New alive sequences,<br>         Log probs of the alive sequences,<br>         New finished sequences,<br>         Scores of the new finished sequences,<br>         Flags indicating which sequence in finished as reached EOS,<br>         dict of final decoding states)<br>    """<br>    states = [mtf.replace_dimensions(<br>        state, batch_and_beam_dim, [batch_dim, beam_dim]) for state in states]<br>    # Each inner loop, we carry out three steps:<br>    # 1. Get the current topk items.<br>    # 2. Extract the ones that have finished and haven't finished<br>    # 3. Recompute the contents of finished based on scores.<br>    (top2k_seq, top2k_log_probs, top2k_scores, top2k_finished,<br>     new_states, first_selector) = grow_topk(<br>         i, alive_seq, alive_log_probs, states)<br>    with tf.variable_scope("grow_alive"):<br>      alive_seq, alive_log_probs, _, second_selector = grow_alive(<br>          top2k_seq, top2k_scores, top2k_log_probs, top2k_finished)<br>    with tf.variable_scope("grow_finished"):<br>      finished_seq, finished_scores, finished_flags, _ = grow_finished(<br>          finished_seq, finished_scores, finished_flags, top2k_seq,<br>          top2k_scores, top2k_finished)<br>    old_beam_dim = mtf.Dimension("old_beam", beam_dim.size)<br>    selector = mtf.einsum(<br>        [mtf.rename_dimension(first_selector, beam_dim.name, old_beam_dim.name),<br>         second_selector],<br>        output_shape=[batch_dim, old_beam_dim, beam_dim])<br>    gathered_states = []<br>    if use_tpu and layout is not None and mesh_shape is not None:<br>      # This hack combines the beam dimension with some of the batch dimension.<br>      # It makes gathering faster on TPU.<br>      #<br>      # Instead of multiplying by a [beam, beam] selector matrix, we instead<br>      # multiply by a [minor_batchbeam, minor_batchbeam] selector matrix.<br>      # This is theoretically more FLOPs, but it brings the matrix size closer<br>      # to the magic optimal value of 128.<br>      #<br>      # TODO(noam): file a bug with the XLA team to do this automatically<br>      major_batch_size = mtf.tensor_dim_to_mesh_dim_size(<br>          layout, mesh_shape, batch_dim)<br>      major_batch = mtf.Dimension(batch_dim.name, major_batch_size)<br>      minor_batch = mtf.Dimension(<br>          "minor_batch", batch_dim.size // major_batch.size)<br>      old_minor_batch = mtf.Dimension("old_minor_batch", minor_batch.size)<br>      old_combined = mtf.Dimension(<br>          "old_combined", minor_batch.size  beam_dim.size)<br>      combined = mtf.Dimension(<br>          "new_combined", old_combined.size)<br>      same_minor_batch = mtf.to_float(<br>          mtf.equal(mtf.range(mesh, old_minor_batch, tf.float32),<br>                    mtf.range(mesh, minor_batch, tf.float32)))<br>      selector = mtf.reshape(<br>          selector, [major_batch, minor_batch, old_beam_dim, beam_dim])<br>      selector = mtf.einsum(<br>          [selector, same_minor_batch],<br>          output_shape=[major_batch,<br>                        old_minor_batch, old_beam_dim,<br>                        minor_batch, beam_dim],<br>          reduced_dims=[])<br>      selector = mtf.reshape(selector, [major_batch, old_combined, combined])<br>      for state in new_states:<br>        s = mtf.replace_dimensions(<br>            state, [batch_dim, beam_dim], [major_batch, old_combined])<br>        s = mtf.einsum(<br>            [s, mtf.cast(selector, state.dtype)],<br>            reduced_dims=[old_combined],<br>            output_shape=mtf.replace_dimensions(<br>                state.shape, [batch_dim, beam_dim],<br>                [major_batch, combined]))<br>        gathered_states.append(mtf.replace_dimensions(<br>            s, [major_batch, combined], batch_and_beam_dim))<br>    else:<br>      for state in new_states:<br>        state = mtf.einsum(<br>            [mtf.rename_dimension(state, beam_dim.name, old_beam_dim.name),<br>             mtf.cast(selector, state.dtype)],<br>            reduced_dims=[old_beam_dim], output_shape=state.shape)<br>        state = mtf.replace_dimensions(<br>            state, [batch_dim, beam_dim], batch_and_beam_dim)<br>        gathered_states.append(state)<br><br>    return (i + 1, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>            finished_flags) + tuple(gathered_states)<br><br>  def _is_finished(i, unused_alive_seq, alive_log_probs, unused_finished_seq,<br>                   finished_scores, finished_in_finished, unused_states):<br>    """Checking termination condition.<br><br>    We terminate when we decoded up to decode_length or the lowest scoring item<br>    in finished has a greater score that the highest prob item in alive divided<br>    by the max length penalty<br><br>    Args:<br>      i: loop index<br>      alive_log_probs: probabilities of the beams. [batch_size, beam_size]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br>      finished_in_finished: finished bools for each of these sequences.<br>        [batch_size, beam_size]<br><br>    Returns:<br>      Bool.<br>    """<br>    # TODO(noam): support a different decode length...<br>    # decode_length = mtf.constant(mesh, length_dim.size, dtype=tf.int32)<br><br>    # del alive_log_probs, finished_scores, finished_in_finished<br>    # return mtf.less(i, length_dim.size)<br>    if not stop_early:<br>      return mtf.less(i, decode_length)<br>    max_length_penalty = mtf.pow(<br>        ((5. + mtf.cast(decode_length, finished_scores.dtype)) / 6.), alpha)<br>    # The best possible score of the most likely alive sequence.<br>    lower_bound_alive_scores = mtf.gather(<br>        alive_log_probs, mtf.constant(mesh, 0, dtype=tf.int32),<br>        beam_dim) / max_length_penalty<br><br>    # Now to compute the lowest score of a finished sequence in finished<br>    # If the sequence isn't finished, we multiply it's score by 0. since<br>    # scores are all -ve, taking the min will give us the score of the lowest<br>    # finished item.<br>    lowest_score_of_finished_in_finished = mtf.reduce_min(<br>        finished_scores  mtf.cast(finished_in_finished, finished_scores.dtype),<br>        reduced_dim=beam_dim)<br><br>    # If none of the sequences have finished, then the min will be 0 and<br>    # we have to replace it by -ve INF if it is. The score of any seq in alive<br>    # will be much higher than -ve INF and the termination condition will not<br>    # be met.<br>    lowest_score_of_finished_in_finished += (<br>        (1. - mtf.cast(mtf.reduce_any(<br>            finished_in_finished, reduced_dim=beam_dim),<br>                       finished_scores.dtype))  -INF)<br><br>    bound_is_met = mtf.reduce_all(<br>        mtf.greater(lowest_score_of_finished_in_finished,<br>                    lower_bound_alive_scores))<br>    return mtf.logical_and(<br>        mtf.less(i, decode_length), mtf.logical_not(bound_is_met))<br><br>  initial_step_num = mtf.constant(mesh, 0, dtype=tf.int32)<br>  states = [mtf.replace_dimensions(<br>      state, [batch_dim, beam_dim], batch_and_beam_dim) for state in states]<br>  while_loop_inputs = [<br>      initial_step_num, alive_seq, alive_log_probs, finished_seq,<br>      finished_scores, finished_flags] + states<br><br>  (_, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>   finished_flags) = mtf.while_loop(<br>       _is_finished, inner_loop, while_loop_inputs,<br>       num_loop_vars=None if use_tpu else 6)[:6]<br><br>  # Accounting for corner case: It's possible that no sequence in alive for a<br>  # particular batch item ever reached EOS. In that case, we should just copy<br>  # the contents of alive for that batch item. tf.reduce_any(finished_flags, 1)<br>  # if 0, means that no sequence for that batch index had reached EOS. We need<br>  # to do the same for the scores as well.<br>  finished_seq = mtf.where(<br>      mtf.reduce_any(finished_flags, reduced_dim=beam_dim),<br>      finished_seq, alive_seq)<br>  finished_scores = mtf.where(<br>      mtf.reduce_any(finished_flags, reduced_dim=beam_dim),<br>      finished_scores, alive_log_probs)<br>  return finished_seq, finished_scores

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_309604.txt
> def calcSegments(x, v):<br>    """<br>    Find index vectors `rise` and `fall` such that `rise` holds the indeces `i`<br>    such that x[i+1]x[i] and `fall` holds indeces `j` such that either<br>    - x[j+1] < x[j] or,<br>    - x[j]x[j-1] and v[j]<v[j-1].<br><br>    The vectors are essential to the DCEGM algorithm, as they definite the<br>    relevant intervals to be used to construct the upper envelope of potential<br>    solutions to the (necessary) first order conditions.<br><br>    Parameters<br>    ----------<br>    x : np.ndarray<br>        array of points where `v` is evaluated<br>    v : np.ndarray<br>        array of values of some function of `x`<br><br>    Returns<br>    -------<br>    rise : np.ndarray<br>        see description above<br>    fall : np.ndarray<br>        see description above<br>    """<br>    # NOTE: assumes that the first segment is in fact increasing (forced in EGM<br>    # by augmentation with the constrained segment).<br>    # elements in common grid g<br><br>    # Identify index intervals of falling and rising regions<br>    # We need these to construct the upper envelope because we need to discard<br>    # solutions from the inverted Euler equations that do not represent optimal<br>    # choices (the FOCs are only necessary in these models).<br>    #<br>    # `fall` is a vector of indeces that represent the first elements in all<br>    # of the falling segments (the curve can potentially fold several times)<br>    fall = np.empty(0, dtype=int) # initialize with empty and then add the last point below while-loop<br><br>    rise = np.array([0]) # Initialize such thatthe lowest point is the first grid point<br>    i = 1 # Initialize<br>    while i <= len(x) - 2:<br>        # Check if the next (`ip1` stands for i plus 1) grid point is below the<br>        # current one, such that the line is folding back.<br>        ip1_falls = x[i+1] < x[i] # true if grid decreases on index increment<br>        i_rose = x[i]  x[i-1] # true if grid decreases on index decrement<br>        val_fell = v[i] < v[i-1] # true if value rises on index decrement<br><br>        if (ip1_falls and i_rose) or (val_fell and i_rose):<br><br>            # we are in a region where the endogenous grid is decreasing or<br>            # the value function rises by stepping back in the grid.<br>            fall = np.append(fall, i) # add the index to the vector<br><br>            # We now iterate from the current index onwards until we find point<br>            # where resources rises again. Unfortunately, we need to check<br>            # each points, as there can be multiple spells of falling endogenous<br>            # grids, so we cannot use bisection or some other fast algorithm.<br>            k = i<br>            while x[k+1] < x[k]:<br>                k = k + 1<br>            # k now holds either the next index the starts a new rising<br>            # region, or it holds the length of M, `m_len`.<br><br>            rise = np.append(rise, k)<br><br>            # Set the index to the point where resources again is rising<br>            i = k<br><br>        i = i + 1<br><br>    # Add the last index for convenience (then all segments are complete, as<br>    # len(fall) == len(rise), and we can form them by range(rise[j], fall[j]+1).<br>    fall = np.append(fall, len(v)-1)<br><br>    return rise, fall

### DOC[4] (IRRELEVANT) leetcode/leetcode_2366.txt
> def min_operations(nums):<br>    """You are given a 0-indexed integer array `nums`. In one operation you can replace any element of the array with any two elements that sum to it.<br><br>   For example, consider `nums = [5,6,7]`. In one operation, we can replace `nums[1]` with `2` and `4` and convert `nums` to `[5,2,4,7]`.<br><br>Return _the minimum number of operations to make an array that is sorted in non-decreasing order_.<br><br>Example 1:<br><br>Input: nums = \[3,9,3\]<br>Output: 2<br>Explanation: Here are the steps to sort the array in non-decreasing order:<br>- From \[3,9,3\], replace the 9 with 3 and 6 so the array becomes \[3,3,6,3\]<br>- From \[3,3,6,3\], replace the 6 with 3 and 3 so the array becomes \[3,3,3,3,3\]<br>There are 2 steps to sort the array in non-decreasing order. Therefore, we return 2.<br><br>Example 2:<br><br>Input: nums = \[1,2,3,4,5\]<br>Output: 0<br>Explanation: The array is already in non-decreasing order. Therefore, we return 0. <br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `1 <= nums[i] <= 109`"""<br><br>    operations = 0<br>    for i in range(1, len(nums)):<br>        if nums[i] <= nums[i - 1]:<br>            diff = nums[i - 1] - nums[i] + 1<br>            operations += math.ceil(math.log2(diff))<br>            nums[i] += diff<br>    return operations

### DOC[5] (IRRELEVANT) leetcode/leetcode_798.txt
> def moves_to_chessboard(board):<br>    """You are given an array `nums`. You can rotate it by a non-negative integer `k` so that the array becomes `[nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]`. Afterward, any entries that are less than or equal to their index are worth one point.<br><br>   For example, if we have `nums = [2,4,1,3,0]`, and we rotate by `k = 2`, it becomes `[1,3,0,2,4]`. This is worth `3` points because `1  0` \[no points\], `3  1` \[no points\], `0 <= 2` \[one point\], `2 <= 3` \[one point\], `4 <= 4` \[one point\].<br><br>Return _the rotation index_ `k` _that corresponds to the highest score we can achieve if we rotated_ `nums` _by it_. If there are multiple answers, return the smallest such index `k`.<br><br>Example 1:<br><br>Input: nums = \[2,3,1,4,0\]<br>Output: 3<br>Explanation: Scores for each k are listed below: <br>k = 0,  nums = \[2,3,1,4,0\],    score 2<br>k = 1,  nums = \[3,1,4,0,2\],    score 3<br>k = 2,  nums = \[1,4,0,2,3\],    score 3<br>k = 3,  nums = \[4,0,2,3,1\],    score 4<br>k = 4,  nums = \[0,2,3,1,4\],    score 3<br>So we should choose k = 3, which has the highest score.<br><br>Example 2:<br><br>Input: nums = \[1,3,0,2,4\]<br>Output: 0<br>Explanation: nums will always have 3 points no matter how it shifts.<br>So we will choose the smallest k, which is 0.<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `0 <= nums[i] < nums.length`"""<br><br>    N = len(board)<br>    row, col = 0, 0<br>    row_count, col_count = 0, 0<br><br>    for i in range(N):<br>        for j in range(N):<br>            if (board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) != 0:<br>                return -1<br><br>    for i in range(N):<br>        row ^= board[0][i]<br>        col ^= board[i][0]<br>        row_count += 1 if board[0][i] == 1 else 0<br>        col_count += 1 if board[i][0] == 1 else 0<br><br>    if row != 0 and row_count  2 != N:<br>        return -1<br>    if col != 0 and col_count  2 != N:<br>        return -1<br><br>    if N % 2 == 1:<br>        if row_count % 2 == 1:<br>            row_count = N - row_count<br>        if col_count % 2 == 1:<br>            col_count = N - col_count<br>    else:<br>        row_count = min(row_count, N - row_count)<br>        col_count = min(col_count, N - col_count)<br><br>    return (row_count + col_count) // 2


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_561.txt
> def array_pair_sum(nums):<br>    """Given an integer array `nums` of `2n` integers, group these integers into `n` pairs `(a1, b1), (a2, b2), ..., (an, bn)` such that the sum of `min(ai, bi)` for all `i` is maximized. Return _the maximized sum_.<br><br>Example 1:<br><br>Input: nums = \[1,4,3,2\]<br>Output: 4<br>Explanation: All possible pairings (ignoring the ordering of elements) are:<br>1. (1, 4), (2, 3) - min(1, 4) + min(2, 3) = 1 + 2 = 3<br>2. (1, 3), (2, 4) - min(1, 3) + min(2, 4) = 1 + 2 = 3<br>3. (1, 2), (3, 4) - min(1, 2) + min(3, 4) = 1 + 3 = 4<br>So the maximum possible sum is 4.<br><br>Example 2:<br><br>Input: nums = \[6,2,6,5,1,2\]<br>Output: 9<br>Explanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.<br><br>Constraints:<br><br>   `1 <= n <= 104`<br>   `nums.length == 2  n`<br>   `-104 <= nums[i] <= 104`"""<br><br>    nums.sort()<br>    return sum(nums[::2])
