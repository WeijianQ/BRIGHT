# Query `6`

## Original Question

*There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.

   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.

Return _the ordering of courses you should take to finish all courses_. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.

Example 1:

Input: numCourses = 2, prerequisites = \[\[1,0\]\]
Output: \[0,1\]
Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is \[0,1\].

Example 2:

Input: numCourses = 4, prerequisites = \[\[1,0\],\[2,0\],\[3,1\],\[3,2\]\]
Output: \[0,2,1,3\]
Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.
So one correct course order is \[0,1,2,3\]. Another correct ordering is \[0,2,1,3\].

Example 3:

Input: numCourses = 1, prerequisites = \[\]
Output: \[0\]

Constraints:

   `1 <= numCourses <= 2000`
   `0 <= prerequisites.length <= numCourses  (numCourses - 1)`
   `prerequisites[i].length == 2`
   `0 <= ai, bi < numCourses`
   `ai != bi`
   All the pairs `[ai, bi]` are distinct.*

## gpt4 Reasoning

```markdown
The essential problem here is to find an order in which all courses can be completed given a set of prerequisite conditions. This is a classic problem of topological sorting in graph theory, where courses can be represented as nodes in a directed graph and prerequisites as directed edges between these nodes. The goal is to find a linear ordering of the vertices such that for every directed edge `uv` (from vertex `u` to vertex `v`), vertex `u` comes before `v` in the ordering.

The steps to address this problem effectively could involve:

1. **Graph Representation**: First, represent the courses and prerequisites as a directed graph. The nodes of the graph represent courses, and directed edges represent the prerequisite relationships. This can be achieved using adjacency lists, where each entry `adj[i]` lists all courses that require course `i` as a prerequisite.

2. **Detect Cycles**: If the graph contains a cycle, it is impossible to complete all courses (i.e., there is no topological ordering). Detecting cycles can be done using depth-first search (DFS) with a mechanism to track visited nodes and the recursion stack. If a node is encountered that is already in the recursion stack, a cycle exists.

3. **Topological Sort**: If the graph is acyclic, perform a topological sort. This can be done using DFS with a post-order traversal. Essentially, once you finish exploring a node's dependencies (i.e., its prerequisites and their prerequisites recursively), you add that node to the output list. This ensures that a course is added to the order only after all its prerequisites have been added.

**Implementation Overview**:
- Initialize an adjacency list to represent the graph and a visited array to keep track of visited nodes during DFS.
- For each prerequisite pair `[a, b]`, add `a` to the adjacency list of `b` to indicate that `b` is a prerequisite for `a`.
- Perform DFS on each unvisited node to detect cycles and if found, return an empty array since it's impossible to complete all courses.
- If no cycles are detected, use DFS to perform a topological sort. Keep track of the post-order of the traversal (i.e., add each node to the output list after exploring all its adjacent nodes).
- Reverse the output list since the nodes were added in post-order, and return it as the course order.

**Relevant Information**:
- The number of courses and the specific prerequisites are crucial to building the graph.
- The presence of a cycle indicates that it's impossible to finish all courses.
- The topological order of the acyclic graph (if it exists) provides a valid sequence in which all courses can be completed.
- Since there can be multiple valid topological orders, any valid order is an acceptable solution.

This approach effectively leverages graph theory concepts to solve the problem, ensuring that all prerequisites are met before a course is taken while also detecting any impossibilities in course completion.
```

### Metrics

```
recip_rank: 0.5000
P_1: 0.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.2000
recall_10: 0.2000
recall_25: 0.2000
recall_50: 0.2000
recall_100: 0.2000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.2140
ndcg_cut_10: 0.2140
ndcg_cut_25: 0.2140
ndcg_cut_50: 0.2140
ndcg_cut_100: 0.2140
map_cut_1: 0.0000
map_cut_5: 0.1000
map_cut_10: 0.1000
map_cut_25: 0.1000
map_cut_50: 0.1000
map_cut_100: 0.1000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_134201.txt
> def stable_reverse_topological_sort(graph):<br>    """Return a list of nodes in topological sort order.<br><br>    This topological sort is a unique permutation of the nodes<br>    such that an edge from u to v implies that u appears before v in the<br>    topological sort order.<br><br>    Parameters<br>    ----------<br>    graph : NetworkX digraph<br>            A directed graph<br><br>    Raises<br>    ------<br>    NetworkXError<br>        Topological sort is defined for directed graphs only. If the<br>        graph G is undirected, a NetworkXError is raised.<br>    NetworkXUnfeasible<br>        If G is not a directed acyclic graph (DAG) no topological sort<br>        exists and a NetworkXUnfeasible exception is raised.<br><br>    Notes<br>    -----<br>    - This algorithm is based on a description and proof in<br>      The Algorithm Design Manual [1]_ .<br>    - This implementation is modified from networkx 1.11 implementation [2]_<br>      to achieve stability, support only reverse (allows yielding instead of<br>      returning a list), and remove the `nbunch` argument (had no use for it).<br><br>    See also<br>    --------<br>    is_directed_acyclic_graph<br><br>    References<br>    ----------<br>    .. [1] Skiena, S. S. The Algorithm Design Manual  (Springer-Verlag, 1998).<br>        http://www.amazon.com/exec/obidos/ASIN/0387948600/ref=ase_thealgorithmrepo/<br>    .. [2] networkx on GitHub<br>        https://github.com/networkx/networkx/blob/8358afac209c00b7feb3e81c901098852a9413b3/networkx/algorithms/dag.py#L88-L168<br>    """<br>    if not graph.is_directed():<br>        raise networkx.NetworkXError(<br>            'Topological sort not defined on undirected graphs.')<br><br>    # nonrecursive version<br>    seen = set()<br>    explored = set()<br><br>    for v in sorted(graph.nodes()):<br>        if v in explored:<br>            continue<br>        fringe = [v]  # nodes yet to look at<br>        while fringe:<br>            w = fringe[-1]  # depth first search<br>            if w in explored:  # already looked down this branch<br>                fringe.pop()<br>                continue<br>            seen.add(w)     # mark as seen<br>            # Check successors for cycles and for new nodes<br>            new_nodes = []<br>            for n in sorted(graph[w]):<br>                if n not in explored:<br>                    if n in seen:  # CYCLE!! OH NOOOO!!<br>                        raise networkx.NetworkXUnfeasible(<br>                            'Graph contains a cycle.')<br>                    new_nodes.append(n)<br>            if new_nodes:   # Add new_nodes to fringe<br>                fringe.extend(new_nodes)<br>            else:           # No new nodes so w is fully explored<br>                explored.add(w)<br>                yield w<br>                fringe.pop()

### DOC[2] (GROUND TRUTH) leetcode/leetcode_207.txt
> from collections import defaultdict, deque<br>    """There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.<br><br>   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.<br><br>Return `true` if you can finish all courses. Otherwise, return `false`.<br><br>Example 1:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\]\]<br>Output: true<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0. So it is possible.<br><br>Example 2:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\],\[0,1\]\]<br>Output: false<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br><br>Constraints:<br><br>   `1 <= numCourses <= 2000`<br>   `0 <= prerequisites.length <= 5000`<br>   `prerequisites[i].length == 2`<br>   `0 <= ai, bi < numCourses`<br>   All the pairs prerequisites\[i\] are unique."""<br><br><br>def canFinish(numCourses, prerequisites):<br>    adj = defaultdict(list)<br>    inDegree = [0]  numCourses<br>    <br>    for a, b in prerequisites:<br>        adj[b].append(a)<br>        inDegree[a] += 1<br>    <br>    q = deque([i for i in range(numCourses) if inDegree[i]==0])<br>    <br>    while q:<br>        currCourse = q.popleft()<br>        numCourses -= 1<br>        <br>        for nextCourse in adj[currCourse]:<br>            inDegree[nextCourse] -= 1<br>            if inDegree[nextCourse] == 0:<br>                q.append(nextCourse)<br>    <br>    return numCourses == 0

### DOC[3] (IRRELEVANT) leetcode/leetcode_1494.txt
> from collections import deque<br>    """You are given an integer `n`, which indicates that there are `n` courses labeled from `1` to `n`. You are also given an array `relations` where `relations[i] = [prevCoursei, nextCoursei]`, representing a prerequisite relationship between course `prevCoursei` and course `nextCoursei`: course `prevCoursei` has to be taken before course `nextCoursei`. Also, you are given the integer `k`.<br><br>In one semester, you can take at most `k` courses as long as you have taken all the prerequisites in the previous semesters for the courses you are taking.<br><br>Return _the minimum number of semesters needed to take all courses_. The testcases will be generated such that it is possible to take every course.<br><br>Example 1:<br><br>Input: n = 4, relations = \[\[2,1\],\[3,1\],\[1,4\]\], k = 2<br>Output: 3<br>Explanation: The figure above represents the given graph.<br>In the first semester, you can take courses 2 and 3.<br>In the second semester, you can take course 1.<br>In the third semester, you can take course 4.<br><br>Example 2:<br><br>Input: n = 5, relations = \[\[2,1\],\[3,1\],\[4,1\],\[1,5\]\], k = 2<br>Output: 4<br>Explanation: The figure above represents the given graph.<br>In the first semester, you can only take courses 2 and 3 since you cannot take more than two per semester.<br>In the second semester, you can take course 4.<br>In the third semester, you can take course 1.<br>In the fourth semester, you can take course 5.<br><br>Constraints:<br><br>   `1 <= n <= 15`<br>   `1 <= k <= n`<br>   `0 <= relations.length <= n  (n-1) / 2`<br>   `relations[i].length == 2`<br>   `1 <= prevCoursei, nextCoursei <= n`<br>   `prevCoursei != nextCoursei`<br>   All the pairs `[prevCoursei, nextCoursei]` are unique.<br>   The given graph is a directed acyclic graph."""<br><br><br>def minNumberOfSemesters(n, relations, k):<br>    indegree = [0]  (n + 1)<br>    graph = [[] for _ in range(n + 1)]<br><br>    for prev_course, next_course in relations:<br>        graph[prev_course].append(next_course)<br>        indegree[next_course] += 1<br><br>    semesters = 0<br>    while n  0:<br>        zero_indegree = deque()<br>        for i in range(1, len(indegree)):<br>            if indegree[i] == 0:<br>                zero_indegree.append(i)<br>                indegree[i] = -1<br><br>        courses = 0<br>        while zero_indegree and courses < k:<br>            curr_course = zero_indegree.popleft()<br>            n -= 1<br><br>            for next_course in graph[curr_course]:<br>                indegree[next_course] -= 1<br>            courses += 1<br>        semesters += 1<br>    return semesters

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_297163.txt
> def topological_order(nodes, incoming):<br>    """Performs topological sort of a DAG-like structure<br>    (directed acyclic graph).<br><br>    :param nodes: Collection of nodes<br>    :param incoming: Function taking node as an argument and returning iterable<br>                     of nodes with edges pointing _towards_ given one<br><br>    :return: Iterable of nodes in the topological order<br><br>    .. note::<br><br>        ``incoming`` function works in _reverse_ to the typical adjacency<br>        relation in graphs: if ``A in incoming(B)``, it implies that ``A-B``<br>        is among the graph edges (not ``B-A``!).<br><br>        This reversal is useful in practice when dealing with graphs<br>        representing dependencies, module imports, header includes, and so on.<br><br>    Example::<br><br>        for package in topological_order(packages, attr_func('dependencies')):<br>            install(package)<br><br>    .. versionadded:: 0.0.4<br>    """<br>    ensure_iterable(nodes) ; ensure_countable(nodes)<br>    ensure_callable(incoming)<br><br>    # data structure for tracking node's visit state<br>    NOT_VISITED, VISITING, VISITED = range(3)<br>    visit_states = {}<br>    visit_state = lambda node: visit_states.get(id(node), NOT_VISITED)<br><br>    def visit(node):<br>        """Topological sort visitor function."""<br>        if visit_state(node) == VISITING:<br>            raise ValueError("cycle found on node %r" % (node,))<br>        if visit_state(node) == NOT_VISITED:<br>            visit_states[id(node)] = VISITING<br>            for neighbor in incoming(node):<br>                for n in visit(neighbor):<br>                    yield n<br>            visit_states[id(node)] = VISITED<br>            yield node<br><br>    def generator():<br>        """Main generator function that loops through the nodes<br>        until we've visited them all.<br>        """<br>        visited_count = 0<br>        while visited_count < len(nodes):<br>            visited_count = 0<br>            for node in nodes:<br>                if visit_state(node) == VISITED:<br>                    visited_count += 1<br>                else:<br>                    for n in visit(node):<br>                        yield n<br><br>    return generator()

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_188660.txt
> def depth_first_search_with_parent_data(graph, root_node = None, adjacency_lists = None):<br>    """Performs a depth-first search with visiting order of nodes determined by provided adjacency lists,<br>     and also returns a parent lookup dict and a children lookup dict."""<br>    ordering = []<br>    parent_lookup = {}<br>    children_lookup = defaultdict(lambda: [])<br><br>    all_nodes = graph.get_all_node_ids()<br>    if not all_nodes:<br>        return ordering, parent_lookup, children_lookup<br><br>    stack = deque()<br>    discovered = defaultdict(lambda: False)<br>    unvisited_nodes = set(all_nodes)<br><br>    if root_node is None:<br>        root_node = all_nodes[0]<br><br>    if adjacency_lists is None:<br>        adj = lambda v: graph.neighbors(v)<br>    else:<br>        adj = lambda v: adjacency_lists[v]<br><br>    # --Initialize the stack, simulating the DFS call on the root node<br>    stack.appendleft(root_node)<br>    parent_lookup[root_node] = root_node<br><br>    # We're using a non-recursive implementation of DFS, since Python isn't great for deep recursion<br>    while True:<br>        # Main DFS Loop<br>        while len(stack)  0:<br>            u = stack.popleft()<br><br>            if not discovered[u]:<br>                discovered[u] = True<br>                if u in unvisited_nodes:<br>                    unvisited_nodes.remove(u)<br>                ordering.append(u)<br>                neighbors = adj(u)<br>                # When adding the new nodes to the stack, we want to add them in reverse order so that<br>                # the order the nodes are visited is the same as with a recursive DFS implementation<br>                for n in neighbors[::-1]:<br>                    if discovered[n]:<br>                        # If the node already exists in the discovered nodes list<br>                        # we don't want to re-add it to the stack<br>                        continue<br>                    stack.appendleft(n)<br>                    parent_lookup[n] = u<br>                    children_lookup[u].append(n)<br><br>        # While there are still nodes that need visiting, repopulate the stack<br>        if len(unvisited_nodes)  0:<br>            u = unvisited_nodes.pop()<br>            stack.appendleft(u)<br>        else:<br>            break<br><br>    return ordering, parent_lookup, children_lookup


## Ground Truth

### GROUND TRUTH 0, ranked 1, leetcode/leetcode_207.txt
> from collections import defaultdict, deque<br>    """There are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.<br><br>   For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.<br><br>Return `true` if you can finish all courses. Otherwise, return `false`.<br><br>Example 1:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\]\]<br>Output: true<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0. So it is possible.<br><br>Example 2:<br><br>Input: numCourses = 2, prerequisites = \[\[1,0\],\[0,1\]\]<br>Output: false<br>Explanation: There are a total of 2 courses to take. <br>To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.<br><br>Constraints:<br><br>   `1 <= numCourses <= 2000`<br>   `0 <= prerequisites.length <= 5000`<br>   `prerequisites[i].length == 2`<br>   `0 <= ai, bi < numCourses`<br>   All the pairs prerequisites\[i\] are unique."""<br><br><br>def canFinish(numCourses, prerequisites):<br>    adj = defaultdict(list)<br>    inDegree = [0]  numCourses<br>    <br>    for a, b in prerequisites:<br>        adj[b].append(a)<br>        inDegree[a] += 1<br>    <br>    q = deque([i for i in range(numCourses) if inDegree[i]==0])<br>    <br>    while q:<br>        currCourse = q.popleft()<br>        numCourses -= 1<br>        <br>        for nextCourse in adj[currCourse]:<br>            inDegree[nextCourse] -= 1<br>            if inDegree[nextCourse] == 0:<br>                q.append(nextCourse)<br>    <br>    return numCourses == 0

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_310.txt
> from collections import deque<br>    """A tree is an undirected graph in which any two vertices are connected by _exactly_ one path. In other words, any connected graph without simple cycles is a tree.<br><br>Given a tree of `n` nodes labelled from `0` to `n - 1`, and an array of `n - 1` `edges` where `edges[i] = [ai, bi]` indicates that there is an undirected edge between the two nodes `ai` and `bi` in the tree, you can choose any node of the tree as the root. When you select a node `x` as the root, the result tree has height `h`. Among all possible rooted trees, those with minimum height (i.e. `min(h)`) are called minimum height trees (MHTs).<br><br>Return _a list of all MHTs' root labels_. You can return the answer in any order.<br><br>The height of a rooted tree is the number of edges on the longest downward path between the root and a leaf.<br><br>Example 1:<br><br>Input: n = 4, edges = \[\[1,0\],\[1,2\],\[1,3\]\]<br>Output: \[1\]<br>Explanation: As shown, the height of the tree is 1 when the root is the node with label 1 which is the only MHT.<br><br>Example 2:<br><br>Input: n = 6, edges = \[\[3,0\],\[3,1\],\[3,2\],\[3,4\],\[5,4\]\]<br>Output: \[3,4\]<br><br>Constraints:<br><br>   `1 <= n <= 2  104`<br>   `edges.length == n - 1`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   All the pairs `(ai, bi)` are distinct.<br>   The given input is guaranteed to be a tree and there will be no repeated edges."""<br><br>from typing import List<br><br>def find_min_height_trees(n: int, edges: List[List[int]]) - List[int]:<br>    if n == 1:<br>        return [0]<br><br>    adj_list = [set() for _ in range(n)]<br>    for a, b in edges:<br>        adj_list[a].add(b)<br>        adj_list[b].add(a)<br><br>    leaves = deque(i for i in range(n) if len(adj_list[i]) == 1)<br><br>    while n  2:<br>        leaves_size = len(leaves)<br>        n -= leaves_size<br>        for _ in range(leaves_size):<br>            leaf = leaves.popleft()<br>            for neighbor in adj_list[leaf]:<br>                adj_list[neighbor].remove(leaf)<br>                if len(adj_list[neighbor]) == 1:<br>                    leaves.append(neighbor)<br><br>    return list(leaves)

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_630.txt
> import heapq<br>    """There are `n` different online courses numbered from `1` to `n`. You are given an array `courses` where `courses[i] = [durationi, lastDayi]` indicate that the `ith` course should be taken continuously for `durationi` days and must be finished before or on `lastDayi`.<br><br>You will start on the `1st` day and you cannot take two or more courses simultaneously.<br><br>Return _the maximum number of courses that you can take_.<br><br>Example 1:<br><br>Input: courses = \[\[100,200\],\[200,1300\],\[1000,1250\],\[2000,3200\]\]<br>Output: 3<br>Explanation: <br>There are totally 4 courses, but you can take 3 courses at most:<br>First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day.<br>Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. <br>Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. <br>The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date.<br><br>Example 2:<br><br>Input: courses = \[\[1,2\]\]<br>Output: 1<br><br>Example 3:<br><br>Input: courses = \[\[3,2\],\[4,3\]\]<br>Output: 0<br><br>Constraints:<br><br>   `1 <= courses.length <= 104`<br>   `1 <= durationi, lastDayi <= 104`"""<br><br><br>def scheduleCourse(courses):<br>    courses.sort(key=lambda x: x[1])<br>    curr_time, duration_sum = 0, []<br><br>    for duration, deadline in courses:<br>        curr_time += duration<br>        heapq.heappush(duration_sum, -duration)<br><br>        if curr_time  deadline:<br>            curr_time += heapq.heappop(duration_sum)<br><br>    return len(duration_sum)

### GROUND TRUTH 3, ranked not in top 100, leetcode/leetcode_2115.txt
> def numDistinct(binary):<br>    """You have information about `n` different recipes. You are given a string array `recipes` and a 2D string array `ingredients`. The `ith` recipe has the name `recipes[i]`, and you can create it if you have all the needed ingredients from `ingredients[i]`. Ingredients to a recipe may need to be created from other recipes, i.e., `ingredients[i]` may contain a string that is in `recipes`.<br><br>You are also given a string array `supplies` containing all the ingredients that you initially have, and you have an infinite supply of all of them.<br><br>Return _a list of all the recipes that you can create._ You may return the answer in any order.<br><br>Note that two recipes may contain each other in their ingredients.<br><br>Example 1:<br><br>Input: recipes = \[ "bread "\], ingredients = \[\[ "yeast ", "flour "\]\], supplies = \[ "yeast ", "flour ", "corn "\]<br>Output: \[ "bread "\]<br>Explanation:<br>We can create  "bread " since we have the ingredients  "yeast " and  "flour ".<br><br>Example 2:<br><br>Input: recipes = \[ "bread ", "sandwich "\], ingredients = \[\[ "yeast ", "flour "\],\[ "bread ", "meat "\]\], supplies = \[ "yeast ", "flour ", "meat "\]<br>Output: \[ "bread ", "sandwich "\]<br>Explanation:<br>We can create  "bread " since we have the ingredients  "yeast " and  "flour ".<br>We can create  "sandwich " since we have the ingredient  "meat " and can create the ingredient  "bread ".<br><br>Example 3:<br><br>Input: recipes = \[ "bread ", "sandwich ", "burger "\], ingredients = \[\[ "yeast ", "flour "\],\[ "bread ", "meat "\],\[ "sandwich ", "meat ", "bread "\]\], supplies = \[ "yeast ", "flour ", "meat "\]<br>Output: \[ "bread ", "sandwich ", "burger "\]<br>Explanation:<br>We can create  "bread " since we have the ingredients  "yeast " and  "flour ".<br>We can create  "sandwich " since we have the ingredient  "meat " and can create the ingredient  "bread ".<br>We can create  "burger " since we have the ingredient  "meat " and can create the ingredients  "bread " and  "sandwich ".<br><br>Constraints:<br><br>   `n == recipes.length == ingredients.length`<br>   `1 <= n <= 100`<br>   `1 <= ingredients[i].length, supplies.length <= 100`<br>   `1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10`<br>   `recipes[i], ingredients[i][j]`, and `supplies[k]` consist only of lowercase English letters.<br>   All the values of `recipes` and `supplies` combined are unique.<br>   Each `ingredients[i]` does not contain any duplicate values."""<br><br>    mod = 109 + 7<br>    zero_count, ones_count = 0, 0<br><br>    for c in binary:<br>        if c == '0':<br>            zero_count = (zero_count + ones_count) % mod<br>        else:<br>            ones_count = (ones_count  2 + 1) % mod<br>    <br>    return zero_count

### GROUND TRUTH 4, ranked not in top 100, leetcode/leetcode_2392.txt
> def build_matrix(k: int, row_conditions: List[List[int]], col_conditions: List[List[int]]) - List[List[int]]:<br>    """You are given a positive integer `k`. You are also given:<br><br>   a 2D integer array `rowConditions` of size `n` where `rowConditions[i] = [abovei, belowi]`, and<br>   a 2D integer array `colConditions` of size `m` where `colConditions[i] = [lefti, righti]`.<br><br>The two arrays contain integers from `1` to `k`.<br><br>You have to build a `k x k` matrix that contains each of the numbers from `1` to `k` exactly once. The remaining cells should have the value `0`.<br><br>The matrix should also satisfy the following conditions:<br><br>   The number `abovei` should appear in a row that is strictly above the row at which the number `belowi` appears for all `i` from `0` to `n - 1`.<br>   The number `lefti` should appear in a column that is strictly left of the column at which the number `righti` appears for all `i` from `0` to `m - 1`.<br><br>Return _any matrix that satisfies the conditions_. If no answer exists, return an empty matrix.<br><br>Example 1:<br><br>Input: k = 3, rowConditions = \[\[1,2\],\[3,2\]\], colConditions = \[\[2,1\],\[3,2\]\]<br>Output: \[\[3,0,0\],\[0,0,1\],\[0,2,0\]\]<br>Explanation: The diagram above shows a valid example of a matrix that satisfies all the conditions.<br>The row conditions are the following:<br>- Number 1 is in row 1, and number 2 is in row 2, so 1 is above 2 in the matrix.<br>- Number 3 is in row 0, and number 2 is in row 2, so 3 is above 2 in the matrix.<br>The column conditions are the following:<br>- Number 2 is in column 1, and number 1 is in column 2, so 2 is left of 1 in the matrix.<br>- Number 3 is in column 0, and number 2 is in column 1, so 3 is left of 2 in the matrix.<br>Note that there may be multiple correct answers.<br><br>Example 2:<br><br>Input: k = 3, rowConditions = \[\[1,2\],\[2,3\],\[3,1\],\[2,3\]\], colConditions = \[\[2,1\]\]<br>Output: \[\]<br>Explanation: From the first two conditions, 3 has to be below 1 but the third conditions needs 3 to be above 1 to be satisfied.<br>No matrix can satisfy all the conditions, so we return the empty matrix.<br><br>Constraints:<br><br>   `2 <= k <= 400`<br>   `1 <= rowConditions.length, colConditions.length <= 104`<br>   `rowConditions[i].length == colConditions[i].length == 2`<br>   `1 <= abovei, belowi, lefti, righti <= k`<br>   `abovei != belowi`<br>   `lefti != righti`"""<br><br>    row, col = [0]  (k + 1), [0]  (k + 1)<br>    for condition in row_conditions:<br>        if row[condition[0]] = row[condition[1]]:<br>            return []<br>        row[condition[1]] = row[condition[0]] + 1<br>    for condition in col_conditions:<br>        if col[condition[0]] = col[condition[1]]:<br>            return []<br>        col[condition[1]] = col[condition[0]] + 1<br>    matrix = [[0]  k for _ in range(k)]<br>    for i in range(1, k + 1):<br>        matrix[row[i]][col[i]] = i<br>    return matrix
