# Query `7`

## Original Question

*A city's skyline is the outer contour of the silhouette formed by all the buildings in that city when viewed from a distance. Given the locations and heights of all the buildings, return _the skyline formed by these buildings collectively_.

The geometric information of each building is given in the array `buildings` where `buildings[i] = [lefti, righti, heighti]`:

   `lefti` is the x coordinate of the left edge of the `ith` building.
   `righti` is the x coordinate of the right edge of the `ith` building.
   `heighti` is the height of the `ith` building.

You may assume all buildings are perfect rectangles grounded on an absolutely flat surface at height `0`.

The skyline should be represented as a list of "key points " sorted by their x-coordinate in the form `[[x1,y1],[x2,y2],...]`. Each key point is the left endpoint of some horizontal segment in the skyline except the last point in the list, which always has a y-coordinate `0` and is used to mark the skyline's termination where the rightmost building ends. Any ground between the leftmost and rightmost buildings should be part of the skyline's contour.

Note: There must be no consecutive horizontal lines of equal height in the output skyline. For instance, `[...,[2 3],[4 5],[7 5],[11 5],[12 7],...]` is not acceptable; the three lines of height 5 should be merged into one in the final output as such: `[...,[2 3],[4 5],[12 7],...]`

Example 1:

Input: buildings = \[\[2,9,10\],\[3,7,15\],\[5,12,12\],\[15,20,10\],\[19,24,8\]\]
Output: \[\[2,10\],\[3,15\],\[7,12\],\[12,0\],\[15,10\],\[20,8\],\[24,0\]\]
Explanation:
Figure A shows the buildings of the input.
Figure B shows the skyline formed by those buildings. The red points in figure B represent the key points in the output list.

Example 2:

Input: buildings = \[\[0,2,3\],\[2,5,3\]\]
Output: \[\[0,3\],\[5,0\]\]

Constraints:

   `1 <= buildings.length <= 104`
   `0 <= lefti < righti <= 231 - 1`
   `1 <= heighti <= 231 - 1`
   `buildings` is sorted by `lefti` in non-decreasing order.*

## gpt4 Reasoning

```markdown
The essential problem here is to compute the skyline of a set of buildings, which involves determining the outer contour of the combined silhouette formed by all the buildings when viewed from a distance. The output should be a list of key points that represent the "corners" or changes in the silhouette's height, ensuring no consecutive horizontal lines of the same height appear in the output. The input provides the buildings' positions and heights in a structured format, where each building is represented by its left edge, right edge, and height.

### Step-by-Step Solution

1. **Initialization**: 
   - Create a list to hold the final skyline key points.
   - Convert the building information into a list of "events" where each event is either a building's start or end. A building's start could add a new line to the skyline if it's taller than the existing lines at that point, and a building's end could change the skyline if it was part of the current contour.

2. **Sorting Events**:
   - Sort the events first by their x-coordinate. For events with the same x-coordinate, sort building starts before ends to ensure a building is considered before its potential removal affects the skyline. When starting points have the same x-coordinate, the taller building comes first; for ending points with the same x-coordinate, the shorter comes first. This sorting ensures the correct order of processing for the silhouette to form accurately.

3. **Processing Events**:
   - Use a data structure (like a max-heap) to keep track of the current buildings' heights when scanning through the events. This structure allows quick access to the tallest building at any point in time.
   - As you encounter a new building start, add its height to the structure. If this height is the new maximum, it indicates a change in the skyline, and thus, a new key point should be added.
   - When encountering a building end, remove its height from the structure. If this height was the maximum, then the next maximum height in the structure (if any) will determine the new contour of the skyline. If the new maximum height is less than the removed height, this indicates a downward change in the skyline, and a new key point should be added.

4. **Key Points**:
   - Every time there is a change in the maximum height encountered (either by starting a new building taller than the current max or ending a building that was part of the current max), a new key point is generated. This key point has the x-coordinate of the current event and the new maximum height (or 0 if the structure is empty, indicating the end of the skyline).

5. **Edge Cases**:
   - To handle consecutive buildings of the same height smoothly, the algorithm's sorting step ensures that all starts of such buildings are processed before any ends, effectively treating them as a single continuous building.
   - The final point in the skyline should always have a height of 0 to indicate the skyline's termination.

### Conclusion

The challenge in generating the skyline lies in efficiently managing the heights of overlapping buildings and accurately determining where the silhouette changes. By carefully sorting events and using a data structure to keep track of the current heights, we can iterate through the building information to construct the skyline. The key is to identify when the addition or removal of a building will actually alter the skyline's contour, which involves comparing each building's height to the current maximum height and updating the list of key points accordingly.
```

### Metrics

```
recip_rank: 0.1667
P_1: 0.0000
P_5: 0.0000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.2184
ndcg_cut_25: 0.2184
ndcg_cut_50: 0.2184
ndcg_cut_100: 0.2184
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0833
map_cut_25: 0.0833
map_cut_50: 0.0833
map_cut_100: 0.0833
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_807.txt
> def custom_sort_string(order, s):<br>    """There is a city composed of `n x n` blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed `n x n` integer matrix `grid` where `grid[r][c]` represents the height of the building located in the block at row `r` and column `c`.<br><br>A city's skyline is the outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.<br><br>We are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a `0`\-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.<br><br>Return _the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction_.<br><br>Example 1:<br><br>Input: grid = \[\[3,0,8,4\],\[2,4,5,7\],\[9,2,6,3\],\[0,3,1,0\]\]<br>Output: 35<br>Explanation: The building heights are shown in the center of the above image.<br>The skylines when viewed from each cardinal direction are drawn in red.<br>The grid after increasing the height of buildings without affecting skylines is:<br>gridNew = \[ \[8, 4, 8, 7\],<br>            \[7, 4, 7, 7\],<br>            \[9, 4, 8, 7\],<br>            \[3, 3, 3, 3\] \]<br><br>Example 2:<br><br>Input: grid = \[\[0,0,0\],\[0,0,0\],\[0,0,0\]\]<br>Output: 0<br>Explanation: Increasing the height of any building will result in the skyline changing.<br><br>Constraints:<br><br>   `n == grid.length`<br>   `n == grid[r].length`<br>   `2 <= n <= 50`<br>   `0 <= grid[r][c] <= 100`"""<br><br>    return ''.join(sorted(s, key=lambda x: order.index(x) if x in order else len(order)))

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_52685.txt
> def _generate_placements(self, width, height):<br>        """<br>        Generate a list with <br><br>        Arguments:<br>            skyline (list): SkylineHSegment list<br>            width (number):<br><br>        Returns:<br>            tuple (Rectangle, fitness):<br>                Rectangle: Rectangle in valid position<br>                left_skyline: Index for the skyline under the rectangle left edge.<br>                right_skyline: Index for the skyline under the rectangle right edte.<br>        """<br>        skyline = self._skyline<br><br>        points = collections.deque()<br><br>        left_index = right_index = 0 # Left and right side skyline index<br>        support_height = skyline[0].top<br>        support_index = 0 <br>    <br>        placements = self._placement_points_generator(skyline, width)<br>        for p in placements:<br><br>            # If Rectangle's right side changed segment, find new support<br>            if p+width  skyline[right_index].right:<br>                for right_index in range(right_index+1, len(skyline)):<br>                    if skyline[right_index].top = support_height:<br>                        support_index = right_index<br>                        support_height = skyline[right_index].top<br>                    if p+width <= skyline[right_index].right:<br>                        break<br>                <br>            # If left side changed segment.<br>            if p = skyline[left_index].right:<br>                left_index +=1<br>           <br>            # Find new support if the previous one was shifted out.<br>            if support_index < left_index:<br>                support_index = left_index<br>                support_height = skyline[left_index].top<br>                for i in range(left_index, right_index+1):<br>                    if skyline[i].top = support_height:<br>                        support_index = i<br>                        support_height = skyline[i].top<br><br>            # Add point if there is enought room at the top<br>            if support_height+height <= self.height:<br>                points.append((Rectangle(p, support_height, width, height),\<br>                    left_index, right_index))<br><br>        return points

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_52684.txt
> def _placement_points_generator(self, skyline, width):<br>        """Returns a generator for the x coordinates of all the placement<br>        points on the skyline for a given rectangle.<br><br>        WARNING: In some cases could be duplicated points, but it is faster<br>        to compute them twice than to remove them.<br>        <br>        Arguments:<br>            skyline (list): Skyline HSegment list<br>            width (int, float): Rectangle width<br><br>        Returns:<br>            generator<br>        """ <br>        skyline_r = skyline[-1].right<br>        skyline_l = skyline[0].left<br><br>        # Placements using skyline segment left point<br>        ppointsl = (s.left for s in skyline if s.left+width <= skyline_r)<br><br>        # Placements using skyline segment right point<br>        ppointsr = (s.right-width for s in skyline if s.right-width = skyline_l)<br><br>        # Merge positions<br>        return heapq.merge(ppointsl, ppointsr)

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_141268.txt
> def find_contours(array, level,<br>                  fully_connected='low', positive_orientation='low'):<br>    """Find iso-valued contours in a 2D array for a given level value.<br><br>    Uses the "marching squares" method to compute a the iso-valued contours of<br>    the input 2D array for a particular level value. Array values are linearly<br>    interpolated to provide better precision for the output contours.<br><br>    Parameters<br>    ----------<br>    array : 2D ndarray of double<br>        Input data in which to find contours.<br>    level : float<br>        Value along which to find contours in the array.<br>    fully_connected : str, {'low', 'high'}<br>         Indicates whether array elements below the given level value are to be<br>         considered fully-connected (and hence elements above the value will<br>         only be face connected), or vice-versa. (See notes below for details.)<br>    positive_orientation : either 'low' or 'high'<br>         Indicates whether the output contours will produce positively-oriented<br>         polygons around islands of low- or high-valued elements. If 'low' then<br>         contours will wind counter- clockwise around elements below the<br>         iso-value. Alternately, this means that low-valued elements are always<br>         on the left of the contour. (See below for details.)<br><br>    Returns<br>    -------<br>    contours : list of (n,2)-ndarrays<br>        Each contour is an ndarray of shape ``(n, 2)``,<br>        consisting of n ``(row, column)`` coordinates along the contour.<br><br>    Notes<br>    -----<br>    The marching squares algorithm is a special case of the marching cubes<br>    algorithm [1]_.  A simple explanation is available here::<br><br>      http://www.essi.fr/~lingrand/MarchingCubes/algo.html<br><br>    There is a single ambiguous case in the marching squares algorithm: when<br>    a given ``2 x 2``-element square has two high-valued and two low-valued<br>    elements, each pair diagonally adjacent. (Where high- and low-valued is<br>    with respect to the contour value sought.) In this case, either the<br>    high-valued elements can be 'connected together' via a thin isthmus that<br>    separates the low-valued elements, or vice-versa. When elements are<br>    connected together across a diagonal, they are considered 'fully<br>    connected' (also known as 'face+vertex-connected' or '8-connected'). Only<br>    high-valued or low-valued elements can be fully-connected, the other set<br>    will be considered as 'face-connected' or '4-connected'. By default,<br>    low-valued elements are considered fully-connected; this can be altered<br>    with the 'fully_connected' parameter.<br><br>    Output contours are not guaranteed to be closed: contours which intersect<br>    the array edge will be left open. All other contours will be closed. (The<br>    closed-ness of a contours can be tested by checking whether the beginning<br>    point is the same as the end point.)<br><br>    Contours are oriented. By default, array values lower than the contour<br>    value are to the left of the contour and values greater than the contour<br>    value are to the right. This means that contours will wind<br>    counter-clockwise (i.e. in 'positive orientation') around islands of<br>    low-valued pixels. This behavior can be altered with the<br>    'positive_orientation' parameter.<br><br>    The order of the contours in the output list is determined by the position<br>    of the smallest ``x,y`` (in lexicographical order) coordinate in the<br>    contour.  This is a side-effect of how the input array is traversed, but<br>    can be relied upon.<br><br>    .. warning::<br><br>       Array coordinates/values are assumed to refer to the center of the<br>       array element. Take a simple example input: ``[0, 1]``. The interpolated<br>       position of 0.5 in this array is midway between the 0-element (at<br>       ``x=0``) and the 1-element (at ``x=1``), and thus would fall at<br>       ``x=0.5``.<br><br>    This means that to find reasonable contours, it is best to find contours<br>    midway between the expected "light" and "dark" values. In particular,<br>    given a binarized array, do not choose to find contours at the low or<br>    high value of the array. This will often yield degenerate contours,<br>    especially around structures that are a single array element wide. Instead<br>    choose a middle value, as above.<br><br>    References<br>    ----------<br>    .. [1] Lorensen, William and Harvey E. Cline. Marching Cubes: A High<br>           Resolution 3D Surface Construction Algorithm. Computer Graphics<br>           (SIGGRAPH 87 Proceedings) 21(4) July 1987, p. 163-170).<br><br>    Examples<br>    --------<br>     a = np.zeros((3, 3))<br>     a[0, 0] = 1<br>     a<br>    array([[ 1.,  0.,  0.],<br>           [ 0.,  0.,  0.],<br>           [ 0.,  0.,  0.]])<br>     find_contours(a, 0.5)<br>    [array([[ 0. ,  0.5],<br>           [ 0.5,  0. ]])]<br>    """<br>    array = np.asarray(array, dtype=np.double)<br>    if array.ndim != 2:<br>        raise ValueError('Only 2D arrays are supported.')<br>    level = float(level)<br>    if (fully_connected not in _param_options or<br>            positive_orientation not in _param_options):<br>        raise ValueError('Parameters "fully_connected" and'<br>                         ' "positive_orientation" must be either "high" or'<br>                         ' "low".')<br>    point_list = _find_contours_cy.iterate_and_store(array, level,<br>                                                     fully_connected == 'high')<br>    contours = _assemble_contours(_take_2(point_list))<br>    if positive_orientation == 'high':<br>        contours = [c[::-1] for c in contours]<br>    return contours

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_120111.txt
> def density2d(data,<br>              channels=[0,1],<br>              bins=1024,<br>              gate_fraction=0.65,<br>              xscale='logicle',<br>              yscale='logicle',<br>              sigma=10.0,<br>              full_output=False):<br>    """<br>    Gate that preserves events in the region with highest density.<br><br>    Gate out all events in `data` but those near regions of highest<br>    density for the two specified channels.<br><br>    Parameters<br>    ----------<br>    data : FCSData or numpy array<br>        NxD flow cytometry data where N is the number of events and D is<br>        the number of parameters (aka channels).<br>    channels : list of int, list of str, optional<br>        Two channels on which to perform gating.<br>    bins : int or array_like or [int, int] or [array, array], optional<br>        Bins used for gating:<br><br>          - If None, use ``data.hist_bins`` to obtain bin edges for both<br>            axes. None is not allowed if ``data.hist_bins`` is not<br>            available.<br>          - If int, `bins` specifies the number of bins to use for both<br>            axes. If ``data.hist_bins`` exists, it will be used to generate<br>            a number `bins` of bins.<br>          - If array_like, `bins` directly specifies the bin edges to use<br>            for both axes.<br>          - If [int, int], each element of `bins` specifies the number of<br>            bins for each axis. If ``data.hist_bins`` exists, use it to<br>            generate ``bins[0]`` and ``bins[1]`` bin edges, respectively.<br>          - If [array, array], each element of `bins` directly specifies<br>            the bin edges to use for each axis.<br>          - Any combination of the above, such as [int, array], [None,<br>            int], or [array, int]. In this case, None indicates to generate<br>            bin edges using ``data.hist_bins`` as above, int indicates the<br>            number of bins to generate, and an array directly indicates the<br>            bin edges. Note that None is not allowed if ``data.hist_bins``<br>            does not exist.<br>    gate_fraction : float, optional<br>        Fraction of events to retain after gating. Should be between 0 and<br>        1, inclusive.<br>    xscale : str, optional<br>        Scale of the bins generated for the x axis, either ``linear``,<br>        ``log``, or ``logicle``. `xscale` is ignored in `bins` is an array<br>        or a list of arrays.<br>    yscale : str, optional<br>        Scale of the bins generated for the y axis, either ``linear``,<br>        ``log``, or ``logicle``. `yscale` is ignored in `bins` is an array<br>        or a list of arrays.<br>    sigma : scalar or sequence of scalars, optional<br>        Standard deviation for Gaussian kernel used by<br>        `scipy.ndimage.filters.gaussian_filter` to smooth 2D histogram<br>        into a density.<br>    full_output : bool, optional<br>        Flag specifying to return additional outputs. If true, the outputs<br>        are given as a namedtuple.<br><br>    Returns<br>    -------<br>    gated_data : FCSData or numpy array<br>        Gated flow cytometry data of the same format as `data`.<br>    mask : numpy array of bool, only if ``full_output==True``<br>        Boolean gate mask used to gate data such that ``gated_data =<br>        data[mask]``.<br>    contour : list of 2D numpy arrays, only if ``full_output==True``<br>        List of 2D numpy array(s) of x-y coordinates tracing out<br>        the edge of the gated region.<br><br>    Raises<br>    ------<br>    ValueError<br>        If more or less than 2 channels are specified.<br>    ValueError<br>        If `data` has less than 2 dimensions or less than 2 events.<br>    Exception<br>        If an unrecognized matplotlib Path code is encountered when<br>        attempting to generate contours.<br><br>    Notes<br>    -----<br>    The algorithm for gating based on density works as follows:<br><br>        1) Calculate 2D histogram of `data` in the specified channels.<br>        2) Map each event from `data` to its histogram bin (implicitly<br>           gating out any events which exist outside specified `bins`).<br>        3) Use `gate_fraction` to determine number of events to retain<br>           (rounded up). Only events which are not implicitly gated out<br>           are considered.<br>        4) Smooth 2D histogram using a 2D Gaussian filter.<br>        5) Normalize smoothed histogram to obtain valid probability mass<br>           function (PMF).<br>        6) Sort bins by probability.<br>        7) Accumulate events (starting with events belonging to bin with<br>           highest probability ("densest") and proceeding to events<br>           belonging to bins with lowest probability) until at least the<br>           desired number of events is achieved. While the algorithm<br>           attempts to get as close to `gate_fraction` fraction of events<br>           as possible, more events may be retained based on how many<br>           events fall into each histogram bin (since entire bins are<br>           retained at a time, not individual events).<br><br>    """<br><br>    # Extract channels in which to gate<br>    if len(channels) != 2:<br>        raise ValueError('2 channels should be specified')<br>    data_ch = data[:,channels]<br>    if data_ch.ndim == 1:<br>        data_ch = data_ch.reshape((-1,1))<br><br>    # Check gating fraction<br>    if gate_fraction < 0 or gate_fraction  1:<br>        raise ValueError('gate fraction should be between 0 and 1, inclusive')<br><br>    # Check dimensions<br>    if data_ch.ndim < 2:<br>        raise ValueError('data should have at least 2 dimensions')<br>    if data_ch.shape[0] <= 1:<br>        raise ValueError('data should have more than one event')<br><br>    # Build output namedtuple if necessary<br>    if full_output:<br>        Density2dGateOutput = collections.namedtuple(<br>            'Density2dGateOutput',<br>            ['gated_data', 'mask', 'contour'])<br><br>    # If ``data_ch.hist_bins()`` exists, obtain bin edges from it if<br>    # necessary.<br>    if hasattr(data_ch, 'hist_bins') and \<br>            hasattr(data_ch.hist_bins, '__call__'):<br>        # Check whether `bins` contains information for one or two axes<br>        if hasattr(bins, '__iter__') and len(bins)==2:<br>            # `bins` contains separate information for both axes<br>            # If bins for the X axis is not an iterable, get bin edges from<br>            # ``data_ch.hist_bins()``.<br>            if not hasattr(bins[0], '__iter__'):<br>                bins[0] = data_ch.hist_bins(channels=0,<br>                                            nbins=bins[0],<br>                                            scale=xscale)<br>            # If bins for the Y axis is not an iterable, get bin edges from<br>            # ``data_ch.hist_bins()``.<br>            if not hasattr(bins[1], '__iter__'):<br>                bins[1] = data_ch.hist_bins(channels=1,<br>                                            nbins=bins[1],<br>                                            scale=yscale)<br>        else:<br>            # `bins` contains information for one axis, which will be used<br>            # twice.<br>            # If bins is not an iterable, get bin edges from<br>            # ``data_ch.hist_bins()``.<br>            if not hasattr(bins, '__iter__'):<br>                bins = [data_ch.hist_bins(channels=0,<br>                                          nbins=bins,<br>                                          scale=xscale),<br>                        data_ch.hist_bins(channels=1,<br>                                          nbins=bins,<br>                                          scale=yscale)]<br><br>    # Make 2D histogram<br>    H,xe,ye = np.histogram2d(data_ch[:,0], data_ch[:,1], bins=bins)<br><br>    # Map each event to its histogram bin by sorting events into a 2D array of<br>    # lists which mimics the histogram.<br>    #<br>    # Use np.digitize to calculate the histogram bin index for each event<br>    # given the histogram bin edges. Note that the index returned by<br>    # np.digitize is such that bins[i-1] <= x < bins[i], whereas indexing the<br>    # histogram will result in the following: hist[i,j] = bin corresponding to<br>    # xedges[i] <= x < xedges[i+1] and yedges[i] <= y < yedges[i+1].<br>    # Therefore, we need to subtract 1 from the np.digitize result to be able<br>    # to index into the appropriate bin in the histogram.<br>    event_indices = np.arange(data_ch.shape[0])<br>    x_bin_indices = np.digitize(data_ch[:,0], bins=xe) - 1<br>    y_bin_indices = np.digitize(data_ch[:,1], bins=ye) - 1<br><br>    # In the current version of numpy, there exists a disparity in how<br>    # np.histogram and np.digitize treat the rightmost bin edge (np.digitize<br>    # is not the strict inverse of np.histogram). Specifically, np.histogram<br>    # treats the rightmost bin interval as fully closed (rightmost bin edge is<br>    # included in rightmost bin), whereas np.digitize treats all bins as<br>    # half-open (you can specify which side is closed and which side is open;<br>    # `right` parameter). The expected behavior for this gating function is to<br>    # mimic np.histogram behavior, so we must reconcile this disparity.<br>    x_bin_indices[data_ch[:,0] == xe[-1]] = len(xe)-2<br>    y_bin_indices[data_ch[:,1] == ye[-1]] = len(ye)-2<br><br>    # Ignore (gate out) events which exist outside specified bins.<br>    # `np.digitize()-1` will assign events less than `bins` to bin "-1" and<br>    # events greater than `bins` to len(bins)-1.<br>    outlier_mask = (<br>        (x_bin_indices == -1) |<br>        (x_bin_indices == len(xe)-1) |<br>        (y_bin_indices == -1) |<br>        (y_bin_indices == len(ye)-1))<br><br>    event_indices = event_indices[~outlier_mask]<br>    x_bin_indices = x_bin_indices[~outlier_mask]<br>    y_bin_indices = y_bin_indices[~outlier_mask]<br><br>    # Create a 2D array of lists mimicking the histogram to accumulate events<br>    # associated with each bin.<br>    filler = np.frompyfunc(lambda x: list(), 1, 1)<br>    H_events = np.empty_like(H, dtype=np.object)<br>    filler(H_events, H_events)<br><br>    for event_idx, x_bin_idx, y_bin_idx in \<br>            zip(event_indices, x_bin_indices, y_bin_indices):<br>        H_events[x_bin_idx, y_bin_idx].append(event_idx)<br><br>    # Determine number of events to keep. Only consider events which have not<br>    # been thrown out as outliers.<br>    n = int(np.ceil(gate_fractionfloat(len(event_indices))))<br><br>    # n = 0 edge case (e.g. if gate_fraction = 0.0); incorrectly handled below<br>    if n == 0:<br>        mask = np.zeros(shape=data_ch.shape[0], dtype=bool)<br>        gated_data = data[mask]<br>        if full_output:<br>            return Density2dGateOutput(<br>                gated_data=gated_data, mask=mask, contour=[])<br>        else:<br>            return gated_data<br><br>    # Smooth 2D histogram<br>    sH = scipy.ndimage.filters.gaussian_filter(<br>        H,<br>        sigma=sigma,<br>        order=0,<br>        mode='constant',<br>        cval=0.0,<br>        truncate=6.0)<br><br>    # Normalize smoothed histogram to make it a valid probability mass function<br>    D = sH / np.sum(sH)<br><br>    # Sort bins by density<br>    vD = D.ravel()<br>    vH = H.ravel()<br>    sidx = np.argsort(vD)[::-1]<br>    svH = vH[sidx]  # linearized counts array sorted by density<br><br>    # Find minimum number of accepted bins needed to reach specified number<br>    # of events<br>    csvH = np.cumsum(svH)<br>    Nidx = np.nonzero(csvH = n)[0][0]    # we want to include this index<br><br>    # Get indices of events to keep<br>    vH_events = H_events.ravel()<br>    accepted_indices = vH_events[sidx[:(Nidx+1)]]<br>    accepted_indices = np.array([item       # flatten list of lists<br>                                 for sublist in accepted_indices<br>                                 for item in sublist])<br>    accepted_indices = np.sort(accepted_indices)<br><br>    # Convert list of accepted indices to boolean mask array<br>    mask = np.zeros(shape=data.shape[0], dtype=bool)<br>    mask[accepted_indices] = True<br><br>    gated_data = data[mask]<br><br>    if full_output:<br>        # Use scikit-image to find the contour of the gated region<br>        #<br>        # To find the contour of the gated region, values in the 2D probability<br>        # mass function ``D`` are used to trace contours at the level of the<br>        # probability associated with the last accepted bin, ``vD[sidx[Nidx]]``.<br><br>        # find_contours() specifies contours as collections of row and column<br>        # indices into the density matrix. The row or column index may be<br>        # interpolated (i.e. non-integer) for greater precision.<br>        contours_ij = skimage.measure.find_contours(D, vD[sidx[Nidx]])<br><br>        # Map contours from indices into density matrix to histogram x and y<br>        # coordinate spaces (assume values in the density matrix are associated<br>        # with histogram bin centers).<br>        xc = (xe[:-1] + xe[1:]) / 2.0   # x-axis bin centers<br>        yc = (ye[:-1] + ye[1:]) / 2.0   # y-axis bin centers<br><br>        contours = [np.array([np.interp(contour_ij[:,0],<br>                                        np.arange(len(xc)),<br>                                        xc),<br>                              np.interp(contour_ij[:,1],<br>                                        np.arange(len(yc)),<br>                                        yc)]).T<br>                    for contour_ij in contours_ij]<br><br>        return Density2dGateOutput(<br>            gated_data=gated_data, mask=mask, contour=contours)<br>    else:<br>        return gated_data


## Ground Truth

### GROUND TRUTH 0, ranked 5, leetcode/leetcode_699.txt
> def fallingSquares(positions):<br>    """There are several squares being dropped onto the X-axis of a 2D plane.<br><br>You are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.<br><br>Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.<br><br>After each square is dropped, you must record the height of the current tallest stack of squares.<br><br>Return _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.<br><br>Example 1:<br><br>Input: positions = \[\[1,2\],\[2,3\],\[6,1\]\]<br>Output: \[2,5,5\]<br>Explanation:<br>After the first drop, the tallest stack is square 1 with a height of 2.<br>After the second drop, the tallest stack is squares 1 and 2 with a height of 5.<br>After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.<br>Thus, we return an answer of \[2, 5, 5\].<br><br>Example 2:<br><br>Input: positions = \[\[100,100\],\[200,100\]\]<br>Output: \[100,100\]<br>Explanation:<br>After the first drop, the tallest stack is square 1 with a height of 100.<br>After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.<br>Thus, we return an answer of \[100, 100\].<br>Note that square 2 only brushes the right side of square 1, which does not count as landing on it.<br><br>Constraints:<br><br>   `1 <= positions.length <= 1000`<br>   `1 <= lefti <= 108`<br>   `1 <= sideLengthi <= 106`"""<br><br>    ans = []<br>    intervals = []<br><br>    for p in positions:<br>        L, size = p<br>        R = L + size<br>        h = size<br>        for h2, R2 in intervals:<br>            if R2  L and R  R2:<br>                h = max(h, size + h2)<br><br>        maxHeight = max((h2 for h2, R2 in intervals), default=0)<br>        ans.append(max(maxHeight, h))<br>        intervals.append((h, R))<br><br>    return ans

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_2381.txt
> def shiftCharacters(s: str, shifts: List[List[int]]) - str:<br>    """You are given a string `s` of lowercase English letters and a 2D integer array `shifts` where `shifts[i] = [starti, endi, directioni]`. For every `i`, shift the characters in `s` from the index `starti` to the index `endi` (inclusive) forward if `directioni = 1`, or shift the characters backward if `directioni = 0`.<br><br>Shifting a character forward means replacing it with the next letter in the alphabet (wrapping around so that `'z'` becomes `'a'`). Similarly, shifting a character backward means replacing it with the previous letter in the alphabet (wrapping around so that `'a'` becomes `'z'`).<br><br>Return _the final string after all such shifts to_ `s` _are applied_.<br><br>Example 1:<br><br>Input: s =  "abc ", shifts = \[\[0,1,0\],\[1,2,1\],\[0,2,1\]\]<br>Output:  "ace "<br>Explanation: Firstly, shift the characters from index 0 to index 1 backward. Now s =  "zac ".<br>Secondly, shift the characters from index 1 to index 2 forward. Now s =  "zbd ".<br>Finally, shift the characters from index 0 to index 2 forward. Now s =  "ace ".<br><br>Example 2:<br><br>Input: s =  "dztz ", shifts = \[\[0,0,0\],\[1,1,1\]\]<br>Output:  "catz "<br>Explanation: Firstly, shift the characters from index 0 to index 0 backward. Now s =  "cztz ".<br>Finally, shift the characters from index 1 to index 1 forward. Now s =  "catz ".<br><br>Constraints:<br><br>   `1 <= s.length, shifts.length <= 5  104`<br>   `shifts[i].length == 3`<br>   `0 <= starti <= endi < s.length`<br>   `0 <= directioni <= 1`<br>   `s` consists of lowercase English letters."""<br><br>    shift_values = [0]  len(s)<br>    for shift in shifts:<br>        start, end, direction = shift<br>        value = 1 if direction == 1 else -1<br>        shift_values[start] += value<br>        if end + 1 < len(s):<br>            shift_values[end + 1] -= value<br><br>    for i in range(1, len(s)):<br>        shift_values[i] += shift_values[i - 1]<br><br>    return ''.join(chr((ord(s[i]) - ord('a') + shift_values[i]) % 26 + ord('a')) for i in range(len(s)))
