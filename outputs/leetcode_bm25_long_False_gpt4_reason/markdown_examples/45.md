# Query `45`

## Original Question

*You are given an undirected graph (the "original graph ") with `n` nodes labeled from `0` to `n - 1`. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.

The graph is given as a 2D array of `edges` where `edges[i] = [ui, vi, cnti]` indicates that there is an edge between nodes `ui` and `vi` in the original graph, and `cnti` is the total number of new nodes that you will subdivide the edge into. Note that `cnti == 0` means you will not subdivide the edge.

To subdivide the edge `[ui, vi]`, replace it with `(cnti + 1)` new edges and `cnti` new nodes. The new nodes are `x1`, `x2`, ..., `xcnti`, and the new edges are `[ui, x1]`, `[x1, x2]`, `[x2, x3]`, ..., `[xcnti-1, xcnti]`, `[xcnti, vi]`.

In this new graph, you want to know how many nodes are reachable from the node `0`, where a node is reachable if the distance is `maxMoves` or less.

Given the original graph and `maxMoves`, return _the number of nodes that are reachable from node_ `0` _in the new graph_.

Example 1:

Input: edges = \[\[0,1,10\],\[0,2,1\],\[1,2,2\]\], maxMoves = 6, n = 3
Output: 13
Explanation: The edge subdivisions are shown in the image above.
The nodes that are reachable are highlighted in yellow.

Example 2:

Input: edges = \[\[0,1,4\],\[1,2,6\],\[0,2,8\],\[1,3,1\]\], maxMoves = 10, n = 4
Output: 23

Example 3:

Input: edges = \[\[1,2,4\],\[1,4,5\],\[1,3,1\],\[2,3,4\],\[3,4,5\]\], maxMoves = 17, n = 5
Output: 1
Explanation: Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.

Constraints:

   `0 <= edges.length <= min(n  (n - 1) / 2, 104)`
   `edges[i].length == 3`
   `0 <= ui < vi < n`
   There are no multiple edges in the graph.
   `0 <= cnti <= 104`
   `0 <= maxMoves <= 109`
   `1 <= n <= 3000`*

## gpt4 Reasoning

```markdown
The essential problem here is to calculate the number of nodes in a transformed (subdivided) graph that are reachable from node 0 within a certain number of moves (maxMoves). The transformation involves subdividing each edge of the original graph into multiple edges by inserting new nodes. The reachability of a node is defined by the distance from node 0 being less than or equal to maxMoves.

To solve this problem, we need to consider the following steps and relevant information:

### 1. Construct the New Graph
- **Subdivision of Edges:** For each edge in the original graph, we add `cnti` new nodes and replace the original edge with `(cnti + 1)` new edges. This process increases the total number of nodes and edges in the graph.
- **New Node Labeling:** Since the original graph has nodes labeled from `0` to `n-1`, new nodes can be labeled starting from `n` to avoid conflicts.
- **Graph Representation:** A suitable representation (e.g., adjacency list) is needed to efficiently store and traverse the new graph.

### 2. Calculate Reachability
- **Breadth-First Search (BFS) or Dijkstra's Algorithm:** Since we're dealing with distances and not just connectivity, Dijkstra's algorithm seems more appropriate due to varying edge lengths (represented by the number of new nodes between original nodes). However, since all edges have the same "weight" (1 move between consecutive nodes), a modified BFS could also be efficient.
- **Initialization:** Start from node 0 and initialize its distance to 0. For all other nodes, the distance is initially infinite.
- **Traversal:** Update the distance for each reachable node. If a node's distance from node 0 is less than or equal to maxMoves, it's considered reachable.
- **Counting Reachable Nodes:** As we traverse, we keep a count of nodes that meet the reachability criteria.

### 3. Edge Cases and Constraints
- **Disconnected Node 0:** If node 0 is not connected to any other node, only node 0 is reachable.
- **Large maxMoves:** If maxMoves is very large, potentially all nodes in the new graph are reachable.
- **Efficiency:** Given the constraints (up to 3000 nodes and 10^4 subdivisions), the algorithm needs to be efficient. Preprocessing the edges to minimize unnecessary subdivisions (if maxMoves is small) could be a performance optimization.

### 4. Implementation Sketch
1. **Preprocess Edges:** For each edge, create the necessary subdivisions and update the graph representation.
2. **Traversal:** Use a priority queue for Dijkstra's algorithm or a queue for BFS to traverse the graph from node 0, updating distances and counting reachable nodes.
3. **Return the Count:** After traversal, return the total count of reachable nodes.

This approach addresses the essential problem by focusing on constructing the new graph with subdivided edges and then efficiently calculating reachability from node 0 within the given move limit.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_576.txt
> def findPaths(m, n, maxMove, startRow, startColumn):               <br>    """There is an `m x n` grid with a ball. The ball is initially at the position `[startRow, startColumn]`. You are allowed to move the ball to one of the four adjacent cells in the grid (possibly out of the grid crossing the grid boundary). You can apply at most `maxMove` moves to the ball.<br><br>Given the five integers `m`, `n`, `maxMove`, `startRow`, `startColumn`, return the number of paths to move the ball out of the grid boundary. Since the answer can be very large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: m = 2, n = 2, maxMove = 2, startRow = 0, startColumn = 0<br>Output: 6<br><br>Example 2:<br><br>Input: m = 1, n = 3, maxMove = 3, startRow = 0, startColumn = 1<br>Output: 12<br><br>Constraints:<br><br>   `1 <= m, n <= 50`<br>   `0 <= maxMove <= 50`<br>   `0 <= startRow < m`<br>   `0 <= startColumn < n`"""<br><br>    MOD = 109 + 7                     <br>    dp = [[[0] n for _ in range(m)] for _ in range(maxMove + 1)]<br>    moves = ((-1, 0), (1, 0), (0, -1), (0, 1))<br><br>    for k in range(1, maxMove + 1):                                <br>        for i in range(m):                                         <br>            for j in range(n):                                           <br>                for move in moves:              <br>                    ni, nj = i + move[0], j + move[1]<br>                    if ni < 0 or ni = m or nj < 0 or nj = n:                                 <br>                        dp[k][i][j] = (dp[k][i][j] + 1) % MOD          <br>                    else:<br>                        dp[k][i][j] = (dp[k][i][j] + dp[k - 1][ni][nj]) % MOD<br><br>    return dp[maxMove][startRow][startColumn]

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_236897.txt
> def search(self, source, destination = None, display = None,<br>               component = None, q = None,<br>               algo = 'DFS', reverse = False, kargs):<br>        '''<br>        API: search(self, source, destination = None, display = None,<br>               component = None, q = Stack(),<br>               algo = 'DFS', reverse = False, kargs)<br>        Description:<br>        Generic search method. Changes behavior (dfs,bfs,dijkstra,prim)<br>        according to algo argument.<br>        if destination is not specified:<br>           This method determines all nodes reachable from "source" ie. creates<br>           precedence tree and returns it (dictionary).<br>        if destionation is given:<br>           If there exists a path from "source" to "destination" it will return<br>           list of the nodes is this path. If there is no such path, it will<br>           return the precedence tree constructed from source (dictionary).<br>        Optionally, it marks all nodes reachable from "source" with a component<br>        number. The variable "q" determines the order in which the nodes are<br>        searched.<br>        Input:<br>            source: Search starts from node with this name.<br>            destination: Destination node name.<br>            display: Display method.<br>            algo: Algortihm that specifies search. Available algortihms are<br>            'DFS', 'BFS', 'Dijkstra' and 'Prim'.<br>            reverse: Search goes in reverse arc directions if True.<br>            kargs: Additional keyword arguments.<br>        Post:<br>            Nodes will have 'component' attribute that will have component<br>            number as value (if component argument provided). Color attribute<br>            of nodes and edges may change.<br>        Return:<br>            Returns predecessor tree in dictionary form if destination is<br>            not specified, returns list of node names in the path from source<br>            to destionation if destionation is specified and there is a path.<br>            If there is no path returns predecessor tree in dictionary form.<br>            See description section.<br>        '''<br>        if display == None:<br>            display = self.attr['display']<br>        else:<br>            self.set_display_mode(display)<br>        if algo == 'DFS':<br>            if q is None:<br>                q = Stack()<br>            self.get_node(source).set_attr('component', component)<br>        elif algo == 'BFS' or algo == 'UnweightedSPT':<br>            if q is None:<br>                q = Queue()<br>            self.get_node(source).set_attr('component', component)<br>        elif algo == 'Dijkstra' or algo == 'Prim':<br>            if q is None:<br>                q = PriorityQueue()<br>        else:<br>            print("Unknown search algorithm...exiting")<br>            return<br>        neighbors = self.neighbors<br>        if self.graph_type == DIRECTED_GRAPH and reverse:<br>            neighbors = self.in_neighbors<br>        for i in self.get_node_list():<br>            self.get_node(i).set_attr('label', '-')<br>            self.get_node(i).attr.pop('priority', None)<br>            self.get_node(i).set_attr('distance', None)<br>            self.get_node(i).set_attr('color', 'black')<br>            for j in neighbors[i]:<br>                if reverse:<br>                    self.set_edge_attr(j, i, 'color', 'black')<br>                else:<br>                    self.set_edge_attr(i, j, 'color', 'black')<br>        self.display()<br>        pred = {}<br>        self.process_edge_search(None, source, pred, q, component, algo,<br>                                 kargs)<br>        found = True<br>        if source != destination:<br>            found = False<br>        while not q.isEmpty() and not found:<br>            current = q.peek()<br>            if self.get_node(current).get_attr('color') == 'green':<br>                q.remove(current)<br>                continue<br>            self.process_node_search(current, q, kargs)<br>            self.get_node(current).set_attr('color', 'blue')<br>            if current != source:<br>                if reverse:<br>                    self.set_edge_attr(current, pred[current], 'color', 'green')<br>                else:<br>                    self.set_edge_attr(pred[current], current, 'color', 'green')<br>            if current == destination:<br>                found = True<br>                break<br>            self.display()<br>            for n in neighbors[current]:<br>                if self.get_node(n).get_attr('color') != 'green':<br>                    if reverse:<br>                        self.set_edge_attr(n, current, 'color', 'yellow')<br>                    else:<br>                        self.set_edge_attr(current, n, 'color', 'yellow')<br>                    self.display()<br>                    self.process_edge_search(current, n, pred, q, component,<br>                                             algo, kargs)<br>                    if reverse:<br>                        self.set_edge_attr(n, current, 'color', 'black')<br>                    else:<br>                        self.set_edge_attr(current, n, 'color', 'black')<br>            q.remove(current)<br>            self.get_node(current).set_attr('color', 'green')<br>            self.display()<br>        if found:<br>            path = [destination]<br>            current = destination<br>            while current != source:<br>                path.insert(0, pred[current])<br>                current = pred[current]<br>            return path<br>        if destination == None:<br>            return pred<br>        else:<br>            return None

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_236900.txt
> def process_edge_search(self, current, neighbor, pred, q, component, algo,<br>                            kargs):<br>        '''<br>        API: process_edge_search(self, current, neighbor, pred, q, component,<br>                                 algo, kargs)<br>        Description:<br>        Used by search() method. Processes edges according to the underlying<br>        algortihm. User does not need to call this method directly.<br>        Input:<br>            current: Name of the current node.<br>            neighbor: Name of the neighbor node.<br>            pred: Predecessor tree.<br>            q: Data structure that holds nodes to be processed in a queue.<br>            component: component number.<br>            algo: Search algorithm. See search() documentation.<br>            kwargs: Keyword arguments.<br>        Post:<br>            'color', 'distance', 'component' attribute of nodes and edges may<br>            change.<br>        '''<br>        if algo == 'Dijkstra':<br>            return self.process_edge_dijkstra(current, neighbor, pred, q,<br>                                              component)<br>        if algo == 'Prim':<br>            return self.process_edge_prim(current, neighbor, pred, q,<br>                                          component)<br>        neighbor_node = self.get_node(neighbor)<br>        if current == None:<br>            neighbor_node.set_attr('distance', 0)<br>            if isinstance(q, PriorityQueue):<br>                q.push(neighbor, 0)<br>            else:<br>                q.push(neighbor)<br>            if component != None:<br>                neighbor_node.set_attr('component', component)<br>                neighbor_node.set_attr('label', component)<br>            else:<br>                neighbor_node.set_attr('label', 0)<br>            return<br>        if isinstance(q, PriorityQueue):<br>            current_priority = q.get_priority(neighbor)<br>            if algo == 'UnweightedSPT' or algo == 'BFS':<br>                priority = self.get_node(current).get_attr('distance') + 1<br>            if algo == 'DFS':<br>                priority = -self.get_node(current).get_attr('distance') - 1<br>            if current_priority is not None and priority = current_priority:<br>                return<br>            q.push(neighbor, priority)<br>            if algo == 'UnweightedSPT' or algo == 'BFS':<br>                neighbor_node.set_attr('distance', priority)<br>            if algo == 'DFS':<br>                neighbor_node.set_attr('depth', -priority)<br>        else:<br>            distance = self.get_node(current).get_attr('distance') + 1<br>            if ((algo == 'UnweightedSPT' or algo == 'BFS') and<br>                neighbor_node.get_attr('distance') is not None):<br>                return<br>            neighbor_node.set_attr('distance', distance)<br>            neighbor_node.set_attr('label', str(distance))<br>            q.push(neighbor)<br>        pred[neighbor] = current<br>        neighbor_node.set_attr('color', 'red')<br>        if component != None:<br>            neighbor_node.set_attr('component', component)<br>            neighbor_node.set_attr('label', component)<br>        self.display()

### DOC[4] (IRRELEVANT) leetcode/leetcode_918.txt
> from heapq import heappush, heappop<br>    """Given a circular integer array `nums` of length `n`, return _the maximum possible sum of a non-empty subarray of_ `nums`.<br><br>A circular array means the end of the array connects to the beginning of the array. Formally, the next element of `nums[i]` is `nums[(i + 1) % n]` and the previous element of `nums[i]` is `nums[(i - 1 + n) % n]`.<br><br>A subarray may only include each element of the fixed buffer `nums` at most once. Formally, for a subarray `nums[i], nums[i + 1], ..., nums[j]`, there does not exist `i <= k1`, `k2 <= j` with `k1 % n == k2 % n`.<br><br>Example 1:<br><br>Input: nums = \[1,-2,3,-2\]<br>Output: 3<br>Explanation: Subarray \[3\] has maximum sum 3.<br><br>Example 2:<br><br>Input: nums = \[5,-3,5\]<br>Output: 10<br>Explanation: Subarray \[5,5\] has maximum sum 5 + 5 = 10.<br><br>Example 3:<br><br>Input: nums = \[-3,-2,-3\]<br>Output: -2<br>Explanation: Subarray \[-2\] has maximum sum -2.<br><br>Constraints:<br><br>   `n == nums.length`<br>   `1 <= n <= 3  104`<br>   `-3  104 <= nums[i] <= 3  104`"""<br><br><br>def reachableNodes(edges, maxMoves, n):<br>    graph = [[] for _ in range(n)]<br>    for u, v, cnt in edges:<br>        graph[u].append((v, cnt + 1))<br>        graph[v].append((u, cnt + 1))<br><br>    visited = set()<br>    pq = [(-maxMoves, 0)]<br><br>    while pq:<br>        moves_left, node = heappop(pq)<br><br>        if node in visited:<br>            continue<br>        visited.add(node)<br><br>        for next_node, moves_needed in graph[node]:<br>            moves_left_after = moves_left - moves_needed<br>            if next_node not in visited and moves_left_after  0:<br>                heappush(pq, (moves_left_after, next_node))<br><br>    return len(visited)

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_77907.txt
> def extract(features, groups,<br>            weight_method=default_weight_method,<br>            num_bins=default_num_bins,<br>            edge_range=default_edge_range,<br>            trim_outliers=default_trim_behaviour,<br>            trim_percentile=default_trim_percentile,<br>            use_original_distribution=False,<br>            relative_to_all=False,<br>            asymmetric=False,<br>            return_networkx_graph=default_return_networkx_graph,<br>            out_weights_path=default_out_weights_path):<br>    """<br>    Extracts the histogram-distance weighted adjacency matrix.<br><br>    Parameters<br>    ----------<br>    features : ndarray or str<br>        1d array of scalar values, either provided directly as a 1d numpy array,<br>        or as a path to a file containing these values<br><br>    groups : ndarray or str<br>        Membership array of same length as `features`, each value specifying which group that particular node belongs to.<br>        Input can be either provided directly as a 1d numpy array,or as a path to a file containing these values.<br><br>        For example, if you have cortical thickness values for 1000 vertices (`features` is ndarray of length 1000),<br>        belonging to 100 patches, the groups array (of length 1000) could  have numbers 1 to 100 (number of unique values)<br>        specifying which element belongs to which cortical patch.<br><br>        Grouping with numerical values (contiguous from 1 to num_patches) is strongly recommended for simplicity,<br>        but this could also be a list of strings of length p, in which case a tuple is returned,<br>        identifying which weight belongs to which pair of patches.<br><br>    weight_method : string or callable, optional<br>        Type of distance (or metric) to compute between the pair of histograms.<br>        It can either be a string identifying one of the weights implemented below, or a valid callable.<br><br>        If a string, it must be one of the following methods:<br><br>        - 'chebyshev'<br>        - 'chebyshev_neg'<br>        - 'chi_square'<br>        - 'correlate'<br>        - 'correlate_1'<br>        - 'cosine'<br>        - 'cosine_1'<br>        - 'cosine_2'<br>        - 'cosine_alt'<br>        - 'euclidean'<br>        - 'fidelity_based'<br>        - 'histogram_intersection'<br>        - 'histogram_intersection_1'<br>        - 'jensen_shannon'<br>        - 'kullback_leibler'<br>        - 'manhattan'<br>        - 'minowski'<br>        - 'noelle_1'<br>        - 'noelle_2'<br>        - 'noelle_3'<br>        - 'noelle_4'<br>        - 'noelle_5'<br>        - 'relative_bin_deviation'<br>        - 'relative_deviation'<br><br>        Note only the following are metrics:<br><br>        - 'manhattan'<br>        - 'minowski'<br>        - 'euclidean'<br>        - 'noelle_2'<br>        - 'noelle_4'<br>        - 'noelle_5'<br><br>        The following are semi- or quasi-metrics:<br><br>        - 'kullback_leibler'<br>        - 'jensen_shannon'<br>        - 'chi_square'<br>        - 'chebyshev'<br>        - 'cosine_1'<br>        - 'chebyshev_neg'<br>        - 'correlate_1'<br>        - 'histogram_intersection_1'<br>        - 'relative_deviation'<br>        - 'relative_bin_deviation'<br>        - 'noelle_1'<br>        - 'noelle_3'<br><br>        The following are  classified to be similarity functions:<br><br>        - 'histogram_intersection'<br>        - 'correlate'<br>        - 'cosine'<br>        - 'cosine_2'<br>        - 'cosine_alt'<br>        - 'fidelity_based'<br><br>        Default choice: 'minowski'.<br><br>        The method can also be one of the following identifying metrics that operate on the original data directly -<br>         e.g. difference in the medians coming from the distributions of the pair of ROIs.<br><br>         - 'diff_medians'<br>         - 'diff_means'<br>         - 'diff_medians_abs'<br>         - 'diff_means_abs'<br><br>         Please note this can lead to adjacency matrices that may not be symmetric<br>            e.g. difference metric on two scalars is not symmetric).<br>            In this case, be sure to use the flag: allow_non_symmetric=True<br><br>        If weight_method is a callable, it must two accept two arrays as input and return one scalar as output.<br>            Example: ``diff_in_skew = lambda x, y: abs(scipy.stats.skew(x)-scipy.stats.skew(y))``<br>            NOTE: this method will be applied to histograms (not the original distribution of features from group/ROI).<br>            In order to apply this callable directly on the original distribution (without trimming and histogram binning),<br>            use ``use_original_distribution=True``.<br><br>    num_bins : scalar, optional<br>        Number of bins to use when computing histogram within each patch/group.<br><br>        Note:<br><br>        1) Please ensure same number of bins are used across different subjects<br>        2) histogram shape can vary widely with number of bins (esp with fewer bins in the range of 3-20), and hence the features extracted based on them vary also.<br>        3) It is recommended to study the impact of this parameter on the final results of the experiment.<br><br>        This could also be optimized within an inner cross-validation loop if desired.<br><br>    edge_range : tuple or None<br>        The range of edges within which to bin the given values.<br>        This can be helpful to ensure correspondence across multiple invocations of hiwenet (for different subjects),<br>        in terms of range across all bins as well as individual bin edges.<br>        Default is to automatically compute from the given values.<br><br>        Accepted format:<br><br>            - tuple of finite values: (range_min, range_max)<br>            - None, triggering automatic calculation (default)<br><br>        Notes : when controlling the ``edge_range``, it is not possible trim the tails (e.g. using the parameters<br>        ``trim_outliers`` and ``trim_percentile``) for the current set of features using its own range.<br><br>    trim_outliers : bool, optional<br>        Whether to trim a small percentile of outliers at the edges of feature range,<br>        when features are expected to contain extreme outliers (like 0 or eps or Inf).<br>        This is important to avoid numerical problems and also to stabilize the weight estimates.<br><br>    trim_percentile : float<br>        Small value specifying the percentile of outliers to trim.<br>        Default: 5 (5%). Must be in open interval (0, 100).<br><br>    use_original_distribution : bool, optional<br>        When using a user-defined callable, this flag<br>        1) allows skipping of pre-processing (trimming outliers) and histogram construction,<br>        2) enables the application of arbitrary callable (user-defined) on the original distributions coming from the two groups/ROIs/nodes directly.<br><br>        Example: ``diff_in_medians = lambda x, y: abs(np.median(x)-np.median(y))``<br><br>        This option is valid only when weight_method is a valid callable,<br>            which must take two inputs (possibly of different lengths) and return a single scalar.<br><br>    relative_to_all : bool<br>        Flag to instruct the computation of a grand histogram (distribution pooled from values in all ROIs),<br>        and compute distances (based on distance specified by ``weight_method``) by from each ROI to the grand mean.<br>        This would result in only N distances for N ROIs, instead of the usual N(N-1) pair-wise distances.<br><br>    asymmetric : bool<br>        Flag to identify resulting adjacency matrix is expected to be non-symmetric.<br>        Note: this results in twice the computation time!<br>        Default: False , for histogram metrics implemented here are symmetric.<br><br>    return_networkx_graph : bool, optional<br>        Specifies the need for a networkx graph populated with weights computed. Default: False.<br><br>    out_weights_path : str, optional<br>        Where to save the extracted weight matrix. If networkx output is returned, it would be saved in GraphML format.<br>        Default: nothing saved unless instructed.<br><br>    Returns<br>    -------<br>    edge_weights : ndarray<br>        numpy 2d array of pair-wise edge-weights (of size: num_groups x num_groups),<br>        wherein num_groups is determined by the total number of unique values in `groups`.<br><br>        Note:<br><br>        - Only the upper triangular matrix is filled as the distance between node i and j would be the same as j and i.<br>        - The edge weights from the upper triangular matrix can easily be obtained by<br><br>        .. code-block:: python<br><br>            weights_array = edge_weights[ np.triu_indices_from(edge_weights, 1) ]<br><br>    """<br><br>    # parameter check<br>    features, groups, num_bins, edge_range, group_ids, num_groups, num_links = check_params(<br>            features, groups, num_bins, edge_range, trim_outliers, trim_percentile)<br><br>    weight_func, use_orig_distr, non_symmetric = check_weight_method(weight_method,<br>                                                                     use_original_distribution, asymmetric)<br><br>    # using the same bin edges for all nodes/groups to ensure correspondence<br>    # NOTE: common bin edges is important for the disances to be any meaningful<br>    edges = compute_bin_edges(features, num_bins, edge_range,<br>                              trim_outliers, trim_percentile, use_orig_distr)<br><br>    # handling special<br>    if relative_to_all:<br>        result = non_pairwise.relative_to_all(features, groups, edges, weight_func,<br>                                              use_orig_distr, group_ids, num_groups,<br>                                              return_networkx_graph, out_weights_path)<br>    else:<br>        result = pairwise_extract(features, groups, edges, weight_func, use_orig_distr,<br>                                  group_ids, num_groups, num_links,<br>                                  non_symmetric, return_networkx_graph, out_weights_path)<br><br>    # this can be a networkx graph or numpy array depending on request<br>    return result


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2092.txt
> def find_secret_sharers(n, meetings, first_person):<br>    """You are given an integer `n` indicating there are `n` people numbered from `0` to `n - 1`. You are also given a 0-indexed 2D integer array `meetings` where `meetings[i] = [xi, yi, timei]` indicates that person `xi` and person `yi` have a meeting at `timei`. A person may attend multiple meetings at the same time. Finally, you are given an integer `firstPerson`.<br><br>Person `0` has a secret and initially shares the secret with a person `firstPerson` at time `0`. This secret is then shared every time a meeting takes place with a person that has the secret. More formally, for every meeting, if a person `xi` has the secret at `timei`, then they will share the secret with person `yi`, and vice versa.<br><br>The secrets are shared instantaneously. That is, a person may receive the secret and share it with people in other meetings within the same time frame.<br><br>Return _a list of all the people that have the secret after all the meetings have taken place._ You may return the answer in any order.<br><br>Example 1:<br><br>Input: n = 6, meetings = \[\[1,2,5\],\[2,3,8\],\[1,5,10\]\], firstPerson = 1<br>Output: \[0,1,2,3,5\]<br>Explanation:<br>At time 0, person 0 shares the secret with person 1.<br>At time 5, person 1 shares the secret with person 2.<br>At time 8, person 2 shares the secret with person 3.<br>At time 10, person 1 shares the secret with person 5.​​​​<br>Thus, people 0, 1, 2, 3, and 5 know the secret after all the meetings.<br><br>Example 2:<br><br>Input: n = 4, meetings = \[\[3,1,3\],\[1,2,2\],\[0,3,3\]\], firstPerson = 3<br>Output: \[0,1,3\]<br>Explanation:<br>At time 0, person 0 shares the secret with person 3.<br>At time 2, neither person 1 nor person 2 know the secret.<br>At time 3, person 3 shares the secret with person 0 and person 1.<br>Thus, people 0, 1, and 3 know the secret after all the meetings.<br><br>Example 3:<br><br>Input: n = 5, meetings = \[\[3,4,2\],\[1,2,1\],\[2,3,1\]\], firstPerson = 1<br>Output: \[0,1,2,3,4\]<br>Explanation:<br>At time 0, person 0 shares the secret with person 1.<br>At time 1, person 1 shares the secret with person 2, and person 2 shares the secret with person 3.<br>Note that person 2 can share the secret at the same time as receiving it.<br>At time 2, person 3 shares the secret with person 4.<br>Thus, people 0, 1, 2, 3, and 4 know the secret after all the meetings.<br><br>Constraints:<br><br>   `2 <= n <= 105`<br>   `1 <= meetings.length <= 105`<br>   `meetings[i].length == 3`<br>   `0 <= xi, yi <= n - 1`<br>   `xi != yi`<br>   `1 <= timei <= 105`<br>   `1 <= firstPerson <= n - 1`"""<br><br>    secret_holders = [-1]  n<br>    secret_holders[0] = 0<br>    secret_holders[first_person] = 0<br><br>    meetings.sort(key=lambda x: x[2])<br><br>    for x, y, time in meetings:<br>        if secret_holders[x] != -1 and secret_holders[x] <= time:<br>            secret_holders[y] = time<br>        if secret_holders[y] != -1 and secret_holders[y] <= time:<br>            secret_holders[x] = time<br><br>    return [i for i in range(n) if secret_holders[i] != -1]
