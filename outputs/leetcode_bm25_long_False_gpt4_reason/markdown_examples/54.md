# Query `54`

## Original Question

*You are given an `m x n` `grid` where each cell can have one of three values:

   `0` representing an empty cell,
   `1` representing a fresh orange, or
   `2` representing a rotten orange.

Every minute, any fresh orange that is 4-directionally adjacent to a rotten orange becomes rotten.

Return _the minimum number of minutes that must elapse until no cell has a fresh orange_. If _this is impossible, return_ `-1`.

Example 1:

Input: grid = \[\[2,1,1\],\[1,1,0\],\[0,1,1\]\]
Output: 4

Example 2:

Input: grid = \[\[2,1,1\],\[0,1,1\],\[1,0,1\]\]
Output: -1
Explanation: The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally.

Example 3:

Input: grid = \[\[0,2\]\]
Output: 0
Explanation: Since there are already no fresh oranges at minute 0, the answer is just 0.

Constraints:

   `m == grid.length`
   `n == grid[i].length`
   `1 <= m, n <= 10`
   `grid[i][j]` is `0`, `1`, or `2`.*

## gpt4 Reasoning

```markdown
The essential problem here is to simulate the process of fresh oranges becoming rotten due to their proximity to already rotten oranges and to calculate the minimum time it takes for all possible oranges to become rotten or to determine if there are any oranges that cannot become rotten due to isolation.

### Steps to Solve the Problem

1. **Initialization**: Start by scanning the entire grid to identify the positions of all rotten and fresh oranges. We can use a queue to keep track of the rotten oranges (since they spread the rot), and a counter for the fresh oranges. This initial step is crucial for understanding the state of the grid before the process begins.

2. **Simulation of Rotting Process**: 
   - We will process the rotting in rounds, where each round represents one minute. In each round, we will look at oranges that are currently rotten (those in our queue) and attempt to rot adjacent fresh oranges.
   - For each rotten orange in the queue, we check its 4-directional neighbors. If a neighbor is a fresh orange (`1`), we turn it into a rotten orange (`2`) and add its position to the queue for the next round of processing. We also decrement the fresh orange counter.
   - This step is repeated until either there are no more fresh oranges or the queue of newly rotten oranges is empty (indicating a round where no new oranges were rotted).

3. **Checking for Isolation**: 
   - If, after the process, there are still fresh oranges left (i.e., the fresh orange counter is not zero), it means some oranges are isolated and cannot be reached by the rotting process. In this case, we return `-1`.
   - If all oranges are rotten (the fresh orange counter is zero), we return the number of rounds as the minimum number of minutes needed for all oranges to become rotten.

### Relevant Information

- **4-directional adjacency**: This means an orange can only affect others in its immediate up, down, left, or right positions.
- **Grid dimensions**: The problem specifies the grid can be up to 10x10, meaning the problem is designed to be solvable with brute-force approaches without significant performance concerns.
- **Edge cases**: It's essential to consider edge cases such as grids with no fresh oranges initially (where the answer is `0`) or grids where fresh oranges are completely isolated by empty cells (leading to `-1`).

### Example Analysis

- **Example 1**: Given grid = `[[2,1,1],[1,1,0],[0,1,1]]`, the process unfolds over 4 minutes, with each minute seeing adjacent fresh oranges turn rotten until all reachable ones are rotten. The output is `4`.
- **Example 2**: Given grid = `[[2,1,1],[0,1,1],[1,0,1]]`, the orange at the bottom left is isolated by empty cells and can never become rotten, leading to a `-1` output.
- **Example 3**: Given grid = `[[0,2]]`, there are no fresh oranges to start with, so the process requires `0` minutes, and the output is `0`.

This problem combines elements of breadth-first search (BFS) for spreading the rot across the grid, along with careful accounting of the state of the grid (tracking fresh and rotten oranges). The simulation continues in rounds until either all reachable fresh oranges have turned rotten or it's determined that not all oranges can be rotted, which is a classic problem of simulating a process over time on a discrete grid.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0200
recall_1: 0.5000
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.6131
ndcg_cut_10: 0.6131
ndcg_cut_25: 0.6131
ndcg_cut_50: 0.6131
ndcg_cut_100: 0.7054
map_cut_1: 0.5000
map_cut_5: 0.5000
map_cut_10: 0.5000
map_cut_25: 0.5000
map_cut_50: 0.5000
map_cut_100: 0.5101
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2258.txt
> from collections import deque<br>    """You are given a 0-indexed 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:<br><br>   `0` represents grass,<br>   `1` represents fire,<br>   `2` represents a wall that you and fire cannot pass through.<br><br>You are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.<br><br>Return _the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can always reach the safehouse regardless of the minutes stayed, return `109`.<br><br>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.<br><br>A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).<br><br>Example 1:<br><br>Input: grid = \[\[0,2,0,0,0,0,0\],\[0,0,0,2,2,1,0\],\[0,2,0,0,1,2,0\],\[0,0,2,2,2,0,2\],\[0,0,0,0,0,0,0\]\]<br>Output: 3<br>Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.<br>You will still be able to safely reach the safehouse.<br>Staying for more than 3 minutes will not allow you to safely reach the safehouse.<br><br>Example 2:<br><br>Input: grid = \[\[0,0,0,0\],\[0,1,2,0\],\[0,2,0,0\]\]<br>Output: -1<br>Explanation: The figure above shows the scenario where you immediately move towards the safehouse.<br>Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.<br>Thus, -1 is returned.<br><br>Example 3:<br><br>Input: grid = \[\[0,0,0\],\[2,2,0\],\[1,2,0\]\]<br>Output: 1000000000<br>Explanation: The figure above shows the initial grid.<br>Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.<br>Thus, 109 is returned.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `2 <= m, n <= 300`<br>   `4 <= m  n <= 2  104`<br>   `grid[i][j]` is either `0`, `1`, or `2`.<br>   `grid[0][0] == grid[m - 1][n - 1] == 0`"""<br><br><br>dx = [0, 1, 0, -1]<br>dy = [1, 0, -1, 0]<br><br>def getMaxSafeMinutes(grid):<br>    m, n = len(grid), len(grid[0])<br>    dist = [[-1 for _ in range(n)] for _ in range(m)]<br>    q = deque()<br><br>    if grid[m - 1][n - 1] != 1:<br>        dist[m - 1][n - 1] = 0<br>        q.append((m - 1, n - 1))<br><br>    while q:<br>        x, y = q.popleft()<br>        for d in range(4):<br>            nx, ny = x + dx[d], y + dy[d]<br>            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:<br>                dist[nx][ny] = dist[x][y] + 1<br>                q.append((nx, ny))<br><br>    if dist[0][0] == -1:<br>        return -1<br><br>    res = 0<br>    for test in range(dist[0][0], int(1e9)):<br>        ok = True<br>        for x in range(m):<br>            for y in range(n):<br>                if grid[x][y] == 1:<br>                    for d in range(4):<br>                        nx, ny = x + dx[d], y + dy[d]<br>                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:<br>                            break<br>                    else:<br>                        ok = False<br>                        break<br>        if ok:<br>            res = test<br>        else:<br>            break<br>    return res

### DOC[2] (IRRELEVANT) leetcode/leetcode_928.txt
> def surfaceArea(grid):<br>    """You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.<br><br>Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.<br><br>Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops.<br><br>We will remove exactly one node from `initial`, completely removing it and any connections from this node to any other node.<br><br>Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.<br><br>Example 1:<br><br>Input: graph = \[\[1,1,0\],\[1,1,0\],\[0,0,1\]\], initial = \[0,1\]<br>Output: 0<br><br>Example 2:<br><br>Input: graph = \[\[1,1,0\],\[1,1,1\],\[0,1,1\]\], initial = \[0,1\]<br>Output: 1<br><br>Example 3:<br><br>Input: graph = \[\[1,1,0,0\],\[1,1,1,0\],\[0,1,1,1\],\[0,0,1,1\]\], initial = \[0,1\]<br>Output: 1<br><br>Constraints:<br><br>   `n == graph.length`<br>   `n == graph[i].length`<br>   `2 <= n <= 300`<br>   `graph[i][j]` is `0` or `1`.<br>   `graph[i][j] == graph[j][i]`<br>   `graph[i][i] == 1`<br>   `1 <= initial.length < n`<br>   `0 <= initial[i] <= n - 1`<br>   All the integers in `initial` are unique."""<br><br>    n = len(grid)<br>    area = 0<br><br>    for i in range(n):<br>        for j in range(n):<br>            if grid[i][j]:<br>                area += 4  grid[i][j] + 2<br>                if i  0:<br>                    area -= 2  min(grid[i][j], grid[i - 1][j])<br>                if j  0:<br>                    area -= 2  min(grid[i][j], grid[i][j - 1])<br><br>    return area

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_239131.txt
> def binary_shrink_old(image, iterations=-1):<br>    """Shrink an image by repeatedly removing pixels which have partners<br>       above, to the left, to the right and below until the image doesn't change<br>       <br>       image - binary image to be manipulated<br>       iterations - # of times to shrink, -1 to shrink until idempotent<br>       <br>       There are horizontal/vertical thinners which detect a pixel on<br>       an edge with an interior pixel either horizontally or vertically<br>       attached like this:<br>       0  0  0<br>       X  1  X<br>       X  1  X<br>       and there are much more specific diagonal thinners which detect<br>       a pixel on the edge of a diagonal, like this:<br>       0  0  0<br>       0  1  0<br>       0  0  1<br>       Rotate each of these 4x to get the four directions for each<br>    """<br>    global binary_shrink_top_right, binary_shrink_bottom_left<br>    if binary_shrink_top_right is None:<br>        #<br>        # None of these patterns can remove both of two isolated<br>        # eight-connected pixels. Taken together, they can remove any<br>        # pixel touching a background pixel.<br>        #<br>        # The top right pixels:<br>        # <br>        # 0xx<br>        # ..0<br>        # ...<br>        #<br>        binary_shrink_top_right = make_table(False,<br>                                             np.array([[0,0,0],<br>                                                       [0,1,0],<br>                                                       [0,1,0]],bool),<br>                                             np.array([[1,1,1],<br>                                                       [0,1,0],<br>                                                       [0,1,0]],bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [0,1,0],<br>                                                        [1,0,0]], bool),<br>                                              np.array([[1,1,1],<br>                                                        [0,1,1],<br>                                                        [1,0,1]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [1,1,0],<br>                                                        [0,0,0]], bool),<br>                                              np.array([[0,0,1],<br>                                                        [1,1,1],<br>                                                        [0,0,1]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [1,1,0],<br>                                                        [0,1,1]], bool),<br>                                              np.array([[0,0,1],<br>                                                        [1,1,1],<br>                                                        [0,1,0]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [0,1,0],<br>                                                        [0,0,1]], bool),<br>                                              np.array([[1,1,1],<br>                                                        [1,1,0],<br>                                                        [1,0,1]], bool))<br>        binary_shrink_top_right &= make_table(False,<br>                                              np.array([[0,0,0],<br>                                                        [0,1,0],<br>                                                        [1,1,1]], bool),<br>                                              np.array([[1,1,1],<br>                                                        [1,1,0],<br>                                                        [0,1,1]], bool))<br>        #<br>        # bottom left pixels<br>        #<br>        # ...<br>        # 0..<br>        # xx0<br>        binary_shrink_bottom_left = make_table(False,<br>                                               np.array([[0,1,0],<br>                                                         [0,1,0],<br>                                                         [0,0,0]],bool),<br>                                               np.array([[0,1,0],<br>                                                         [0,1,0],<br>                                                         [1,1,1]],bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[0,0,1],<br>                                                          [0,1,0],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,0,1],<br>                                                          [1,1,0],<br>                                                          [1,1,1]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[0,0,0],<br>                                                          [0,1,1],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,0,0],<br>                                                          [1,1,1],<br>                                                          [1,0,0]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[1,1,0],<br>                                                          [0,1,1],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[0,1,0],<br>                                                          [1,1,1],<br>                                                          [1,0,0]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[1,0,0],<br>                                                          [0,1,0],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,0,1],<br>                                                          [0,1,1],<br>                                                          [1,1,1]], bool))<br>        binary_shrink_bottom_left &= make_table(False,<br>                                                np.array([[1,1,1],<br>                                                          [0,1,0],<br>                                                          [0,0,0]], bool),<br>                                                np.array([[1,1,0],<br>                                                          [0,1,1],<br>                                                          [1,1,1]], bool))<br>    orig_image = image<br>    index_i, index_j, image = prepare_for_index_lookup(image, False)<br>    if iterations == -1:<br>        iterations = len(index_i)<br>    for i in range(iterations):<br>        pixel_count = len(index_i)<br>        for table in (binary_shrink_top_right, <br>                      binary_shrink_bottom_left):<br>            index_i, index_j = index_lookup(index_i, index_j, <br>                                            image, table, 1)<br>        if len(index_i) == pixel_count:<br>            break<br>    image = extract_from_image_lookup(orig_image, index_i, index_j)<br>    return image

### DOC[4] (IRRELEVANT) leetcode/leetcode_1001.txt
> def repeatedNTimes(nums):<br>    """There is a 2D `grid` of size `n x n` where each cell of this grid has a lamp that is initially turned off.<br><br>You are given a 2D array of lamp positions `lamps`, where `lamps[i] = [rowi, coli]` indicates that the lamp at `grid[rowi][coli]` is turned on. Even if the same lamp is listed more than once, it is turned on.<br><br>When a lamp is turned on, it illuminates its cell and all other cells in the same row, column, or diagonal.<br><br>You are also given another 2D array `queries`, where `queries[j] = [rowj, colj]`. For the `jth` query, determine whether `grid[rowj][colj]` is illuminated or not. After answering the `jth` query, turn off the lamp at `grid[rowj][colj]` and its 8 adjacent lamps if they exist. A lamp is adjacent if its cell shares either a side or corner with `grid[rowj][colj]`.<br><br>Return _an array of integers_ `ans`_,_ _where_ `ans[j]` _should be_ `1` _if the cell in the_ `jth` _query was illuminated, or_ `0` _if the lamp was not._<br><br>Example 1:<br><br>Input: n = 5, lamps = \[\[0,0\],\[4,4\]\], queries = \[\[1,1\],\[1,0\]\]<br>Output: \[1,0\]<br>Explanation: We have the initial grid with all lamps turned off. In the above picture we see the grid after turning on the lamp at grid\[0\]\[0\] then turning on the lamp at grid\[4\]\[4\].<br>The 0th query asks if the lamp at grid\[1\]\[1\] is illuminated or not (the blue square). It is illuminated, so set ans\[0\] = 1. Then, we turn off all lamps in the red square.<br> <br>The 1st query asks if the lamp at grid\[1\]\[0\] is illuminated or not (the blue square). It is not illuminated, so set ans\[1\] = 0. Then, we turn off all lamps in the red rectangle.<br> <br><br>Example 2:<br><br>Input: n = 5, lamps = \[\[0,0\],\[4,4\]\], queries = \[\[1,1\],\[1,1\]\]<br>Output: \[1,1\]<br><br>Example 3:<br><br>Input: n = 5, lamps = \[\[0,0\],\[0,4\]\], queries = \[\[0,4\],\[0,1\],\[1,4\]\]<br>Output: \[1,1,0\]<br><br>Constraints:<br><br>   `1 <= n <= 109`<br>   `0 <= lamps.length <= 20000`<br>   `0 <= queries.length <= 20000`<br>   `lamps[i].length == 2`<br>   `0 <= rowi, coli < n`<br>   `queries[j].length == 2`<br>   `0 <= rowj, colj < n`"""<br><br>    hash_map = {}<br>    for num in nums:<br>        if num in hash_map:<br>            return num<br>        else:<br>            hash_map[num] = 1

### DOC[5] (IRRELEVANT) leetcode/leetcode_924.txt
> def fair_candy_swap(aliceSizes, bobSizes):<br>    """You are given a network of `n` nodes represented as an `n x n` adjacency matrix `graph`, where the `ith` node is directly connected to the `jth` node if `graph[i][j] == 1`.<br><br>Some nodes `initial` are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.<br><br>Suppose `M(initial)` is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from `initial`.<br><br>Return the node that, if removed, would minimize `M(initial)`. If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.<br><br>Note that if a node was removed from the `initial` list of infected nodes, it might still be infected later due to the malware spread.<br><br>Example 1:<br><br>Input: graph = \[\[1,1,0\],\[1,1,0\],\[0,0,1\]\], initial = \[0,1\]<br>Output: 0<br><br>Example 2:<br><br>Input: graph = \[\[1,0,0\],\[0,1,0\],\[0,0,1\]\], initial = \[0,2\]<br>Output: 0<br><br>Example 3:<br><br>Input: graph = \[\[1,1,1\],\[1,1,1\],\[1,1,1\]\], initial = \[1,2\]<br>Output: 1<br><br>Constraints:<br><br>   `n == graph.length`<br>   `n == graph[i].length`<br>   `2 <= n <= 300`<br>   `graph[i][j]` is `0` or `1`.<br>   `graph[i][j] == graph[j][i]`<br>   `graph[i][i] == 1`<br>   `1 <= initial.length <= n`<br>   `0 <= initial[i] <= n - 1`<br>   All the integers in `initial` are unique."""<br><br>    aliceTotal, bobTotal = sum(aliceSizes), sum(bobSizes)<br>    delta = (bobTotal - aliceTotal) // 2<br>    for a in aliceSizes:<br>        for b in bobSizes:<br>            if a + delta == b:<br>                return [a, b]<br>    return []


## Ground Truth

### GROUND TRUTH 0, ranked 98, leetcode/leetcode_2101.txt
> def can_reach_bottom(grid, row, col):<br>    """You are given a list of bombs. The range of a bomb is defined as the area where its effect can be felt. This area is in the shape of a circle with the center as the location of the bomb.<br><br>The bombs are represented by a 0-indexed 2D integer array `bombs` where `bombs[i] = [xi, yi, ri]`. `xi` and `yi` denote the X-coordinate and Y-coordinate of the location of the `ith` bomb, whereas `ri` denotes the radius of its range.<br><br>You may choose to detonate a single bomb. When a bomb is detonated, it will detonate all bombs that lie in its range. These bombs will further detonate the bombs that lie in their ranges.<br><br>Given the list of `bombs`, return _the maximum number of bombs that can be detonated if you are allowed to detonate only one bomb_.<br><br>Example 1:<br><br>Input: bombs = \[\[2,1,3\],\[6,1,4\]\]<br>Output: 2<br>Explanation:<br>The above figure shows the positions and ranges of the 2 bombs.<br>If we detonate the left bomb, the right bomb will not be affected.<br>But if we detonate the right bomb, both bombs will be detonated.<br>So the maximum bombs that can be detonated is max(1, 2) = 2.<br><br>Example 2:<br><br>Input: bombs = \[\[1,1,5\],\[10,10,5\]\]<br>Output: 1<br>Explanation:<br>Detonating either bomb will not detonate the other bomb, so the maximum number of bombs that can be detonated is 1.<br><br>Example 3:<br><br>Input: bombs = \[\[1,2,3\],\[2,3,1\],\[3,4,2\],\[4,5,3\],\[5,6,4\]\]<br>Output: 5<br>Explanation:<br>The best bomb to detonate is bomb 0 because:<br>- Bomb 0 detonates bombs 1 and 2. The red circle denotes the range of bomb 0.<br>- Bomb 2 detonates bomb 3. The blue circle denotes the range of bomb 2.<br>- Bomb 3 detonates bomb 4. The green circle denotes the range of bomb 3.<br>Thus all 5 bombs are detonated.<br><br>Constraints:<br><br>   `1 <= bombs.length <= 100`<br>   `bombs[i].length == 3`<br>   `1 <= xi, yi, ri <= 105`"""<br><br>    if row == len(grid) - 1:<br>        return True<br>    grid[row][col] = 1<br><br>    directions = [(-1, 0), (0, 1), (1, 0), (0, -1)]<br><br>    for dr, dc in directions:<br>        nr, nc = row + dr, col + dc<br>        if 0 <= nr < len(grid) and 0 <= nc < len(grid[0]) and grid[nr][nc] == 0:<br>            if can_reach_bottom(grid, nr, nc):<br>                return True<br><br>    return False<br><br>def latestDayToCross(row, col, cells):<br>    grid = [[0]  col for _ in range(row)]<br>    ans = 0<br><br>    for day, cell in enumerate(cells):<br>        grid[cell[0] - 1][cell[1] - 1] = 1<br><br>        found = False<br>        for j in range(col):<br>            if grid[0][j] == 0 and can_reach_bottom(grid, 0, j):<br>                found = True<br>                break<br><br>        if not found:<br>            ans = day<br>            break<br><br>    return ans

### GROUND TRUTH 1, ranked 0, leetcode/leetcode_2258.txt
> from collections import deque<br>    """You are given a 0-indexed 2D integer array `grid` of size `m x n` which represents a field. Each cell has one of three values:<br><br>   `0` represents grass,<br>   `1` represents fire,<br>   `2` represents a wall that you and fire cannot pass through.<br><br>You are situated in the top-left cell, `(0, 0)`, and you want to travel to the safehouse at the bottom-right cell, `(m - 1, n - 1)`. Every minute, you may move to an adjacent grass cell. After your move, every fire cell will spread to all adjacent cells that are not walls.<br><br>Return _the maximum number of minutes that you can stay in your initial position before moving while still safely reaching the safehouse_. If this is impossible, return `-1`. If you can always reach the safehouse regardless of the minutes stayed, return `109`.<br><br>Note that even if the fire spreads to the safehouse immediately after you have reached it, it will be counted as safely reaching the safehouse.<br><br>A cell is adjacent to another cell if the former is directly north, east, south, or west of the latter (i.e., their sides are touching).<br><br>Example 1:<br><br>Input: grid = \[\[0,2,0,0,0,0,0\],\[0,0,0,2,2,1,0\],\[0,2,0,0,1,2,0\],\[0,0,2,2,2,0,2\],\[0,0,0,0,0,0,0\]\]<br>Output: 3<br>Explanation: The figure above shows the scenario where you stay in the initial position for 3 minutes.<br>You will still be able to safely reach the safehouse.<br>Staying for more than 3 minutes will not allow you to safely reach the safehouse.<br><br>Example 2:<br><br>Input: grid = \[\[0,0,0,0\],\[0,1,2,0\],\[0,2,0,0\]\]<br>Output: -1<br>Explanation: The figure above shows the scenario where you immediately move towards the safehouse.<br>Fire will spread to any cell you move towards and it is impossible to safely reach the safehouse.<br>Thus, -1 is returned.<br><br>Example 3:<br><br>Input: grid = \[\[0,0,0\],\[2,2,0\],\[1,2,0\]\]<br>Output: 1000000000<br>Explanation: The figure above shows the initial grid.<br>Notice that the fire is contained by walls and you will always be able to safely reach the safehouse.<br>Thus, 109 is returned.<br><br>Constraints:<br><br>   `m == grid.length`<br>   `n == grid[i].length`<br>   `2 <= m, n <= 300`<br>   `4 <= m  n <= 2  104`<br>   `grid[i][j]` is either `0`, `1`, or `2`.<br>   `grid[0][0] == grid[m - 1][n - 1] == 0`"""<br><br><br>dx = [0, 1, 0, -1]<br>dy = [1, 0, -1, 0]<br><br>def getMaxSafeMinutes(grid):<br>    m, n = len(grid), len(grid[0])<br>    dist = [[-1 for _ in range(n)] for _ in range(m)]<br>    q = deque()<br><br>    if grid[m - 1][n - 1] != 1:<br>        dist[m - 1][n - 1] = 0<br>        q.append((m - 1, n - 1))<br><br>    while q:<br>        x, y = q.popleft()<br>        for d in range(4):<br>            nx, ny = x + dx[d], y + dy[d]<br>            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0 and dist[nx][ny] == -1:<br>                dist[nx][ny] = dist[x][y] + 1<br>                q.append((nx, ny))<br><br>    if dist[0][0] == -1:<br>        return -1<br><br>    res = 0<br>    for test in range(dist[0][0], int(1e9)):<br>        ok = True<br>        for x in range(m):<br>            for y in range(n):<br>                if grid[x][y] == 1:<br>                    for d in range(4):<br>                        nx, ny = x + dx[d], y + dy[d]<br>                        if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 2:<br>                            break<br>                    else:<br>                        ok = False<br>                        break<br>        if ok:<br>            res = test<br>        else:<br>            break<br>    return res
