# Query `52`

## Original Question

*You are given the `root` of a binary tree with `n` nodes where each `node` in the tree has `node.val` coins. There are `n` coins in total throughout the whole tree.

In one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.

Return _the minimum number of moves required to make every node have exactly one coin_.

Example 1:

Input: root = \[3,0,0\]
Output: 2
Explanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.

Example 2:

Input: root = \[0,3,0\]
Output: 3
Explanation: From the left child of the root, we move two coins to the root \[taking two moves\]. Then, we move one coin from the root of the tree to the right child.

Constraints:

   The number of nodes in the tree is `n`.
   `1 <= n <= 100`
   `0 <= Node.val <= n`
   The sum of all `Node.val` is `n`.*

## gpt4 Reasoning

```markdown
The essential problem here is to balance the number of coins across all nodes in a binary tree such that each node ends up with exactly one coin, while minimizing the total number of moves (transfers) needed to achieve this balance. Each move consists of transferring a single coin between two adjacent nodes, where adjacency is defined by the parent-child relationship in the tree.

To solve this problem, we need to adopt a strategy that efficiently redistributes the coins while keeping track of the total number of moves. The key insight is to approach the problem from a bottom-up perspective, starting from the leaves of the tree and working our way up to the root. This method ensures that we only need to pass through each node once, making the solution more efficient.

### Step-by-Step Approach:

1. **Post-order Traversal**: We perform a post-order traversal of the binary tree. This means we first visit the left child, then the right child, and finally the node itself. This traversal order is crucial because it allows us to deal with the leaf nodes first and then propagate the surplus or deficit of coins up the tree.

2. **Calculating Surplus or Deficit**: For each node, we calculate the surplus or deficit of coins. A node with more than one coin has a surplus, and a node with no coin has a deficit. The amount of surplus or deficit is determined by subtracting one (the desired number of coins per node) from the current number of coins at that node.

3. **Redistributing Coins**: When we visit a node, we look at the surplus or deficit of its children. If a child has a surplus, we move the excess coins from the child to the current node. If a child has a deficit, we move the needed coins from the current node to the child. Each move corresponds to a single coin being transferred, and the absolute value of the surplus or deficit indicates the number of moves needed.

4. **Accumulating Moves**: As we redistribute coins to balance each node, we accumulate the total number of moves required. The key here is to understand that moving a coin from a child to its parent or vice versa counts as one move, regardless of the actual distance the coin moves in the tree structure.

5. **Handling the Root**: By the time we reach the root, all its children would have exactly one coin. Any surplus or deficit at the root can be adjusted without needing to move coins, as the total number of coins matches the total number of nodes.

### Relevant Information:

- The number of nodes `n` and the constraint that the sum of all `Node.val` is `n` ensures that it's possible to balance the tree so that each node ends up with exactly one coin.
- The solution does not depend on the binary tree being balanced or complete; it works for any shape of the binary tree.

### Solution Summary:

The minimum number of moves required to balance the coins across the tree is the sum of all moves needed to correct deficits and surpluses at each node, starting from the leaves and moving up to the root. By using a post-order traversal and addressing each node's surplus or deficit as we go, we ensure an efficient redistribution of coins that minimizes the total number of moves. This approach leverages the structure of the binary tree and the constraints of the problem (e.g., the total number of coins equals the number of nodes) to achieve an optimal solution.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2603.txt
> from collections import defaultdict<br>    """There exists an undirected and unrooted tree with `n` nodes indexed from `0` to `n - 1`. You are given an integer `n` and a 2D integer array edges of length `n - 1`, where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an array `coins` of size `n` where `coins[i]` can be either `0` or `1`, where `1` indicates the presence of a coin in the vertex `i`.<br><br>Initially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times:<br><br>   Collect all the coins that are at a distance of at most `2` from the current vertex, or<br>   Move to any adjacent vertex in the tree.<br><br>Find _the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex_.<br><br>Note that if you pass an edge several times, you need to count it into the answer several times.<br><br>Example 1:<br><br>Input: coins = \[1,0,0,0,0,1\], edges = \[\[0,1\],\[1,2\],\[2,3\],\[3,4\],\[4,5\]\]<br>Output: 2<br>Explanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.<br><br>Example 2:<br><br>Input: coins = \[0,0,0,1,1,0,0,1\], edges = \[\[0,1\],\[0,2\],\[1,3\],\[1,4\],\[2,5\],\[5,6\],\[5,7\]\]<br>Output: 2<br>Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.<br><br>Constraints:<br><br>   `n == coins.length`<br>   `1 <= n <= 3  104`<br>   `0 <= coins[i] <= 1`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree."""<br><br><br>def min_edges_to_collect_coins(coins, edges):<br>    adj = defaultdict(list)<br>    for a, b in edges:<br>        adj[a].append(b)<br>        adj[b].append(a)<br>    return dfs(adj, coins, 0, -1)[1] // 2<br><br>def dfs(adj, coins, node, parent):<br>    sum_coins = coins[node]<br>    distance = 0<br>    for neighbor in adj[node]:<br>        if neighbor != parent:<br>            result = dfs(adj, coins, neighbor, node)<br>            sum_coins += result[0]<br>            distance += 2  result[0] + result[1]<br>    return (sum_coins, distance)

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_226080.txt
> def _loc(self, pos, idx):<br>        """Convert an index pair (alpha, beta) into a single index that corresponds to<br>        the position of the value in the sorted list.<br><br>        Most queries require the index be built. Details of the index are<br>        described in self._build_index.<br><br>        Indexing requires traversing the tree from a leaf node to the root. The<br>        parent of each node is easily computable at (pos - 1) // 2.<br><br>        Left-child nodes are always at odd indices and right-child nodes are<br>        always at even indices.<br><br>        When traversing up from a right-child node, increment the total by the<br>        left-child node.<br><br>        The final index is the sum from traversal and the index in the sublist.<br><br>        For example, using the index from self._build_index:<br><br>        _index = 14 5 9 3 2 4 5<br>        _offset = 3<br><br>        Tree:<br><br>                 14<br>              5      9<br>            3   2  4   5<br><br>        Converting index pair (2, 3) into a single index involves iterating like<br>        so:<br><br>        1. Starting at the leaf node: offset + alpha = 3 + 2 = 5. We identify<br>           the node as a left-child node. At such nodes, we simply traverse to<br>           the parent.<br><br>        2. At node 9, position 2, we recognize the node as a right-child node<br>           and accumulate the left-child in our total. Total is now 5 and we<br>           traverse to the parent at position 0.<br><br>        3. Iteration ends at the root.<br><br>        Computing the index is the sum of the total and beta: 5 + 3 = 8.<br>        """<br>        if not pos:<br>            return idx<br><br>        _index = self._index<br><br>        if not len(_index):<br>            self._build_index()<br><br>        total = 0<br><br>        # Increment pos to point in the index to len(self._lists[pos]).<br><br>        pos += self._offset<br><br>        # Iterate until reaching the root of the index tree at pos = 0.<br><br>        while pos:<br><br>            # Right-child nodes are at odd indices. At such indices<br>            # account the total below the left child node.<br><br>            if not (pos & 1):<br>                total += _index[pos - 1]<br><br>            # Advance pos to the parent node.<br><br>            pos = (pos - 1)  1<br><br>        return total + idx

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_109214.txt
> def clean_column_values(df, inplace=True):<br>    r""" Convert dollar value strings, numbers with commas, and percents into floating point values<br><br>     df = get_data('us_gov_deficits_raw')<br>     df2 = clean_column_values(df, inplace=False)<br>     df2.iloc[0]<br>    Fiscal year                                                               10/2017-3/2018<br>    President's party                                                                      R<br>    Senate majority party                                                                  R<br>    House majority party                                                                   R<br>    Top-bracket marginal income tax rate                                                38.3<br>    National debt millions                                                       2.10896e+07<br>    National debt millions of 1983 dollars                                       8.47004e+06<br>    Deficit\n(millions of 1983 dollars)                                               431443<br>    Surplus string in 1983 dollars                                                       NaN<br>    Deficit string in 1983 dollars ($ = $10B)    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$<br>    Net surplus in 1983 dollars ($B)                                                    -430<br>    Name: 0, dtype: object<br>    """<br>    dollars_percents = re.compile(r'[%$,;\s]+')<br>    if not inplace:<br>        df = df.copy()<br>    for c in df.columns:<br>        values = None<br>        if df[c].dtype.char in '<U S O'.split():<br>            try:<br>                values = df[c].copy()<br>                values = values.fillna('')<br>                values = values.astype(str).str.replace(dollars_percents, '')<br>                # values = values.str.strip().str.replace(dollars_percents, '').str.strip()<br>                if values.str.len().sum()  .2  df[c].astype(str).str.len().sum():<br>                    values[values.isnull()] = np.nan<br>                    values[values == ''] = np.nan<br>                    values = values.astype(float)<br>            except ValueError:<br>                values = None<br>            except:  # noqa<br>                logger.error('Error on column {} with dtype {}'.format(c, df[c].dtype))<br>                raise<br><br>        if values is not None:<br>            if values.isnull().sum() < .6  len(values) and values.any():<br>                df[c] = values<br>    return df

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_110825.txt
> def _pos(self, idx):<br>        """Convert an index into a pair (alpha, beta) that can be used to access<br>        the corresponding _lists[alpha][beta] position.<br><br>        Most queries require the index be built. Details of the index are<br>        described in self._build_index.<br><br>        Indexing requires traversing the tree to a leaf node. Each node has<br>        two children which are easily computable. Given an index, pos, the<br>        left-child is at pos  2 + 1 and the right-child is at pos  2 + 2.<br><br>        When the index is less than the left-child, traversal moves to the<br>        left sub-tree. Otherwise, the index is decremented by the left-child<br>        and traversal moves to the right sub-tree.<br><br>        At a child node, the indexing pair is computed from the relative<br>        position of the child node as compared with the offset and the remaining<br>        index.<br><br>        For example, using the index from self._build_index:<br><br>        _index = 14 5 9 3 2 4 5<br>        _offset = 3<br><br>        Tree:<br><br>                 14<br>              5      9<br>            3   2  4   5<br><br>        Indexing position 8 involves iterating like so:<br><br>        1. Starting at the root, position 0, 8 is compared with the left-child<br>           node (5) which it is greater than. When greater the index is<br>           decremented and the position is updated to the right child node.<br><br>        2. At node 9 with index 3, we again compare the index to the left-child<br>           node with value 4. Because the index is the less than the left-child<br>           node, we simply traverse to the left.<br><br>        3. At node 4 with index 3, we recognize that we are at a leaf node and<br>           stop iterating.<br><br>        4. To compute the sublist index, we subtract the offset from the index<br>           of the leaf node: 5 - 3 = 2. To compute the index in the sublist, we<br>           simply use the index remaining from iteration. In this case, 3.<br><br>        The final index pair from our example is (2, 3) which corresponds to<br>        index 8 in the sorted list.<br>        """<br>        if idx < 0:<br>            last_len = len(self._lists[-1])<br><br>            if (-idx) <= last_len:<br>                return len(self._lists) - 1, last_len + idx<br><br>            idx += self._len<br><br>            if idx < 0:<br>                raise IndexError('list index out of range')<br>        elif idx = self._len:<br>            raise IndexError('list index out of range')<br><br>        if idx < len(self._lists[0]):<br>            return 0, idx<br><br>        _index = self._index<br><br>        if not _index:<br>            self._build_index()<br><br>        pos = 0<br>        child = 1<br>        len_index = len(_index)<br><br>        while child < len_index:<br>            index_child = _index[child]<br><br>            if idx < index_child:<br>                pos = child<br>            else:<br>                idx -= index_child<br>                pos = child + 1<br><br>            child = (pos << 1) + 1<br><br>        return (pos - self._offset, idx)

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_162628.txt
> def portfolio(weights, latest_prices, min_allocation=0.01, total_portfolio_value=10000):<br>    """<br>    For a long only portfolio, convert the continuous weights to a discrete allocation<br>    in a greedy iterative approach. This can be thought of as a clever way to round<br>    the continuous weights to an integer number of shares<br><br>    :param weights: continuous weights generated from the ``efficient_frontier`` module<br>    :type weights: dict<br>    :param latest_prices: the most recent price for each asset<br>    :type latest_prices: pd.Series or dict<br>    :param min_allocation: any weights less than this number are considered negligible,<br>                           defaults to 0.01<br>    :type min_allocation: float, optional<br>    :param total_portfolio_value: the desired total value of the portfolio, defaults to 10000<br>    :type total_portfolio_value: int/float, optional<br>    :raises TypeError: if ``weights`` is not a dict<br>    :raises TypeError: if ``latest_prices`` isn't a series<br>    :raises ValueError: if not ``0 < min_allocation < 0.3``<br>    :return: the number of shares of each ticker that should be purchased, along with the amount<br>             of funds leftover.<br>    :rtype: (dict, float)<br>    """<br>    if not isinstance(weights, dict):<br>        raise TypeError("weights should be a dictionary of {ticker: weight}")<br>    if not isinstance(latest_prices, (pd.Series, dict)):<br>        raise TypeError("latest_prices should be a pd.Series")<br>    if min_allocation  0.3:<br>        raise ValueError("min_allocation should be a small float")<br>    if total_portfolio_value <= 0:<br>        raise ValueError("total_portfolio_value must be greater than zero")<br><br>    # Drop any companies with negligible weights. We use a tuple because order matters.<br>    nonzero_weights = [(k, v) for k, v in weights.items() if v  min_allocation]<br>    print(<br>        "{} out of {} tickers were removed".format(<br>            len(weights) - len(nonzero_weights), len(weights)<br>        )<br>    )<br>    # Sort in descending order of weight<br>    nonzero_weights.sort(key=lambda x: x[1], reverse=True)<br>    available_funds = total_portfolio_value<br>    shares_bought = []<br>    buy_prices = []<br><br>    # First round<br>    for ticker, weight in nonzero_weights:<br>        price = latest_prices[ticker]<br>        # Attempt to buy the lower integer number of shares<br>        n_shares = int(weight  total_portfolio_value / price)<br>        cost = n_shares  price<br>        if cost  available_funds:<br>            # Buy as many as possible<br>            n_shares = available_funds // price<br>            if n_shares == 0:<br>                print("Insufficient funds")<br>        available_funds -= cost<br>        shares_bought.append(n_shares)<br>        buy_prices.append(price)<br><br>    # Second round<br>    while available_funds  0:<br>        # Calculate the equivalent continuous weights of the shares that<br>        # have already been bought<br>        current_weights = np.array(buy_prices)  np.array(shares_bought)<br>        current_weights /= current_weights.sum()<br>        ideal_weights = np.array([i[1] for i in nonzero_weights])<br>        deficit = ideal_weights - current_weights<br><br>        # Attempt to buy the asset whose current weights deviate the most<br>        idx = np.argmax(deficit)<br>        ticker, weight = nonzero_weights[idx]<br>        price = latest_prices[ticker]<br><br>        # If we can't afford this asset, search for the next highest deficit that we<br>        # can purchase.<br>        counter = 0<br>        while price  available_funds:<br>            deficit[idx] = 0  # we can no longer purchase the asset at idx<br>            idx = np.argmax(deficit)  # find the next most deviant asset<br><br>            # If either of these conditions is met, we break out of both while loops<br>            # hence the repeated statement below<br>            if deficit[idx] < 0 or counter == 10:<br>                break<br><br>            ticker, weight = nonzero_weights[idx]<br>            price = latest_prices[ticker]<br>            counter += 1<br><br>        if deficit[idx] <= 0 or counter == 10:<br>            # See https://stackoverflow.com/questions/189645/<br>            break<br><br>        # Buy one share at a time<br>        shares_bought[idx] += 1<br>        available_funds -= price<br><br>    print("Funds remaining: {:.2f}".format(available_funds))<br><br>    num_shares = dict(zip([i[0] for i in nonzero_weights], shares_bought))<br>    return num_shares, available_funds


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_834.txt
> def ambiguousCoordinates(s):<br>    """There is an undirected connected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.<br><br>You are given the integer `n` and the array `edges` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree.<br><br>Return an array `answer` of length `n` where `answer[i]` is the sum of the distances between the `ith` node in the tree and all other nodes.<br><br>Example 1:<br><br>Input: n = 6, edges = \[\[0,1\],\[0,2\],\[2,3\],\[2,4\],\[2,5\]\]<br>Output: \[8,12,6,10,10,10\]<br>Explanation: The tree is shown above.<br>We can see that dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)<br>equals 1 + 1 + 2 + 2 + 2 = 8.<br>Hence, answer\[0\] = 8, and so on.<br><br>Example 2:<br><br>Input: n = 1, edges = \[\]<br>Output: \[0\]<br><br>Example 3:<br><br>Input: n = 2, edges = \[\[1,0\]\]<br>Output: \[1,1\]<br><br>Constraints:<br><br>   `1 <= n <= 3  104`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   The given input represents a valid tree."""<br><br>    def generateNumber(s):<br>        if not s or (len(s)  1 and s[0] == '0' and s[-1] == '0'):<br>            return []<br>        if len(s)  1 and s[0] == '0':<br>            return ["0." + s[1:]]<br>        res = [s]<br>        if len(s) == 1 or s[-1] == '0':<br>            return res<br>        for i in range(1, len(s)):<br>            res.append(s[:i] + "." + s[i:])<br>        return res<br><br>    n = len(s)<br>    res = []<br>    <br>    for i in range(2, n - 1):<br>        first = generateNumber(s[1:i])<br>        second = generateNumber(s[i:n - 1])<br>        <br>        for f in first:<br>            for sec in second:<br>                res.append("(" + f + ", " + sec + ")")<br>    <br>    return res
