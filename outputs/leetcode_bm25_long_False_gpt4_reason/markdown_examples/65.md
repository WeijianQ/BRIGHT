# Query `65`

## Original Question

*You are given an integer array `bloomDay`, an integer `m` and an integer `k`.

You want to make `m` bouquets. To make a bouquet, you need to use `k` adjacent flowers from the garden.

The garden consists of `n` flowers, the `ith` flower will bloom in the `bloomDay[i]` and then can be used in exactly one bouquet.

Return _the minimum number of days you need to wait to be able to make_ `m` _bouquets from the garden_. If it is impossible to make m bouquets return `-1`.

Example 1:

Input: bloomDay = \[1,10,3,10,2\], m = 3, k = 1
Output: 3
Explanation: Let us see what happened in the first three days. x means flower bloomed and \_ means flower did not bloom in the garden.
We need 3 bouquets each should contain 1 flower.
After day 1: \[x, \_, \_, \_, \_\]   // we can only make one bouquet.
After day 2: \[x, \_, \_, \_, x\]   // we can only make two bouquets.
After day 3: \[x, \_, x, \_, x\]   // we can make 3 bouquets. The answer is 3.

Example 2:

Input: bloomDay = \[1,10,3,10,2\], m = 3, k = 2
Output: -1
Explanation: We need 3 bouquets each has 2 flowers, that means we need 6 flowers. We only have 5 flowers so it is impossible to get the needed bouquets and we return -1.

Example 3:

Input: bloomDay = \[7,7,7,7,12,7,7\], m = 2, k = 3
Output: 12
Explanation: We need 2 bouquets each should have 3 flowers.
Here is the garden after the 7 and 12 days:
After day 7: \[x, x, x, x, \_, x, x\]
We can make one bouquet of the first three flowers that bloomed. We cannot make another bouquet from the last three flowers that bloomed because they are not adjacent.
After day 12: \[x, x, x, x, x, x, x\]
It is obvious that we can make two bouquets in different ways.

Constraints:

   `bloomDay.length == n`
   `1 <= n <= 105`
   `1 <= bloomDay[i] <= 109`
   `1 <= m <= 106`
   `1 <= k <= n`*

## gpt4 Reasoning

```markdown
The essential problem here is to determine the minimum number of days required to wait before being able to make `m` bouquets of `k` adjacent flowers each from a garden, given the days each flower takes to bloom. If it's not possible to make the required number of bouquets, we return `-1`. This is essentially a search problem with a specific constraint on the arrangement of elements (flowers in this case) that can be included in a solution (bouquet).

### Key Points to Consider:

1. **Adjacent Requirement**: A bouquet consists of `k` adjacent flowers. This means we cannot just pick any `k` flowers that have bloomed; they must be next to each other in the array.

2. **Bloom Days**: Each flower has a specific day on which it will bloom, indicated by the `bloomDay` array. Before this day, the flower cannot be used in a bouquet.

3. **Minimum Days**: We're asked for the minimum number of days required, suggesting an optimization problem where we're minimizing time while satisfying the bouquet-making constraint.

4. **Binary Search on Days**: Given the nature of the problem (finding a minimum number of days), a binary search approach can be efficient. We can binary search on the number of days as our decision space, checking for each mid-point (mid-number of days) if it's possible to make the required `m` bouquets.

### Strategy:

1. **Binary Search Setup**: Determine the search range. The minimum possible day is `1` (if we have a flower that blooms on day 1 and that's all we need), and the maximum is the latest bloom day in the `bloomDay` array since no bouquet can be made past the last bloom day.

2. **Feasibility Check**: For a given number of days (mid-point in our binary search), we check if it's possible to make `m` bouquets. We iterate through the `bloomDay` array, counting how many bouquets of `k` adjacent flowers we can make with the flowers that have bloomed by that day.

3. **Adjusting Search Range**: If we can make at least `m` bouquets, we know it's possible to do so within that number of days or possibly fewer, so we try to find a lower number of days by adjusting our search range. If we cannot make enough bouquets, we need more days and thus adjust our search range to look for a higher number of days.

4. **Edge Case - Impossibility**: If the total number of flowers is less than `m * k`, it's immediately impossible to make the required bouquets, and we should return `-1`.

### Implementation Outline:

1. **Initialize**: Set the search range with a minimum of `1` and a maximum of the maximum value in `bloomDay`.

2. **Binary Search**:
   - While the search range is valid, find the mid-point.
   - Check if it's possible to make `m` bouquets by this day.
   - If possible, try to find an earlier day (adjust range to left).
   - If not possible, try to find a later day (adjust range to right).

3. **Feasibility Function**:
   - Iterate through `bloomDay`, counting flowers that have bloomed by the current mid-point day.
   - Whenever you have `k` adjacent bloomed flowers, count it as a bouquet and reset the adjacent bloomed flowers counter.
   - If the total bouquets count reaches `m`, return true (feasible).

4. **Return** the minimum day if possible, else `-1`.

This approach efficiently narrows down the minimum number of days needed by exploiting the sorted nature of time (days) and checking the feasibility of making bouquets within a given timeframe.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.5000
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.6131
ndcg_cut_10: 0.6131
ndcg_cut_25: 0.6131
ndcg_cut_50: 0.6131
ndcg_cut_100: 0.6131
map_cut_1: 0.5000
map_cut_5: 0.5000
map_cut_10: 0.5000
map_cut_25: 0.5000
map_cut_50: 0.5000
map_cut_100: 0.5000
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2136.txt
> def earliestBlooms(plantTime, growTime):<br>    """You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays `plantTime` and `growTime`, of length `n` each:<br><br>   `plantTime[i]` is the number of full days it takes you to plant the `ith` seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked `plantTime[i]` days on planting it in total.<br>   `growTime[i]` is the number of full days it takes the `ith` seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.<br><br>From the beginning of day `0`, you can plant the seeds in any order.<br><br>Return _the earliest possible day where all seeds are blooming_.<br><br>Example 1:<br><br>Input: plantTime = \[1,4,3\], growTime = \[2,3,1\]<br>Output: 9<br>Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.<br>One optimal way is:<br>On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.<br>On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.<br>On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.<br>Thus, on day 9, all the seeds are blooming.<br><br>Example 2:<br><br>Input: plantTime = \[1,2,3,2\], growTime = \[2,1,2,1\]<br>Output: 9<br>Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.<br>One optimal way is:<br>On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.<br>On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.<br>On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.<br>On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.<br>Thus, on day 9, all the seeds are blooming.<br><br>Example 3:<br><br>Input: plantTime = \[1\], growTime = \[1\]<br>Output: 2<br>Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.<br>Thus, on day 2, all the seeds are blooming.<br><br>Constraints:<br><br>   `n == plantTime.length == growTime.length`<br>   `1 <= n <= 105`<br>   `1 <= plantTime[i], growTime[i] <= 104`"""<br><br>    n = len(plantTime)<br>    processTime = list(zip(plantTime, growTime))<br>    processTime.sort()<br><br>    day = 0<br>    blooms = 0<br>    for p in processTime:<br>        day += p[0]<br>        blooms = max(blooms, day + p[1])<br>    return blooms

### DOC[2] (IRRELEVANT) leetcode/leetcode_1042.txt
> def mergeStones(stones, k):<br>    """You have `n` gardens, labeled from `1` to `n`, and an array `paths` where `paths[i] = [xi, yi]` describes a bidirectional path between garden `xi` to garden `yi`. In each garden, you want to plant one of 4 types of flowers.<br><br>All gardens have at most 3 paths coming into or leaving it.<br><br>Your task is to choose a flower type for each garden such that, for any two gardens connected by a path, they have different types of flowers.<br><br>Return _any such a choice as an array_ `answer`_, where_ `answer[i]` _is the type of flower planted in the_ `(i+1)th` _garden. The flower types are denoted_ `1`_,_ `2`_,_ `3`_, or_ `4`_. It is guaranteed an answer exists._<br><br>Example 1:<br><br>Input: n = 3, paths = \[\[1,2\],\[2,3\],\[3,1\]\]<br>Output: \[1,2,3\]<br>Explanation:<br>Gardens 1 and 2 have different types.<br>Gardens 2 and 3 have different types.<br>Gardens 3 and 1 have different types.<br>Hence, \[1,2,3\] is a valid answer. Other valid answers include \[1,2,4\], \[1,4,2\], and \[3,2,1\].<br><br>Example 2:<br><br>Input: n = 4, paths = \[\[1,2\],\[3,4\]\]<br>Output: \[1,2,1,2\]<br><br>Example 3:<br><br>Input: n = 4, paths = \[\[1,2\],\[2,3\],\[3,4\],\[4,1\],\[1,3\],\[2,4\]\]<br>Output: \[1,2,3,4\]<br><br>Constraints:<br><br>   `1 <= n <= 104`<br>   `0 <= paths.length <= 2  104`<br>   `paths[i].length == 2`<br>   `1 <= xi, yi <= n`<br>   `xi != yi`<br>   Every garden has at most 3 paths coming into or leaving it."""<br><br>    n = len(stones)<br>    if (n - 1) % (k - 1) != 0:<br>        return -1<br>    prefixSum = [0]  (n + 1)<br>    dp = [[[-1]  (k + 1) for _ in range(n)] for _ in range(n)]<br><br>    for i in range(n):<br>        prefixSum[i + 1] = prefixSum[i] + stones[i]<br><br>    for l in range(2, n + 1):<br>        for i in range(n - l + 1):<br>            j = i + l - 1<br>            for m in range(2, k + 1):<br>                for p in range(i, j + 1 - m + 1, k - 1):<br>                    dp[i][j][m] = (dp[i][p][1] + dp[p + 1][j][m - 1]) % (1e9 + 7)<br>            if (j - i) % (k - 1) == 0:<br>                dp[i][j][1] = (dp[i][j][k] + prefixSum[j + 1] - prefixSum[i]) % (1e9 + 7)<br><br>    return dp[0][n - 1][1]

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_238048.txt
> def generate(graph, feasible_configurations, decision_variables,<br>             linear_energy_ranges, quadratic_energy_ranges, min_classical_gap,<br>             smt_solver_name=None):<br>    """Generates the Ising model that induces the given feasible configurations. The code is based<br>    on the papers [#do]_ and [#mc]_.<br><br>    Args:<br>        graph (nx.Graph): The target graph on which the Ising model is to be built.<br>        feasible_configurations (dict): The set of feasible configurations<br>            of the decision variables. The key is a feasible configuration<br>            as a tuple of spins, the values are the associated energy.<br>        decision_variables (list/tuple): Which variables in the graph are<br>            assigned as decision variables.<br>        linear_energy_ranges (dict, optional): A dict of the form<br>            {v: (min, max), ...} where min and max are the range<br>            of values allowed to v.<br>        quadratic_energy_ranges (dict): A dict of the form<br>            {(u, v): (min, max), ...} where min and max are the range<br>            of values allowed to (u, v).<br>        min_classical_gap (float): The minimum energy gap between the highest feasible state and the<br>            lowest infeasible state.<br>        smt_solver_name (str/None): The name of the smt solver. Must<br>            be a solver available to pysmt. If None, uses the pysmt default.<br><br>    Returns:<br>        tuple: A 4-tuple containing:<br><br>            dict: The linear biases of the Ising problem.<br><br>            dict: The quadratic biases of the Ising problem.<br><br>            :obj:`dimod.BinaryQuadraticModel`<br><br>            float: The classical energy gap between ground and the first<br>            excited state.<br><br>    Raises:<br>        ImpossiblePenaltyModel: If the penalty model cannot be built. Normally due<br>            to a non-zero infeasible gap.<br><br>    .. [#do] Bian et al., "Discrete optimization using quantum annealing on sparse Ising models",<br>        https://www.frontiersin.org/articles/10.3389/fphy.2014.00056/full<br><br>    .. [#mc] Z. Bian, F. Chudak, R. Israel, B. Lackey, W. G. Macready, and A. Roy<br>        "Mapping constrained optimization problems to quantum annealing with application to fault diagnosis"<br>        https://arxiv.org/pdf/1603.03111.pdf<br><br>    """<br>    if len(graph) == 0:<br>        return dimod.BinaryQuadraticModel.empty(dimod.SPIN), float('inf')<br><br>    # we need to build a Table. The table encodes all of the information used by the smt solver<br>    table = Table(graph, decision_variables, linear_energy_ranges, quadratic_energy_ranges)<br><br>    # iterate over every possible configuration of the decision variables.<br>    for config in itertools.product((-1, 1), repeat=len(decision_variables)):<br><br>        # determine the spin associated with each variable in decision variables.<br>        spins = dict(zip(decision_variables, config))<br><br>        if config in feasible_configurations:<br>            # if the configuration is feasible, we require that the minimum energy over all<br>            # possible aux variable settings be exactly its target energy (given by the value)<br>            table.set_energy(spins, feasible_configurations[config])<br>        else:<br>            # if the configuration is infeasible, we simply want its minimum energy over all<br>            # possible aux variable settings to be an upper bound on the classical gap.<br>            if isinstance(feasible_configurations, dict) and feasible_configurations:<br>                highest_feasible_energy = max(feasible_configurations.values())<br>            else:<br>                highest_feasible_energy = 0<br><br>            table.set_energy_upperbound(spins, highest_feasible_energy)<br><br>    # now we just need to get a solver<br>    with Solver(smt_solver_name) as solver:<br><br>        # add all of the assertions from the table to the solver<br>        for assertion in table.assertions:<br>            solver.add_assertion(assertion)<br><br>        # add min classical gap assertion<br>        gap_assertion = table.gap_bound_assertion(min_classical_gap)<br>        solver.add_assertion(gap_assertion)<br><br>        # check if the model is feasible at all.<br>        if solver.solve():<br>            # since we know the current model is feasible, grab the initial model.<br>            model = solver.get_model()<br><br>            # we want to increase the gap until we have found the max classical gap<br>            # note: gmax is the maximum possible gap for a particular set of variables. To find it,<br>            #   we take the sum of the largest coefficients possible and double it. We double it<br>            #   because in Ising, the largest gap possible from the largest coefficient is the<br>            #   negative of said coefficient. Example: consider a graph with one node A, with a<br>            #   energy range of [-2, 1]. The largest energy gap between spins +1 and -1 is 4;<br>            #   namely, the largest absolute coefficient -2 with the ising spins results to<br>            #   gap = (-2)(-1) - (-2)(1) = 4.<br>            gmin = min_classical_gap<br>            gmax = sum(max(abs(r) for r in linear_energy_ranges[v]) for v in graph)<br>            gmax += sum(max(abs(r) for r in quadratic_energy_ranges[(u, v)])<br>                        for (u, v) in graph.edges)<br>            gmax = 2<br><br>            # 2 is a good target gap<br>            g = max(2., gmin)<br><br>            while abs(gmax - gmin) = MAX_GAP_DELTA:<br>                solver.push()<br><br>                gap_assertion = table.gap_bound_assertion(g)<br>                solver.add_assertion(gap_assertion)<br><br>                if solver.solve():<br>                    model = solver.get_model()<br>                    gmin = float(model.get_py_value(table.gap))<br><br>                else:<br>                    solver.pop()<br>                    gmax = g<br><br>                g = min(gmin + .1, (gmax + gmin) / 2)<br><br>        else:<br>            raise ImpossiblePenaltyModel("Model cannot be built")<br><br>    # finally we need to convert our values back into python floats.<br><br>    classical_gap = float(model.get_py_value(table.gap))<br><br>    # if the problem is fully specified (or empty) it has infinite gap<br>    if (len(decision_variables) == len(graph) and<br>            decision_variables and  # at least one variable<br>            len(feasible_configurations) == 2len(decision_variables)):<br>        classical_gap = float('inf')<br><br>    return table.theta.to_bqm(model), classical_gap

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_131194.txt
> def blake_encode_ngrams(ngrams,   # type: Iterable[str]<br>                        keys,     # type: Sequence[bytes]<br>                        ks,       # type: Sequence[int]<br>                        l,        # type: int<br>                        encoding  # type: str<br>                        ):<br>    # type: (...) - bitarray.bitarray<br>    """ Computes the encoding of the ngrams using the BLAKE2 hash function.<br><br>        We deliberately do not use the double hashing scheme as proposed in [<br>        Schnell2011]_, because this<br>        would introduce an exploitable structure into the Bloom filter. For more<br>        details on the<br>        weakness, see [Kroll2015]_.<br><br>        In short, the double hashing scheme only allows for :math:`l^2`<br>        different encodings for any possible n-gram,<br>        whereas the use of :math:`k` different independent hash functions gives<br>        you :math:`\\sum_{j=1}^{k}{\\binom{l}{j}}`<br>        combinations.<br><br><br>        Our construction<br><br>        It is advantageous to construct Bloom filters using a family of hash<br>        functions with the property of<br>        `k-independence <https://en.wikipedia.org/wiki/K-independent_hashing`_<br>        to compute the indices for an entry.<br>        This approach minimises the change of collisions.<br><br>        An informal definition of k-independence of a family of hash functions<br>        is, that if selecting a function at random<br>        from the family, it guarantees that the hash codes of any designated k<br>        keys are independent random variables.<br><br>        Our construction utilises the fact that the output bits of a<br>        cryptographic hash function are uniformly distributed,<br>        independent, binary random variables (well, at least as close to as<br>        possible. See [Kaminsky2011]_ for an analysis).<br>        Thus, slicing the output of a cryptographic hash function into k<br>        different slices gives you k independent random<br>        variables.<br><br>        We chose Blake2 as the cryptographic hash function mainly for two reasons:<br><br>         it is fast.<br>         in keyed hashing mode, Blake2 provides MACs with just one hash<br>          function call instead of the two calls in the HMAC construction used<br>          in the double hashing scheme.<br><br><br>        .. warning::<br>           Please be aware that, although this construction makes the attack of<br>           [Kroll2015]_ infeasible, it is most likely<br>           not enough to ensure security. Or in their own words:<br><br>             | However, we think that using independent hash functions alone<br>               will not be sufficient to ensure security,<br>               since in this case other approaches (maybe related to or at least<br>               inspired through work from the<br>               area of Frequent Itemset Mining) are promising to detect at least<br>               the most frequent atoms automatically.<br><br>        :param ngrams: list of n-grams to be encoded<br>        :param keys: secret key for blake2 as bytes<br>        :param ks: ks[i] is k value to use for ngram[i]<br>        :param l: length of the output bitarray (has to be a power of 2)<br>        :param encoding: the encoding to use when turning the ngrams to bytes<br><br>        :return: bitarray of length l with the bits set which correspond to the<br>                 encoding of the ngrams<br>    """<br>    key, = keys  # Unpack.<br><br>    log_l = int(math.log(l, 2))<br>    if not 2  log_l == l:<br>        raise ValueError(<br>            'parameter "l" has to be a power of two for the BLAKE2 encoding, '<br>            'but was: {}'.format(<br>                l))<br>    bf = bitarray(l)<br>    bf.setall(False)<br><br>    for m, k in zip(ngrams, ks):<br>        random_shorts = []  # type: List[int]<br>        num_macs = (k + 31) // 32<br>        for i in range(num_macs):<br>            hash_bytes = blake2b(m.encode(encoding=encoding), key=key,<br>                                 salt=str(i).encode()).digest()<br>            random_shorts.extend(struct.unpack('32H',<br>                                               hash_bytes))  # interpret<br>            # hash bytes as 32 unsigned shorts.<br>        for i in range(k):<br>            idx = random_shorts[i] % l<br>            bf[idx] = 1<br>    return bf

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_314887.txt
> def min_vertex_coloring(G, sampler=None, sampler_args):<br>    """Returns an approximate minimum vertex coloring.<br><br>    Vertex coloring is the problem of assigning a color to the<br>    vertices of a graph in a way that no adjacent vertices have the<br>    same color. A minimum vertex coloring is the problem of solving<br>    the vertex coloring problem using the smallest number of colors.<br><br>    Since neighboring vertices must satisfy a constraint of having<br>    different colors, the problem can be posed as a binary constraint<br>    satisfaction problem.<br><br>    Defines a QUBO with ground states corresponding to minimum<br>    vertex colorings and uses the sampler to sample from it.<br><br>    Parameters<br>    ----------<br>    G : NetworkX graph<br>        The graph on which to find a minimum vertex coloring.<br><br>    sampler<br>        A binary quadratic model sampler. A sampler is a process that<br>        samples from low energy states in models defined by an Ising<br>        equation or a Quadratic Unconstrained Binary Optimization<br>        Problem (QUBO). A sampler is expected to have a 'sample_qubo'<br>        and 'sample_ising' method. A sampler is expected to return an<br>        iterable of samples, in order of increasing energy. If no<br>        sampler is provided, one must be provided using the<br>        `set_default_sampler` function.<br><br>    sampler_args<br>        Additional keyword parameters are passed to the sampler.<br><br>    Returns<br>    -------<br>    coloring : dict<br>        A coloring for each vertex in G such that no adjacent nodes<br>        share the same color. A dict of the form {node: color, ...}<br><br>    Example<br>    -------<br>    This example colors a single Chimera unit cell. It colors the four<br>    horizontal qubits one color (0) and the four vertical qubits another (1).<br><br>     # Set up a sampler; this example uses a sampler from dimod https://github.com/dwavesystems/dimod<br>     import dimod<br>     import dwave_networkx as dnx<br>     samplerSA = dimod.SimulatedAnnealingSampler()<br>     # Create a graph and color it<br>     G = dnx.chimera_graph(1, 1, 4)<br>     colors = dnx.min_vertex_coloring(G, sampler=samplerSA)<br>     colors<br>    {0: 0, 1: 0, 2: 0, 3: 0, 4: 1, 5: 1, 6: 1, 7: 1}<br><br>    References<br>    ----------<br>    .. [DWMP] Dahl, E., "Programming the D-Wave: Map Coloring Problem",<br>       https://www.dwavesys.com/sites/default/files/Map%20Coloring%20WP2.pdf<br><br>    Notes<br>    -----<br>    Samplers by their nature may not return the optimal solution. This<br>    function does not attempt to confirm the quality of the returned<br>    sample.<br><br>    """<br><br>    # if the given graph is not connected, apply the function to each connected component<br>    # seperately.<br>    if not nx.is_connected(G):<br>        coloring = {}<br>        for subG in (G.subgraph(c).copy() for c in nx.connected_components(G)):<br>            sub_coloring = min_vertex_coloring(subG, sampler, sampler_args)<br>            coloring.update(sub_coloring)<br>        return coloring<br><br>    n_nodes = len(G)  # number of nodes<br>    n_edges = len(G.edges)  # number of edges<br><br>    # ok, first up, we can eliminate a few graph types trivially<br><br>    # Graphs with no edges, have chromatic number 1<br>    if not n_edges:<br>        return {node: 0 for node in G}<br><br>    # Complete graphs have chromatic number N<br>    if n_edges == n_nodes  (n_nodes - 1) // 2:<br>        return {node: color for color, node in enumerate(G)}<br><br>    # The number of variables in the QUBO is approximately the number of nodes in the graph<br>    # times the number of potential colors, so we want as tight an upper bound on the<br>    # chromatic number (chi) as possible<br>    chi_ub = _chromatic_number_upper_bound(G, n_nodes, n_edges)<br><br>    # now we can start coloring. Without loss of generality, we can determine some of<br>    # the node colors before trying to solve.<br>    partial_coloring, possible_colors, chi_lb = _partial_precolor(G, chi_ub)<br><br>    # ok, to get the rest of the coloring, we need to start building the QUBO. We do this<br>    # by assigning a variable x_v_c for each node v and color c. This variable will be 1<br>    # when node v is colored c, and 0 otherwise.<br><br>    # let's assign an index to each of the variables<br>    counter = itertools.count()<br>    x_vars = {v: {c: next(counter) for c in possible_colors[v]} for v in possible_colors}<br><br>    # now we have three different constraints we wish to add.<br><br>    # the first constraint enforces the coloring rule, that for each pair of vertices<br>    # u, v that share an edge, they should be different colors<br>    Q_neighbor = _vertex_different_colors_qubo(G, x_vars)<br><br>    # the second constraint enforces that each vertex has a single color assigned<br>    Q_vertex = _vertex_one_color_qubo(x_vars)<br><br>    # the third constraint is that we want a minimum vertex coloring, so we want to<br>    # disincentivize the colors we might not need.<br>    Q_min_color = _minimum_coloring_qubo(x_vars, chi_lb, chi_ub, magnitude=.75)<br><br>    # combine all three constraints<br>    Q = Q_neighbor<br>    for (u, v), bias in iteritems(Q_vertex):<br>        if (u, v) in Q:<br>            Q[(u, v)] += bias<br>        elif (v, u) in Q:<br>            Q[(v, u)] += bias<br>        else:<br>            Q[(u, v)] = bias<br>    for (v, v), bias in iteritems(Q_min_color):<br>        if (v, v) in Q:<br>            Q[(v, v)] += bias<br>        else:<br>            Q[(v, v)] = bias<br><br>    # use the sampler to find low energy states<br>    response = sampler.sample_qubo(Q, sampler_args)<br><br>    # we want the lowest energy sample<br>    sample = next(iter(response))<br><br>    # read off the coloring<br>    for v in x_vars:<br>        for c in x_vars[v]:<br>            if sample[x_vars[v][c]]:<br>                partial_coloring[v] = c<br><br>    return partial_coloring


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2024.txt
> def max_consecutive_answers(answer_key: str, k: int) - int:<br>    """A teacher is writing a test with `n` true/false questions, with `'T'` denoting true and `'F'` denoting false. He wants to confuse the students by maximizing the number of consecutive questions with the same answer (multiple trues or multiple falses in a row).<br><br>You are given a string `answerKey`, where `answerKey[i]` is the original answer to the `ith` question. In addition, you are given an integer `k`, the maximum number of times you may perform the following operation:<br><br>   Change the answer key for any question to `'T'` or `'F'` (i.e., set `answerKey[i]` to `'T'` or `'F'`).<br><br>Return _the maximum number of consecutive_ `'T'`s or `'F'`s _in the answer key after performing the operation at most_ `k` _times_.<br><br>Example 1:<br><br>Input: answerKey =  "TTFF ", k = 2<br>Output: 4<br>Explanation: We can replace both the 'F's with 'T's to make answerKey =  "TTTT ".<br>There are four consecutive 'T's.<br><br>Example 2:<br><br>Input: answerKey =  "TFFT ", k = 1<br>Output: 3<br>Explanation: We can replace the first 'T' with an 'F' to make answerKey =  "FFFT ".<br>Alternatively, we can replace the second 'T' with an 'F' to make answerKey =  "TFFF ".<br>In both cases, there are three consecutive 'F's.<br><br>Example 3:<br><br>Input: answerKey =  "TTFTTFTT ", k = 1<br>Output: 5<br>Explanation: We can replace the first 'F' to make answerKey =  "TTTTTFTT "<br>Alternatively, we can replace the second 'F' to make answerKey =  "TTFTTTTT ". <br>In both cases, there are five consecutive 'T's.<br><br>Constraints:<br><br>   `n == answerKey.length`<br>   `1 <= n <= 5  104`<br>   `answerKey[i]` is either `'T'` or `'F'`<br>   `1 <= k <= n`"""<br><br>    max_len, left, T_cnt, F_cnt = 0, 0, 0, 0<br><br>    for right, c in enumerate(answer_key):<br>        if c == 'T':<br>            T_cnt += 1<br>        else:<br>            F_cnt += 1<br><br>        if min(T_cnt, F_cnt)  k:<br>            if answer_key[left] == 'T':<br>                T_cnt -= 1<br>            else:<br>                F_cnt -= 1<br>            left += 1<br>        else:<br>            max_len = max(max_len, T_cnt + F_cnt)<br><br>    return max_len

### GROUND TRUTH 1, ranked 0, leetcode/leetcode_2136.txt
> def earliestBlooms(plantTime, growTime):<br>    """You have `n` flower seeds. Every seed must be planted first before it can begin to grow, then bloom. Planting a seed takes time and so does the growth of a seed. You are given two 0-indexed integer arrays `plantTime` and `growTime`, of length `n` each:<br><br>   `plantTime[i]` is the number of full days it takes you to plant the `ith` seed. Every day, you can work on planting exactly one seed. You do not have to work on planting the same seed on consecutive days, but the planting of a seed is not complete until you have worked `plantTime[i]` days on planting it in total.<br>   `growTime[i]` is the number of full days it takes the `ith` seed to grow after being completely planted. After the last day of its growth, the flower blooms and stays bloomed forever.<br><br>From the beginning of day `0`, you can plant the seeds in any order.<br><br>Return _the earliest possible day where all seeds are blooming_.<br><br>Example 1:<br><br>Input: plantTime = \[1,4,3\], growTime = \[2,3,1\]<br>Output: 9<br>Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.<br>One optimal way is:<br>On day 0, plant the 0th seed. The seed grows for 2 full days and blooms on day 3.<br>On days 1, 2, 3, and 4, plant the 1st seed. The seed grows for 3 full days and blooms on day 8.<br>On days 5, 6, and 7, plant the 2nd seed. The seed grows for 1 full day and blooms on day 9.<br>Thus, on day 9, all the seeds are blooming.<br><br>Example 2:<br><br>Input: plantTime = \[1,2,3,2\], growTime = \[2,1,2,1\]<br>Output: 9<br>Explanation: The grayed out pots represent planting days, colored pots represent growing days, and the flower represents the day it blooms.<br>One optimal way is:<br>On day 1, plant the 0th seed. The seed grows for 2 full days and blooms on day 4.<br>On days 0 and 3, plant the 1st seed. The seed grows for 1 full day and blooms on day 5.<br>On days 2, 4, and 5, plant the 2nd seed. The seed grows for 2 full days and blooms on day 8.<br>On days 6 and 7, plant the 3rd seed. The seed grows for 1 full day and blooms on day 9.<br>Thus, on day 9, all the seeds are blooming.<br><br>Example 3:<br><br>Input: plantTime = \[1\], growTime = \[1\]<br>Output: 2<br>Explanation: On day 0, plant the 0th seed. The seed grows for 1 full day and blooms on day 2.<br>Thus, on day 2, all the seeds are blooming.<br><br>Constraints:<br><br>   `n == plantTime.length == growTime.length`<br>   `1 <= n <= 105`<br>   `1 <= plantTime[i], growTime[i] <= 104`"""<br><br>    n = len(plantTime)<br>    processTime = list(zip(plantTime, growTime))<br>    processTime.sort()<br><br>    day = 0<br>    blooms = 0<br>    for p in processTime:<br>        day += p[0]<br>        blooms = max(blooms, day + p[1])<br>    return blooms
