# Query `11`

## Original Question

*According to [Wikipedia's article](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life): "The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. "

The board is made up of an `m x n` grid of cells, where each cell has an initial state: live (represented by a `1`) or dead (represented by a `0`). Each cell interacts with its [eight neighbors](https://en.wikipedia.org/wiki/Moore_neighborhood) (horizontal, vertical, diagonal) using the following four rules (taken from the above Wikipedia article):

1.  Any live cell with fewer than two live neighbors dies as if caused by under-population.
2.  Any live cell with two or three live neighbors lives on to the next generation.
3.  Any live cell with more than three live neighbors dies, as if by over-population.
4.  Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.

The next state is created by applying the above rules simultaneously to every cell in the current state, where births and deaths occur simultaneously. Given the current state of the `m x n` grid `board`, return _the next state_.

Example 1:

Input: board = \[\[0,1,0\],\[0,0,1\],\[1,1,1\],\[0,0,0\]\]
Output: \[\[0,0,0\],\[1,0,1\],\[0,1,1\],\[0,1,0\]\]

Example 2:

Input: board = \[\[1,1\],\[1,0\]\]
Output: \[\[1,1\],\[1,1\]\]

Constraints:

   `m == board.length`
   `n == board[i].length`
   `1 <= m, n <= 25`
   `board[i][j]` is `0` or `1`.

Follow up:

   Could you solve it in-place? Remember that the board needs to be updated simultaneously: You cannot update some cells first and then use their updated values to update other cells.
   In this question, we represent the board using a 2D array. In principle, the board is infinite, which would cause problems when the active area encroaches upon the border of the array (i.e., live cells reach the border). How would you address these problems?*

## gpt4 Reasoning

```markdown
The essential problem here is to compute the next state of a grid in Conway's Game of Life, adhering to its rules. This involves checking each cell's neighbors and applying the rules to determine if each cell will be alive or dead in the next generation. The challenge is to do this simultaneously for all cells, as the state of one cell depends on the unchanged states of its neighbors. Let's break down the solution and address the follow-up questions.

### Solving the Problem

1. **Iterate Over the Grid**: Go through each cell in the grid to evaluate its next state based on its neighbors.

2. **Count Live Neighbors**: For each cell, count the number of live neighbors it has. This involves checking up to eight surrounding cells. Be careful to handle edge cases where cells are on the border of the grid and have fewer neighbors.

3. **Apply the Rules**: Based on the count of live neighbors, determine the next state of each cell:
    - A live cell with fewer than two live neighbors dies.
    - A live cell with two or three live neighbors survives.
    - A live cell with more than three live neighbors dies.
    - A dead cell with exactly three live neighbors becomes alive.

4. **Simultaneous Updates**: To ensure that all cells are updated simultaneously, one approach is to create a copy of the board where changes can be made. Once all cells have been evaluated, this copy becomes the new state of the board.

### Follow-up: In-place Solution

To update the board in-place without a separate copy, we need a way to store both the current and next states of a cell simultaneously. This can be achieved using extra bits in the integer value of each cell to encode this information.

- **Encoding State Transitions**: Use two bits for each cell. The first bit represents the current state, and the second bit represents the next state. For example, `00` means the cell is currently dead and remains dead; `01` means the cell is currently dead but becomes alive; `10` means the cell is currently alive but dies; and `11` means the cell is alive and remains alive.
- **Updating In-place**: Iterate over the grid, count live neighbors, and use the rules to set the second bit according to what the next state should be. After all cells are processed, iterate over the grid again and update each cell to its next state by shifting the bits.

### Handling an Infinite Grid

For an infinite grid, the problem becomes more complex because we cannot iterate over an infinite number of cells, and live cells can potentially expand towards infinity.

1. **Active Region**: Instead of considering the entire infinite grid, focus on the active region, which includes all live cells and the dead cells that are neighbors of live cells. Only this region has the potential to change in the next generation.

2. **Dynamic Data Structures**: Use a hash set or a similar structure to keep track of the coordinates of live cells. This way, you only need to consider and update the cells that are either alive or could become alive based on their neighbors.

3. **Expansion Handling**: When computing the next generation, check if any new cells become alive at the border of the active region and expand the region accordingly. This approach dynamically adjusts to changes and keeps the computation feasible.

By applying these strategies, we can address the challenges of updating the grid state simultaneously and handling an infinite grid, adhering to the rules of Conway's Game of Life.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_17939.txt
> def play(self):<br>        """ Play Conway's Game of Life. """<br><br>        # Write the initial configuration to file.<br><br>        self.t = 1  # Current time level<br>        while self.t <= self.T:  # Evolve!<br>            # print( "At time level %d" % t)<br><br>            # Loop over each cell of the grid and apply Conway's rules.<br>            for i in range(self.N):<br>                for j in range(self.N):<br>                    live = self.live_neighbours(i, j)<br>                    if (self.old_grid[i][j] == 1 and live < 2):<br>                        self.new_grid[i][j] = 0  # Dead from starvation.<br>                    elif (self.old_grid[i][j] == 1 and (live == 2 or live == 3)):<br>                        self.new_grid[i][j] = 1  # Continue living.<br>                    elif (self.old_grid[i][j] == 1 and live  3):<br>                        self.new_grid[i][j] = 0  # Dead from overcrowding.<br>                    elif (self.old_grid[i][j] == 0 and live == 3):<br>                        self.new_grid[i][j] = 1  # Alive from reproduction.<br><br>            # Output the new configuration.<br><br>            # The new configuration becomes the old configuration for the next generation.<br>            self.old_grid = self.new_grid.copy()<br>            self.draw_board()<br>            # Move on to the next time level<br>            self.t += 1

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_72821.txt
> def update_state(world):<br>    """<br>    Increment the world state, determining which cells live, die, or appear.<br><br>    Args:<br>        world (list[list]): A square matrix of cells<br><br>    Returns: None<br>    """<br><br>    world_size = len(world)<br><br>    def wrap(index):<br>        """Wrap an index around the other end of the array"""<br>        return index % world_size<br><br>    for x in range(world_size):<br>        for y in range(world_size):<br>            # Decide if this node cares about the rules right now<br>            if not world[x][y].allow_change.get():<br>                continue<br>            live_neighbor_count = sum([<br>                world[wrap(x)][wrap(y + 1)].value,<br>                world[wrap(x + 1)][wrap(y + 1)].value,<br>                world[wrap(x + 1)][wrap(y)].value,<br>                world[wrap(x + 1)][wrap(y - 1)].value,<br>                world[wrap(x)][wrap(y-1)].value,<br>                world[wrap(x - 1)][wrap(y - 1)].value,<br>                world[wrap(x - 1)][wrap(y)].value,<br>                world[wrap(x - 1)][wrap(y + 1)].value<br>            ])<br>            if world[x][y].value:<br>                # Any live cell with fewer than two live neighbours dies<br>                # Any live cell with more than three live neighbours dies<br>                # Any live cell with two or three live neighbours lives<br>                if not (live_neighbor_count == 2 or live_neighbor_count == 3):<br>                    world[x][y].value = False<br>            else:<br>                # Any dead cell with exactly three live neighbours comes alive<br>                if live_neighbor_count == 3:<br>                    world[x][y].value = True

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_73443.txt
> def main():<br>    """Play Conway's Game of Life on the terminal."""<br>    def die((x, y)):<br>        """Pretend any out-of-bounds cell is dead."""<br>        if 0 <= x < width and 0 <= y < height:<br>            return x, y<br><br>    LOAD_FACTOR = 9  # Smaller means more crowded.<br>    NUDGING_LOAD_FACTOR = LOAD_FACTOR  3  # Smaller means a bigger nudge.<br><br>    term = Terminal()<br>    width = term.width<br>    height = term.height<br>    board = random_board(width - 1, height - 1, LOAD_FACTOR)<br>    detector = BoredomDetector()<br>    cells = cell_strings(term)<br><br>    with nested(term.fullscreen(), term.hidden_cursor()):<br>        try:<br>            while True:<br>                frame_end = time() + 0.05<br>                board = next_board(board, die)<br>                draw(board, term, cells)<br><br>                # If the pattern is stuck in a loop, give it a nudge:<br>                if detector.is_bored_of(board):<br>                    board.update(random_board(width - 1,<br>                                              height - 1,<br>                                              NUDGING_LOAD_FACTOR))<br><br>                stdout.flush()<br>                sleep_until(frame_end)<br>                clear(board, term, height)<br>        except KeyboardInterrupt:<br>            pass

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_5702.txt
> def beam_search(symbols_to_logits_fn,<br>                initial_ids,<br>                beam_size,<br>                decode_length,<br>                vocab_size,<br>                alpha,<br>                states=None,<br>                eos_id=EOS_ID,<br>                stop_early=True,<br>                use_tpu=False,<br>                use_top_k_with_unique=True):<br>  """Beam search with length penalties.<br><br>  Requires a function that can take the currently decoded symbols and return<br>  the logits for the next symbol. The implementation is inspired by<br>  https://arxiv.org/abs/1609.08144.<br><br>  When running, the beam search steps can be visualized by using tfdbg to watch<br>  the operations generating the output ids for each beam step.  These operations<br>  have the pattern:<br>    (alive|finished)_topk_(seq,scores)<br><br>  Operations marked `alive` represent the new beam sequences that will be<br>  processed in the next step.  Operations marked `finished` represent the<br>  completed beam sequences, which may be padded with 0s if no beams finished.<br><br>  Operations marked `seq` store the full beam sequence for the time step.<br>  Operations marked `scores` store the sequence's final log scores.<br><br>  The beam search steps will be processed sequentially in order, so when<br>  capturing observed from these operations, tensors, clients can make<br>  assumptions about which step is being recorded.<br><br>  WARNING: Assumes 2nd dimension of tensors in `states` and not invariant, this<br>  means that the shape of the 2nd dimension of these tensors will not be<br>  available (i.e. set to None) inside symbols_to_logits_fn.<br><br>  Args:<br>    symbols_to_logits_fn: Interface to the model, to provide logits.<br>        Shoud take [batch_size, decoded_ids] and return [batch_size, vocab_size]<br>    initial_ids: Ids to start off the decoding, this will be the first thing<br>        handed to symbols_to_logits_fn (after expanding to beam size)<br>        [batch_size]<br>    beam_size: Size of the beam.<br>    decode_length: Number of steps to decode for.<br>    vocab_size: Size of the vocab, must equal the size of the logits returned by<br>        symbols_to_logits_fn<br>    alpha: alpha for length penalty.<br>    states: dict (possibly nested) of decoding states.<br>    eos_id: ID for end of sentence.<br>    stop_early: a boolean - stop once best sequence is provably determined.<br>    use_tpu: A bool, whether to do beam search on TPU.<br>    use_top_k_with_unique: bool, whether to use a fast (but decreased precision)<br>      top_k during TPU beam search.<br><br>  Returns:<br>    Tuple of<br>    (decoded beams [batch_size, beam_size, decode_length]<br>     decoding probabilities [batch_size, beam_size])<br>  """<br>  batch_size = common_layers.shape_list(initial_ids)[0]<br><br>  # Assume initial_ids are prob 1.0<br>  initial_log_probs = tf.constant([[0.] + [-INF]  (beam_size - 1)])<br>  # Expand to beam_size (batch_size, beam_size)<br>  alive_log_probs = tf.tile(initial_log_probs, [batch_size, 1])<br><br>  # Expand each batch and state to beam_size<br>  alive_seq = _expand_to_beam_size(initial_ids, beam_size)<br>  alive_seq = tf.expand_dims(alive_seq, axis=2)  # (batch_size, beam_size, 1)<br>  if use_tpu:<br>    alive_seq = tf.tile(alive_seq, [1, 1, decode_length + 1])<br>  if states:<br>    states = nest.map_structure(<br>        lambda state: _expand_to_beam_size(state, beam_size), states)<br>  else:<br>    states = {}<br><br>  # Finished will keep track of all the sequences that have finished so far<br>  # Finished log probs will be negative infinity in the beginning<br>  # finished_flags will keep track of booleans<br>  finished_seq = tf.zeros(common_layers.shape_list(alive_seq), tf.int32)<br>  # Setting the scores of the initial to negative infinity.<br>  finished_scores = tf.ones([batch_size, beam_size])  -INF<br>  finished_flags = tf.zeros([batch_size, beam_size], tf.bool)<br><br>  def grow_finished(finished_seq, finished_scores, finished_flags, curr_seq,<br>                    curr_scores, curr_finished):<br>    """Given sequences and scores, will gather the top k=beam size sequences.<br><br>    Args:<br>      finished_seq: Current finished sequences.<br>        [batch_size, beam_size, current_decoded_length]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br>      finished_flags: finished bools for each of these sequences.<br>        [batch_size, beam_size]<br>      curr_seq: current topk sequence that has been grown by one position.<br>        [batch_size, beam_size, current_decoded_length]<br>      curr_scores: scores for each of these sequences. [batch_size, beam_size]<br>      curr_finished: Finished flags for each of these sequences.<br>        [batch_size, beam_size]<br>    Returns:<br>      Tuple of<br>        (Topk sequences based on scores,<br>         log probs of these sequences,<br>         Finished flags of these sequences)<br>    """<br>    if not use_tpu:<br>      # First append a column of 0'ids to finished to make the same length with<br>      # finished scores<br>      finished_seq = tf.concat(<br>          [finished_seq,<br>           tf.zeros([batch_size, beam_size, 1], tf.int32)], axis=2)<br><br>    # Set the scores of the unfinished seq in curr_seq to large negative<br>    # values<br>    curr_scores += (1. - tf.to_float(curr_finished))  -INF<br>    # concatenating the sequences and scores along beam axis<br>    curr_finished_seq = tf.concat([finished_seq, curr_seq], axis=1)<br>    curr_finished_scores = tf.concat([finished_scores, curr_scores], axis=1)<br>    curr_finished_flags = tf.concat([finished_flags, curr_finished], axis=1)<br>    return compute_topk_scores_and_seq(<br>        curr_finished_seq,<br>        curr_finished_scores,<br>        curr_finished_scores,<br>        curr_finished_flags,<br>        beam_size,<br>        batch_size,<br>        "grow_finished",<br>        use_tpu=use_tpu,<br>        use_top_k_with_unique=use_top_k_with_unique)<br><br>  def grow_alive(curr_seq, curr_scores, curr_log_probs, curr_finished, states):<br>    """Given sequences and scores, will gather the top k=beam size sequences.<br><br>    Args:<br>      curr_seq: current topk sequence that has been grown by one position.<br>        [batch_size, beam_size, i+1]<br>      curr_scores: scores for each of these sequences. [batch_size, beam_size]<br>      curr_log_probs: log probs for each of these sequences.<br>        [batch_size, beam_size]<br>      curr_finished: Finished flags for each of these sequences.<br>        [batch_size, beam_size]<br>      states: dict (possibly nested) of decoding states.<br>    Returns:<br>      Tuple of<br>        (Topk sequences based on scores,<br>         log probs of these sequences,<br>         Finished flags of these sequences)<br>    """<br>    # Set the scores of the finished seq in curr_seq to large negative<br>    # values<br>    curr_scores += tf.to_float(curr_finished)  -INF<br>    return compute_topk_scores_and_seq(curr_seq, curr_scores, curr_log_probs,<br>                                       curr_finished, beam_size, batch_size,<br>                                       "grow_alive", states, use_tpu=use_tpu)<br><br>  def grow_topk(i, alive_seq, alive_log_probs, states):<br>    r"""Inner beam search loop.<br><br>    This function takes the current alive sequences, and grows them to topk<br>    sequences where k = 2beam. We use 2beam because, we could have beam_size<br>    number of sequences that might hit <EOS and there will be no alive<br>    sequences to continue. With 2beam_size, this will not happen. This relies<br>    on the assumption the vocab size is  beam size. If this is true, we'll<br>    have at least beam_size non <EOS extensions if we extract the next top<br>    2beam words.<br>    Length penalty is given by = (5+len(decode)/6) ^ -\alpha. Pls refer to<br>    https://arxiv.org/abs/1609.08144.<br><br>    Args:<br>      i: loop index<br>      alive_seq: Topk sequences decoded so far [batch_size, beam_size, i+1]<br>      alive_log_probs: probabilities of these sequences. [batch_size, beam_size]<br>      states: dict (possibly nested) of decoding states.<br>    Returns:<br>      Tuple of<br>        (Topk sequences extended by the next word,<br>         The log probs of these sequences,<br>         The scores with length penalty of these sequences,<br>         Flags indicating which of these sequences have finished decoding,<br>         dict of transformed decoding states)<br>    """<br>    # Get the logits for all the possible next symbols<br>    if use_tpu and states:<br>      flat_ids = tf.reshape(<br>          tf.slice(alive_seq, [0, 0, i], [batch_size, beam_size, 1]),<br>          [batch_size  beam_size, -1])<br>    else:<br>      flat_ids = tf.reshape(alive_seq, [batch_size  beam_size, -1])<br><br>    # (batch_size  beam_size, decoded_length)<br>    if states:<br>      flat_states = nest.map_structure(_merge_beam_dim, states)<br>      flat_logits, flat_states = symbols_to_logits_fn(flat_ids, i, flat_states)<br>      states = nest.map_structure(<br>          lambda t: _unmerge_beam_dim(t, batch_size, beam_size), flat_states)<br>    elif use_tpu:<br>      flat_logits = symbols_to_logits_fn(flat_ids, i)<br>    else:<br>      flat_logits = symbols_to_logits_fn(flat_ids)<br><br>    logits = tf.reshape(flat_logits, [batch_size, beam_size, -1])<br><br>    # Convert logits to normalized log probs<br>    candidate_log_probs = common_layers.log_prob_from_logits(logits)<br><br>    # Multiply the probabilities by the current probabilities of the beam.<br>    # (batch_size, beam_size, vocab_size) + (batch_size, beam_size, 1)<br>    log_probs = candidate_log_probs + tf.expand_dims(alive_log_probs, axis=2)<br><br>    length_penalty = tf.pow(((5. + tf.to_float(i + 1)) / 6.), alpha)<br><br>    curr_scores = log_probs / length_penalty<br>    # Flatten out (beam_size, vocab_size) probs in to a list of possibilities<br>    flat_curr_scores = tf.reshape(curr_scores, [-1, beam_size  vocab_size])<br><br>    if use_tpu and use_top_k_with_unique:<br>      topk_scores, topk_ids = top_k_with_unique(<br>          flat_curr_scores, k=beam_size  2)<br>    else:<br>      topk_scores, topk_ids = tf.nn.top_k(flat_curr_scores, k=beam_size  2)<br><br>    # Recovering the log probs because we will need to send them back<br>    topk_log_probs = topk_scores  length_penalty<br><br>    # Work out what beam the top probs are in.<br>    topk_beam_index = topk_ids // vocab_size<br>    topk_ids %= vocab_size  # Unflatten the ids<br><br>    if not use_tpu:<br>      # The next three steps are to create coordinates for tf.gather_nd to pull<br>      # out the correct sequences from id's that we need to grow.<br>      # We will also use the coordinates to gather the booleans of the beam<br>      # items that survived.<br>      batch_pos = compute_batch_indices(batch_size, beam_size  2)<br><br>      # top beams will give us the actual coordinates to do the gather.<br>      # stacking will create a tensor of dimension batch  beam  2, where the<br>      # last dimension contains the i,j gathering coordinates.<br>      topk_coordinates = tf.stack([batch_pos, topk_beam_index], axis=2)<br><br>      # Gather up the most probable 2beams both for the ids and<br>      # finished_in_alive bools<br>      topk_seq = tf.gather_nd(alive_seq, topk_coordinates)<br>      if states:<br>        states = nest.map_structure(<br>            lambda state: tf.gather_nd(state, topk_coordinates), states)<br><br>      # Append the most probable alive<br>      topk_seq = tf.concat([topk_seq, tf.expand_dims(topk_ids, axis=2)], axis=2)<br>    else:<br>      # Gather up the most probable 2beams both for the ids and<br>      # finished_in_alive bools<br>      topk_seq = fast_tpu_gather(alive_seq, topk_beam_index)<br><br>      if states:<br>        states = nest.map_structure(<br>            lambda state: fast_tpu_gather(state, topk_beam_index), states)<br><br>      # Update the most probable alive<br>      topk_seq = tf.transpose(topk_seq, perm=[2, 0, 1])<br>      topk_seq = inplace_ops.alias_inplace_update(topk_seq, i + 1, topk_ids)<br>      topk_seq = tf.transpose(topk_seq, perm=[1, 2, 0])<br><br>    topk_finished = tf.equal(topk_ids, eos_id)<br><br>    return topk_seq, topk_log_probs, topk_scores, topk_finished, states<br><br>  def inner_loop(i, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>                 finished_flags, states):<br>    """Inner beam search loop.<br><br>    There are three groups of tensors, alive, finished, and topk.<br>    The alive group contains information about the current alive sequences<br>    The topk group contains information about alive + topk current decoded words<br>    the finished group contains information about finished sentences, that is,<br>    the ones that have decoded to <EOS. These are what we return.<br>    The general beam search algorithm is as follows:<br>    While we haven't terminated (pls look at termination condition)<br>      1. Grow the current alive to get beam2 topk sequences<br>      2. Among the topk, keep the top beam_size ones that haven't reached EOS<br>      into alive<br>      3. Among the topk, keep the top beam_size ones have reached EOS into<br>      finished<br>    Repeat<br>    To make things simple with using fixed size tensors, we will end<br>    up inserting unfinished sequences into finished in the beginning. To stop<br>    that we add -ve INF to the score of the unfinished sequence so that when a<br>    true finished sequence does appear, it will have a higher score than all the<br>    unfinished ones.<br><br>    Args:<br>      i: loop index<br>      alive_seq: Topk sequences decoded so far [batch_size, beam_size, i+1]<br>      alive_log_probs: probabilities of the beams. [batch_size, beam_size]<br>      finished_seq: Current finished sequences.<br>        [batch_size, beam_size, i+1]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br>      finished_flags: finished bools for each of these sequences.<br>        [batch_size, beam_size]<br>      states: dict (possibly nested) of decoding states.<br><br>    Returns:<br>      Tuple of<br>        (Incremented loop index<br>         New alive sequences,<br>         Log probs of the alive sequences,<br>         New finished sequences,<br>         Scores of the new finished sequences,<br>         Flags indicating which sequence in finished as reached EOS,<br>         dict of final decoding states)<br>    """<br><br>    # Each inner loop, we carry out three steps:<br>    # 1. Get the current topk items.<br>    # 2. Extract the ones that have finished and haven't finished<br>    # 3. Recompute the contents of finished based on scores.<br>    topk_seq, topk_log_probs, topk_scores, topk_finished, states = grow_topk(<br>        i, alive_seq, alive_log_probs, states)<br>    alive_seq, alive_log_probs, _, states = grow_alive(<br>        topk_seq, topk_scores, topk_log_probs, topk_finished, states)<br>    finished_seq, finished_scores, finished_flags, _ = grow_finished(<br>        finished_seq, finished_scores, finished_flags, topk_seq, topk_scores,<br>        topk_finished)<br><br>    return (i + 1, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>            finished_flags, states)<br><br>  def _is_finished(i, unused_alive_seq, alive_log_probs, unused_finished_seq,<br>                   finished_scores, unused_finished_in_finished, unused_states):<br>    """Checking termination condition.<br><br>    We terminate when we decoded up to decode_length or the lowest scoring item<br>    in finished has a greater score that the highest prob item in alive divided<br>    by the max length penalty<br><br>    Args:<br>      i: loop index<br>      alive_log_probs: probabilities of the beams. [batch_size, beam_size]<br>      finished_scores: scores for each of these sequences.<br>        [batch_size, beam_size]<br><br>    Returns:<br>      Bool.<br>    """<br>    max_length_penalty = tf.pow(((5. + tf.to_float(decode_length)) / 6.), alpha)<br>    # The best possible score of the most likely alive sequence.<br>    lower_bound_alive_scores = alive_log_probs[:, 0] / max_length_penalty<br><br>    if not stop_early:<br>      # by considering the min score (in the top N beams) we ensure that<br>      # the decoder will keep decoding until there is at least one beam<br>      # (in the top N) that can be improved (w.r.t. the alive beams).<br>      # any unfinished beam will have score -INF - thus the min<br>      # will always be -INF if there is at least one unfinished beam -<br>      # which means the bound_is_met condition cannot be true in this case.<br>      lowest_score_of_finished_in_finished = tf.reduce_min(finished_scores)<br>    else:<br>      # by taking the max score we only care about the first beam;<br>      # as soon as this first beam cannot be beaten from the alive beams<br>      # the beam decoder can stop.<br>      # similarly to the above, if the top beam is not completed, its<br>      # finished_score is -INF, thus it will not activate the<br>      # bound_is_met condition. (i.e., decoder will keep going on).<br>      # note we need to find the max for every sequence eparately - so, we need<br>      # to keep the batch dimension (see axis=1)<br>      lowest_score_of_finished_in_finished = tf.reduce_max(finished_scores,<br>                                                           axis=1)<br><br>    bound_is_met = tf.reduce_all(<br>        tf.greater(lowest_score_of_finished_in_finished,<br>                   lower_bound_alive_scores))<br><br>    return tf.logical_and(<br>        tf.less(i, decode_length), tf.logical_not(bound_is_met))<br><br>  inner_shape = tf.TensorShape([None, None, None])<br>  if use_tpu:<br>    inner_shape = tf.TensorShape([batch_size, beam_size, decode_length + 1])<br>  if use_tpu:<br>    state_struc = nest.map_structure(lambda state: state.get_shape(), states)<br>  else:<br>    state_struc = nest.map_structure(get_state_shape_invariants, states)<br>  (_, alive_seq, alive_log_probs, finished_seq, finished_scores,<br>   finished_flags, states) = tf.while_loop(<br>       _is_finished,<br>       inner_loop, [<br>           tf.constant(0), alive_seq, alive_log_probs, finished_seq,<br>           finished_scores, finished_flags, states<br>       ],<br>       shape_invariants=[<br>           tf.TensorShape([]),<br>           inner_shape,<br>           alive_log_probs.get_shape(),<br>           inner_shape,<br>           finished_scores.get_shape(),<br>           finished_flags.get_shape(),<br>           state_struc<br>       ],<br>       parallel_iterations=1,<br>       back_prop=False)<br><br>  alive_seq.set_shape((None, beam_size, None))<br>  finished_seq.set_shape((None, beam_size, None))<br><br>  # Accounting for corner case: It's possible that no sequence in alive for a<br>  # particular batch item ever reached EOS. In that case, we should just copy<br>  # the contents of alive for that batch item. tf.reduce_any(finished_flags, 1)<br>  # if 0, means that no sequence for that batch index had reached EOS. We need<br>  # to do the same for the scores as well.<br>  finished_seq = tf.where(<br>      tf.reduce_any(finished_flags, 1), finished_seq, alive_seq)<br>  finished_scores = tf.where(<br>      tf.reduce_any(finished_flags, 1), finished_scores, alive_log_probs)<br>  return finished_seq, finished_scores, states

### DOC[5] (IRRELEVANT) leetcode/leetcode_1659.txt
> def maxSum(nums1, nums2):<br>    """You are given four integers, `m`, `n`, `introvertsCount`, and `extrovertsCount`. You have an `m x n` grid, and there are two types of people: introverts and extroverts. There are `introvertsCount` introverts and `extrovertsCount` extroverts.<br><br>You should decide how many people you want to live in the grid and assign each of them one grid cell. Note that you do not have to have all the people living in the grid.<br><br>The happiness of each person is calculated as follows:<br><br>   Introverts start with `120` happiness and lose `30` happiness for each neighbor (introvert or extrovert).<br>   Extroverts start with `40` happiness and gain `20` happiness for each neighbor (introvert or extrovert).<br><br>Neighbors live in the directly adjacent cells north, east, south, and west of a person's cell.<br><br>The grid happiness is the sum of each person's happiness. Return _the maximum possible grid happiness._<br><br>Example 1:<br><br>Input: m = 2, n = 3, introvertsCount = 1, extrovertsCount = 2<br>Output: 240<br>Explanation: Assume the grid is 1-indexed with coordinates (row, column).<br>We can put the introvert in cell (1,1) and put the extroverts in cells (1,3) and (2,3).<br>- Introvert at (1,1) happiness: 120 (starting happiness) - (0 \ 30) (0 neighbors) = 120<br>- Extrovert at (1,3) happiness: 40 (starting happiness) + (1 \ 20) (1 neighbor) = 60<br>- Extrovert at (2,3) happiness: 40 (starting happiness) + (1 \ 20) (1 neighbor) = 60<br>The grid happiness is 120 + 60 + 60 = 240.<br>The above figure shows the grid in this example with each person's happiness. The introvert stays in the light green cell while the extroverts live on the light purple cells.<br><br>Example 2:<br><br>Input: m = 3, n = 1, introvertsCount = 2, extrovertsCount = 1<br>Output: 260<br>Explanation: Place the two introverts in (1,1) and (3,1) and the extrovert at (2,1).<br>- Introvert at (1,1) happiness: 120 (starting happiness) - (1 \ 30) (1 neighbor) = 90<br>- Extrovert at (2,1) happiness: 40 (starting happiness) + (2 \ 20) (2 neighbors) = 80<br>- Introvert at (3,1) happiness: 120 (starting happiness) - (1 \ 30) (1 neighbor) = 90<br>The grid happiness is 90 + 80 + 90 = 260.<br><br>Example 3:<br><br>Input: m = 2, n = 2, introvertsCount = 4, extrovertsCount = 0<br>Output: 240<br><br>Constraints:<br><br>   `1 <= m, n <= 5`<br>   `0 <= introvertsCount, extrovertsCount <= min(m  n, 6)`"""<br><br>    mod = 109 + 7<br>    m, n = len(nums1), len(nums2)<br>    dp1, dp2 = [0]  (m + 1), [0]  (n + 1)<br>    i, j = m - 1, n - 1<br>    while i = 0 or j = 0:<br>        a = dp1[i] + nums1[i] if i = 0 else float('-inf')<br>        b = dp2[j] + nums2[j] if j = 0 else float('-inf')<br>        seen = set()<br>        if a  b:<br>            dp1[i] = a % mod<br>            i -= 1<br>            seen.add(nums1[i + 1])<br>        else:<br>            dp2[j] = b % mod<br>            j -= 1<br>            seen.add(nums2[j + 1])<br>    return max(dp1[0], dp2[0]) % mod


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_73.txt
> def setZeroes(matrix):<br>    """Given an `m x n` integer matrix `matrix`, if an element is `0`, set its entire row and column to `0`'s.<br><br>You must do it [in place](https://en.wikipedia.org/wiki/In-place_algorithm).<br><br>Example 1:<br><br>Input: matrix = \[\[1,1,1\],\[1,0,1\],\[1,1,1\]\]<br>Output: \[\[1,0,1\],\[0,0,0\],\[1,0,1\]\]<br><br>Example 2:<br><br>Input: matrix = \[\[0,1,2,0\],\[3,4,5,2\],\[1,3,1,5\]\]<br>Output: \[\[0,0,0,0\],\[0,4,5,0\],\[0,3,1,0\]\]<br><br>Constraints:<br><br>   `m == matrix.length`<br>   `n == matrix[0].length`<br>   `1 <= m, n <= 200`<br>   `-231 <= matrix[i][j] <= 231 - 1`<br><br>Follow up:<br><br>   A straightforward solution using `O(mn)` space is probably a bad idea.<br>   A simple improvement uses `O(m + n)` space, but still not the best solution.<br>   Could you devise a constant space solution?"""<br><br>    rows = len(matrix)<br>    cols = len(matrix[0])<br>    firstRow, firstCol = False, False<br><br>    for i in range(rows):<br>        for j in range(cols):<br>            if matrix[i][j] == 0:<br>                if i == 0: firstRow = True<br>                if j == 0: firstCol = True<br>                matrix[i][0] = 0<br>                matrix[0][j] = 0<br><br>    for i in range(1, rows):<br>        for j in range(1, cols):<br>            if matrix[i][0] == 0 or matrix[0][j] == 0:<br>                matrix[i][j] = 0<br><br>    if firstRow:<br>        for j in range(cols):<br>            matrix[0][j] = 0<br><br>    if firstCol:<br>        for i in range(rows):<br>            matrix[i][0] = 0
