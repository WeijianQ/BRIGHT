# Query `25`

## Original Question

*Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most `k` distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.

You are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.

Initially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.

Pick a list of at most `k` distinct projects from given projects to maximize your final capital, and return _the final maximized capital_.

The answer is guaranteed to fit in a 32-bit signed integer.

Example 1:

Input: k = 2, w = 0, profits = \[1,2,3\], capital = \[0,1,1\]
Output: 4
Explanation: Since your initial capital is 0, you can only start the project indexed 0.
After finishing it you will obtain profit 1 and your capital becomes 1.
With capital 1, you can either start the project indexed 1 or the project indexed 2.
Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.
Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.

Example 2:

Input: k = 3, w = 0, profits = \[1,2,3\], capital = \[0,1,2\]
Output: 6

Constraints:

   `1 <= k <= 105`
   `0 <= w <= 109`
   `n == profits.length`
   `n == capital.length`
   `1 <= n <= 105`
   `0 <= profits[i] <= 104`
   `0 <= capital[i] <= 109`*

## gpt4 Reasoning

```markdown
The essential problem here is an optimization problem where we have to maximize the total capital by selecting at most `k` distinct projects from a given list of projects, each with its own profit and required capital to start. To solve this problem, we need to carefully select projects that can be started with the available capital and yield the highest profit, thereby increasing the total capital for potentially starting more projects. 

Here's a step-by-step approach to address this problem:

### Step 1: Understanding the Constraints and Preparing the Data

First, we need to understand the constraints:
- We can select at most `k` projects.
- We start with an initial capital `w`.
- Each project requires a minimum capital `capital[i]` to start and yields a profit `profits[i]` upon completion.

Given these constraints, it's clear that we cannot simply pick the projects with the highest profits because we might not have enough capital to start those projects. Therefore, the projects need to be selected based not only on the profit they yield but also on the capital required to start them.

### Step 2: Prioritizing Projects

To efficiently pick projects, we can use a priority queue (or a heap data structure) in two ways:
- One priority queue (min-heap) to keep track of projects based on the required capital, so we can easily find the projects we have enough capital to start.
- Another priority queue (max-heap) to keep track of the profitable projects that we can afford, so we can always choose the most profitable project available to us.

### Step 3: Algorithm

1. **Initialization**: Start by adding all projects to the min-heap based on their required capital. This will help us quickly identify which projects are feasible to start with the initial capital `w`.

2. **Project Selection**: For each of the `k` projects we are allowed to pick:
   - Move all projects from the min-heap (capital-based) to the max-heap (profit-based) that we can afford with our current capital (`w` or more).
   - If the max-heap is not empty, select the project with the highest profit (top of the max-heap). Remove this project from the heap, and add its profit to our total capital `w`.
   - If the max-heap is empty and we can't start any project, we break out of the loop as we can't select more projects.

3. **Maximized Capital**: After iterating through up to `k` projects, the total capital `w` is our maximized capital.

### Step 4: Handling Edge Cases

- If `k` is larger than the number of projects we can feasibly start with our given capital, we simply select as many as we can up to the point where either all projects have been selected or we can no longer afford to start any new projects.
- We need to ensure that we do not select a project more than once. This is inherently handled because once a project is selected, it's removed from the max-heap.

### Conclusion

By following these steps, we can maximize the total capital after finishing at most `k` distinct projects. This approach ensures that we always pick the most profitable projects that we can afford at any point, thus optimizing our total capital.
```

### Metrics

```
recip_rank: 0.0029
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_244722.txt
> def pick(self, form, target_units, parcel_size, ave_unit_size,<br>             current_units, max_parcel_size=200000, min_unit_size=400,<br>             drop_after_build=True, residential=True, bldg_sqft_per_job=400.0,<br>             profit_to_prob_func=None):<br>        """<br>        Choose the buildings from the list that are feasible to build in<br>        order to match the specified demand.<br><br>        Parameters<br>        ----------<br>        form : string or list<br>            One or more of the building forms from the pro forma specification -<br>            e.g. "residential" or "mixedresidential" - these are configuration<br>            parameters passed previously to the pro forma.  If more than one form<br>            is passed the forms compete with each other (based on profitability)<br>            for which one gets built in order to meet demand.<br>        target_units : int<br>            The number of units to build.  For non-residential buildings this<br>            should be passed as the number of job spaces that need to be created.<br>        parcel_size : series<br>            The size of the parcels.  This was passed to feasibility as well,<br>            but should be passed here as well.  Index should be parcel_ids.<br>        ave_unit_size : series<br>            The average residential unit size around each parcel - this is<br>            indexed by parcel, but is usually a disaggregated version of a<br>            zonal or accessibility aggregation.<br>        bldg_sqft_per_job : float (default 400.0)<br>            The average square feet per job for this building form.<br>        min_unit_size : float<br>            Values less than this number in ave_unit_size will be set to this<br>            number.  Deals with cases where units are currently not built.<br>        current_units : series<br>            The current number of units on the parcel.  Is used to compute the<br>            net number of units produced by the developer model.  Many times<br>            the developer model is redeveloping units (demolishing them) and<br>            is trying to meet a total number of net units produced.<br>        max_parcel_size : float<br>            Parcels larger than this size will not be considered for<br>            development - usually large parcels should be specified manually<br>            in a development projects table.<br>        drop_after_build : bool<br>            Whether or not to drop parcels from consideration after they<br>            have been chosen for development.  Usually this is true so as<br>            to not develop the same parcel twice.<br>        residential: bool<br>            If creating non-residential buildings set this to false and<br>            developer will fill in job_spaces rather than residential_units<br>        profit_to_prob_func: function<br>            As there are so many ways to turn the development feasibility<br>            into a probability to select it for building, the user may pass<br>            a function which takes the feasibility dataframe and returns<br>            a series of probabilities.  If no function is passed, the behavior<br>            of this method will not change<br><br>        Returns<br>        -------<br>        None if thar are no feasible buildings<br>        new_buildings : dataframe<br>            DataFrame of buildings to add.  These buildings are rows from the<br>            DataFrame that is returned from feasibility.<br>        """<br><br>        if len(self.feasibility) == 0:<br>            # no feasible buildings, might as well bail<br>            return<br><br>        if form is None:<br>            df = self.feasibility<br>        elif isinstance(form, list):<br>            df = self.keep_form_with_max_profit(form)<br>        else:<br>            df = self.feasibility[form]<br><br>        # feasible buildings only for this building type<br>        df = df[df.max_profit_far  0]<br>        ave_unit_size[ave_unit_size < min_unit_size] = min_unit_size<br>        df["ave_unit_size"] = ave_unit_size<br>        df["parcel_size"] = parcel_size<br>        df['current_units'] = current_units<br>        df = df[df.parcel_size < max_parcel_size]<br><br>        df['residential_units'] = (df.residential_sqft / df.ave_unit_size).round()<br>        df['job_spaces'] = (df.non_residential_sqft / bldg_sqft_per_job).round()<br><br>        if residential:<br>            df['net_units'] = df.residential_units - df.current_units<br>        else:<br>            df['net_units'] = df.job_spaces - df.current_units<br>        df = df[df.net_units  0]<br><br>        if len(df) == 0:<br>            print("WARNING THERE ARE NO FEASIBLE BUILDING TO CHOOSE FROM")<br>            return<br><br>        # print "Describe of net units\n", df.net_units.describe()<br>        print("Sum of net units that are profitable: {:,}"<br>              .format(int(df.net_units.sum())))<br><br>        if profit_to_prob_func:<br>            p = profit_to_prob_func(df)<br>        else:<br>            df['max_profit_per_size'] = df.max_profit / df.parcel_size<br>            p = df.max_profit_per_size.values / df.max_profit_per_size.sum()<br><br>        if df.net_units.sum() < target_units:<br>            print("WARNING THERE WERE NOT ENOUGH PROFITABLE UNITS TO",<br>                  "MATCH DEMAND")<br>            build_idx = df.index.values<br>        elif target_units <= 0:<br>            build_idx = []<br>        else:<br>            # we don't know how many developments we will need, as they differ in net_units.<br>            # If all developments have net_units of 1 than we need target_units of them.<br>            # So we choose the smaller of available developments and target_units.<br>            choices = np.random.choice(df.index.values, size=min(len(df.index), target_units),<br>                                       replace=False, p=p)<br>            tot_units = df.net_units.loc[choices].values.cumsum()<br>            ind = int(np.searchsorted(tot_units, target_units, side="left")) + 1<br>            build_idx = choices[:ind]<br><br>        if drop_after_build:<br>            self.feasibility = self.feasibility.drop(build_idx)<br><br>        new_df = df.loc[build_idx]<br>        new_df.index.name = "parcel_id"<br>        return new_df.reset_index()

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_91903.txt
> def allocate(self, amount, update=True):<br>        """<br>        This allocates capital to the Security. This is the method used to<br>        buy/sell the security.<br><br>        A given amount of shares will be determined on the current price, a<br>        commission will be calculated based on the parent's commission fn, and<br>        any remaining capital will be passed back up  to parent as an<br>        adjustment.<br><br>        Args:<br>             amount (float): Amount of adjustment.<br>             update (bool): Force update?<br><br>        """<br><br>        # will need to update if this has been idle for a while...<br>        # update if needupdate or if now is stale<br>        # fetch parent's now since our now is stale<br>        if self._needupdate or self.now != self.parent.now:<br>            self.update(self.parent.now)<br><br>        # ignore 0 alloc<br>        # Note that if the price of security has dropped to zero, then it<br>        # should never be selected by SelectAll, SelectN etc. I.e. we should<br>        # not open the position at zero price. At the same time, we are able<br>        # to close it at zero price, because at that point amount=0.<br>        # Note also that we don't erase the position in an asset which price<br>        # has dropped to zero (though the weight will indeed be = 0)<br>        if amount == 0:<br>            return<br><br>        if self.parent is self or self.parent is None:<br>            raise Exception(<br>                'Cannot allocate capital to a parentless security')<br><br>        if self._price == 0 or np.isnan(self._price):<br>            raise Exception(<br>                'Cannot allocate capital to '<br>                '%s because price is %s as of %s'<br>                % (self.name, self._price, self.parent.now))<br><br>        # buy/sell<br>        # determine quantity - must also factor in commission<br>        # closing out?<br>        if amount == -self._value:<br>            q = -self._position<br>        else:<br>            q = amount / (self._price  self.multiplier)<br>            if self.integer_positions:<br>                if (self._position  0) or ((self._position == 0) and (<br>                        amount  0)):<br>                    # if we're going long or changing long position<br>                    q = math.floor(q)<br>                else:<br>                    # if we're going short or changing short position<br>                    q = math.ceil(q)<br><br>        # if q is 0 nothing to do<br>        if q == 0 or np.isnan(q):<br>            return<br><br>        # unless we are closing out a position (q == -position)<br>        # we want to ensure that<br>        #<br>        # - In the event of a positive amount, this indicates the maximum<br>        # amount a given security can use up for a purchase. Therefore, if<br>        # commissions push us above this amount, we cannot buy `q`, and must<br>        # decrease its value<br>        #<br>        # - In the event of a negative amount, we want to 'raise' at least the<br>        # amount indicated, no less. Therefore, if we have commission, we must<br>        # sell additional units to fund this requirement. As such, q must once<br>        # again decrease.<br>        #<br>        if not q == -self._position:<br>            full_outlay, _, _ = self.outlay(q)<br><br>            # if full outlay  amount, we must decrease the magnitude of `q`<br>            # this can potentially lead to an infinite loop if the commission<br>            # per share  price per share. However, we cannot really detect<br>            # that in advance since the function can be non-linear (say a fn<br>            # like max(1, abs(q)  0.01). Nevertheless, we want to avoid these<br>            # situations.<br>            # cap the maximum number of iterations to 1e4 and raise exception<br>            # if we get there<br>            # if integer positions then we know we are stuck if q doesn't change<br><br>            # if integer positions is false then we want full_outlay == amount<br>            # if integer positions is true then we want to be at the q where<br>            #   if we bought 1 more then we wouldn't have enough cash<br>            i = 0<br>            last_q = q<br>            last_amount_short = full_outlay - amount<br>            while not np.isclose(full_outlay, amount, rtol=0.) and q != 0:<br><br>                dq_wout_considering_tx_costs = (full_outlay - amount)/(self._price  self.multiplier)<br>                q = q - dq_wout_considering_tx_costs<br><br>                if self.integer_positions:<br>                    q = math.floor(q)<br><br>                full_outlay, _, _ = self.outlay(q)<br><br>                # if our q is too low and we have integer positions<br>                # then we know that the correct quantity is the one  where<br>                # the outlay of q + 1 < amount. i.e. if we bought one more<br>                # position then we wouldn't have enough cash<br>                if self.integer_positions:<br><br>                    full_outlay_of_1_more, _, _ = self.outlay(q + 1)<br><br>                    if full_outlay < amount and full_outlay_of_1_more  amount:<br>                        break<br><br>                # if not integer positions then we should keep going until<br>                # full_outlay == amount or is close enough<br><br>                i = i + 1<br>                if i  1e4:<br>                    raise Exception(<br>                        'Potentially infinite loop detected. This occurred '<br>                        'while trying to reduce the amount of shares purchased'<br>                        ' to respect the outlay <= amount rule. This is most '<br>                        'likely due to a commission function that outputs a '<br>                        'commission that is greater than the amount of cash '<br>                        'a short sale can raise.')<br><br>                if self.integer_positions and last_q == q:<br>                    raise Exception(<br>                        'Newton Method like root search for quantity is stuck!'<br>                        ' q did not change in iterations so it is probably a bug'<br>                        ' but we are not entirely sure it is wrong! Consider '<br>                        ' changing to warning.'<br>                    )<br>                last_q = q<br><br>                if np.abs(full_outlay - amount)  np.abs(last_amount_short):<br>                    raise Exception(<br>                        'The difference between what we have raised with q and'<br>                        ' the amount we are trying to raise has gotten bigger since'<br>                        ' last iteration! full_outlay should always be approaching'<br>                        ' amount! There may be a case where the commission fn is'<br>                        ' not smooth'<br>                    )<br>                last_amount_short = full_outlay - amount<br><br>        # if last step led to q == 0, then we can return just like above<br>        if q == 0:<br>            return<br><br>        # this security will need an update, even if pos is 0 (for example if<br>        # we close the positions, value and pos is 0, but still need to do that<br>        # last update)<br>        self._needupdate = True<br><br>        # adjust position & value<br>        self._position += q<br><br>        # calculate proper adjustment for parent<br>        # parent passed down amount so we want to pass<br>        # -outlay back up to parent to adjust for capital<br>        # used<br>        full_outlay, outlay, fee = self.outlay(q)<br><br>        # store outlay for future reference<br>        self._outlay += outlay<br><br>        # call parent<br>        self.parent.adjust(-full_outlay, update=update, flow=False, fee=fee)

### DOC[3] (IRRELEVANT) leetcode/leetcode_1599.txt
> def minOperationsMaxProfit(customers, boardingCost, runningCost):<br>    """You are the operator of a Centennial Wheel that has four gondolas, and each gondola has room for up to four people. You have the ability to rotate the gondolas counterclockwise, which costs you `runningCost` dollars.<br><br>You are given an array `customers` of length `n` where `customers[i]` is the number of new customers arriving just before the `ith` rotation (0-indexed). This means you must rotate the wheel `i` times before the `customers[i]` customers arrive. You cannot make customers wait if there is room in the gondola. Each customer pays `boardingCost` dollars when they board on the gondola closest to the ground and will exit once that gondola reaches the ground again.<br><br>You can stop the wheel at any time, including before serving all customers. If you decide to stop serving customers, all subsequent rotations are free in order to get all the customers down safely. Note that if there are currently more than four customers waiting at the wheel, only four will board the gondola, and the rest will wait for the next rotation.<br><br>Return _the minimum number of rotations you need to perform to maximize your profit._ If there is no scenario where the profit is positive, return `-1`.<br><br>Example 1:<br><br>Input: customers = \[8,3\], boardingCost = 5, runningCost = 6<br>Output: 3<br>Explanation: The numbers written on the gondolas are the number of people currently there.<br>1. 8 customers arrive, 4 board and 4 wait for the next gondola, the wheel rotates. Current profit is 4 \ $5 - 1 \ $6 = $14.<br>2. 3 customers arrive, the 4 waiting board the wheel and the other 3 wait, the wheel rotates. Current profit is 8 \ $5 - 2 \ $6 = $28.<br>3. The final 3 customers board the gondola, the wheel rotates. Current profit is 11 \ $5 - 3 \ $6 = $37.<br>The highest profit was $37 after rotating the wheel 3 times.<br><br>Example 2:<br><br>Input: customers = \[10,9,6\], boardingCost = 6, runningCost = 4<br>Output: 7<br>Explanation:<br>1. 10 customers arrive, 4 board and 6 wait for the next gondola, the wheel rotates. Current profit is 4 \ $6 - 1 \ $4 = $20.<br>2. 9 customers arrive, 4 board and 11 wait (2 originally waiting, 9 newly waiting), the wheel rotates. Current profit is 8 \ $6 - 2 \ $4 = $40.<br>3. The final 6 customers arrive, 4 board and 13 wait, the wheel rotates. Current profit is 12 \ $6 - 3 \ $4 = $60.<br>4. 4 board and 9 wait, the wheel rotates. Current profit is 16 \ $6 - 4 \ $4 = $80.<br>5. 4 board and 5 wait, the wheel rotates. Current profit is 20 \ $6 - 5 \ $4 = $100.<br>6. 4 board and 1 waits, the wheel rotates. Current profit is 24 \ $6 - 6 \ $4 = $120.<br>7. 1 boards, the wheel rotates. Current profit is 25 \ $6 - 7 \ $4 = $122.<br>The highest profit was $122 after rotating the wheel 7 times.<br><br>Example 3:<br><br>Input: customers = \[3,4,0,5,1\], boardingCost = 1, runningCost = 92<br>Output: -1<br>Explanation:<br>1. 3 customers arrive, 3 board and 0 wait, the wheel rotates. Current profit is 3 \ $1 - 1 \ $92 = -$89.<br>2. 4 customers arrive, 4 board and 0 wait, the wheel rotates. Current profit is 7 \ $1 - 2 \ $92 = -$177.<br>3. 0 customers arrive, 0 board and 0 wait, the wheel rotates. Current profit is 7 \ $1 - 3 \ $92 = -$269.<br>4. 5 customers arrive, 4 board and 1 waits, the wheel rotates. Current profit is 11 \ $1 - 4 \ $92 = -$357.<br>5. 1 customer arrives, 2 board and 0 wait, the wheel rotates. Current profit is 13 \ $1 - 5 \ $92 = -$447.<br>The profit was never positive, so return -1.<br><br>Constraints:<br><br>   `n == customers.length`<br>   `1 <= n <= 105`<br>   `0 <= customers[i] <= 50`<br>   `1 <= boardingCost, runningCost <= 100`"""<br><br>    waiting = 0<br>    profit = 0<br>    max_profit = 0<br>    rotations = 0<br>    result = -1<br><br>    for i in range(len(customers) + sum(customers)):<br>        if i < len(customers):<br>            waiting += customers[i]<br>        boarding = min(waiting, 4)<br>        waiting -= boarding<br>        profit += boarding  boardingCost - runningCost<br><br>        if profit  max_profit:<br>            max_profit = profit<br>            result = rotations + 1<br>        rotations += 1<br>    <br>    return result

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_154085.txt
> def _conc_alloc_size(self, sim_size):<br>        """<br>        Concretizes a size argument, if necessary, to something that makes sense when allocating space. Here we just<br>        maximize its potential size up to the maximum variable size specified in the libc plugin.<br><br>        TODO:<br>        Further consideration of the tradeoffs of this approach is probably warranted. SimHeapPTMalloc especially makes<br>        a lot of different concretization strategy assumptions, but this function handles one of the more important<br>        problems that any heap implementation will face: how to decide the amount of space to allocate upon request for<br>        a symbolic size. Either we do as we do here and silently constrain the amount returned to a default max value,<br>        or we could add a path constraint to the state to prevent exploration of any paths that would have legitimately<br>        occurred given a larger allocation size.<br><br>        The first approach (the silent maximum) has its benefit in that the explored state space will not be<br>        constrained. Sometimes this could work out, as when an allocation is returned that is smaller than requested but<br>        which the program doesn't end up making full use of anyways. Alternatively, this lack of fidelity could cause<br>        the program to overwrite other allocations made, since it should be able to assume the allocation is as large as<br>        it requested it be.<br><br>        The second approach (the path constraint) has its benefit in that no paths will be explored that could fail<br>        when an allocation is made too small. On the other hand, as stated above, some of these paths might not have<br>        failed anyways, and doing this causes us to lose the opportunity to explore those paths.<br><br>        Perhaps these behaviors could be parameterized in the future?<br>        """<br>        if self.state.solver.symbolic(sim_size):<br>            size = self.state.solver.max_int(sim_size)<br>            if size  self.state.libc.max_variable_size:<br>                l.warning("Allocation request of %d bytes exceeded maximum of %d bytes; allocating %d bytes",<br>                          size, self.state.libc.max_variable_size, size)<br>                size = self.state.libc.max_variable_size<br>        else:<br>            size = self.state.solver.eval(sim_size)<br>        return size

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_238048.txt
> def generate(graph, feasible_configurations, decision_variables,<br>             linear_energy_ranges, quadratic_energy_ranges, min_classical_gap,<br>             smt_solver_name=None):<br>    """Generates the Ising model that induces the given feasible configurations. The code is based<br>    on the papers [#do]_ and [#mc]_.<br><br>    Args:<br>        graph (nx.Graph): The target graph on which the Ising model is to be built.<br>        feasible_configurations (dict): The set of feasible configurations<br>            of the decision variables. The key is a feasible configuration<br>            as a tuple of spins, the values are the associated energy.<br>        decision_variables (list/tuple): Which variables in the graph are<br>            assigned as decision variables.<br>        linear_energy_ranges (dict, optional): A dict of the form<br>            {v: (min, max), ...} where min and max are the range<br>            of values allowed to v.<br>        quadratic_energy_ranges (dict): A dict of the form<br>            {(u, v): (min, max), ...} where min and max are the range<br>            of values allowed to (u, v).<br>        min_classical_gap (float): The minimum energy gap between the highest feasible state and the<br>            lowest infeasible state.<br>        smt_solver_name (str/None): The name of the smt solver. Must<br>            be a solver available to pysmt. If None, uses the pysmt default.<br><br>    Returns:<br>        tuple: A 4-tuple containing:<br><br>            dict: The linear biases of the Ising problem.<br><br>            dict: The quadratic biases of the Ising problem.<br><br>            :obj:`dimod.BinaryQuadraticModel`<br><br>            float: The classical energy gap between ground and the first<br>            excited state.<br><br>    Raises:<br>        ImpossiblePenaltyModel: If the penalty model cannot be built. Normally due<br>            to a non-zero infeasible gap.<br><br>    .. [#do] Bian et al., "Discrete optimization using quantum annealing on sparse Ising models",<br>        https://www.frontiersin.org/articles/10.3389/fphy.2014.00056/full<br><br>    .. [#mc] Z. Bian, F. Chudak, R. Israel, B. Lackey, W. G. Macready, and A. Roy<br>        "Mapping constrained optimization problems to quantum annealing with application to fault diagnosis"<br>        https://arxiv.org/pdf/1603.03111.pdf<br><br>    """<br>    if len(graph) == 0:<br>        return dimod.BinaryQuadraticModel.empty(dimod.SPIN), float('inf')<br><br>    # we need to build a Table. The table encodes all of the information used by the smt solver<br>    table = Table(graph, decision_variables, linear_energy_ranges, quadratic_energy_ranges)<br><br>    # iterate over every possible configuration of the decision variables.<br>    for config in itertools.product((-1, 1), repeat=len(decision_variables)):<br><br>        # determine the spin associated with each variable in decision variables.<br>        spins = dict(zip(decision_variables, config))<br><br>        if config in feasible_configurations:<br>            # if the configuration is feasible, we require that the minimum energy over all<br>            # possible aux variable settings be exactly its target energy (given by the value)<br>            table.set_energy(spins, feasible_configurations[config])<br>        else:<br>            # if the configuration is infeasible, we simply want its minimum energy over all<br>            # possible aux variable settings to be an upper bound on the classical gap.<br>            if isinstance(feasible_configurations, dict) and feasible_configurations:<br>                highest_feasible_energy = max(feasible_configurations.values())<br>            else:<br>                highest_feasible_energy = 0<br><br>            table.set_energy_upperbound(spins, highest_feasible_energy)<br><br>    # now we just need to get a solver<br>    with Solver(smt_solver_name) as solver:<br><br>        # add all of the assertions from the table to the solver<br>        for assertion in table.assertions:<br>            solver.add_assertion(assertion)<br><br>        # add min classical gap assertion<br>        gap_assertion = table.gap_bound_assertion(min_classical_gap)<br>        solver.add_assertion(gap_assertion)<br><br>        # check if the model is feasible at all.<br>        if solver.solve():<br>            # since we know the current model is feasible, grab the initial model.<br>            model = solver.get_model()<br><br>            # we want to increase the gap until we have found the max classical gap<br>            # note: gmax is the maximum possible gap for a particular set of variables. To find it,<br>            #   we take the sum of the largest coefficients possible and double it. We double it<br>            #   because in Ising, the largest gap possible from the largest coefficient is the<br>            #   negative of said coefficient. Example: consider a graph with one node A, with a<br>            #   energy range of [-2, 1]. The largest energy gap between spins +1 and -1 is 4;<br>            #   namely, the largest absolute coefficient -2 with the ising spins results to<br>            #   gap = (-2)(-1) - (-2)(1) = 4.<br>            gmin = min_classical_gap<br>            gmax = sum(max(abs(r) for r in linear_energy_ranges[v]) for v in graph)<br>            gmax += sum(max(abs(r) for r in quadratic_energy_ranges[(u, v)])<br>                        for (u, v) in graph.edges)<br>            gmax = 2<br><br>            # 2 is a good target gap<br>            g = max(2., gmin)<br><br>            while abs(gmax - gmin) = MAX_GAP_DELTA:<br>                solver.push()<br><br>                gap_assertion = table.gap_bound_assertion(g)<br>                solver.add_assertion(gap_assertion)<br><br>                if solver.solve():<br>                    model = solver.get_model()<br>                    gmin = float(model.get_py_value(table.gap))<br><br>                else:<br>                    solver.pop()<br>                    gmax = g<br><br>                g = min(gmin + .1, (gmax + gmin) / 2)<br><br>        else:<br>            raise ImpossiblePenaltyModel("Model cannot be built")<br><br>    # finally we need to convert our values back into python floats.<br><br>    classical_gap = float(model.get_py_value(table.gap))<br><br>    # if the problem is fully specified (or empty) it has infinite gap<br>    if (len(decision_variables) == len(graph) and<br>            decision_variables and  # at least one variable<br>            len(feasible_configurations) == 2len(decision_variables)):<br>        classical_gap = float('inf')<br><br>    return table.theta.to_bqm(model), classical_gap


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2542.txt
> def maxScore(nums1, nums2, k):<br>    """You are given two 0-indexed integer arrays `nums1` and `nums2` of equal length `n` and a positive integer `k`. You must choose a subsequence of indices from `nums1` of length `k`.<br><br>For chosen indices `i0`, `i1`, ..., `ik - 1`, your score is defined as:<br><br>   The sum of the selected elements from `nums1` multiplied with the minimum of the selected elements from `nums2`.<br>   It can defined simply as: `(nums1[i0] + nums1[i1] +...+ nums1[ik - 1])  min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1])`.<br><br>Return _the maximum possible score._<br><br>A subsequence of indices of an array is a set that can be derived from the set `{0, 1, ..., n-1}` by deleting some or no elements.<br><br>Example 1:<br><br>Input: nums1 = \[1,3,3,2\], nums2 = \[2,1,3,4\], k = 3<br>Output: 12<br>Explanation: <br>The four possible subsequence scores are:<br>- We choose the indices 0, 1, and 2 with score = (1+3+3) \ min(2,1,3) = 7.<br>- We choose the indices 0, 1, and 3 with score = (1+3+2) \ min(2,1,4) = 6. <br>- We choose the indices 0, 2, and 3 with score = (1+3+2) \ min(2,3,4) = 12. <br>- We choose the indices 1, 2, and 3 with score = (3+3+2) \ min(1,3,4) = 8.<br>Therefore, we return the max score, which is 12.<br><br>Example 2:<br><br>Input: nums1 = \[4,2,3,1,1\], nums2 = \[7,5,10,9,6\], k = 1<br>Output: 30<br>Explanation: <br>Choosing index 2 is optimal: nums1\[2\] \ nums2\[2\] = 3 \ 10 = 30 is the maximum possible score.<br><br>Constraints:<br><br>   `n == nums1.length == nums2.length`<br>   `1 <= n <= 105`<br>   `0 <= nums1[i], nums2[j] <= 105`<br>   `1 <= k <= n`"""<br><br>    n = len(nums1)<br>    res = 0<br>    sum_n1 = 0<br>    min_n2 = nums2[0]<br>    i, j = 0, 0<br>    while j < n:<br>        sum_n1 += nums1[j]<br>        min_n2 = min(min_n2, nums2[j])<br>        if j - i + 1  k:<br>            sum_n1 -= nums1[i]<br>            i += 1<br>        if j + 1 = k:<br>            res = max(res, sum_n1  min_n2)<br>        j += 1<br>    return res
