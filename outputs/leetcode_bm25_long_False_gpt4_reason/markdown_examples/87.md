# Query `87`

## Original Question

*There are `n` people standing in a queue, and they numbered from `0` to `n - 1` in left to right order. You are given an array `heights` of distinct integers where `heights[i]` represents the height of the `ith` person.

A person can see another person to their right in the queue if everybody in between is shorter than both of them. More formally, the `ith` person can see the `jth` person if `i < j` and `min(heights[i], heights[j]) > max(heights[i+1], heights[i+2], ..., heights[j-1])`.

Return _an array_ `answer` _of length_ `n` _where_ `answer[i]` _is the number of people the_ `ith` _person can see to their right in the queue_.

Example 1:

Input: heights = \[10,6,8,5,11,9\]
Output: \[3,1,2,1,1,0\]
Explanation:
Person 0 can see person 1, 2, and 4.
Person 1 can see person 2.
Person 2 can see person 3 and 4.
Person 3 can see person 4.
Person 4 can see person 5.
Person 5 can see no one since nobody is to the right of them.

Example 2:

Input: heights = \[5,1,2,3,10\]
Output: \[4,1,1,1,0\]

Constraints:

   `n == heights.length`
   `1 <= n <= 105`
   `1 <= heights[i] <= 105`
   All the values of `heights` are unique.*

## gpt4 Reasoning

```markdown
To solve this problem, we need to find out for each person in the queue, how many people they can see to their right based on the conditions given. The essential problem is to efficiently navigate through the `heights` array to calculate the visibility count for each person, considering the constraints that a person can only see another person if there is no one taller in between them.

### Step-by-Step Solution:

1. **Initialization:**
   - Create an array `answer` of length `n` (same as `heights`), initialized with zeros. This array will store the count of people visible to the right for each person.
   - Use a data structure to keep track of the heights we have seen as we iterate from left to right. A stack is suitable for this purpose because it allows us to efficiently add new heights and remove heights that are no longer relevant (i.e., when we encounter a taller person).

2. **Iterate Through the Queue:**
   - We iterate through each person in the queue from left to right.
   - For the current person, we need to check how many people they can see directly to their right. We do this by looking at the stack which keeps track of the heights of the people to their right.
   - If the stack is empty or the current person is shorter than the height at the top of the stack, it means the current person cannot see over the person at the top of the stack. We push the current height onto the stack.
   - If the current person is taller than the height at the top of the stack, it means they can see over this person. We pop heights from the stack until we find a height taller than the current person or the stack is empty. For each height removed, increment the `answer[i]` because the current person can see over the person represented by that height.

3. **Calculate Visibility:**
   - While iterating, for each person (i.e., for each height in `heights`), we keep track of how many people they can see by incrementing the respective `answer[i]` for each person they can see (determined by the conditions mentioned above).
   - It's important to note that since we are looking for how many people a person can see to their right, we don't need to adjust the counts for people already considered.

4. **Edge Cases and Optimization:**
   - Given the constraints that all values in `heights` are unique, we don't need to worry about handling equal heights.
   - Since the heights are distinct, the comparison between any two heights will always be conclusive (either greater than or less than).
   - We might optimize our solution by noting that once a person's height is removed from the stack, it doesn't need to be considered again because there's now a taller person in between any further visibility checks.

### Final Thoughts:
This approach effectively uses a stack to keep track of potential visibility barriers (taller people) and efficiently calculates the visibility for each person by only considering each person once. This leads to an overall time complexity of O(n), where n is the number of people in the queue, since each person is pushed to and popped from the stack at most once.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_406.txt
> from typing import List<br>    """You are given an array of people, `people`, which are the attributes of some people in a queue (not necessarily in order). Each `people[i] = [hi, ki]` represents the `ith` person of height `hi` with exactly `ki` other people in front who have a height greater than or equal to `hi`.<br><br>Reconstruct and return _the queue that is represented by the input array_ `people`. The returned queue should be formatted as an array `queue`, where `queue[j] = [hj, kj]` is the attributes of the `jth` person in the queue (`queue[0]` is the person at the front of the queue).<br><br>Example 1:<br><br>Input: people = \[\[7,0\],\[4,4\],\[7,1\],\[5,0\],\[6,1\],\[5,2\]\]<br>Output: \[\[5,0\],\[7,0\],\[5,2\],\[6,1\],\[4,4\],\[7,1\]\]<br>Explanation:<br>Person 0 has height 5 with no other people taller or the same height in front.<br>Person 1 has height 7 with no other people taller or the same height in front.<br>Person 2 has height 5 with two persons taller or the same height in front, which is person 0 and 1.<br>Person 3 has height 6 with one person taller or the same height in front, which is person 1.<br>Person 4 has height 4 with four people taller or the same height in front, which are people 0, 1, 2, and 3.<br>Person 5 has height 7 with one person taller or the same height in front, which is person 1.<br>Hence \[\[5,0\],\[7,0\],\[5,2\],\[6,1\],\[4,4\],\[7,1\]\] is the reconstructed queue.<br><br>Example 2:<br><br>Input: people = \[\[6,0\],\[5,0\],\[4,0\],\[3,2\],\[2,2\],\[1,4\]\]<br>Output: \[\[4,0\],\[5,0\],\[2,2\],\[3,2\],\[1,4\],\[6,0\]\]<br><br>Constraints:<br><br>   `1 <= people.length <= 2000`<br>   `0 <= hi <= 106`<br>   `0 <= ki < people.length`<br>   It is guaranteed that the queue can be reconstructed."""<br><br><br>def reconstructQueue(people: List[List[int]]) - List[List[int]]:<br>    people.sort(key=lambda x: (-x[0], x[1]))<br><br>    result = []<br>    for p in people:<br>        result.insert(p[1], p)<br>    return result

### DOC[2] (IRRELEVANT) leetcode/leetcode_2151.txt
> from collections import defaultdict, deque<br>    """There are two types of persons:<br><br>   The good person: The person who always tells the truth.<br>   The bad person: The person who might tell the truth and might lie.<br><br>You are given a 0-indexed 2D integer array `statements` of size `n x n` that represents the statements made by `n` people about each other. More specifically, `statements[i][j]` could be one of the following:<br><br>   `0` which represents a statement made by person `i` that person `j` is a bad person.<br>   `1` which represents a statement made by person `i` that person `j` is a good person.<br>   `2` represents that no statement is made by person `i` about person `j`.<br><br>Additionally, no person ever makes a statement about themselves. Formally, we have that `statements[i][i] = 2` for all `0 <= i < n`.<br><br>Return _the maximum number of people who can be good based on the statements made by the_ `n` _people_.<br><br>Example 1:<br><br>Input: statements = \[\[2,1,2\],\[1,2,2\],\[2,0,2\]\]<br>Output: 2<br>Explanation: Each person makes a single statement.<br>- Person 0 states that person 1 is good.<br>- Person 1 states that person 0 is good.<br>- Person 2 states that person 1 is bad.<br>Let's take person 2 as the key.<br>- Assuming that person 2 is a good person:<br>    - Based on the statement made by person 2, person 1 is a bad person.<br>    - Now we know for sure that person 1 is bad and person 2 is good.<br>    - Based on the statement made by person 1, and since person 1 is bad, they could be:<br>        - telling the truth. There will be a contradiction in this case and this assumption is invalid.<br>        - lying. In this case, person 0 is also a bad person and lied in their statement.<br>    - Following that person 2 is a good person, there will be only one good person in the group.<br>- Assuming that person 2 is a bad person:<br>    - Based on the statement made by person 2, and since person 2 is bad, they could be:<br>        - telling the truth. Following this scenario, person 0 and 1 are both bad as explained before.<br>            - Following that person 2 is bad but told the truth, there will be no good persons in the group.<br>        - lying. In this case person 1 is a good person.<br>            - Since person 1 is a good person, person 0 is also a good person.<br>            - Following that person 2 is bad and lied, there will be two good persons in the group.<br>We can see that at most 2 persons are good in the best case, so we return 2.<br>Note that there is more than one way to arrive at this conclusion.<br><br>Example 2:<br><br>Input: statements = \[\[2,0\],\[0,2\]\]<br>Output: 1<br>Explanation: Each person makes a single statement.<br>- Person 0 states that person 1 is bad.<br>- Person 1 states that person 0 is bad.<br>Let's take person 0 as the key.<br>- Assuming that person 0 is a good person:<br>    - Based on the statement made by person 0, person 1 is a bad person and was lying.<br>    - Following that person 0 is a good person, there will be only one good person in the group.<br>- Assuming that person 0 is a bad person:<br>    - Based on the statement made by person 0, and since person 0 is bad, they could be:<br>        - telling the truth. Following this scenario, person 0 and 1 are both bad.<br>            - Following that person 0 is bad but told the truth, there will be no good persons in the group.<br>        - lying. In this case person 1 is a good person.<br>            - Following that person 0 is bad and lied, there will be only one good person in the group.<br>We can see that at most, one person is good in the best case, so we return 1.<br>Note that there is more than one way to arrive at this conclusion.<br><br>Constraints:<br><br>   `n == statements.length == statements[i].length`<br>   `2 <= n <= 15`<br>   `statements[i][j]` is either `0`, `1`, or `2`.<br>   `statements[i][i] == 2`"""<br><br><br>def network_becomes_idle(edges, patience):<br>    n = len(patience)<br>    graph = defaultdict(list)<br>    <br>    for edge in edges:<br>        graph[edge[0]].append(edge[1])<br>        graph[edge[1]].append(edge[0])<br><br>    dist = [-1]  n<br>    dist[0] = 0<br>    q = deque([0])<br>    <br>    while q:<br>        node = q.popleft()<br>        <br>        for neighbor in graph[node]:<br>            if dist[neighbor] == -1:<br>                dist[neighbor] = dist[node] + 1<br>                q.append(neighbor)<br><br>    max_time = 0<br>    for i in range(1, n):<br>        time = ((2  dist[i] - 1) // patience[i])  patience[i] + 2  dist[i]<br>        max_time = max(max_time, time)<br>    <br>    return max_time + 1

### DOC[3] (IRRELEVANT) leetcode/leetcode_851.txt
> def to_goat_latin(sentence: str) - str:<br>    """There is a group of `n` people labeled from `0` to `n - 1` where each person has a different amount of money and a different level of quietness.<br><br>You are given an array `richer` where `richer[i] = [ai, bi]` indicates that `ai` has more money than `bi` and an integer array `quiet` where `quiet[i]` is the quietness of the `ith` person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where `x` is richer than `y` and `y` is richer than `x` at the same time).<br><br>Return _an integer array_ `answer` _where_ `answer[x] = y` _if_ `y` _is the least quiet person (that is, the person_ `y` _with the smallest value of_ `quiet[y]`_) among all people who definitely have equal to or more money than the person_ `x`.<br><br>Example 1:<br><br>Input: richer = \[\[1,0\],\[2,1\],\[3,1\],\[3,7\],\[4,3\],\[5,3\],\[6,3\]\], quiet = \[3,2,5,4,6,1,7,0\]<br>Output: \[5,5,2,5,4,5,6,7\]<br>Explanation: <br>answer\[0\] = 5.<br>Person 5 has more money than 3, which has more money than 1, which has more money than 0.<br>The only person who is quieter (has lower quiet\[x\]) is person 7, but it is not clear if they have more money than person 0.<br>answer\[7\] = 7.<br>Among all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet\[x\]) is person 7.<br>The other answers can be filled out with similar reasoning.<br><br>Example 2:<br><br>Input: richer = \[\], quiet = \[0\]<br>Output: \[0\]<br><br>Constraints:<br><br>   `n == quiet.length`<br>   `1 <= n <= 500`<br>   `0 <= quiet[i] < n`<br>   All the values of `quiet` are unique.<br>   `0 <= richer.length <= n  (n - 1) / 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   All the pairs of `richer` are unique.<br>   The observations in `richer` are all logically consistent."""<br><br>    words = sentence.split()<br>    vowels = set("AEIOUaeiou")<br>    result = []<br><br>    for i, word in enumerate(words):<br>        if word[0] not in vowels:<br>            word = word[1:] + word[0]<br>        result.append(word + "ma" + "a"  (i + 1))<br><br>    return ' '.join(result)

### DOC[4] (IRRELEVANT) leetcode/leetcode_699.txt
> def fallingSquares(positions):<br>    """There are several squares being dropped onto the X-axis of a 2D plane.<br><br>You are given a 2D integer array `positions` where `positions[i] = [lefti, sideLengthi]` represents the `ith` square with a side length of `sideLengthi` that is dropped with its left edge aligned with X-coordinate `lefti`.<br><br>Each square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.<br><br>After each square is dropped, you must record the height of the current tallest stack of squares.<br><br>Return _an integer array_ `ans` _where_ `ans[i]` _represents the height described above after dropping the_ `ith` _square_.<br><br>Example 1:<br><br>Input: positions = \[\[1,2\],\[2,3\],\[6,1\]\]<br>Output: \[2,5,5\]<br>Explanation:<br>After the first drop, the tallest stack is square 1 with a height of 2.<br>After the second drop, the tallest stack is squares 1 and 2 with a height of 5.<br>After the third drop, the tallest stack is still squares 1 and 2 with a height of 5.<br>Thus, we return an answer of \[2, 5, 5\].<br><br>Example 2:<br><br>Input: positions = \[\[100,100\],\[200,100\]\]<br>Output: \[100,100\]<br>Explanation:<br>After the first drop, the tallest stack is square 1 with a height of 100.<br>After the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.<br>Thus, we return an answer of \[100, 100\].<br>Note that square 2 only brushes the right side of square 1, which does not count as landing on it.<br><br>Constraints:<br><br>   `1 <= positions.length <= 1000`<br>   `1 <= lefti <= 108`<br>   `1 <= sideLengthi <= 106`"""<br><br>    ans = []<br>    intervals = []<br><br>    for p in positions:<br>        L, size = p<br>        R = L + size<br>        h = size<br>        for h2, R2 in intervals:<br>            if R2  L and R  R2:<br>                h = max(h, size + h2)<br><br>        maxHeight = max((h2 for h2, R2 in intervals), default=0)<br>        ans.append(max(maxHeight, h))<br>        intervals.append((h, R))<br><br>    return ans

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_91903.txt
> def allocate(self, amount, update=True):<br>        """<br>        This allocates capital to the Security. This is the method used to<br>        buy/sell the security.<br><br>        A given amount of shares will be determined on the current price, a<br>        commission will be calculated based on the parent's commission fn, and<br>        any remaining capital will be passed back up  to parent as an<br>        adjustment.<br><br>        Args:<br>             amount (float): Amount of adjustment.<br>             update (bool): Force update?<br><br>        """<br><br>        # will need to update if this has been idle for a while...<br>        # update if needupdate or if now is stale<br>        # fetch parent's now since our now is stale<br>        if self._needupdate or self.now != self.parent.now:<br>            self.update(self.parent.now)<br><br>        # ignore 0 alloc<br>        # Note that if the price of security has dropped to zero, then it<br>        # should never be selected by SelectAll, SelectN etc. I.e. we should<br>        # not open the position at zero price. At the same time, we are able<br>        # to close it at zero price, because at that point amount=0.<br>        # Note also that we don't erase the position in an asset which price<br>        # has dropped to zero (though the weight will indeed be = 0)<br>        if amount == 0:<br>            return<br><br>        if self.parent is self or self.parent is None:<br>            raise Exception(<br>                'Cannot allocate capital to a parentless security')<br><br>        if self._price == 0 or np.isnan(self._price):<br>            raise Exception(<br>                'Cannot allocate capital to '<br>                '%s because price is %s as of %s'<br>                % (self.name, self._price, self.parent.now))<br><br>        # buy/sell<br>        # determine quantity - must also factor in commission<br>        # closing out?<br>        if amount == -self._value:<br>            q = -self._position<br>        else:<br>            q = amount / (self._price  self.multiplier)<br>            if self.integer_positions:<br>                if (self._position  0) or ((self._position == 0) and (<br>                        amount  0)):<br>                    # if we're going long or changing long position<br>                    q = math.floor(q)<br>                else:<br>                    # if we're going short or changing short position<br>                    q = math.ceil(q)<br><br>        # if q is 0 nothing to do<br>        if q == 0 or np.isnan(q):<br>            return<br><br>        # unless we are closing out a position (q == -position)<br>        # we want to ensure that<br>        #<br>        # - In the event of a positive amount, this indicates the maximum<br>        # amount a given security can use up for a purchase. Therefore, if<br>        # commissions push us above this amount, we cannot buy `q`, and must<br>        # decrease its value<br>        #<br>        # - In the event of a negative amount, we want to 'raise' at least the<br>        # amount indicated, no less. Therefore, if we have commission, we must<br>        # sell additional units to fund this requirement. As such, q must once<br>        # again decrease.<br>        #<br>        if not q == -self._position:<br>            full_outlay, _, _ = self.outlay(q)<br><br>            # if full outlay  amount, we must decrease the magnitude of `q`<br>            # this can potentially lead to an infinite loop if the commission<br>            # per share  price per share. However, we cannot really detect<br>            # that in advance since the function can be non-linear (say a fn<br>            # like max(1, abs(q)  0.01). Nevertheless, we want to avoid these<br>            # situations.<br>            # cap the maximum number of iterations to 1e4 and raise exception<br>            # if we get there<br>            # if integer positions then we know we are stuck if q doesn't change<br><br>            # if integer positions is false then we want full_outlay == amount<br>            # if integer positions is true then we want to be at the q where<br>            #   if we bought 1 more then we wouldn't have enough cash<br>            i = 0<br>            last_q = q<br>            last_amount_short = full_outlay - amount<br>            while not np.isclose(full_outlay, amount, rtol=0.) and q != 0:<br><br>                dq_wout_considering_tx_costs = (full_outlay - amount)/(self._price  self.multiplier)<br>                q = q - dq_wout_considering_tx_costs<br><br>                if self.integer_positions:<br>                    q = math.floor(q)<br><br>                full_outlay, _, _ = self.outlay(q)<br><br>                # if our q is too low and we have integer positions<br>                # then we know that the correct quantity is the one  where<br>                # the outlay of q + 1 < amount. i.e. if we bought one more<br>                # position then we wouldn't have enough cash<br>                if self.integer_positions:<br><br>                    full_outlay_of_1_more, _, _ = self.outlay(q + 1)<br><br>                    if full_outlay < amount and full_outlay_of_1_more  amount:<br>                        break<br><br>                # if not integer positions then we should keep going until<br>                # full_outlay == amount or is close enough<br><br>                i = i + 1<br>                if i  1e4:<br>                    raise Exception(<br>                        'Potentially infinite loop detected. This occurred '<br>                        'while trying to reduce the amount of shares purchased'<br>                        ' to respect the outlay <= amount rule. This is most '<br>                        'likely due to a commission function that outputs a '<br>                        'commission that is greater than the amount of cash '<br>                        'a short sale can raise.')<br><br>                if self.integer_positions and last_q == q:<br>                    raise Exception(<br>                        'Newton Method like root search for quantity is stuck!'<br>                        ' q did not change in iterations so it is probably a bug'<br>                        ' but we are not entirely sure it is wrong! Consider '<br>                        ' changing to warning.'<br>                    )<br>                last_q = q<br><br>                if np.abs(full_outlay - amount)  np.abs(last_amount_short):<br>                    raise Exception(<br>                        'The difference between what we have raised with q and'<br>                        ' the amount we are trying to raise has gotten bigger since'<br>                        ' last iteration! full_outlay should always be approaching'<br>                        ' amount! There may be a case where the commission fn is'<br>                        ' not smooth'<br>                    )<br>                last_amount_short = full_outlay - amount<br><br>        # if last step led to q == 0, then we can return just like above<br>        if q == 0:<br>            return<br><br>        # this security will need an update, even if pos is 0 (for example if<br>        # we close the positions, value and pos is 0, but still need to do that<br>        # last update)<br>        self._needupdate = True<br><br>        # adjust position & value<br>        self._position += q<br><br>        # calculate proper adjustment for parent<br>        # parent passed down amount so we want to pass<br>        # -outlay back up to parent to adjust for capital<br>        # used<br>        full_outlay, outlay, fee = self.outlay(q)<br><br>        # store outlay for future reference<br>        self._outlay += outlay<br><br>        # call parent<br>        self.parent.adjust(-full_outlay, update=update, flow=False, fee=fee)


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2104.txt
> from collections import defaultdict<br>    """You are given an integer array `nums`. The range of a subarray of `nums` is the difference between the largest and smallest element in the subarray.<br><br>Return _the sum of all subarray ranges of_ `nums`_._<br><br>A subarray is a contiguous non-empty sequence of elements within an array.<br><br>Example 1:<br><br>Input: nums = \[1,2,3\]<br>Output: 4<br>Explanation: The 6 subarrays of nums are the following:<br>\[1\], range = largest - smallest = 1 - 1 = 0 <br>\[2\], range = 2 - 2 = 0<br>\[3\], range = 3 - 3 = 0<br>\[1,2\], range = 2 - 1 = 1<br>\[2,3\], range = 3 - 2 = 1<br>\[1,2,3\], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.<br><br>Example 2:<br><br>Input: nums = \[1,3,3\]<br>Output: 4<br>Explanation: The 6 subarrays of nums are the following:<br>\[1\], range = largest - smallest = 1 - 1 = 0<br>\[3\], range = 3 - 3 = 0<br>\[3\], range = 3 - 3 = 0<br>\[1,3\], range = 3 - 1 = 2<br>\[3,3\], range = 3 - 3 = 0<br>\[1,3,3\], range = 3 - 1 = 2<br>So the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.<br><br>Example 3:<br><br>Input: nums = \[4,-2,-3,4,1\]<br>Output: 59<br>Explanation: The sum of all subarray ranges of nums is 59.<br><br>Constraints:<br><br>   `1 <= nums.length <= 1000`<br>   `-109 <= nums[i] <= 109`<br><br>Follow-up: Could you find a solution with `O(n)` time complexity?"""<br><br><br>class LockingTree:<br><br>    def __init__(self, parent):<br>        self.parent = parent<br>        self.children = defaultdict(set)<br>        self.locks = [-1]  len(parent)<br>        for i in range(1, len(parent)):<br>            self.children[parent[i]].add(i)<br>    <br>    def lock(self, num, user):<br>        if self.locks[num] == -1:<br>            self.locks[num] = user<br>            return True<br>        return False<br>    <br>    def unlock(self, num, user):<br>        if self.locks[num] == user:<br>            self.locks[num] = -1<br>            return True<br>        return False<br>    <br>    def upgrade(self, num, user):<br>        if self.locks[num] != -1: return False<br>        <br>        cur = num<br>        while cur != -1:<br>            if self.locks[cur] != -1: return False<br>            cur = self.parent[cur]<br>        <br>        locked_descendant = self._has_locked_descendants(num)<br>        if locked_descendant:<br>            self.locks[num] = user<br>        return locked_descendant<br>    <br>    def _has_locked_descendants(self, node):<br>        locked_descendant = False<br>        for child in self.children[node]:<br>            if self.locks[child] != -1:<br>                locked_descendant = True<br>                self.locks[child] = -1<br>            locked_descendant |= self._has_locked_descendants(child)<br>        return locked_descendant

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_2281.txt
> mod = 1000000007<br>    """As the ruler of a kingdom, you have an army of wizards at your command.<br><br>You are given a 0-indexed integer array `strength`, where `strength[i]` denotes the strength of the `ith` wizard. For a contiguous group of wizards (i.e. the wizards' strengths form a subarray of `strength`), the total strength is defined as the product of the following two values:<br><br>   The strength of the weakest wizard in the group.<br>   The total of all the individual strengths of the wizards in the group.<br><br>Return _the sum of the total strengths of all contiguous groups of wizards_. Since the answer may be very large, return it modulo `109 + 7`.<br><br>A subarray is a contiguous non-empty sequence of elements within an array.<br><br>Example 1:<br><br>Input: strength = \[1,3,1,2\]<br>Output: 44<br>Explanation: The following are all the contiguous groups of wizards:<br>- \[1\] from \[1,3,1,2\] has a total strength of min(\[1\]) \ sum(\[1\]) = 1 \ 1 = 1<br>- \[3\] from \[1,3,1,2\] has a total strength of min(\[3\]) \ sum(\[3\]) = 3 \ 3 = 9<br>- \[1\] from \[1,3,1,2\] has a total strength of min(\[1\]) \ sum(\[1\]) = 1 \ 1 = 1<br>- \[2\] from \[1,3,1,2\] has a total strength of min(\[2\]) \ sum(\[2\]) = 2 \ 2 = 4<br>- \[1,3\] from \[1,3,1,2\] has a total strength of min(\[1,3\]) \ sum(\[1,3\]) = 1 \ 4 = 4<br>- \[3,1\] from \[1,3,1,2\] has a total strength of min(\[3,1\]) \ sum(\[3,1\]) = 1 \ 4 = 4<br>- \[1,2\] from \[1,3,1,2\] has a total strength of min(\[1,2\]) \ sum(\[1,2\]) = 1 \ 3 = 3<br>- \[1,3,1\] from \[1,3,1,2\] has a total strength of min(\[1,3,1\]) \ sum(\[1,3,1\]) = 1 \ 5 = 5<br>- \[3,1,2\] from \[1,3,1,2\] has a total strength of min(\[3,1,2\]) \ sum(\[3,1,2\]) = 1 \ 6 = 6<br>- \[1,3,1,2\] from \[1,3,1,2\] has a total strength of min(\[1,3,1,2\]) \ sum(\[1,3,1,2\]) = 1 \ 7 = 7<br>The sum of all the total strengths is 1 + 9 + 1 + 4 + 4 + 4 + 3 + 5 + 6 + 7 = 44.<br><br>Example 2:<br><br>Input: strength = \[5,4,6\]<br>Output: 213<br>Explanation: The following are all the contiguous groups of wizards: <br>- \[5\] from \[5,4,6\] has a total strength of min(\[5\]) \ sum(\[5\]) = 5 \ 5 = 25<br>- \[4\] from \[5,4,6\] has a total strength of min(\[4\]) \ sum(\[4\]) = 4 \ 4 = 16<br>- \[6\] from \[5,4,6\] has a total strength of min(\[6\]) \ sum(\[6\]) = 6 \ 6 = 36<br>- \[5,4\] from \[5,4,6\] has a total strength of min(\[5,4\]) \ sum(\[5,4\]) = 4 \ 9 = 36<br>- \[4,6\] from \[5,4,6\] has a total strength of min(\[4,6\]) \ sum(\[4,6\]) = 4 \ 10 = 40<br>- \[5,4,6\] from \[5,4,6\] has a total strength of min(\[5,4,6\]) \ sum(\[5,4,6\]) = 4 \ 15 = 60<br>The sum of all the total strengths is 25 + 16 + 36 + 36 + 40 + 60 = 213.<br><br>Constraints:<br><br>   `1 <= strength.length <= 105`<br>   `1 <= strength[i] <= 109`"""<br><br>def sum_of_strength(strength):<br>    res, strength_len = 0, len(strength)<br>    for i in range(strength_len):<br>        minimum = total = strength[i]<br>        for j in range(i, strength_len):<br>            minimum = min(minimum, strength[j])<br>            total += strength[j]<br>            res = (res + minimum  total % mod) % mod<br>    return res
