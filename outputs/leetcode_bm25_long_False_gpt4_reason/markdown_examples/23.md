# Query `23`

## Original Question

*You are given an integer array `matchsticks` where `matchsticks[i]` is the length of the `ith` matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.

Return `true` if you can make this square and `false` otherwise.

Example 1:

Input: matchsticks = \[1,1,2,2,2\]
Output: true
Explanation: You can form a square with length 2, one side of the square came two sticks with length 1.

Example 2:

Input: matchsticks = \[3,3,3,3,4\]
Output: false
Explanation: You cannot find a way to form a square with all the matchsticks.

Constraints:

   `1 <= matchsticks.length <= 15`
   `1 <= matchsticks[i] <= 108`*

## gpt4 Reasoning

```markdown
The essential problem here is to determine whether all the given matchsticks can be arranged in such a way that they form a square. This means each side of the square must be of equal length, and every matchstick must be used exactly once without breaking any. To solve this problem, we need to consider both the total length of the matchsticks and how they can be partitioned into four equal groups (each representing a side of the square).

### Step 1: Check Total Length
First, we need to check if the total length of all matchsticks is a multiple of 4 because the perimeter of the square must be evenly divided into four equal sides. If the total length is not divisible by 4, we can immediately return `false`, as it would be impossible to form a square.

### Step 2: Sorting
Sorting the matchsticks in descending order can be helpful. This is because using the longer matchsticks first might make it easier to determine earlier if forming a square is not possible, potentially reducing the number of combinations that need to be checked.

### Step 3: Recursive Backtracking
After ensuring the total length is divisible by 4, we know what the target length for each side of the square should be. The problem then reduces to a recursive search problem, where we try to create four groups of matchsticks, each summing up to the target length. This is often solved using a depth-first search (DFS) approach with backtracking, where we try to place each matchstick into one of the four sides and explore the possibility. If at any point, a matchstick cannot fit into any side without exceeding the target length, we backtrack and try a different arrangement.

### Step 4: Avoiding Redundancies
To make the search efficient, it's important to avoid redundant checks. For instance, if a matchstick didn't fit in a specific position, trying another matchstick of the same length immediately after won't change the outcome. Implementing pruning strategies to skip unnecessary checks can significantly reduce the search space and computation time.

### Conclusion
In summary, solving this problem involves:
1. Checking if the total length of matchsticks is divisible by 4.
2. Sorting the matchsticks in descending order to facilitate easier and possibly quicker checks.
3. Using a recursive backtracking approach to try and partition the matchsticks into four groups each equal to a quarter of the total length.
4. Implementing efficient strategies to avoid redundant checks and reduce the search space.

This problem is a classic example of a combinatorial search problem, where optimizing the search strategy and pruning the search space are key to finding a solution within a reasonable time frame.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_6417.txt
> def take_step(self,<br>                  state: StateType,<br>                  max_actions: int = None,<br>                  allowed_actions: List[Set] = None) - List[StateType]:<br>        """<br>        The main method in the ``TransitionFunction`` API.  This function defines the computation<br>        done at each step of decoding and returns a ranked list of next states.<br><br>        The input state is `grouped`, to allow for efficient computation, but the output states<br>        should all have a ``group_size`` of 1, to make things easier on the decoding algorithm.<br>        They will get regrouped later as needed.<br><br>        Because of the way we handle grouping in the decoder states, constructing a new state is<br>        actually a relatively expensive operation.  If you know a priori that only some of the<br>        states will be needed (either because you have a set of gold action sequences, or you have<br>        a fixed beam size), passing that information into this function will keep us from<br>        constructing more states than we need, which will greatly speed up your computation.<br><br>        IMPORTANT: This method `must` returns states already sorted by their score, otherwise<br>        ``BeamSearch`` and other methods will break.  For efficiency, we do not perform an<br>        additional sort in those methods.<br><br>        ALSO IMPORTANT: When ``allowed_actions`` is given and ``max_actions`` is not, we assume you<br>        want to evaluate all possible states and do not need any sorting (e.g., this is true for<br>        maximum marginal likelihood training that does not use a beam search).  In this case, we<br>        may skip the sorting step for efficiency reasons.<br><br>        Parameters<br>        ----------<br>        state : ``State``<br>            The current state of the decoder, which we will take a step `from`.  We may be grouping<br>            together computation for several states here.  Because we can have several states for<br>            each instance in the original batch being evaluated at the same time, we use<br>            ``group_size`` for this kind of batching, and ``batch_size`` for the `original` batch<br>            in ``model.forward.``<br>        max_actions : ``int``, optional<br>            If you know that you will only need a certain number of states out of this (e.g., in a<br>            beam search), you can pass in the max number of actions that you need, and we will only<br>            construct that many states (for each `batch` instance - `not` for each `group`<br>            instance!).  This can save a whole lot of computation if you have an action space<br>            that's much larger than your beam size.<br>        allowed_actions : ``List[Set]``, optional<br>            If the ``DecoderTrainer`` has constraints on which actions need to be evaluated (e.g.,<br>            maximum marginal likelihood only needs to evaluate action sequences in a given set),<br>            you can pass those constraints here, to avoid constructing state objects unnecessarily.<br>            If there are no constraints from the trainer, passing a value of ``None`` here will<br>            allow all actions to be considered.<br><br>            This is a list because it is `batched` - every instance in the batch has a set of<br>            allowed actions.  Note that the size of this list is the ``group_size`` in the<br>            ``State``, `not` the ``batch_size`` of ``model.forward``.  The training algorithm needs<br>            to convert from the `batched` allowed action sequences that it has to a `grouped`<br>            allowed action sequence list.<br><br>        Returns<br>        -------<br>        next_states : ``List[State]``<br>            A list of next states, ordered by score.<br>        """<br>        raise NotImplementedError

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_315679.txt
> def check_atd(text):<br>    """Check for redundancies from After the Deadline."""<br>    err = "after_the_deadline.redundancy"<br>    msg = "Redundancy. Use '{}' instead of '{}'."<br><br>    redundancies = [<br>        [u"Bō",               ["Bo Staff"]],<br>        ["Challah",           ["Challah bread"]],<br>        ["Hallah",            ["Hallah bread"]],<br>        ["Challah",           ["Challah bread"]],<br>        ["I",                 ["I myself", "I personally"]],<br>        ["Mount Fuji",        ["Mount Fujiyama"]],<br>        ["Milky Way",         ["Milky Way galaxy"]],<br>        ["Rio Grande",        ["Rio Grande river"]],<br>        ["adage",             ["old adage"]],<br>        ["add",               ["add a further", "add an additional"]],<br>        ["advance",           ["advance forward"]],<br>        ["alternative",       ["alternative choice"]],<br>        ["amaretto",          ["amaretto almond"]],<br>        ["annihilate",        ["completely annihilate"]],<br>        ["anniversary",       ["annual anniversary"]],<br>        ["anonymous",         ["unnamed anonymous"]],<br>        ["as",                ["equally as"]],<br>        ["ascend",            ["ascend up"]],<br>        ["ask",               ["ask the question"]],<br>        ["assemble",          ["assemble together"]],<br>        ["at present the",    ["at the present time the"]],<br>        ["at this point",     ["at this point in time"]],<br>        ["attach",            ["attach together"]],<br>        ["autumn",            ["autumn season"]],<br>        ["bald",              ["bald-headed"]],<br>        ["balsa",             ["balsa wood"]],<br>        ["belongings",        ["personal belongings"]],<br>        ["benefits",          ["desirable benefits"]],<br>        ["bento",             ["bento box"]],<br>        ["best",              ["best ever"]],<br>        ["bit",               ["tiny bit"]],<br>        ["blend",             ["blend together"]],<br>        ["bond",              ["common bond"]],<br>        ["bonus",             ["added bonus", "extra bonus"]],<br>        ["bouquet",           ["bouquet of flowers"]],<br>        ["breakthrough",      ["major breakthrough"]],<br>        ["bride",             ["new bride"]],<br>        ["brief",             ["brief in duration"]],<br>        ["bruin",             ["bruin bear"]],<br>        ["hot",               ["burning hot"]],<br>        ["cacophony",         ["cacophony of sound"]],<br>        ["cameo",             ["brief cameo", "cameo appearance"]],<br>        ["cancel",            ["cancel out"]],<br>        ["cash",              ["cash money"]],<br>        ["chai",              ["chai tea"]],<br>        ["chance",            ["random chance"]],<br>        ["charm",             ["personal charm"]],<br>        ["circle",            ["circle around", "round circle"]],<br>        ["circulate",         ["circulate around"]],<br>        ["classify",          ["classify into groups"]],<br>        ["classmates",        ["fellow classmates"]],<br>        ["cliche",            ["old cliche", "overused cliche"]],<br>        ["climb",             ["climb up"]],<br>        ["clock",             ["time clock"]],<br>        ["collaborate",       ["collaborate together"]],<br>        ["collaboration",     ["joint collaboration"]],<br>        ["colleague",         ["fellow colleague"]],<br>        ["combine",           ["combine together"]],<br>        ["commute",           ["commute back and forth"]],<br>        ["compete",           ["compete with each other"]],<br>        ["comprise",          ["comprise of"]],<br>        ["comprises",         ["comprises of"]],<br>        ["conceived",         ["first conceived"]],<br>        ["conclusion",        ["final conclusion"]],<br>        ["confer",            ["confer together"]],<br>        ["confrontation",     ["direct confrontation"]],<br>        # ["confused",          ["confused state"]],<br>        ["connect",           ["connect together", "connect up"]],<br>        ["consensus",         ["consensus of opinion", "general consensus"]],<br>        ["consult",           ["consult with"]],<br>        ["conversation",      ["oral conversation"]],<br>        ["cool",              ["cool down"]],<br>        ["cooperate",         ["cooperate together"]],<br>        ["cooperation",       ["mutual cooperation"]],<br>        ["copy",              ["duplicate copy"]],<br>        ["core",              ["inner core"]],<br>        ["cost",              ["cost the sum of"]],<br>        ["could",             ["could possibly"]],<br>        ["coupon",            ["money-saving coupon"]],<br>        ["created",           ["originally created"]],<br>        ["crisis",            ["crisis situation"]],<br>        ["crouch",            ["crouch down"]],<br>        ["currently",         ["now currently"]],<br>        ["custom",            ["old custom", "usual custom"]],<br>        ["danger",            ["serious danger"]],<br>        ["dates",             ["dates back"]],<br>        ["decision",          ["definite decision"]],<br>        ["depreciate",        ["depreciate in value"]],<br>        ["descend",           ["descend down"]],<br>        ["destroy",           ["totally destroy"]],<br>        ["destroyed",         ["completely destroyed"]],<br>        ["destruction",       ["total destruction"]],<br>        ["details",           ["specific details"]],<br>        ["dilemma",           ["difficult dilemma"]],<br>        ["disappear",         ["disappear from sight"]],<br>        ["discovered",        ["originally discovered"]],<br>        ["dive",              ["dive down"]],<br>        ["done",              ["over and done with"]],<br>        ["drawing",           ["illustrated drawing"]],<br>        ["drop",              ["drop down"]],<br>        ["dune",              ["sand dune"]],<br>        ["during",            ["during the course of"]],<br>        ["dwindle",           ["dwindle down"]],<br>        ["dwindled",          ["dwindled down"]],<br>        ["every",             ["each and every"]],<br>        ["earlier",           ["earlier in time"]],<br>        ["eliminate",         ["completely eliminate", "eliminate altogether",<br>                               "entirely eliminate"]],<br>        ["ember",             ["glowing ember"]],<br>        ["embers",            ["burning embers"]],<br>        ["emergency",         ["emergency situation", "unexpected emergency"]],<br>        ["empty",             ["empty out"]],<br>        ["enclosed",          ["enclosed herein"]],<br>        ["end",               ["final end"]],<br>        ["engulfed",          ["completely engulfed"]],<br>        ["enter",             ["enter in", "enter into"]],<br>        ["equal",             ["equal to one another"]],<br>        ["eradicate",         ["eradicate completely"]],<br>        ["essential",         ["absolutely essential"]],<br>        ["estimated at",      ["estimated at about",<br>                               "estimated at approximately",<br>                               "estimated at around"]],<br>        ["etc.",              ["and etc."]],<br>        ["evolve",            ["evolve over time"]],<br>        ["exaggerate",        ["over exaggerate"]],<br>        ["exited",            ["exited from"]],<br>        ["experience",        ["actual experience", "past experience"]],<br>        ["experts",           ["knowledgeable experts"]],<br>        ["extradite",         ["extradite back"]],<br>        ["face the consequences", ["face up to the consequences"]],<br>        ["face the fact",     ["face up to the fact"]],<br>        ["face the challenge", ["face up to the challenge"]],<br>        ["face the problem",  ["face up to the problem"]],<br>        ["facilitate",        ["facilitate easier"]],<br>        ["fact",              ["established fact"]],<br>        ["facts",             ["actual facts", "hard facts", "true facts"]],<br>        ["fad",               ["passing fad"]],<br>        ["fall",              ["fall down"]],<br>        ["fall",              ["fall season"]],<br>        ["feat",              ["major feat"]],<br>        ["feel",              ["feel inside"]],<br>        ["feelings",          ["inner feelings"]],<br>        ["few",               ["few in number"]],<br>        ["filled",            ["completely filled", "filled to capacity"]],<br>        ["first",             ["first of all"]],<br>        ["first time",        ["first time ever"]],<br>        ["fist",              ["closed fist"]],<br>        ["fly",               ["fly through the air"]],<br>        ["focus",             ["focus in", "main focus"]],<br>        ["follow",            ["follow after"]],<br>        ["for example",       ["as for example"]],<br>        # ["foremost",          ["first and foremost"]],<br>        ["forever",           ["forever and ever"]],<br>        ["free",              ["for free"]],<br>        ["friend",            ["personal friend"]],<br>        ["friendship",        ["personal friendship"]],<br>        ["full",              ["full to capacity"]],<br>        ["fundamentals",      ["basic fundamentals"]],<br>        ["fuse",              ["fuse together"]],<br>        ["gather",            ["gather together", "gather up"]],<br>        ["get up",            ["get up on his feet", "get up on your feet"]],<br>        ["gift",              ["free gift"]],<br>        ["gifts",             ["free gifts"]],<br>        ["goal",              ["ultimate goal"]],<br>        # ["graduate",          ["former graduate"]],<br>        ["grow",              ["grow in size"]],<br>        ["guarantee",         ["absolute guarantee"]],<br>        ["gunman",            ["armed gunman"]],<br>        ["gunmen",            ["armed gunmen"]],<br>        ["habitat",           ["native habitat"]],<br>        ["had done",          ["had done previously"]],<br>        ["halves",            ["two equal halves"]],<br>        # ["has",               ["has got"]],<br>        # ["have",              ["have got"]],<br>        ["haven",             ["safe haven"]],<br>        # ["he",                ["he himself"]],<br>        ["heat",              ["heat up"]],<br>        ["history",           ["past history"]],<br>        ["hoist",             ["hoist up"]],<br>        ["hole",              ["empty hole"]],<br>        ["honcho",            ["head honcho"]],<br>        ["ice",               ["frozen ice"]],<br>        ["ideal",             ["perfect ideal"]],<br>        ["identical",         ["same identical"]],<br>        ["identification",    ["positive identification"]],<br>        ["imports",           ["foreign imports"]],<br>        ["impulse",           ["sudden impulse"]],<br>        ["in fact",           ["in actual fact"]],<br>        ["in the yard",       ["outside in the yard"]],<br>        ["inclusive",         ["all inclusive"]],<br>        ["incredible",        ["incredible to believe"]],<br>        ["incumbent",         ["present incumbent"]],<br>        # ["indicted",          ["indicted on a charge"]],<br>        ["industry",          ["private industry"]],<br>        ["injuries",          ["harmful injuries"]],<br>        ["innovation",        ["new innovation"]],<br>        ["innovative",        ["innovative new", "new innovative"]],<br>        # ["input",             ["input into"]],<br>        ["instinct",          ["natural instinct", "naturally instinct"]],<br>        ["integrate",         ["integrate together",<br>                               "integrate with each other"]],<br>        ["interdependent",    ["interdependent on each other",<br>                               "mutually interdependent"]],<br>        ["introduced",        ["introduced for the first time"]],<br>        ["invention",         ["new invention"]],<br>        ["kneel",             ["kneel down"]],<br>        ["knots",             ["knots per hour"]],<br>        # ["last",              ["last of all"]],<br>        # ["later",             ["later time"]],<br>        ["lift",              ["lift up"]],<br>        ["lingers",           ["still lingers"]],<br>        ["look to the future", ["look ahead to the future"]],<br>        ["love triangle",     ["three-way love triangle"]],<br>        ["maintained",        ["constantly maintained"]],<br>        ["manually",          ["manually by hand"]],<br>        ["marina",            ["boat marina"]],<br>        ["may",               ["may possibly"]],<br>        ["meet",              ["meet together", "meet with each other"]],<br>        ["memories",          ["past memories"]],<br>        ["merge",             ["merge together"]],<br>        ["merged",            ["merged together"]],<br>        ["meshed",            ["meshed together"]],<br>        ["midnight",          ["twelve midnight"]],<br>        ["migraine",          ["migraine headache"]],<br>        ["minestrone",        ["minestrone soup"]],<br>        ["mix",               ["mix together"]],<br>        ["moment",            ["brief moment", "moment in time"]],<br>        ["monopoly",          ["complete monopoly"]],<br>        ["mural",             ["wall mural"]],<br>        ["mutual respect",    ["mutual respect for each other"]],<br>        ["mutually dependent", ["mutually dependent on each other"]],<br>        ["mystery",           ["unsolved mystery"]],<br>        # ["naked",             ["bare naked"]],<br>        ["nape",              ["nape of her neck"]],<br>        ["necessary",         ["absolutely necessary"]],<br>        ["never",             ["never at any time"]],<br>        ["noon",              ["12 noon", "12 o'clock noon", "high noon",<br>                               "twelve noon"]],<br>        ["nostalgia",         ["nostalgia for the past"]],<br>        ["number of",         ["number of different"]],<br>        ["opening",           ["exposed opening"]],<br>        ["my opinion",        ["my personal opinion"]],<br>        ["opposites",         ["exact opposites", "polar opposites"]],<br>        ["opposite",          ["exact opposite", "polar opposite"]],<br>        ["orbits",            ["orbits around"]],<br>        ["outcome",           ["final outcome"]],<br>        ["panacea",           ["universal panacea"]],<br>        ["pending",           ["now pending"]],<br>        ["penetrate",         ["penetrate through"]],<br>        ["persists",          ["still persists"]],<br>        ["pioneer",           ["old pioneer"]],<br>        ["plan",              ["plan ahead", "plan in advance",<br>                               "proposed plan"]],<br>        ["planning",          ["advance planning", "forward planning"]],<br>        ["plans",             ["future plans"]],<br>        ["plan",              ["future plan"]],<br>        ["point",             ["point in time"]],<br>        ["point",             ["sharp point"]],<br>        ["postpone",          ["postpone until later"]],<br>        ["pouring rain",      ["pouring down rain"]],<br>        ["preview",           ["advance preview"]],<br>        ["previously listed", ["previously listed above"]],<br>        ["probed",            ["probed into"]],<br>        ["proceed",           ["proceed ahead"]],<br>        ["prosthesis",        ["artificial prosthesis"]],<br>        # ["protrude",          ["protrude out"]],<br>        ["proverb",           ["old proverb"]],<br>        # ["proximity",         ["close proximity"]],<br>        ["put off",           ["put off until later"]],<br>        # ["raise",             ["raise up"]],<br>        ["re-elect",          ["re-elect for another term"]],<br>        ["reason is",         ["reason is because"]],<br>        ["recur",             ["recur again"]],<br>        ["recurrence",        ["future recurrence"]],<br>        ["refer",             ["refer back"]],<br>        ["reflect",           ["reflect back"]],<br>        # ["relevant",          ["highly relevant"]],<br>        ["remain",            ["continue to remain"]],<br>        ["remains",           ["still remains"]],<br>        ["replica",           ["exact replica"]],<br>        ["reply",             ["reply back"]],<br>        # ["requirements",      ["necessary requirements"]],<br>        ["reservations",      ["advance reservations"]],<br>        ["retreat",           ["retreat back"]],<br>        ["revert",            ["revert back"]],<br>        ["round",             ["round in shape"]],<br>        ["rule of thumb",     ["rough rule of thumb"]],<br>        ["rumor",             ["unconfirmed rumor"]],<br>        ["rustic",            ["rustic country"]],<br>        ["same",              ["exact same", "precise same", "same exact"]],<br>        ["sanctuary",         ["safe sanctuary"]],<br>        ["satisfaction",      ["full satisfaction"]],<br>        ["scrutinize",        ["scrutinize in detail"]],<br>        ["scrutiny",          ["careful scrutiny", "close scrutiny"]],<br>        ["secret",            ["secret that cannot be told"]],<br>        ["seek",              ["seek to find"]],<br>        ["separated",         ["separated apart from each other"]],<br>        ["share",             ["share together"]],<br>        ["shiny",             ["shiny in appearance"]],<br>        ["sincere",           ["truly sincere"]],<br>        ["sink",              ["sink down"]],<br>        ["skipped",           ["skipped over"]],<br>        # ["slow",              ["slow speed"]],<br>        # ["small",             ["small size"]],<br>        ["soft",              ["soft in texture", "soft to the touch"]],<br>        ["sole",              ["sole of the foot"]],<br>        ["some time",         ["some time to come"]],<br>        ["speck",             ["small speck"]],<br>        ["speed",             ["rate of speed"]],<br>        ["spell out",         ["spell out in detail"]],<br>        ["spiked",            ["spiked upward", "spiked upwards"]],<br>        ["spring",            ["spring season"]],<br>        ["stranger",          ["anonymous stranger"]],<br>        ["studio audience",   ["live studio audience"]],<br>        ["subway",            ["underground subway"]],<br>        ["sufficient",        ["sufficient enough"]],<br>        ["summer",            ["summer season"]],<br>        ["sure",              ["absolutely sure"]],<br>        ["surprise",          ["unexpected surprise"]],<br>        ["surround",          ["completely surround"]],<br>        ["surrounded",        ["surrounded on all sides"]],<br>        ["tall",              ["tall in height", "tall in stature"]],<br>        ["telepathy",         ["mental telepathy"]],<br>        ["ten",               ["ten in number"]],<br>        ["these",             ["these ones"]],<br>        # ["they",              ["they themselves"]],<br>        ["those",             ["those ones"]],<br>        ["trench",            ["open trench"]],<br>        ["truth",             ["honest truth"]],<br>        ["tundra",            ["frozen tundra"]],<br>        ["ultimatum",         ["final ultimatum"]],<br>        # ["undeniable",        ["undeniable truth"]],<br>        ["undergraduate",     ["undergraduate student"]],<br>        # ["unintentional",     ["unintentional mistake"]],<br>        ["vacillate",         ["vacillate back and forth"]],<br>        ["veteran",           ["former veteran"]],<br>        ["visible",           ["visible to the eye"]],<br>        ["warn",              ["warn in advance"]],<br>        ["warning",           ["advance warning"]],<br>        ["water heater",      ["hot water heater"]],<br>        ["in which we live",  ["in which we live in"]],<br>        ["winter",            ["winter season"]],<br>        ["witness",           ["live witness"]],<br>        ["yakitori",          ["yakitori chicken"]],<br>        ["yerba mate",        ["yerba mate tea"]],<br>        ["yes",               ["affirmative yes"]],<br>    ]<br><br>    return preferred_forms_check(text, redundancies, err, msg)

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_226291.txt
> def find_prime_polynomials(generator=2, c_exp=8, fast_primes=False, single=False):<br>    '''Compute the list of prime polynomials for the given generator and galois field characteristic exponent.'''<br>    # fast_primes will output less results but will be significantly faster.<br>    # single will output the first prime polynomial found, so if all you want is to just find one prime polynomial to generate the LUT for Reed-Solomon to work, then just use that.<br><br>    # A prime polynomial (necessarily irreducible) is necessary to reduce the multiplications in the Galois Field, so as to avoid overflows.<br>    # Why do we need a "prime polynomial"? Can't we just reduce modulo 255 (for GF(2^8) for example)? Because we need the values to be unique.<br>    # For example: if the generator (alpha) = 2 and c_exp = 8 (GF(2^8) == GF(256)), then the generated Galois Field (0, 1, α, α^1, α^2, ..., α^(p-1)) will be galois field it becomes 0, 1, 2, 4, 8, 16, etc. However, upon reaching 128, the next value will be doubled (ie, next power of 2), which will give 256. Then we must reduce, because we have overflowed above the maximum value of 255. But, if we modulo 255, this will generate 256 == 1. Then 2, 4, 8, 16, etc. giving us a repeating pattern of numbers. This is very bad, as it's then not anymore a bijection (ie, a non-zero value doesn't have a unique index). That's why we can't just modulo 255, but we need another number above 255, which is called the prime polynomial.<br>    # Why so much hassle? Because we are using precomputed look-up tables for multiplication: instead of multiplying ab, we precompute alpha^a, alpha^b and alpha^(a+b), so that we can just use our lookup table at alpha^(a+b) and get our result. But just like in our original field we had 0,1,2,...,p-1 distinct unique values, in our "LUT" field using alpha we must have unique distinct values (we don't care that they are different from the original field as long as they are unique and distinct). That's why we need to avoid duplicated values, and to avoid duplicated values we need to use a prime irreducible polynomial.<br><br>    # Here is implemented a bruteforce approach to find all these prime polynomials, by generating every possible prime polynomials (ie, every integers between field_charac+1 and field_charac2), and then we build the whole Galois Field, and we reject the candidate prime polynomial if it duplicates even one value or if it generates a value above field_charac (ie, cause an overflow).<br>    # Note that this algorithm is slow if the field is too big (above 12), because it's an exhaustive search algorithm. There are probabilistic approaches, and almost surely prime approaches, but there is no determistic polynomial time algorithm to find irreducible monic polynomials. More info can be found at: http://people.mpi-inf.mpg.de/~csaha/lectures/lec9.pdf<br>    # Another faster algorithm may be found at Adleman, Leonard M., and Hendrik W. Lenstra. "Finding irreducible polynomials over finite fields." Proceedings of the eighteenth annual ACM symposium on Theory of computing. ACM, 1986.<br><br>    # Prepare the finite field characteristic (2^p - 1), this also represent the maximum possible value in this field<br>    root_charac = 2 # we're in GF(2)<br>    field_charac = int(root_characc_exp - 1)<br>    field_charac_next = int(root_charac(c_exp+1) - 1)<br><br>    prim_candidates = []<br>    if fast_primes:<br>        prim_candidates = rwh_primes1(field_charac_next) # generate maybe prime polynomials and check later if they really are irreducible<br>        prim_candidates = [x for x in prim_candidates if x  field_charac] # filter out too small primes<br>    else:<br>        prim_candidates = _range(field_charac+2, field_charac_next, root_charac) # try each possible prime polynomial, but skip even numbers (because divisible by 2 so necessarily not irreducible)<br><br>    # Start of the main loop<br>    correct_primes = []<br>    for prim in prim_candidates: # try potential candidates primitive irreducible polys<br>        seen = bytearray(field_charac+1) # memory variable to indicate if a value was already generated in the field (value at index x is set to 1) or not (set to 0 by default)<br>        conflict = False # flag to know if there was at least one conflict<br><br>        # Second loop, build the whole Galois Field<br>        x = GF2int(1)<br>        for i in _range(field_charac):<br>            # Compute the next value in the field (ie, the next power of alpha/generator)<br>            x = x.multiply(generator, prim, field_charac+1)<br><br>            # Rejection criterion: if the value overflowed (above field_charac) or is a duplicate of a previously generated power of alpha, then we reject this polynomial (not prime)<br>            if x  field_charac or seen[x] == 1:<br>                conflict = True<br>                break<br>            # Else we flag this value as seen (to maybe detect future duplicates), and we continue onto the next power of alpha<br>            else:<br>                seen[x] = 1<br><br>        # End of the second loop: if there's no conflict (no overflow nor duplicated value), this is a prime polynomial!<br>        if not conflict: <br>            correct_primes.append(prim)<br>            if single: return prim<br><br>    # Return the list of all prime polynomials<br>    return correct_primes

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_226519.txt
> def find_prime_polys(generator=2, c_exp=8, fast_primes=False, single=False):<br>    '''Compute the list of prime polynomials for the given generator and galois field characteristic exponent.'''<br>    # fast_primes will output less results but will be significantly faster.<br>    # single will output the first prime polynomial found, so if all you want is to just find one prime polynomial to generate the LUT for Reed-Solomon to work, then just use that.<br><br>    # A prime polynomial (necessarily irreducible) is necessary to reduce the multiplications in the Galois Field, so as to avoid overflows.<br>    # Why do we need a "prime polynomial"? Can't we just reduce modulo 255 (for GF(2^8) for example)? Because we need the values to be unique.<br>    # For example: if the generator (alpha) = 2 and c_exp = 8 (GF(2^8) == GF(256)), then the generated Galois Field (0, 1, α, α^1, α^2, ..., α^(p-1)) will be galois field it becomes 0, 1, 2, 4, 8, 16, etc. However, upon reaching 128, the next value will be doubled (ie, next power of 2), which will give 256. Then we must reduce, because we have overflowed above the maximum value of 255. But, if we modulo 255, this will generate 256 == 1. Then 2, 4, 8, 16, etc. giving us a repeating pattern of numbers. This is very bad, as it's then not anymore a bijection (ie, a non-zero value doesn't have a unique index). That's why we can't just modulo 255, but we need another number above 255, which is called the prime polynomial.<br>    # Why so much hassle? Because we are using precomputed look-up tables for multiplication: instead of multiplying ab, we precompute alpha^a, alpha^b and alpha^(a+b), so that we can just use our lookup table at alpha^(a+b) and get our result. But just like in our original field we had 0,1,2,...,p-1 distinct unique values, in our "LUT" field using alpha we must have unique distinct values (we don't care that they are different from the original field as long as they are unique and distinct). That's why we need to avoid duplicated values, and to avoid duplicated values we need to use a prime irreducible polynomial.<br><br>    # Here is implemented a bruteforce approach to find all these prime polynomials, by generating every possible prime polynomials (ie, every integers between field_charac+1 and field_charac2), and then we build the whole Galois Field, and we reject the candidate prime polynomial if it duplicates even one value or if it generates a value above field_charac (ie, cause an overflow).<br>    # Note that this algorithm is slow if the field is too big (above 12), because it's an exhaustive search algorithm. There are probabilistic approaches, and almost surely prime approaches, but there is no determistic polynomial time algorithm to find irreducible monic polynomials. More info can be found at: http://people.mpi-inf.mpg.de/~csaha/lectures/lec9.pdf<br>    # Another faster algorithm may be found at Adleman, Leonard M., and Hendrik W. Lenstra. "Finding irreducible polynomials over finite fields." Proceedings of the eighteenth annual ACM symposium on Theory of computing. ACM, 1986.<br><br>    # Prepare the finite field characteristic (2^p - 1), this also represent the maximum possible value in this field<br>    root_charac = 2 # we're in GF(2)<br>    field_charac = int(root_characc_exp - 1)<br>    field_charac_next = int(root_charac(c_exp+1) - 1)<br><br>    prim_candidates = []<br>    if fast_primes:<br>        prim_candidates = rwh_primes1(field_charac_next) # generate maybe prime polynomials and check later if they really are irreducible<br>        prim_candidates = [x for x in prim_candidates if x  field_charac] # filter out too small primes<br>    else:<br>        prim_candidates = xrange(field_charac+2, field_charac_next, root_charac) # try each possible prime polynomial, but skip even numbers (because divisible by 2 so necessarily not irreducible)<br><br>    # Start of the main loop<br>    correct_primes = []<br>    for prim in prim_candidates: # try potential candidates primitive irreducible polys<br>        seen = bytearray(field_charac+1) # memory variable to indicate if a value was already generated in the field (value at index x is set to 1) or not (set to 0 by default)<br>        conflict = False # flag to know if there was at least one conflict<br><br>        # Second loop, build the whole Galois Field<br>        x = 1<br>        for i in xrange(field_charac):<br>            # Compute the next value in the field (ie, the next power of alpha/generator)<br>            x = gf_mult_noLUT(x, generator, prim, field_charac+1)<br><br>            # Rejection criterion: if the value overflowed (above field_charac) or is a duplicate of a previously generated power of alpha, then we reject this polynomial (not prime)<br>            if x  field_charac or seen[x] == 1:<br>                conflict = True<br>                break<br>            # Else we flag this value as seen (to maybe detect future duplicates), and we continue onto the next power of alpha<br>            else:<br>                seen[x] = 1<br><br>        # End of the second loop: if there's no conflict (no overflow nor duplicated value), this is a prime polynomial!<br>        if not conflict: <br>            correct_primes.append(prim)<br>            if single: return prim<br><br>    # Return the list of all prime polynomials<br>    return correct_primes

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_326876.txt
> def hurst_rs(data, nvals=None, fit="RANSAC", debug_plot=False,<br>             debug_data=False, plot_file=None, corrected=True, unbiased=True):<br>  """<br>  Calculates the Hurst exponent by a standard rescaled range (R/S) approach.<br><br>  Explanation of Hurst exponent:<br>    The Hurst exponent is a measure for the "long-term memory" of a<br>    time series, meaning the long statistical dependencies in the data that do<br>    not originate from cycles.<br><br>    It originates from H.E. Hursts observations of the problem of long-term<br>    storage in water reservoirs. If x_i is the discharge of a river in year i<br>    and we observe this discharge for N years, we can calculate the storage<br>    capacity that would be required to keep the discharge steady at its mean<br>    value.<br><br>    To do so, we first substract the mean over all x_i from the individual<br>    x_i to obtain the departures x'_i from the mean for each year i. As the<br>    excess or deficit in discharge always carrys over from year i to year i+1,<br>    we need to examine the cumulative sum of x'_i, denoted by y_i. This<br>    cumulative sum represents the filling of our hypothetical storage. If the<br>    sum is above 0, we are storing excess discharge from the river, if it is<br>    below zero we have compensated a deficit in discharge by releasing<br>    water from the storage. The range (maximum - minimum) R of y_i therefore<br>    represents the total capacity required for the storage.<br><br>    Hurst showed that this value follows a steady trend for varying N if it<br>    is normalized by the standard deviation sigma over the x_i. Namely he<br>    obtained the following formula:<br><br>    R/sigma = (N/2)^K<br><br>    In this equation, K is called the Hurst exponent. Its value is 0.5 for<br>    white noise, but becomes greater for time series that exhibit some positive<br>    dependency on previous values. For negative dependencies it becomes less<br>    than 0.5.<br><br>  Explanation of the algorithm:<br>    The rescaled range (R/S) approach is directly derived from Hurst's<br>    definition. The time series of length N is split into non-overlapping<br>    subseries of length n. Then, R and S (S = sigma) are calculated for each<br>    subseries and the mean is taken over all subseries yielding (R/S)_n. This<br>    process is repeated for several lengths n. Finally, the exponent K is<br>    obtained by fitting a straight line to the plot of log((R/S)_n) vs log(n).<br><br>    There seems to be no consensus how to chose the subseries lenghts n.<br>    This function therefore leaves the choice to the user. The module provides<br>    some utility functions for "typical" values:<br><br>       binary_n: N/2, N/4, N/8, ...<br>       logarithmic_n: min_n, min_n  f, min_n  f^2, ...<br><br>  References:<br>    .. [h_1] H. E. Hurst, “The problem of long-term storage in reservoirs,”<br>       International Association of Scientific Hydrology. Bulletin, vol. 1,<br>       no. 3, pp. 13–27, 1956.<br>    .. [h_2] H. E. Hurst, “A suggested statistical model of some time series<br>       which occur in nature,” Nature, vol. 180, p. 494, 1957.<br>    .. [h_3] R. Weron, “Estimating long-range dependence: finite sample<br>       properties and confidence intervals,” Physica A: Statistical Mechanics<br>       and its Applications, vol. 312, no. 1, pp. 285–299, 2002.<br><br>  Reference Code:<br>    .. [h_a] "hurst" function in R-package "pracma",<br>             url: https://cran.r-project.org/web/packages/pracma/pracma.pdf<br><br>             Note: Pracma yields several estimates of the Hurst exponent, which<br>             are listed below. Unless otherwise stated they use the divisors<br>             of the length of the sequence as n. The length is reduced by at<br>             most 1% to find the value that has the most divisors.<br><br>              The "Simple R/S" estimate is just log((R/S)_n) / log(n) for <br>               n = N.<br>              The "theoretical Hurst exponent" is the value that would be<br>               expected of an uncorrected rescaled range approach for random<br>               noise of the size of the input data.<br>              The "empirical Hurst exponent" is the uncorrected Hurst exponent<br>               obtained by the rescaled range approach.<br>              The "corrected empirical Hurst exponent" is the Anis-Lloyd-Peters<br>               corrected Hurst exponent, but with sqrt(1/2  pi  n) added to<br>               the (R/S)_n before the log.<br>              The "corrected R over S Hurst exponent" uses the R-function "lm"<br>               instead of pracmas own "polyfit" and uses n = N/2, N/4, N/8, ...<br>               by successively halving the subsequences (which means that some<br>               subsequences may be one element longer than others). In contrast<br>               to its name it does not use the Anis-Lloyd-Peters correction<br>               factor.<br><br>             If you want to compare the output of pracma to the output of<br>             nolds, the "empirical hurst exponent" is the only measure that<br>             exactly corresponds to the Hurst measure implemented in nolds<br>             (by choosing corrected=False, fit="poly" and employing the same<br>             strategy for choosing n as the divisors of the (reduced)<br>             sequence length).<br>    .. [h_b] Rafael Weron, "HURST: MATLAB function to compute the Hurst<br>             exponent using R/S Analysis",<br>             url: https://ideas.repec.org/c/wuu/hscode/m11003.html<br><br>             Note: When the same values for nvals are used and fit is set to<br>             "poly", nolds yields exactly the same results as this<br>             implementation.<br>    .. [h_c] Bill Davidson, "Hurst exponent",<br>             url: http://www.mathworks.com/matlabcentral/fileexchange/9842-hurst-exponent<br>    .. [h_d] Tomaso Aste, "Generalized Hurst exponent",<br>             url: http://de.mathworks.com/matlabcentral/fileexchange/30076-generalized-hurst-exponent<br><br>  Args:<br>    data (array-like of float):<br>      time series<br>  Kwargs:<br>    nvals (iterable of int):<br>      sizes of subseries to use<br>      (default: logmid_n(total_N, ratio=1/4.0, nsteps=15) , that is 15<br>      logarithmically spaced values in the medium 25% of the logarithmic range)<br><br>      Generally, the choice for n is a trade-off between the length and the<br>      number of the subsequences that are used for the calculation of the<br>      (R/S)_n. Very low values of n lead to high variance in the ``r`` and ``s``<br>      while very high values may leave too few subsequences that the mean along<br>      them is still meaningful. Logarithmic spacing makes sense, because it <br>      translates to even spacing in the log-log-plot.<br>    fit (str):<br>      the fitting method to use for the line fit, either 'poly' for normal<br>      least squares polynomial fitting or 'RANSAC' for RANSAC-fitting which<br>      is more robust to outliers<br>    debug_plot (boolean):<br>      if True, a simple plot of the final line-fitting step will be shown<br>    debug_data (boolean):<br>      if True, debugging data will be returned alongside the result<br>    plot_file (str):<br>      if debug_plot is True and plot_file is not None, the plot will be saved<br>      under the given file name instead of directly showing it through<br>      ``plt.show()``<br>    corrected (boolean):<br>      if True, the Anis-Lloyd-Peters correction factor will be applied to the<br>      output according to the expected value for the individual (R/S)_n<br>      (see [h_3]_)<br>    unbiased (boolean):<br>      if True, the standard deviation based on the unbiased variance<br>      (1/(N-1) instead of 1/N) will be used. This should be the default choice,<br>      since the true mean of the sequences is not known. This parameter should<br>      only be changed to recreate results of other implementations.<br><br>  Returns:<br>    float:<br>      estimated Hurst exponent K using a rescaled range approach (if K = 0.5<br>      there are no long-range correlations in the data, if K < 0.5 there are<br>      negative long-range correlations, if K  0.5 there are positive<br>      long-range correlations)<br>    (1d-vector, 1d-vector, list):<br>      only present if debug_data is True: debug data of the form<br>      ``(nvals, rsvals, poly)`` where ``nvals`` are the values used for log(n), <br>      ``rsvals`` are the corresponding log((R/S)_n) and ``poly`` are the line <br>      coefficients (``[slope, intercept]``)<br>  """<br>  data = np.asarray(data)<br>  total_N = len(data)<br>  if nvals is None:<br>    # chooses a default value for nvals that will give 15 logarithmically<br>    # spaced datapoints leaning towards the middle of the logarithmic range<br>    # (since both too small and too large n introduce too much variance)<br>    nvals = logmid_n(total_N, ratio=1/4.0, nsteps=15)<br>  # get individual values for (R/S)_n<br>  rsvals = np.array([rs(data, n, unbiased=unbiased) for n in nvals])<br>  # filter NaNs (zeros should not be possible, because if R is 0 then<br>  # S is also zero)<br>  not_nan = np.logical_not(np.isnan(rsvals))<br>  rsvals = rsvals[not_nan]<br>  nvals = np.asarray(nvals)[not_nan]<br>  # it may happen that no rsvals are left (if all values of data are the same)<br>  if len(rsvals) == 0:<br>    poly = [np.nan, np.nan]<br>    if debug_plot:<br>      warnings.warn("Cannot display debug plot, all (R/S)_n are NaN")<br>  else:<br>    # fit a line to the logarithm of the obtained (R/S)_n<br>    xvals = np.log(nvals)<br>    yvals = np.log(rsvals)<br>    if corrected:<br>      yvals -= np.log([expected_rs(n) for n in nvals])<br>    poly = poly_fit(xvals, yvals, 1, fit=fit)<br>    if debug_plot:<br>      plot_reg(xvals, yvals, poly, "log(n)", "log((R/S)_n)",<br>               fname=plot_file)<br>  # account for correction if necessary<br>  h = poly[0] + 0.5 if corrected else poly[0]<br>  # return line slope (+ correction) as hurst exponent<br>  if debug_data:<br>    return (h, (np.log(nvals), np.log(rsvals), poly))<br>  else:<br>    return h


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2397.txt
> def max_covered_rows(matrix, num_select):<br>    """You are given a 0-indexed `m x n` binary matrix `matrix` and an integer `numSelect`, which denotes the number of distinct columns you must select from `matrix`.<br><br>Let us consider `s = {c1, c2, ...., cnumSelect}` as the set of columns selected by you. A row `row` is covered by `s` if:<br><br>   For each cell `matrix[row][col]` (`0 <= col <= n - 1`) where `matrix[row][col] == 1`, `col` is present in `s` or,<br>   No cell in `row` has a value of `1`.<br><br>You need to choose `numSelect` columns such that the number of rows that are covered is maximized.<br><br>Return _the maximum number of rows that can be covered by a set of_ `numSelect` _columns._<br><br>Example 1:<br><br>Input: matrix = \[\[0,0,0\],\[1,0,1\],\[0,1,1\],\[0,0,1\]\], numSelect = 2<br>Output: 3<br>Explanation: One possible way to cover 3 rows is shown in the diagram above.<br>We choose s = {0, 2}.<br>- Row 0 is covered because it has no occurrences of 1.<br>- Row 1 is covered because the columns with value 1, i.e. 0 and 2 are present in s.<br>- Row 2 is not covered because matrix\[2\]\[1\] == 1 but 1 is not present in s.<br>- Row 3 is covered because matrix\[2\]\[2\] == 1 and 2 is present in s.<br>Thus, we can cover three rows.<br>Note that s = {1, 2} will also cover 3 rows, but it can be shown that no more than three rows can be covered.<br><br>Example 2:<br><br>Input: matrix = \[\[1\],\[0\]\], numSelect = 1<br>Output: 2<br>Explanation: Selecting the only column will result in both rows being covered since the entire matrix is selected.<br>Therefore, we return 2.<br><br>Constraints:<br><br>   `m == matrix.length`<br>   `n == matrix[i].length`<br>   `1 <= m, n <= 12`<br>   `matrix[i][j]` is either `0` or `1`.<br>   `1 <= numSelect <= n`"""<br><br>    m, n = len(matrix), len(matrix[0])<br>    max_covered = 0<br>    for i in range(1 << n):<br>        if bin(i).count('1') == num_select:<br>            covered = 0<br>            for row in range(m):<br>                for col in range(n):<br>                    if matrix[row][col] == 1 and i & (1 << col):<br>                        covered += 1<br>                        break<br>            max_covered = max(max_covered, covered)<br>    return max_covered
