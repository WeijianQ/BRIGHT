# Query `12`

## Original Question

*You are playing the [Bulls and Cows](https://en.wikipedia.org/wiki/Bulls_and_Cows) game with your friend.

You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:

   The number of "bulls ", which are digits in the guess that are in the correct position.
   The number of "cows ", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.

Given the secret number `secret` and your friend's guess `guess`, return _the hint for your friend's guess_.

The hint should be formatted as `"xAyB "`, where `x` is the number of bulls and `y` is the number of cows. Note that both `secret` and `guess` may contain duplicate digits.

Example 1:

Input: secret =  "1807 ", guess =  "7810 "
Output:  "1A3B "
Explanation: Bulls are connected with a '|' and cows are underlined:
 "1807 "
  |
 "7810 "

Example 2:

Input: secret =  "1123 ", guess =  "0111 "
Output:  "1A1B "
Explanation: Bulls are connected with a '|' and cows are underlined:
 "1123 "         "1123 "
  |      or     |
 "0111 "         "0111 "
Note that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.

Constraints:

   `1 <= secret.length, guess.length <= 1000`
   `secret.length == guess.length`
   `secret` and `guess` consist of digits only.*

## gpt4 Reasoning

```markdown
The essential problem here is to create a system that, given a `secret` number and a `guess` number of equal length, calculates the number of correct digits in the correct position (bulls) and the number of correct digits in the wrong position (cows). This system should return a hint in the format "xAyB", where x is the number of bulls and y is the number of cows.

To solve this problem, we can follow these steps:

1. **Initialize Counters**: We start by initializing two counters, one for bulls (`x`) and one for cows (`y`). Both are initially set to 0.

2. **Direct Match for Bulls**: Iterate through the `secret` and `guess` strings simultaneously. For each position, if the digit in `secret` matches the digit in `guess`, we have found a bull. Increment the bulls counter (`x`) and mark this digit as counted to ensure it is not recounted as a cow later. One way to mark it could be by replacing the digit with a special character or flagging it in a separate data structure.

3. **Indirect Match for Cows**: For the digits that were not direct matches (not bulls), we need to determine if they can be matched with any digit in a different position (cows). This step is a bit trickier because:
    - We need to ensure that we only count a digit as a cow if the `secret` has that digit in a different position not already matched as a bull.
    - We must also ensure that we do not count the same digit more times than it appears in `secret`. This means tracking the frequency of each digit in `secret` and `guess` that were not matched as bulls.

4. **Tracking Frequencies**: One way to track frequencies is by using an array or a dictionary to count the occurrences of each digit in both `secret` and `guess` for the non-bull digits. Since the digits are 0 through 9, an array of length 10 for each (or two dictionaries if preferred) can be sufficient. As we iterate through the non-bull digits, increase the count in the respective array/dictionary for `secret` and `guess`.

5. **Calculating Cows**: After counting the frequencies of non-bull digits in both `secret` and `guess`, iterate through the arrays/dictionaries of frequencies. For each digit, the number of cows can be incremented by the minimum of the two frequencies (from `secret` and `guess`) for that digit. This ensures that we only count a digit as a cow if it exists in both `secret` and `guess`, and only up to the number of times it appears in both.

6. **Format and Return the Hint**: Finally, format the hint as "xAyB" using the bulls (`x`) and cows (`y`) counters and return it.

By following these steps, we ensure that we accurately count both the bulls and cows according to the rules of the game, taking into account the constraints and the potential for duplicate digits in both the `secret` and the `guess`.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_226148.txt
> def majority_vote_byte_scan(relfilepath, fileslist, outpath, blocksize=65535, default_char_null=False):<br>    '''Takes a list of files in string format representing the same data, and disambiguate by majority vote: for position in string, if the character is not the same accross all entries, we keep the major one. If none, it will be replaced by a null byte (because we can't know if any of the entries are correct about this character).<br>    relfilepath is the filename or the relative file path relative to the parent directory (ie, this is the relative path so that we can compare the files from several directories).'''<br>    # The idea of replication combined with ECC was a bit inspired by this paper: Friedman, Roy, Yoav Kantor, and Amir Kantor. "Combining Erasure-Code and Replication Redundancy Schemes for Increased Storage and Repair Efficiency in P2P Storage Systems.", 2013, Technion, Computer Science Department, Technical Report CS-2013-03<br>    # But it is a very well known concept in redundancy engineering, usually called triple-modular redundancy (which is here extended to n-modular since we can supply any number of files we want, not just three).<br>    # Preference in case of ambiguity is always given to the file of the first folder.<br><br>    fileshandles = []<br>    for filepath in fileslist:<br>        if filepath:<br>            # Already a file handle? Just store it in the fileshandles list<br>            if hasattr(filepath, 'read'):<br>                fileshandles.append(filepath)<br>            # Else it's a string filepath, open the file<br>            else:<br>                fileshandles.append(open(filepath, 'rb'))<br><br>    # Create and open output (merged) file, except if we were already given a file handle<br>    if hasattr(outpath, 'write'):<br>        outfile = outpath<br>    else:<br>        outpathfull = os.path.join(outpath, relfilepath)<br>        pardir = os.path.dirname(outpathfull)<br>        if not os.path.exists(pardir):<br>            os.makedirs(pardir)<br>        outfile = open(outpathfull, 'wb')<br><br>    # Cannot vote if there's not at least 3 files!<br>    # In this case, just copy the file from the first folder, verbatim<br>    if len(fileshandles) < 3:<br>        # If there's at least one input file, then copy it verbatim to the output folder<br>        if fileshandles:<br>            create_dir_if_not_exist(os.path.dirname(outpathfull))<br>            buf = 1<br>            while (buf):<br>                buf = fileshandles[0].read()<br>                outfile.write(buf)<br>                outfile.flush()<br>        return (1, "Error with file %s: only %i copies available, cannot vote (need at least 3)! Copied the first file from the first folder, verbatim." % (relfilepath, len(fileshandles)))<br><br>    errors = []<br>    entries = [1]len(fileshandles)  # init with 0 to start the while loop<br>    while (entries.count('') < len(fileshandles)):<br>        final_entry = []<br>        # Read a block from all input files into memory<br>        for i in xrange(len(fileshandles)):<br>            entries[i] = fileshandles[i].read(blocksize)<br><br>        # End of file for all files, we exit<br>        if entries.count('') == len(fileshandles):<br>            break<br>        # Else if there's only one file, just copy the file's content over<br>        elif len(entries) == 1:<br>            final_entry = entries[0]<br><br>        # Else, do the majority vote<br>        else:<br>            # Walk along each column (imagine the strings being rows in a matrix, then we pick one column at each iteration = all characters at position i of each string), so that we can compare these characters easily<br>            for i in xrange(max(len(entry) for entry in entries)):<br>                hist = {} # kind of histogram, we just memorize how many times a character is presented at the position i in each string TODO: use collections.Counter instead of dict()?<br>                # Extract the character at position i of each string and compute the histogram at the same time (number of time this character appear among all strings at this position i)<br>                for entry in entries:<br>                    # Check if we are not beyond the current entry's length<br>                    if i < len(entry): # TODO: check this line, this should allow the vote to continue even if some files are shorter than others<br>                        # Extract the character and use it to contribute to the histogram<br>                        # TODO: add warning message when one file is not of the same size as the others<br>                        key = str(ord(entry[i])) # convert to the ascii value to avoid any funky problem with encoding in dict keys<br>                        hist[key] = hist.get(key, 0) + 1 # increment histogram for this value. If it does not exists, use 0. (essentially equivalent to hist[key] += 1 but with exception management if key did not already exists)<br>                # If there's only one character (it's the same accross all strings at position i), then it's an exact match, we just save the character and we can skip to the next iteration<br>                if len(hist) == 1:<br>                    final_entry.append(chr(int(hist.iterkeys().next())))<br>                    continue<br>                # Else, the character is different among different entries, we will pick the major one (mode)<br>                elif len(hist)  1:<br>                    # Sort the dict by value (and reverse because we want the most frequent first)<br>                    skeys = sorted(hist, key=hist.get, reverse=True)<br>                    # Ambiguity! If each entries present a different character (thus the major has only an occurrence of 1), then it's too ambiguous and we just set a null byte to signal that<br>                    if hist[skeys[0]] == 1:<br>                        if default_char_null:<br>                            if default_char_null is True:<br>                                final_entry.append("\x00")<br>                            else:<br>                                final_entry.append(default_char_null)<br>                        else:<br>                            # Use the entry of the first file that is still open<br>                            first_char = ''<br>                            for entry in entries:<br>                                # Found the first file that has a character at this position: store it and break loop<br>                                if i < len(entry):<br>                                    first_char = entry[i]<br>                                    break<br>                            # Use this character in spite of ambiguity<br>                            final_entry.append(first_char)<br>                        errors.append(outfile.tell() + i) # Print an error indicating the characters that failed<br>                    # Else if there is a tie (at least two characters appear with the same frequency), then we just pick one of them<br>                    elif hist[skeys[0]] == hist[skeys[1]]:<br>                        final_entry.append(chr(int(skeys[0]))) # TODO: find a way to account for both characters. Maybe return two different strings that will both have to be tested? (eg: maybe one has a tampered hash, both will be tested and if one correction pass the hash then it's ok we found the correct one)<br>                    # Else we have a clear major character that appear in more entries than any other character, then we keep this one<br>                    else:<br>                        final_entry.append(chr(int(skeys[0]))) # alternative one-liner: max(hist.iteritems(), key=operator.itemgetter(1))[0]<br>                    continue<br>            # Concatenate to a string (this is faster than using a string from the start and concatenating at each iteration because Python strings are immutable so Python has to copy over the whole string, it's in O(n^2)<br>            final_entry = ''.join(final_entry)<br>            # Commit to output file<br>            outfile.write(final_entry)<br>            outfile.flush()<br><br>    # Errors signaling<br>    if errors:<br>        error_msg = "Unrecoverable corruptions (because of ambiguity) in file %s on characters: %s." % (relfilepath, [hex(int(x)) for x in errors]) # Signal to user that this file has unrecoverable corruptions (he may try to fix the bits manually or with his own script)<br>        return (1, error_msg) # return an error<br>    # Close all input files<br>    for fh in fileshandles:<br>        fh.close()<br>    # Close output file<br>    if outfile != outpath:  # close only if we were not given a file handle in the first place<br>        outfile.flush()<br>        outfile.close()<br>    return (0, None)

### DOC[2] (IRRELEVANT) leetcode/leetcode_2343.txt
> from typing import List<br>    """You are given a 0-indexed array of strings `nums`, where each string is of equal length and consists of only digits.<br><br>You are also given a 0-indexed 2D integer array `queries` where `queries[i] = [ki, trimi]`. For each `queries[i]`, you need to:<br><br>   Trim each number in `nums` to its rightmost `trimi` digits.<br>   Determine the index of the `kith` smallest trimmed number in `nums`. If two trimmed numbers are equal, the number with the lower index is considered to be smaller.<br>   Reset each number in `nums` to its original length.<br><br>Return _an array_ `answer` _of the same length as_ `queries`, _where_ `answer[i]` _is the answer to the_ `ith` _query._<br><br>Note:<br><br>   To trim to the rightmost `x` digits means to keep removing the leftmost digit, until only `x` digits remain.<br>   Strings in `nums` may contain leading zeros.<br><br>Example 1:<br><br>Input: nums = \[ "102 ", "473 ", "251 ", "814 "\], queries = \[\[1,1\],\[2,3\],\[4,2\],\[1,2\]\]<br>Output: \[2,2,1,0\]<br>Explanation:<br>1. After trimming to the last digit, nums = \[ "2 ", "3 ", "1 ", "4 "\]. The smallest number is 1 at index 2.<br>2. Trimmed to the last 3 digits, nums is unchanged. The 2nd smallest number is 251 at index 2.<br>3. Trimmed to the last 2 digits, nums = \[ "02 ", "73 ", "51 ", "14 "\]. The 4th smallest number is 73.<br>4. Trimmed to the last 2 digits, the smallest number is 2 at index 0.<br>   Note that the trimmed number  "02 " is evaluated as 2.<br><br>Example 2:<br><br>Input: nums = \[ "24 ", "37 ", "96 ", "04 "\], queries = \[\[2,1\],\[2,2\]\]<br>Output: \[3,0\]<br>Explanation:<br>1. Trimmed to the last digit, nums = \[ "4 ", "7 ", "6 ", "4 "\]. The 2nd smallest number is 4 at index 3.<br>   There are two occurrences of 4, but the one at index 0 is considered smaller than the one at index 3.<br>2. Trimmed to the last 2 digits, nums is unchanged. The 2nd smallest number is 24.<br><br>Constraints:<br><br>   `1 <= nums.length <= 100`<br>   `1 <= nums[i].length <= 100`<br>   `nums[i]` consists of only digits.<br>   All `nums[i].length` are equal.<br>   `1 <= queries.length <= 100`<br>   `queries[i].length == 2`<br>   `1 <= ki <= nums.length`<br>   `1 <= trimi <= nums[i].length`<br><br>Follow up: Could you use the Radix Sort Algorithm to solve this problem? What will be the complexity of that solution?"""<br><br><br>def kthSmallestIndex(nums: List[str], queries: List[List[int]]) - List[int]:<br>    answer = []<br>    indices = list(enumerate(map(int, nums)))<br>    indices.sort(key=lambda x: (x[1], x[0]))<br><br>    for k, trim in queries:<br>        trimmed_indices = [(i, int(n[-trim:])) for i, n in enumerate(nums)]<br>        trimmed_indices.sort(key=lambda x: (x[1], x[0]))<br>        answer.append(trimmed_indices[k-1][0])<br><br>    return answer

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_16184.txt
> def join(self, right, on=None, how='inner'):<br>        """<br>        Merge two SFrames. Merges the current (left) SFrame with the given<br>        (right) SFrame using a SQL-style equi-join operation by columns.<br><br>        Parameters<br>        ----------<br>        right : SFrame<br>            The SFrame to join.<br><br>        on : None | str | list | dict, optional<br>            The column name(s) representing the set of join keys.  Each row that<br>            has the same value in this set of columns will be merged together.<br><br>             If 'None' is given, join will use all columns that have the same<br>              name as the set of join keys.<br><br>             If a str is given, this is interpreted as a join using one column,<br>              where both SFrames have the same column name.<br><br>             If a list is given, this is interpreted as a join using one or<br>              more column names, where each column name given exists in both<br>              SFrames.<br><br>             If a dict is given, each dict key is taken as a column name in the<br>              left SFrame, and each dict value is taken as the column name in<br>              right SFrame that will be joined together. e.g.<br>              {'left_col_name':'right_col_name'}.<br><br>        how : {'left', 'right', 'outer', 'inner'}, optional<br>            The type of join to perform.  'inner' is default.<br><br>             inner: Equivalent to a SQL inner join.  Result consists of the<br>              rows from the two frames whose join key values match exactly,<br>              merged together into one SFrame.<br><br>             left: Equivalent to a SQL left outer join. Result is the union<br>              between the result of an inner join and the rest of the rows from<br>              the left SFrame, merged with missing values.<br><br>             right: Equivalent to a SQL right outer join.  Result is the union<br>              between the result of an inner join and the rest of the rows from<br>              the right SFrame, merged with missing values.<br><br>             outer: Equivalent to a SQL full outer join. Result is<br>              the union between the result of a left outer join and a right<br>              outer join.<br><br>        Returns<br>        -------<br>        out : SFrame<br><br>        Examples<br>        --------<br>         animals = turicreate.SFrame({'id': [1, 2, 3, 4],<br>        ...                           'name': ['dog', 'cat', 'sheep', 'cow']})<br>         sounds = turicreate.SFrame({'id': [1, 3, 4, 5],<br>        ...                          'sound': ['woof', 'baa', 'moo', 'oink']})<br>         animals.join(sounds, how='inner')<br>        +----+-------+-------+<br>        | id |  name | sound |<br>        +----+-------+-------+<br>        | 1  |  dog  |  woof |<br>        | 3  | sheep |  baa  |<br>        | 4  |  cow  |  moo  |<br>        +----+-------+-------+<br>        [3 rows x 3 columns]<br><br>         animals.join(sounds, on='id', how='left')<br>        +----+-------+-------+<br>        | id |  name | sound |<br>        +----+-------+-------+<br>        | 1  |  dog  |  woof |<br>        | 3  | sheep |  baa  |<br>        | 4  |  cow  |  moo  |<br>        | 2  |  cat  |  None |<br>        +----+-------+-------+<br>        [4 rows x 3 columns]<br><br>         animals.join(sounds, on=['id'], how='right')<br>        +----+-------+-------+<br>        | id |  name | sound |<br>        +----+-------+-------+<br>        | 1  |  dog  |  woof |<br>        | 3  | sheep |  baa  |<br>        | 4  |  cow  |  moo  |<br>        | 5  |  None |  oink |<br>        +----+-------+-------+<br>        [4 rows x 3 columns]<br><br>         animals.join(sounds, on={'id':'id'}, how='outer')<br>        +----+-------+-------+<br>        | id |  name | sound |<br>        +----+-------+-------+<br>        | 1  |  dog  |  woof |<br>        | 3  | sheep |  baa  |<br>        | 4  |  cow  |  moo  |<br>        | 5  |  None |  oink |<br>        | 2  |  cat  |  None |<br>        +----+-------+-------+<br>        [5 rows x 3 columns]<br>        """<br>        available_join_types = ['left','right','outer','inner']<br><br>        if not isinstance(right, SFrame):<br>            raise TypeError("Can only join two SFrames")<br><br>        if how not in available_join_types:<br>            raise ValueError("Invalid join type")<br><br>        if (self.num_columns() <= 0) or (right.num_columns() <= 0):<br>            raise ValueError("Cannot join an SFrame with no columns.")<br><br>        join_keys = dict()<br>        if on is None:<br>            left_names = self.column_names()<br>            right_names = right.column_names()<br>            common_columns = [name for name in left_names if name in right_names]<br>            for name in common_columns:<br>                join_keys[name] = name<br>        elif type(on) is str:<br>            join_keys[on] = on<br>        elif type(on) is list:<br>            for name in on:<br>                if type(name) is not str:<br>                    raise TypeError("Join keys must each be a str.")<br>                join_keys[name] = name<br>        elif type(on) is dict:<br>            join_keys = on<br>        else:<br>            raise TypeError("Must pass a str, list, or dict of join keys")<br><br>        with cython_context():<br>            return SFrame(_proxy=self.__proxy__.join(right.__proxy__, how, join_keys))

### DOC[4] (IRRELEVANT) leetcode/leetcode_2354.txt
> from collections import Counter<br>    """You are given a 0-indexed positive integer array `nums` and a positive integer `k`.<br><br>A pair of numbers `(num1, num2)` is called excellent if the following conditions are satisfied:<br><br>   Both the numbers `num1` and `num2` exist in the array `nums`.<br>   The sum of the number of set bits in `num1 OR num2` and `num1 AND num2` is greater than or equal to `k`, where `OR` is the bitwise OR operation and `AND` is the bitwise AND operation.<br><br>Return _the number of distinct excellent pairs_.<br><br>Two pairs `(a, b)` and `(c, d)` are considered distinct if either `a != c` or `b != d`. For example, `(1, 2)` and `(2, 1)` are distinct.<br><br>Note that a pair `(num1, num2)` such that `num1 == num2` can also be excellent if you have at least one occurrence of `num1` in the array.<br><br>Example 1:<br><br>Input: nums = \[1,2,3,1\], k = 3<br>Output: 5<br>Explanation: The excellent pairs are the following:<br>- (3, 3). (3 AND 3) and (3 OR 3) are both equal to (11) in binary. The total number of set bits is 2 + 2 = 4, which is greater than or equal to k = 3.<br>- (2, 3) and (3, 2). (2 AND 3) is equal to (10) in binary, and (2 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.<br>- (1, 3) and (3, 1). (1 AND 3) is equal to (01) in binary, and (1 OR 3) is equal to (11) in binary. The total number of set bits is 1 + 2 = 3.<br>So the number of excellent pairs is 5.<br><br>Example 2:<br><br>Input: nums = \[5,1,1\], k = 10<br>Output: 0<br>Explanation: There are no excellent pairs for this array.<br><br>Constraints:<br><br>   `1 <= nums.length <= 105`<br>   `1 <= nums[i] <= 109`<br>   `1 <= k <= 60`"""<br><br><br>def countExcellentPairs(nums, k):<br>    frequency = Counter(nums)<br>    count = 0<br>    for num1, freq1 in frequency.items():<br>        for num2, freq2 in frequency.items():<br>            setBits = bin(num1 | num2).count('1') + bin(num1 & num2).count('1')<br>            if setBits = k:<br>                count += freq1  freq2 if num1 != num2 else freq1  (freq1 - 1) // 2<br>    return count

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_2055.txt
> def drop_duplicates(self, keep='first', inplace=False):<br>        """<br>        Return Series with duplicate values removed.<br><br>        Parameters<br>        ----------<br>        keep : {'first', 'last', ``False``}, default 'first'<br>            - 'first' : Drop duplicates except for the first occurrence.<br>            - 'last' : Drop duplicates except for the last occurrence.<br>            - ``False`` : Drop all duplicates.<br>        inplace : bool, default ``False``<br>            If ``True``, performs operation inplace and returns None.<br><br>        Returns<br>        -------<br>        Series<br>            Series with duplicates dropped.<br><br>        See Also<br>        --------<br>        Index.drop_duplicates : Equivalent method on Index.<br>        DataFrame.drop_duplicates : Equivalent method on DataFrame.<br>        Series.duplicated : Related method on Series, indicating duplicate<br>            Series values.<br><br>        Examples<br>        --------<br>        Generate an Series with duplicated entries.<br><br>         s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],<br>        ...               name='animal')<br>         s<br>        0      lama<br>        1       cow<br>        2      lama<br>        3    beetle<br>        4      lama<br>        5     hippo<br>        Name: animal, dtype: object<br><br>        With the 'keep' parameter, the selection behaviour of duplicated values<br>        can be changed. The value 'first' keeps the first occurrence for each<br>        set of duplicated entries. The default value of keep is 'first'.<br><br>         s.drop_duplicates()<br>        0      lama<br>        1       cow<br>        3    beetle<br>        5     hippo<br>        Name: animal, dtype: object<br><br>        The value 'last' for parameter 'keep' keeps the last occurrence for<br>        each set of duplicated entries.<br><br>         s.drop_duplicates(keep='last')<br>        1       cow<br>        3    beetle<br>        4      lama<br>        5     hippo<br>        Name: animal, dtype: object<br><br>        The value ``False`` for parameter 'keep' discards all sets of<br>        duplicated entries. Setting the value of 'inplace' to ``True`` performs<br>        the operation inplace and returns ``None``.<br><br>         s.drop_duplicates(keep=False, inplace=True)<br>         s<br>        1       cow<br>        3    beetle<br>        5     hippo<br>        Name: animal, dtype: object<br>        """<br>        return super().drop_duplicates(keep=keep, inplace=inplace)


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2531.txt
> def compare(w1,w2):<br>    """You are given two 0-indexed strings `word1` and `word2`.<br><br>A move consists of choosing two indices `i` and `j` such that `0 <= i < word1.length` and `0 <= j < word2.length` and swapping `word1[i]` with `word2[j]`.<br><br>Return `true` _if it is possible to get the number of distinct characters in_ `word1` _and_ `word2` _to be equal with exactly one move._ Return `false` _otherwise_.<br><br>Example 1:<br><br>Input: word1 =  "ac ", word2 =  "b "<br>Output: false<br>Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.<br><br>Example 2:<br><br>Input: word1 =  "abcc ", word2 =  "aab "<br>Output: true<br>Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 =  "abac " and word2 =  "cab ", which both have 3 distinct characters.<br><br>Example 3:<br><br>Input: word1 =  "abcde ", word2 =  "fghij "<br>Output: true<br>Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.<br><br>Constraints:<br><br>   `1 <= word1.length, word2.length <= 105`<br>   `word1` and `word2` consist of only lowercase English letters."""<br><br>    counts_w1 = [0]26<br>    counts_w2 = [0]26<br>    for c in w1: counts_w1[ord(c)-ord('a')] += 1<br>    for c in w2: counts_w2[ord(c)-ord('a')] += 1<br>    for i in range(26):<br>        if counts_w1[i] and counts_w2[i]: return True<br>    return False<br><br>def swap_equal_distinct(word1, word2):<br>    exch = compare(word1, word2)<br>    return exch and len(word1) == len(word2)
