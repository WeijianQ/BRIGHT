# Query `76`

## Original Question

*A certain bug's home is on the x-axis at position `x`. Help them get there from position `0`.

The bug jumps according to the following rules:

   It can jump exactly `a` positions forward (to the right).
   It can jump exactly `b` positions backward (to the left).
   It cannot jump backward twice in a row.
   It cannot jump to any `forbidden` positions.

The bug may jump forward beyond its home, but it cannot jump to positions numbered with negative integers.

Given an array of integers `forbidden`, where `forbidden[i]` means that the bug cannot jump to the position `forbidden[i]`, and integers `a`, `b`, and `x`, return _the minimum number of jumps needed for the bug to reach its home_. If there is no possible sequence of jumps that lands the bug on position `x`, return `-1.`

Example 1:

Input: forbidden = \[14,4,18,1,15\], a = 3, b = 15, x = 9
Output: 3
Explanation: 3 jumps forward (0 -> 3 -> 6 -> 9) will get the bug home.

Example 2:

Input: forbidden = \[8,3,16,6,12,20\], a = 15, b = 13, x = 11
Output: -1

Example 3:

Input: forbidden = \[1,6,2,14,5,17,4\], a = 16, b = 9, x = 7
Output: 2
Explanation: One jump forward (0 -> 16) then one jump backward (16 -> 7) will get the bug home.

Constraints:

   `1 <= forbidden.length <= 1000`
   `1 <= a, b, forbidden[i] <= 2000`
   `0 <= x <= 2000`
   All the elements in `forbidden` are distinct.
   Position `x` is not forbidden.*

## gpt4 Reasoning

```markdown
The essential problem here is to find the minimum number of jumps a bug needs to take to reach its home at position `x` from position `0`, given that it can jump forward by `a` positions and backward by `b` positions, with the constraints that it cannot jump backward twice in a row and cannot land on forbidden positions. Additionally, it cannot jump to positions with negative integers.

To address this problem, let's consider the following steps and relevant information:

### Step 1: Understand the Constraints
- **Forward and Backward Jumps**: The bug can jump forward by `a` positions and backward by `b` positions. This allows for a mix of strategies in moving towards the target.
- **Forbidden Positions**: The bug cannot land on any position listed in the `forbidden` array. This constraint might limit the direct path to the target and necessitate detours.
- **Backward Jump Restrictions**: The bug cannot jump backward twice in a row, adding a strategic layer to planning jumps since a backward jump must be followed by a forward jump or reaching the destination.
- **Negative Positions**: Jumps cannot result in positions less than 0, limiting backward jumps early in the journey.

### Step 2: Define the Search Space
Given the constraints and the nature of the problem, the search space (all possible positions the bug might have to consider) can potentially become large. However, the search space can be limited by considering:
- The maximum distance the bug might need to travel, which could be somewhat beyond `x` to allow for a final backward jump to reach `x`.
- Forbidden positions reduce the search space since these are positions the bug will avoid.

### Step 3: Implement a Strategy
A potential strategy involves using Breadth-First Search (BFS) to explore all possible moves from the starting position, given the constraints. The BFS approach is suitable because it explores all possible moves level by level, ensuring that when it first reaches the target position, it does so with the minimum number of moves.

#### Key Points for the Strategy:
- **Queue for BFS**: Use a queue to keep track of positions to explore, along with the number of jumps taken to reach them and whether the last jump was backward.
- **Visited Positions**: Keep track of visited positions to avoid revisiting them and potentially getting into a loop, especially considering the restriction on consecutive backward jumps. This should also take into account whether the last jump to reach a position was backward.
- **Handling Forbidden Positions**: Skip adding positions to the queue if they are forbidden.
- **Boundary Conditions**: Ensure that the positions added to the queue are within valid bounds (e.g., not negative, not beyond a certain threshold past `x`).

### Step 4: Execution
1. Initialize the BFS with the starting position (0, not from a backward jump).
2. At each step, consider both forward and backward jumps from the current position if they are allowed (not forbidden, not leading to a negative position, and respecting the backward jump rule).
3. Update the visited status of each new position, taking into account whether it was reached by a backward jump.
4. Continue the BFS until the target position `x` is reached or the queue is empty (implying there's no path to `x`).

### Step 5: Return the Result
- If the BFS reaches position `x`, return the minimum number of jumps required.
- If position `x` is never reached, return `-1` to indicate it's not possible to get the bug home under the given constraints.

This approach systematically explores all viable paths to reach the destination, adhering to the constraints, and ensures that the first time the destination is reached, it is done with the minimum number of jumps.
```

### Metrics

```
recip_rank: 0.0038
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_457.txt
> def circularArrayLoop(nums: List[int]) - bool:<br>    """You are playing a game involving a circular array of non-zero integers `nums`. Each `nums[i]` denotes the number of indices forward/backward you must move if you are located at index `i`:<br><br>   If `nums[i]` is positive, move `nums[i]` steps forward, and<br>   If `nums[i]` is negative, move `nums[i]` steps backward.<br><br>Since the array is circular, you may assume that moving forward from the last element puts you on the first element, and moving backwards from the first element puts you on the last element.<br><br>A cycle in the array consists of a sequence of indices `seq` of length `k` where:<br><br>   Following the movement rules above results in the repeating index sequence `seq[0] - seq[1] - ... - seq[k - 1] - seq[0] - ...`<br>   Every `nums[seq[j]]` is either all positive or all negative.<br>   `k  1`<br><br>Return `true` _if there is a cycle in_ `nums`_, or_ `false` _otherwise_.<br><br>Example 1:<br><br>Input: nums = \[2,-1,1,2,2\]<br>Output: true<br>Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.<br>We can see the cycle 0 -- 2 -- 3 -- 0 -- ..., and all of its nodes are white (jumping in the same direction).<br><br>Example 2:<br><br>Input: nums = \[-1,-2,-3,-4,-5,6\]<br>Output: false<br>Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.<br>The only cycle is of size 1, so we return false.<br><br>Example 3:<br><br>Input: nums = \[1,-1,5,1,4\]<br>Output: true<br>Explanation: The graph shows how the indices are connected. White nodes are jumping forward, while red is jumping backward.<br>We can see the cycle 0 -- 1 -- 0 -- ..., and while it is of size  1, it has a node jumping forward and a node jumping backward, so it is not a cycle.<br>We can see the cycle 3 -- 4 -- 3 -- ..., and all of its nodes are white (jumping in the same direction).<br><br>Constraints:<br><br>   `1 <= nums.length <= 5000`<br>   `-1000 <= nums[i] <= 1000`<br>   `nums[i] != 0`<br><br>Follow up: Could you solve it in `O(n)` time complexity and `O(1)` extra space complexity?"""<br><br>    N = len(nums)<br>    for i in range(N):<br>        slow, fast = i, i<br>        while True:<br>            slow = getNextIndex(slow, nums)<br>            fast = getNextIndex(getNextIndex(fast, nums), nums)<br>            if slow != fast and nums[slow]  nums[fast]  0:<br>                break<br>            if slow == fast:<br>                break<br>        else:<br>            continue<br>        cycle = False<br>        start = slow<br>        while start != slow:<br>            cycle |= getNextIndex(start, nums) == start<br>            start = getNextIndex(start, nums)<br>        if not cycle:<br>            return True<br>    return False<br><br>def getNextIndex(idx: int, nums: List[int]) - int:<br>    N = len(nums)<br>    return (idx + nums[idx]) % N

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_65611.txt
> def _compute_stacksize(self):<br>        '''<br>        Given this object's code list, compute its maximal stack usage.<br>        This is done by scanning the code, and computing for each opcode<br>        the stack state at the opcode.<br><br>        '''<br><br>        # get local access to code, save some attribute lookups later<br>        code = self.code<br><br>        # A mapping from labels to their positions in the code list<br>        label_pos = { op : pos<br>                        for pos, (op, arg) in enumerate(code)<br>                        if isinstance(op, Label)<br>                    }<br><br>        # sf_targets are the targets of SETUP_FINALLY opcodes. They are<br>        # recorded because they have special stack behaviour. If an exception<br>        # was raised in the block pushed by a SETUP_FINALLY opcode, the block<br>        # is popped and 3 objects are pushed. On return or continue, the<br>        # block is popped and 2 objects are pushed. If nothing happened, the<br>        # block is popped by a POP_BLOCK opcode and 1 object is pushed by a<br>        # (LOAD_CONST, None) operation.<br>        #<br>        # In Python 3, the targets of SETUP_WITH have similar behavior,<br>        # complicated by the fact that they also have an __exit__ method<br>        # stacked and what it returns determines what they pop. So their<br>        # stack depth is one greater, a fact we are going to ignore for the<br>        # time being :-/<br>        #<br>        # Our solution is to record the stack state of SETUP_FINALLY targets<br>        # as having 3 objects pushed, which is the maximum. However, to make<br>        # stack recording consistent, the get_next_stacks function will always<br>        # yield the stack state of the target as if 1 object was pushed, but<br>        # this will be corrected in the actual stack recording.<br><br>        sf_targets = set( label_pos[arg]<br>                          for op, arg in code<br>                          if op == SETUP_FINALLY or op == SETUP_WITH<br>                        )<br><br>        # What we compute - for each opcode, its stack state, as an n-tuple.<br>        # n is the number of blocks pushed. For each block, we record the number<br>        # of objects pushed.<br>        stacks = [None]  len(code)<br><br>        def get_next_stacks(pos, curstack):<br>            """<br>            Get a code position and the stack state before the operation<br>            was done, and yield pairs (pos, curstack) for the next positions<br>            to be explored - those are the positions to which you can get<br>            from the given (pos, curstack).<br><br>            If the given position was already explored, nothing will be yielded.<br>            """<br>            op, arg = code[pos]<br><br>            if isinstance(op, Label):<br>                # We should check if we already reached a node only if it is<br>                # a label.<br><br>                if pos in sf_targets:<br>                    # Adjust a SETUP_FINALLY from 1 to 3 stack entries.<br>                    curstack = curstack[:-1] + (curstack[-1] + 2,)<br><br>                if stacks[pos] is None:<br>                    stacks[pos] = curstack<br>                else:<br>                    if stacks[pos] != curstack:<br>                        raise ValueError("Inconsistent code")<br>                    return<br><br>            def newstack(n):<br>                # Return a new stack, modified by adding n elements to the last<br>                # block<br>                if curstack[-1] + n < 0:<br>                    raise ValueError("Popped a non-existing element")<br>                return curstack[:-1] + (curstack[-1]+n,)<br><br>            if not isopcode(op):<br>                # label or SetLineno - just continue to next line<br>                yield pos+1, curstack<br><br>            elif op in ( RETURN_VALUE, RAISE_VARARGS ):<br>                # No place in particular to continue to<br>                pass<br><br>            elif op in (JUMP_FORWARD, JUMP_ABSOLUTE):<br>                # One possibility for a jump<br>                yield label_pos[arg], curstack<br><br>            elif op in (POP_JUMP_IF_FALSE, POP_JUMP_IF_TRUE):<br>                # Two possibilities for a jump<br>                yield label_pos[arg], newstack(-1)<br>                yield pos+1, newstack(-1)<br><br>            elif op in (JUMP_IF_TRUE_OR_POP, JUMP_IF_FALSE_OR_POP):<br>                # Two possibilities for a jump<br>                yield label_pos[arg], curstack<br>                yield pos+1, newstack(-1)<br><br>            elif op == FOR_ITER:<br>                # FOR_ITER pushes next(TOS) on success, and pops TOS and jumps<br>                # on failure<br>                yield label_pos[arg], newstack(-1)<br>                yield pos+1, newstack(1)<br><br>            elif op == BREAK_LOOP:<br>                # BREAK_LOOP goes to the end of a loop and pops a block<br>                # but like RETURN_VALUE we have no instruction position<br>                # to give. For now treat like RETURN_VALUE<br>                pass<br><br>            elif op == CONTINUE_LOOP:<br>                # CONTINUE_LOOP jumps to the beginning of a loop which should<br>                # already have been discovered. It does not change the stack<br>                # state nor does it create or pop a block.<br>                #yield label_pos[arg], curstack<br>                #yield label_pos[arg], curstack[:-1]<br>                pass<br><br>            elif op == SETUP_LOOP:<br>                # We continue with a new block.<br>                # On break, we jump to the label and return to current stack<br>                # state.<br>                yield label_pos[arg], curstack<br>                yield pos+1, curstack + (0,)<br><br>            elif op == SETUP_EXCEPT:<br>                # We continue with a new block.<br>                # On exception, we jump to the label with 3 extra objects on<br>                # stack<br>                yield label_pos[arg], newstack(3)<br>                yield pos+1, curstack + (0,)<br><br>            elif op == SETUP_FINALLY or op == SETUP_WITH :<br>                # We continue with a new block.<br>                # On exception, we jump to the label with 3 extra objects on<br>                # stack, but to keep stack recording consistent, we behave as<br>                # if we add only 1 object. Extra 2 will be added to the actual<br>                # recording.<br>                yield label_pos[arg], newstack(1)<br>                yield pos+1, curstack + ( int(op == SETUP_WITH) ,)<br><br>            elif op == POP_BLOCK:<br>                # Just pop the block<br>                yield pos+1, curstack[:-1]<br><br>            elif op == END_FINALLY :<br>                # Since stack recording of SETUP_FINALLY targets is of 3 pushed<br>                # objects (as when an exception is raised), we pop 3 objects.<br>                yield pos+1, newstack(-3)<br><br>            elif op == _WITH_CLEANUP_OPCODE:<br>                # Since WITH_CLEANUP[_START] is always found after SETUP_FINALLY<br>                # targets, and the stack recording is that of a raised<br>                # exception, we can simply pop 1 object and let END_FINALLY<br>                # pop the remaining 3.<br>                yield pos+1, newstack(-1)<br><br>            else:<br>                # nothing special, use the CPython value<br>                yield pos+1, newstack( stack_effect( op, arg ) )<br><br><br>        # Now comes the calculation: open_positions holds positions which are<br>        # yet to be explored. In each step we take one open position, and<br>        # explore it by appending the positions to which it can go, to<br>        # open_positions. On the way, we update maxsize.<br>        #<br>        # open_positions is a list of tuples: (pos, stack state)<br>        #<br>        # Sneaky Python coding trick here. get_next_stacks() is a generator,<br>        # it contains yield statements. So when we call get_next_stacks()<br>        # what is returned is an iterator. However, the yield statements in<br>        # get_next_stacks() are not in a loop as usual; rather it is<br>        # straight-line code that will execute 0, 1 or 2 yields depending on<br>        # the Opcode at pos.<br>        #<br>        # the list.extend() method takes an iterator and exhausts it, adding<br>        # all yielded values to the list. Hence the statement<br>        #<br>        #   open_positions.extend(get_next_stacks(pos,curstack))<br>        #<br>        # appends 0, 1 or 2 tuples (pos, stack_state) to open_positions.<br><br>        maxsize = 0<br>        open_positions = [(0, (0,))]<br>        while open_positions:<br>            pos, curstack = open_positions.pop()<br>            maxsize = max(maxsize, sum(curstack))<br>            open_positions.extend(get_next_stacks(pos, curstack))<br><br>        return maxsize

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_154085.txt
> def _conc_alloc_size(self, sim_size):<br>        """<br>        Concretizes a size argument, if necessary, to something that makes sense when allocating space. Here we just<br>        maximize its potential size up to the maximum variable size specified in the libc plugin.<br><br>        TODO:<br>        Further consideration of the tradeoffs of this approach is probably warranted. SimHeapPTMalloc especially makes<br>        a lot of different concretization strategy assumptions, but this function handles one of the more important<br>        problems that any heap implementation will face: how to decide the amount of space to allocate upon request for<br>        a symbolic size. Either we do as we do here and silently constrain the amount returned to a default max value,<br>        or we could add a path constraint to the state to prevent exploration of any paths that would have legitimately<br>        occurred given a larger allocation size.<br><br>        The first approach (the silent maximum) has its benefit in that the explored state space will not be<br>        constrained. Sometimes this could work out, as when an allocation is returned that is smaller than requested but<br>        which the program doesn't end up making full use of anyways. Alternatively, this lack of fidelity could cause<br>        the program to overwrite other allocations made, since it should be able to assume the allocation is as large as<br>        it requested it be.<br><br>        The second approach (the path constraint) has its benefit in that no paths will be explored that could fail<br>        when an allocation is made too small. On the other hand, as stated above, some of these paths might not have<br>        failed anyways, and doing this causes us to lose the opportunity to explore those paths.<br><br>        Perhaps these behaviors could be parameterized in the future?<br>        """<br>        if self.state.solver.symbolic(sim_size):<br>            size = self.state.solver.max_int(sim_size)<br>            if size  self.state.libc.max_variable_size:<br>                l.warning("Allocation request of %d bytes exceeded maximum of %d bytes; allocating %d bytes",<br>                          size, self.state.libc.max_variable_size, size)<br>                size = self.state.libc.max_variable_size<br>        else:<br>            size = self.state.solver.eval(sim_size)<br>        return size

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_144452.txt
> def a_star(sink, heuristic_source, sources, machine, wrap_around):<br>    """Use A to find a path from any of the sources to the sink.<br><br>    Note that the heuristic means that the search will proceed towards<br>    heuristic_source without any concern for any other sources. This means that<br>    the algorithm may miss a very close neighbour in order to pursue its goal<br>    of reaching heuristic_source. This is not considered a problem since 1) the<br>    heuristic source will typically be in the direction of the rest of the tree<br>    and near by and often the closest entity 2) it prevents us accidentally<br>    forming loops in the rest of the tree since we'll stop as soon as we touch<br>    any part of it.<br><br>    Parameters<br>    ----------<br>    sink : (x, y)<br>    heuristic_source : (x, y)<br>        An element from `sources` which is used as a guiding heuristic for the<br>        A algorithm.<br>    sources : set([(x, y), ...])<br>    machine : :py:class:`~rig.place_and_route.Machine`<br>    wrap_around : bool<br>        Consider wrap-around links in heuristic distance calculations.<br><br>    Returns<br>    -------<br>    [(:py:class:`~rig.routing_table.Routes`, (x, y)), ...]<br>        A path starting with a coordinate in `sources` and terminating at<br>        connected neighbour of `sink` (i.e. the path does not include `sink`).<br>        The direction given is the link down which to proceed from the given<br>        (x, y) to arrive at the next point in the path.<br><br>    Raises<br>    ------<br>    :py:class:~rig.place_and_route.exceptions.MachineHasDisconnectedSubregion`<br>        If a path cannot be found.<br>    """<br>    # Select the heuristic function to use for distances<br>    if wrap_around:<br>        heuristic = (lambda node:<br>                     shortest_torus_path_length(to_xyz(node),<br>                                                to_xyz(heuristic_source),<br>                                                machine.width, machine.height))<br>    else:<br>        heuristic = (lambda node:<br>                     shortest_mesh_path_length(to_xyz(node),<br>                                               to_xyz(heuristic_source)))<br><br>    # A dictionary {node: (direction, previous_node}. An entry indicates that<br>    # 1) the node has been visited and 2) which node we hopped from (and the<br>    # direction used) to reach previous_node.  This may be None if the node is<br>    # the sink.<br>    visited = {sink: None}<br><br>    # The node which the tree will be reconnected to<br>    selected_source = None<br><br>    # A heap (accessed via heapq) of (distance, (x, y)) where distance is the<br>    # distance between (x, y) and heuristic_source and (x, y) is a node to<br>    # explore.<br>    to_visit = [(heuristic(sink), sink)]<br>    while to_visit:<br>        _, node = heapq.heappop(to_visit)<br><br>        # Terminate if we've found the destination<br>        if node in sources:<br>            selected_source = node<br>            break<br><br>        # Try all neighbouring locations. Note: link identifiers are from the<br>        # perspective of the neighbour, not the current node!<br>        for neighbour_link in Links:<br>            vector = neighbour_link.opposite.to_vector()<br>            neighbour = ((node[0] + vector[0]) % machine.width,<br>                         (node[1] + vector[1]) % machine.height)<br><br>            # Skip links which are broken<br>            if (neighbour[0], neighbour[1], neighbour_link) not in machine:<br>                continue<br><br>            # Skip neighbours who have already been visited<br>            if neighbour in visited:<br>                continue<br><br>            # Explore all other neighbours<br>            visited[neighbour] = (neighbour_link, node)<br>            heapq.heappush(to_visit, (heuristic(neighbour), neighbour))<br><br>    # Fail of no paths exist<br>    if selected_source is None:<br>        raise MachineHasDisconnectedSubregion(<br>            "Could not find path from {} to {}".format(<br>                sink, heuristic_source))<br><br>    # Reconstruct the discovered path, starting from the source we found and<br>    # working back until the sink.<br>    path = [(Routes(visited[selected_source][0]), selected_source)]<br>    while visited[path[-1][1]][1] != sink:<br>        node = visited[path[-1][1]][1]<br>        direction = Routes(visited[node][0])<br>        path.append((direction, node))<br><br>    return path

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_261935.txt
> def _compute_stacksize(self):<br>        """Get a code list, compute its maximal stack usage."""<br>        # This is done by scanning the code, and computing for each opcode<br>        # the stack state at the opcode.<br>        code = self.code<br><br>        # A mapping from labels to their positions in the code list<br>        label_pos = dict((op, pos)<br>                         for pos, (op, arg) in enumerate(code)<br>                         if isinstance(op, Label))<br><br>        # sf_targets are the targets of SETUP_FINALLY opcodes. They are recorded<br>        # because they have special stack behaviour. If an exception was raised<br>        # in the block pushed by a SETUP_FINALLY opcode, the block is popped<br>        # and 3 objects are pushed. On return or continue, the block is popped<br>        # and 2 objects are pushed. If nothing happened, the block is popped by<br>        # a POP_BLOCK opcode and 1 object is pushed by a (LOAD_CONST, None)<br>        # operation.<br>        #<br>        # Our solution is to record the stack state of SETUP_FINALLY targets<br>        # as having 3 objects pushed, which is the maximum. However, to make<br>        # stack recording consistent, the get_next_stacks function will always<br>        # yield the stack state of the target as if 1 object was pushed, but<br>        # this will be corrected in the actual stack recording.<br><br>        sf_targets = set(label_pos[arg]<br>                         for op, arg in code<br>                         if op == SETUP_FINALLY)<br><br>        # What we compute - for each opcode, its stack state, as an n-tuple.<br>        # n is the number of blocks pushed. For each block, we record the number<br>        # of objects pushed.<br>        stacks = [None]  len(code)<br><br>        def get_next_stacks(pos, curstack):<br>            """Get a code position and the stack state before the operation<br>            was done, and yield pairs (pos, curstack) for the next positions<br>            to be explored - those are the positions to which you can get<br>            from the given (pos, curstack).<br><br>            If the given position was already explored, nothing will be yielded.<br>            """<br>            op, arg = code[pos]<br><br>            if isinstance(op, Label):<br>                # We should check if we already reached a node only if it is<br>                # a label.<br>                if pos in sf_targets:<br>                    curstack = curstack[:-1] + (curstack[-1] + 2,)<br>                if stacks[pos] is None:<br>                    stacks[pos] = curstack<br>                else:<br>                    if stacks[pos] != curstack:<br>                        raise ValueError("Inconsistent code")<br>                    return<br><br>            def newstack(n):<br>                # Return a new stack, modified by adding n elements to the last<br>                # block<br>                if curstack[-1] + n < 0:<br>                    raise ValueError("Popped a non-existing element")<br>                return curstack[:-1] + (curstack[-1]+n,)<br><br>            if not isopcode(op):<br>                # label or SetLineno - just continue to next line<br>                yield pos+1, curstack<br><br>            elif op in (STOP_CODE, RETURN_VALUE, RAISE_VARARGS):<br>                # No place in particular to continue to<br>                pass<br><br>            elif op == MAKE_CLOSURE and python_version == '2.4':<br>                # This is only relevant in Python 2.4 - in Python 2.5 the stack<br>                # effect of MAKE_CLOSURE can be calculated from the arg.<br>                # In Python 2.4, it depends on the number of freevars of TOS,<br>                # which should be a code object.<br>                if pos == 0:<br>                    raise ValueError("MAKE_CLOSURE can't be the first opcode")<br>                lastop, lastarg = code[pos-1]<br>                if lastop != LOAD_CONST:<br>                    raise ValueError(<br>                        "MAKE_CLOSURE should come after a LOAD_CONST op")<br>                try:<br>                    nextrapops = len(lastarg.freevars)<br>                except AttributeError:<br>                    try:<br>                        nextrapops = len(lastarg.co_freevars)<br>                    except AttributeError:<br>                        raise ValueError(<br>                            "MAKE_CLOSURE preceding const should "<br>                            "be a code or a Code object")<br><br>                yield pos+1, newstack(-arg-nextrapops)<br><br>            elif op not in hasflow:<br>                # Simple change of stack<br>                pop, push = getse(op, arg)<br>                yield pos+1, newstack(push - pop)<br><br>            elif op in (JUMP_FORWARD, JUMP_ABSOLUTE):<br>                # One possibility for a jump<br>                yield label_pos[arg], curstack<br><br>            elif python_version < '2.7' and op in (JUMP_IF_FALSE, JUMP_IF_TRUE):<br>                # Two possibilities for a jump<br>                yield label_pos[arg], curstack<br>                yield pos+1, curstack<br><br>            elif python_version = '2.7' and op in (POP_JUMP_IF_FALSE, POP_JUMP_IF_TRUE):<br>                # Two possibilities for a jump<br>                yield label_pos[arg], newstack(-1)<br>                yield pos+1, newstack(-1)<br><br>            elif python_version = '2.7' and op in (JUMP_IF_TRUE_OR_POP, JUMP_IF_FALSE_OR_POP):<br>                # Two possibilities for a jump<br>                yield label_pos[arg], curstack<br>                yield pos+1, newstack(-1)<br><br>            elif op == FOR_ITER:<br>                # FOR_ITER pushes next(TOS) on success, and pops TOS and jumps<br>                # on failure<br>                yield label_pos[arg], newstack(-1)<br>                yield pos+1, newstack(1)<br><br>            elif op == BREAK_LOOP:<br>                # BREAK_LOOP jumps to a place specified on block creation, so<br>                # it is ignored here<br>                pass<br><br>            elif op == CONTINUE_LOOP:<br>                # CONTINUE_LOOP jumps to the beginning of a loop which should<br>                # already ave been discovered, but we verify anyway.<br>                # It pops a block.<br>                if python_version == '2.6':<br>                  pos, stack = label_pos[arg], curstack[:-1]<br>                  if stacks[pos] != stack: #this could be a loop with a 'with' inside<br>                    yield pos, stack[:-1] + (stack[-1]-1,)<br>                  else:<br>                    yield pos, stack<br>                else:<br>                  yield label_pos[arg], curstack[:-1]<br><br>            elif op == SETUP_LOOP:<br>                # We continue with a new block.<br>                # On break, we jump to the label and return to current stack<br>                # state.<br>                yield label_pos[arg], curstack<br>                yield pos+1, curstack + (0,)<br><br>            elif op == SETUP_EXCEPT:<br>                # We continue with a new block.<br>                # On exception, we jump to the label with 3 extra objects on<br>                # stack<br>                yield label_pos[arg], newstack(3)<br>                yield pos+1, curstack + (0,)<br><br>            elif op == SETUP_FINALLY:<br>                # We continue with a new block.<br>                # On exception, we jump to the label with 3 extra objects on<br>                # stack, but to keep stack recording consistent, we behave as<br>                # if we add only 1 object. Extra 2 will be added to the actual<br>                # recording.<br>                yield label_pos[arg], newstack(1)<br>                yield pos+1, curstack + (0,)<br><br>            elif python_version == '2.7' and op == SETUP_WITH:<br>                yield label_pos[arg], curstack<br>                yield pos+1, newstack(-1) + (1,)<br><br>            elif op == POP_BLOCK:<br>                # Just pop the block<br>                yield pos+1, curstack[:-1]<br><br>            elif op == END_FINALLY:<br>                # Since stack recording of SETUP_FINALLY targets is of 3 pushed<br>                # objects (as when an exception is raised), we pop 3 objects.<br>                yield pos+1, newstack(-3)<br><br>            elif op == WITH_CLEANUP:<br>                # Since WITH_CLEANUP is always found after SETUP_FINALLY<br>                # targets, and the stack recording is that of a raised<br>                # exception, we can simply pop 1 object and let END_FINALLY<br>                # pop the remaining 3.<br>                if python_version == '2.7':<br>                  yield pos+1, newstack(2)<br>                else:<br>                  yield pos+1, newstack(-1)<br><br>            else:<br>                assert False, "Unhandled opcode: %r" % op<br><br><br>        # Now comes the calculation: open_positions holds positions which are<br>        # yet to be explored. In each step we take one open position, and<br>        # explore it by adding the positions to which you can get from it, to<br>        # open_positions. On the way, we update maxsize.<br>        # open_positions is a list of tuples: (pos, stack state)<br>        maxsize = 0<br>        open_positions = [(0, (0,))]<br>        while open_positions:<br>            pos, curstack = open_positions.pop()<br>            maxsize = max(maxsize, sum(curstack))<br>            open_positions.extend(get_next_stacks(pos, curstack))<br><br>        return maxsize


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2368.txt
> from collections import defaultdict<br>    """There is an undirected tree with `n` nodes labeled from `0` to `n - 1` and `n - 1` edges.<br><br>You are given a 2D integer array `edges` of length `n - 1` where `edges[i] = [ai, bi]` indicates that there is an edge between nodes `ai` and `bi` in the tree. You are also given an integer array `restricted` which represents restricted nodes.<br><br>Return _the maximum number of nodes you can reach from node_ `0` _without visiting a restricted node._<br><br>Note that node `0` will not be a restricted node.<br><br>Example 1:<br><br>Input: n = 7, edges = \[\[0,1\],\[1,2\],\[3,1\],\[4,0\],\[0,5\],\[5,6\]\], restricted = \[4,5\]<br>Output: 4<br>Explanation: The diagram above shows the tree.<br>We have that \[0,1,2,3\] are the only nodes that can be reached from node 0 without visiting a restricted node.<br><br>Example 2:<br><br>Input: n = 7, edges = \[\[0,1\],\[0,2\],\[0,5\],\[0,4\],\[3,2\],\[6,5\]\], restricted = \[4,2,1\]<br>Output: 3<br>Explanation: The diagram above shows the tree.<br>We have that \[0,5,6\] are the only nodes that can be reached from node 0 without visiting a restricted node.<br><br>Constraints:<br><br>   `2 <= n <= 105`<br>   `edges.length == n - 1`<br>   `edges[i].length == 2`<br>   `0 <= ai, bi < n`<br>   `ai != bi`<br>   `edges` represents a valid tree.<br>   `1 <= restricted.length < n`<br>   `1 <= restricted[i] < n`<br>   All the values of `restricted` are unique."""<br><br><br>def max_nodes_without_restricted(n, edges, restricted):<br>    tree = defaultdict(list)<br>    blocked_nodes = set(restricted)<br><br>    for a, b in edges:<br>        tree[a].append(b)<br>        tree[b].append(a)<br><br>    max_nodes = [0]<br><br>    def dfs(node, depth, parent):<br>        if node in blocked_nodes:<br>            return<br>        max_nodes[0] = max(max_nodes[0], depth)<br>        for child in tree[node]:<br>            if child != parent:<br>                dfs(child, depth + 1, node)<br><br>    dfs(0, 1, -1)<br>    return max_nodes[0]
