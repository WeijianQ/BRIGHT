# Query `19`

## Original Question

*A binary watch has 4 LEDs on the top to represent the hours (0-11), and 6 LEDs on the bottom to represent the minutes (0-59). Each LED represents a zero or one, with the least significant bit on the right.

   For example, the below binary watch reads `"4:51 "`.

Given an integer `turnedOn` which represents the number of LEDs that are currently on (ignoring the PM), return _all possible times the watch could represent_. You may return the answer in any order.

The hour must not contain a leading zero.

   For example, `"01:00 "` is not valid. It should be `"1:00 "`.

The minute must be consist of two digits and may contain a leading zero.

   For example, `"10:2 "` is not valid. It should be `"10:02 "`.

Example 1:

Input: turnedOn = 1
Output: \["0:01","0:02","0:04","0:08","0:16","0:32","1:00","2:00","4:00","8:00"\]

Example 2:

Input: turnedOn = 9
Output: \[\]

Constraints:

   `0 <= turnedOn <= 10`*

## gpt4 Reasoning

```markdown
The essential problem here is to find all the valid times that can be represented on a binary watch given a specific number of LEDs that are turned on. This problem involves understanding how binary numbers map to hours and minutes, as well as adhering to the constraints on the format of the output times.

### Step-by-Step Solution:

1. **Understand Binary Representation for Hours and Minutes:**
   - The top row of 4 LEDs represents the hours (0 to 11). This means the maximum binary value that can be represented is `1011` (binary) which equals 11 in decimal.
   - The bottom row of 6 LEDs represents the minutes (0 to 59). The maximum value here can be `111011` (binary), which equals 59 in decimal.
   - Each LED represents a power of 2, with the rightmost LED being the least significant bit (LSB).

2. **Enumerate All Possible Times:**
   - Since there are 10 LEDs in total, and the maximum number of LEDs that can be on is 10, we need to generate all combinations of LEDs being on for the given `turnedOn` value.
   - This involves a bit of combinatorics, specifically generating combinations of a certain length from a set of 10 elements (LEDs).

3. **Filter Valid Times:**
   - Not all combinations of `turnedOn` LEDs will correspond to valid times. For instance, if all 4 hour LEDs are on, this would represent a value of 15, which is not a valid hour.
   - Similarly, for minutes, if the combination represents a number greater than 59, it is invalid.
   - Therefore, each combination needs to be checked to ensure it represents a valid time.

4. **Format the Output:**
   - The hours do not need a leading zero, but the minutes must always be two digits. This formatting needs to be applied to all valid times before they are added to the output list.

5. **Return All Valid Times:**
   - After generating all combinations, filtering out the invalid ones, and formatting the valid times correctly, we return the list of times. If no valid times can be generated, return an empty list.

### Relevant Information:

- **Binary to Decimal Conversion:** Understanding how to convert binary numbers to decimal is crucial. Each bit represents a power of 2, starting with 2^0 from the right.
- **Combination Generation:** Methods to generate combinations of a certain size from a set of elements are essential. This could involve recursive algorithms or iterative solutions.
- **Time Validation:** Ensuring the generated binary numbers fall within the valid ranges for hours (0-11) and minutes (0-59).
- **Formatting Times:** Implementing logic to format times correctly according to the problem's specifications.

### Example for `turnedOn = 1`:

- Generate all combinations of 1 LED being on out of the 10 possible LEDs.
- This directly gives us: `1:00`, `2:00`, `4:00`, `8:00` for hours and `0:01`, `0:02`, `0:04`, `0:08`, `0:16`, `0:32` for minutes.
- These are all valid and properly formatted, so they are returned as the output.

### Edge Case for `turnedOn = 9`:

- It's impossible to have a valid time with 9 LEDs turned on because the maximum valid combination for minutes (59) requires 5 LEDs and for hours (11) requires 3 LEDs, totaling 8 LEDs. Hence, 9 LEDs being on cannot represent a valid time on the watch, leading to an empty output.

This problem blends binary number understanding, combinatorial generation, and careful filtering/formatting to produce a list of valid times represented by a certain number of illuminated LEDs on a binary watch.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2437.txt
> def count_valid_times(time: str) - int:<br>    """You are given a string of length `5` called `time`, representing the current time on a digital clock in the format `"hh:mm "`. The earliest possible time is `"00:00 "` and the latest possible time is `"23:59 "`.<br><br>In the string `time`, the digits represented by the `?` symbol are unknown, and must be replaced with a digit from `0` to `9`.<br><br>Return _an integer_ `answer`_, the number of valid clock times that can be created by replacing every_ `?` _with a digit from_ `0` _to_ `9`.<br><br>Example 1:<br><br>Input: time =  "?5:00 "<br>Output: 2<br>Explanation: We can replace the ? with either a 0 or 1, producing  "05:00 " or  "15:00 ". Note that we cannot replace it with a 2, since the time  "25:00 " is invalid. In total, we have two choices.<br><br>Example 2:<br><br>Input: time =  "0?:0? "<br>Output: 100<br>Explanation: Each ? can be replaced by any digit from 0 to 9, so we have 100 total choices.<br><br>Example 3:<br><br>Input: time =  "??:?? "<br>Output: 1440<br>Explanation: There are 24 possible choices for the hours, and 60 possible choices for the minutes. In total, we have 24 \ 60 = 1440 choices.<br><br>Constraints:<br><br>   `time` is a valid string of length `5` in the format `"hh:mm "`.<br>   `"00 " <= hh <= "23 "`<br>   `"00 " <= mm <= "59 "`<br>   Some of the digits might be replaced with `'?'` and need to be replaced with digits from `0` to `9`."""<br><br>    count = 1<br>    if time[0] == '?':<br>        count = 3 if time[1] == '?' or time[1] < '4' else 2<br>    if time[1] == '?':<br>        count = 4 if time[0] == '2' else 10<br>    if time[3] == '?':<br>        count = 6<br>    if time[4] == '?':<br>        count = 10<br>    return count

### DOC[2] (IRRELEVANT) leetcode/leetcode_2224.txt
> def minimum_operations(current: str, correct: str) - int:<br>    """You are given two strings `current` and `correct` representing two 24-hour times.<br><br>24-hour times are formatted as `"HH:MM "`, where `HH` is between `00` and `23`, and `MM` is between `00` and `59`. The earliest 24-hour time is `00:00`, and the latest is `23:59`.<br><br>In one operation you can increase the time `current` by `1`, `5`, `15`, or `60` minutes. You can perform this operation any number of times.<br><br>Return _the minimum number of operations needed to convert_ `current` _to_ `correct`.<br><br>Example 1:<br><br>Input: current =  "02:30 ", correct =  "04:35 "<br>Output: 3<br>Explanation:<br>We can convert current to correct in 3 operations as follows:<br>- Add 60 minutes to current. current becomes  "03:30 ".<br>- Add 60 minutes to current. current becomes  "04:30 ".<br>- Add 5 minutes to current. current becomes  "04:35 ".<br>It can be proven that it is not possible to convert current to correct in fewer than 3 operations.<br><br>Example 2:<br><br>Input: current =  "11:00 ", correct =  "11:01 "<br>Output: 1<br>Explanation: We only have to add one minute to current, so the minimum number of operations needed is 1.<br><br>Constraints:<br><br>   `current` and `correct` are in the format `"HH:MM "`<br>   `current <= correct`"""<br><br>    ch, cm = map(int, current.split(':'))<br>    th, tm = map(int, correct.split(':'))<br>    ct = ch  60 + cm<br>    tt = th  60 + tm<br><br>    operations = 0<br>    while ct < tt:<br>        if tt - ct = 60:<br>            ct += 60<br>        elif tt - ct = 15:<br>            ct += 15<br>        elif tt - ct = 5:<br>            ct += 5<br>        else:<br>            ct += 1<br><br>        operations += 1<br><br>    return operations

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_139778.txt
> def timedelta_to_str(value: datetime.timedelta, fmt: str = None) - str:<br>    """Display the timedelta formatted according to the given string.<br><br>    You should use global setting ``TIMEDELTA_FORMAT`` to specify default<br>    format to this function there (like ``DATE_FORMAT`` for builtin ``date``<br>    template filter).<br><br>    Default value for ``TIMEDELTA_FORMAT`` is ``'G:i'``.<br><br>    Format uses the same policy as Django ``date`` template filter or<br>    PHP ``date`` function with several differences.<br><br>    Available format strings:<br><br>    +------------------+-----------------------------+------------------------+<br>    | Format character | Description                 | Example output         |<br>    +==================+=============================+========================+<br>    | ``a``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``A``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``b``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``B``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``c``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``d``            | Total days, 2 digits with   | ``'01'``, ``'41'``     |<br>    |                  | leading zeros. Do not       |                        |<br>    |                  | combine with ``w`` format.  |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``D``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``f``            | Magic "full" format with    | ``'2w 4d 1:28:07'``    |<br>    |                  | short labels.               |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``F``            | Magic "full" format with    | ``'2 weeks, 4 days,    |<br>    |                  | normal labels.              | 1:28:07'``             |<br>    +------------------+-----------------------------+------------------------+<br>    | ``g``            | Day, not total, hours       | ``'0'`` to ``'23'``    |<br>    |                  | without leading zeros. To   |                        |<br>    |                  | use with ``d``, ``j``, or   |                        |<br>    |                  | ``w``.                      |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``G``            | Total hours without         | ``'1'``, ``'433'``     |<br>    |                  | leading zeros. Do not       |                        |<br>    |                  | combine with ``g`` or       |                        |<br>    |                  | ``h`` formats.              |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``h``            | Day, not total, hours with  | ``'00'`` to ``'23'``   |<br>    |                  | leading zeros. To use with  |                        |<br>    |                  | ``d`` or ``w``.             |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``H``            | Total hours with leading    | ``'01', ``'433'``      |<br>    |                  | zeros. Do not combine with  |                        |<br>    |                  | ``g`` or ``h`` formats.     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``i``            | Hour, not total, minutes, 2 | ``00`` to ``'59'``     |<br>    |                  | digits with leading zeros   |                        |<br>    |                  | To use with ``g``, ``G``,   |                        |<br>    |                  | ``h`` or ``H`` formats.     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``I``            | Total minutes, 2 digits or  | ``'01'``, ``'433'``    |<br>    |                  | more with leading zeros. Do |                        |<br>    |                  | not combine with ``i``      |                        |<br>    |                  | format.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``j``            | Total days, one or 2 digits | ``'1'``, ``'41'``      |<br>    |                  | without leading zeros. Do   |                        |<br>    |                  | not combine with ``w``      |                        |<br>    |                  | format.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``J``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``l``            | Days long label.            | ``'day'`` or           |<br>    |                  | Pluralized and localized.   | ``'days'``             |<br>    +------------------+-----------------------------+------------------------+<br>    | ``L``            | Weeks long label.           | ``'week'`` or          |<br>    |                  | Pluralized and localized.   | ``'weeks'``            |<br>    +------------------+-----------------------------+------------------------+<br>    | ``m``            | Week days long label.       | ``'day'`` or           |<br>    |                  | Pluralized and localized.   | ``'days'``             |<br>    +------------------+-----------------------------+------------------------+<br>    | ``M``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``n``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``N``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``O``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``P``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``r``            | Standart Python timedelta   | ``'18 d 1:28:07'``     |<br>    |                  | representation with short   |                        |<br>    |                  | labels.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``R``            | Standart Python timedelta   | ``'18 days, 1:28:07'`` |<br>    |                  | representation with normal  |                        |<br>    |                  | labels.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``s``            | Minute, not total, seconds, | ``'00'`` to ``'59'``   |<br>    |                  | 2 digits with leading       |                        |<br>    |                  | zeros. To use with ``i`` or |                        |<br>    |                  | ``I``.                      |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``S``            | Total seconds. 2 digits or  | ``'00'``, ``'433'``    |<br>    |                  | more with leading zeros. Do |                        |<br>    |                  | not combine with ``s``      |                        |<br>    |                  | format.                     |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``t``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``T``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``u``            | Second, not total,          | ``0`` to ``999999``    |<br>    |                  | microseconds.               |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``U``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``w``            | Week, not total, days, one  | ``0`` to ``6``         |<br>    |                  | digit without leading       |                        |<br>    |                  | zeros. To use with ``W``.   |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``W``            | Total weeks, one or more    | ``'1'``, ``'41'``      |<br>    |                  | digits without leading      |                        |<br>    |                  | zeros.                      |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``y``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``Y``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``z``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br>    | ``Z``            | Not implemented.            |                        |<br>    +------------------+-----------------------------+------------------------+<br><br>    For example,<br><br>    ::<br><br>         import datetime<br>         from rororo.timedelta import timedelta_to_str<br>         delta = datetime.timedelta(seconds=99660)<br>         timedelta_to_str(delta)<br>        ... '27:41'<br>         timedelta_to_str(delta, 'r')<br>        ... '1d 3:41:00'<br>         timedelta_to_str(delta, 'f')<br>        ... '1d 3:41'<br>         timedelta_to_str(delta, 'W L, w l, H:i:s')<br>        ... '0 weeks, 1 day, 03:41:00'<br><br>    Couple words about magic "full" formats. These formats show weeks number<br>    with week label, days number with day label and seconds only if weeks<br>    number, days number or seconds greater that zero.<br><br>    For example,<br><br>    ::<br><br>         import datetime<br>         from rororo.timedelta import timedelta_to_str<br>         delta = datetime.timedelta(hours=12)<br>         timedelta_to_str(delta, 'f')<br>        ... '12:00'<br>         timedelta_to_str(delta, 'F')<br>        ... '12:00'<br>         delta = datetime.timedelta(hours=12, seconds=30)<br>         timedelta_to_str(delta, 'f')<br>        ... '12:00:30'<br>         timedelta_to_str(delta, 'F')<br>        ... '12:00:30'<br>         delta = datetime.timedelta(hours=168)<br>         timedelta_to_str(delta, 'f')<br>        ... '1w 0:00'<br>         timedelta_to_str(delta, 'F')<br>        ... '1 week, 0:00'<br><br>    :param value: Timedelta instance to convert to string.<br>    :param fmt: Format to use for conversion.<br>    """<br>    # Only ``datetime.timedelta`` instances allowed for this function<br>    if not isinstance(value, datetime.timedelta):<br>        raise ValueError(<br>            'Value should be a "datetime.timedelta" instance. You use {0}.'<br>            .format(type(value)))<br><br>    # Generate total data<br>    days = value.days<br>    microseconds = value.microseconds<br>    seconds = timedelta_seconds(value)<br><br>    hours = seconds // 3600<br>    minutes = seconds // 60<br>    weeks = days // 7<br><br>    # Generate collapsed data<br>    day_hours = hours - days  24<br>    hour_minutes = minutes - hours  60<br>    minute_seconds = seconds - minutes  60<br>    week_days = days - weeks  7<br><br>    days_label = 'day' if days % 10 == 1 else 'days'<br>    short_days_label = 'd'<br>    short_week_days_label = 'd'<br>    short_weeks_label = 'w'<br>    week_days_label = 'day' if week_days % 10 == 1 else 'days'<br>    weeks_label = 'week' if weeks % 10 == 1 else 'weeks'<br><br>    # Collect data<br>    data = locals()<br><br>    fmt = fmt or TIMEDELTA_FORMAT<br>    processed = ''<br><br>    for part in fmt:<br>        if part in TIMEDELTA_FORMATS:<br>            is_full_part = part in ('f', 'F')<br>            is_repr_part = part in ('r', 'R')<br><br>            part = TIMEDELTA_FORMATS[part][0]<br><br>            if is_full_part or is_repr_part:<br>                if is_repr_part and not days:<br>                    part = part.replace('%(days)d', '')<br>                    part = part.replace('%(days_label)s,', '')<br>                    part = part.replace('%(short_days_label)s', '')<br><br>                if is_full_part and not minute_seconds:<br>                    part = part.replace(':%(minute_seconds)02d', '')<br><br>                if is_full_part and not weeks:<br>                    part = part.replace('%(weeks)d', '')<br>                    part = part.replace('%(short_weeks_label)s', '')<br>                    part = part.replace('%(weeks_label)s,', '')<br><br>                if is_full_part and not week_days:<br>                    part = part.replace('%(week_days)d', '')<br>                    part = part.replace('%(short_week_days_label)s', '')<br>                    part = part.replace('%(week_days_label)s,', '')<br><br>                part = part.strip()<br>                part = ' '.join(part.split())<br><br>        processed += part<br><br>    return processed % data

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_1975.txt
> def resample(self, rule, how=None, axis=0, fill_method=None, closed=None,<br>                 label=None, convention='start', kind=None, loffset=None,<br>                 limit=None, base=0, on=None, level=None):<br>        """<br>        Resample time-series data.<br><br>        Convenience method for frequency conversion and resampling of time<br>        series. Object must have a datetime-like index (`DatetimeIndex`,<br>        `PeriodIndex`, or `TimedeltaIndex`), or pass datetime-like values<br>        to the `on` or `level` keyword.<br><br>        Parameters<br>        ----------<br>        rule : str<br>            The offset string or object representing target conversion.<br>        how : str<br>            Method for down/re-sampling, default to 'mean' for downsampling.<br><br>            .. deprecated:: 0.18.0<br>               The new syntax is ``.resample(...).mean()``, or<br>               ``.resample(...).apply(<func)``<br>        axis : {0 or 'index', 1 or 'columns'}, default 0<br>            Which axis to use for up- or down-sampling. For `Series` this<br>            will default to 0, i.e. along the rows. Must be<br>            `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`.<br>        fill_method : str, default None<br>            Filling method for upsampling.<br><br>            .. deprecated:: 0.18.0<br>               The new syntax is ``.resample(...).<func()``,<br>               e.g. ``.resample(...).pad()``<br>        closed : {'right', 'left'}, default None<br>            Which side of bin interval is closed. The default is 'left'<br>            for all frequency offsets except for 'M', 'A', 'Q', 'BM',<br>            'BA', 'BQ', and 'W' which all have a default of 'right'.<br>        label : {'right', 'left'}, default None<br>            Which bin edge label to label bucket with. The default is 'left'<br>            for all frequency offsets except for 'M', 'A', 'Q', 'BM',<br>            'BA', 'BQ', and 'W' which all have a default of 'right'.<br>        convention : {'start', 'end', 's', 'e'}, default 'start'<br>            For `PeriodIndex` only, controls whether to use the start or<br>            end of `rule`.<br>        kind : {'timestamp', 'period'}, optional, default None<br>            Pass 'timestamp' to convert the resulting index to a<br>            `DateTimeIndex` or 'period' to convert it to a `PeriodIndex`.<br>            By default the input representation is retained.<br>        loffset : timedelta, default None<br>            Adjust the resampled time labels.<br>        limit : int, default None<br>            Maximum size gap when reindexing with `fill_method`.<br><br>            .. deprecated:: 0.18.0<br>        base : int, default 0<br>            For frequencies that evenly subdivide 1 day, the "origin" of the<br>            aggregated intervals. For example, for '5min' frequency, base could<br>            range from 0 through 4. Defaults to 0.<br>        on : str, optional<br>            For a DataFrame, column to use instead of index for resampling.<br>            Column must be datetime-like.<br><br>            .. versionadded:: 0.19.0<br><br>        level : str or int, optional<br>            For a MultiIndex, level (name or number) to use for<br>            resampling. `level` must be datetime-like.<br><br>            .. versionadded:: 0.19.0<br><br>        Returns<br>        -------<br>        Resampler object<br><br>        See Also<br>        --------<br>        groupby : Group by mapping, function, label, or list of labels.<br>        Series.resample : Resample a Series.<br>        DataFrame.resample: Resample a DataFrame.<br><br>        Notes<br>        -----<br>        See the `user guide<br>        <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#resampling`_<br>        for more.<br><br>        To learn more about the offset strings, please see `this link<br>        <http://pandas.pydata.org/pandas-docs/stable/timeseries.html#offset-aliases`__.<br><br>        Examples<br>        --------<br><br>        Start by creating a series with 9 one minute timestamps.<br><br>         index = pd.date_range('1/1/2000', periods=9, freq='T')<br>         series = pd.Series(range(9), index=index)<br>         series<br>        2000-01-01 00:00:00    0<br>        2000-01-01 00:01:00    1<br>        2000-01-01 00:02:00    2<br>        2000-01-01 00:03:00    3<br>        2000-01-01 00:04:00    4<br>        2000-01-01 00:05:00    5<br>        2000-01-01 00:06:00    6<br>        2000-01-01 00:07:00    7<br>        2000-01-01 00:08:00    8<br>        Freq: T, dtype: int64<br><br>        Downsample the series into 3 minute bins and sum the values<br>        of the timestamps falling into a bin.<br><br>         series.resample('3T').sum()<br>        2000-01-01 00:00:00     3<br>        2000-01-01 00:03:00    12<br>        2000-01-01 00:06:00    21<br>        Freq: 3T, dtype: int64<br><br>        Downsample the series into 3 minute bins as above, but label each<br>        bin using the right edge instead of the left. Please note that the<br>        value in the bucket used as the label is not included in the bucket,<br>        which it labels. For example, in the original series the<br>        bucket ``2000-01-01 00:03:00`` contains the value 3, but the summed<br>        value in the resampled bucket with the label ``2000-01-01 00:03:00``<br>        does not include 3 (if it did, the summed value would be 6, not 3).<br>        To include this value close the right side of the bin interval as<br>        illustrated in the example below this one.<br><br>         series.resample('3T', label='right').sum()<br>        2000-01-01 00:03:00     3<br>        2000-01-01 00:06:00    12<br>        2000-01-01 00:09:00    21<br>        Freq: 3T, dtype: int64<br><br>        Downsample the series into 3 minute bins as above, but close the right<br>        side of the bin interval.<br><br>         series.resample('3T', label='right', closed='right').sum()<br>        2000-01-01 00:00:00     0<br>        2000-01-01 00:03:00     6<br>        2000-01-01 00:06:00    15<br>        2000-01-01 00:09:00    15<br>        Freq: 3T, dtype: int64<br><br>        Upsample the series into 30 second bins.<br><br>         series.resample('30S').asfreq()[0:5]   # Select first 5 rows<br>        2000-01-01 00:00:00   0.0<br>        2000-01-01 00:00:30   NaN<br>        2000-01-01 00:01:00   1.0<br>        2000-01-01 00:01:30   NaN<br>        2000-01-01 00:02:00   2.0<br>        Freq: 30S, dtype: float64<br><br>        Upsample the series into 30 second bins and fill the ``NaN``<br>        values using the ``pad`` method.<br><br>         series.resample('30S').pad()[0:5]<br>        2000-01-01 00:00:00    0<br>        2000-01-01 00:00:30    0<br>        2000-01-01 00:01:00    1<br>        2000-01-01 00:01:30    1<br>        2000-01-01 00:02:00    2<br>        Freq: 30S, dtype: int64<br><br>        Upsample the series into 30 second bins and fill the<br>        ``NaN`` values using the ``bfill`` method.<br><br>         series.resample('30S').bfill()[0:5]<br>        2000-01-01 00:00:00    0<br>        2000-01-01 00:00:30    1<br>        2000-01-01 00:01:00    1<br>        2000-01-01 00:01:30    2<br>        2000-01-01 00:02:00    2<br>        Freq: 30S, dtype: int64<br><br>        Pass a custom function via ``apply``<br><br>         def custom_resampler(array_like):<br>        ...     return np.sum(array_like) + 5<br>        ...<br>         series.resample('3T').apply(custom_resampler)<br>        2000-01-01 00:00:00     8<br>        2000-01-01 00:03:00    17<br>        2000-01-01 00:06:00    26<br>        Freq: 3T, dtype: int64<br><br>        For a Series with a PeriodIndex, the keyword `convention` can be<br>        used to control whether to use the start or end of `rule`.<br><br>        Resample a year by quarter using 'start' `convention`. Values are<br>        assigned to the first quarter of the period.<br><br>         s = pd.Series([1, 2], index=pd.period_range('2012-01-01',<br>        ...                                             freq='A',<br>        ...                                             periods=2))<br>         s<br>        2012    1<br>        2013    2<br>        Freq: A-DEC, dtype: int64<br>         s.resample('Q', convention='start').asfreq()<br>        2012Q1    1.0<br>        2012Q2    NaN<br>        2012Q3    NaN<br>        2012Q4    NaN<br>        2013Q1    2.0<br>        2013Q2    NaN<br>        2013Q3    NaN<br>        2013Q4    NaN<br>        Freq: Q-DEC, dtype: float64<br><br>        Resample quarters by month using 'end' `convention`. Values are<br>        assigned to the last month of the period.<br><br>         q = pd.Series([1, 2, 3, 4], index=pd.period_range('2018-01-01',<br>        ...                                                   freq='Q',<br>        ...                                                   periods=4))<br>         q<br>        2018Q1    1<br>        2018Q2    2<br>        2018Q3    3<br>        2018Q4    4<br>        Freq: Q-DEC, dtype: int64<br>         q.resample('M', convention='end').asfreq()<br>        2018-03    1.0<br>        2018-04    NaN<br>        2018-05    NaN<br>        2018-06    2.0<br>        2018-07    NaN<br>        2018-08    NaN<br>        2018-09    3.0<br>        2018-10    NaN<br>        2018-11    NaN<br>        2018-12    4.0<br>        Freq: M, dtype: float64<br><br>        For DataFrame objects, the keyword `on` can be used to specify the<br>        column instead of the index for resampling.<br><br>         d = dict({'price': [10, 11, 9, 13, 14, 18, 17, 19],<br>        ...           'volume': [50, 60, 40, 100, 50, 100, 40, 50]})<br>         df = pd.DataFrame(d)<br>         df['week_starting'] = pd.date_range('01/01/2018',<br>        ...                                     periods=8,<br>        ...                                     freq='W')<br>         df<br>           price  volume week_starting<br>        0     10      50    2018-01-07<br>        1     11      60    2018-01-14<br>        2      9      40    2018-01-21<br>        3     13     100    2018-01-28<br>        4     14      50    2018-02-04<br>        5     18     100    2018-02-11<br>        6     17      40    2018-02-18<br>        7     19      50    2018-02-25<br>         df.resample('M', on='week_starting').mean()<br>                       price  volume<br>        week_starting<br>        2018-01-31     10.75    62.5<br>        2018-02-28     17.00    60.0<br><br>        For a DataFrame with MultiIndex, the keyword `level` can be used to<br>        specify on which level the resampling needs to take place.<br><br>         days = pd.date_range('1/1/2000', periods=4, freq='D')<br>         d2 = dict({'price': [10, 11, 9, 13, 14, 18, 17, 19],<br>        ...            'volume': [50, 60, 40, 100, 50, 100, 40, 50]})<br>         df2 = pd.DataFrame(d2,<br>        ...                    index=pd.MultiIndex.from_product([days,<br>        ...                                                     ['morning',<br>        ...                                                      'afternoon']]<br>        ...                                                     ))<br>         df2<br>                              price  volume<br>        2000-01-01 morning       10      50<br>                   afternoon     11      60<br>        2000-01-02 morning        9      40<br>                   afternoon     13     100<br>        2000-01-03 morning       14      50<br>                   afternoon     18     100<br>        2000-01-04 morning       17      40<br>                   afternoon     19      50<br>         df2.resample('D', level=0).sum()<br>                    price  volume<br>        2000-01-01     21     110<br>        2000-01-02     22     140<br>        2000-01-03     32     150<br>        2000-01-04     36      90<br>        """<br><br>        from pandas.core.resample import (resample,<br>                                          _maybe_process_deprecations)<br>        axis = self._get_axis_number(axis)<br>        r = resample(self, freq=rule, label=label, closed=closed,<br>                     axis=axis, kind=kind, loffset=loffset,<br>                     convention=convention,<br>                     base=base, key=on, level=level)<br>        return _maybe_process_deprecations(r,<br>                                           how=how,<br>                                           fill_method=fill_method,<br>                                           limit=limit)

### DOC[5] (IRRELEVANT) leetcode/leetcode_1702.txt
> def maximum_binary_string(binary: str) - str:<br>    """You are given a binary string `binary` consisting of only `0`'s or `1`'s. You can apply each of the following operations any number of times:<br><br>   Operation 1: If the number contains the substring `"00 "`, you can replace it with `"10 "`.<br>       For example, `"00010 " - "10010` "<br>   Operation 2: If the number contains the substring `"10 "`, you can replace it with `"01 "`.<br>       For example, `"00010 " - "00001 "`<br><br>_Return the maximum binary string you can obtain after any number of operations. Binary string `x` is greater than binary string `y` if `x`'s decimal representation is greater than `y`'s decimal representation._<br><br>Example 1:<br><br>Input: binary =  "000110 "<br>Output:  "111011 "<br>Explanation: A valid transformation sequence can be:<br> "000110 " -  "000101 " <br> "000101 " -  "100101 " <br> "100101 " -  "110101 " <br> "110101 " -  "110011 " <br> "110011 " -  "111011 "<br><br>Example 2:<br><br>Input: binary =  "01 "<br>Output:  "01 "<br>Explanation:  "01 " cannot be transformed any further.<br><br>Constraints:<br><br>   `1 <= binary.length <= 105`<br>   `binary` consist of `'0'` and `'1'`."""<br><br>    zero_count = binary.count('0')<br>    <br>    if zero_count <= 1:<br>        return binary<br>    <br>    one_count = len(binary) - zero_count<br><br>    result = "1"  one_count + "0"  (zero_count - 1) + "1####1"<br>    return result[:len(binary)]


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_17.txt
> def letter_combinations(digits: str):<br>    """Given a string containing digits from `2-9` inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.<br><br>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.<br><br>Example 1:<br><br>Input: digits =  "23 "<br>Output: \[ "ad ", "ae ", "af ", "bd ", "be ", "bf ", "cd ", "ce ", "cf "\]<br><br>Example 2:<br><br>Input: digits =  " "<br>Output: \[\]<br><br>Example 3:<br><br>Input: digits =  "2 "<br>Output: \[ "a ", "b ", "c "\]<br><br>Constraints:<br><br>   `0 <= digits.length <= 4`<br>   `digits[i]` is a digit in the range `['2', '9']`."""<br><br>    if not digits: return []<br>    phone = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]<br>    result = [""]<br><br>    for digit in digits:<br>        temp = []<br>        for s in result:<br>            for c in phone[int(digit) - 2]:<br>                temp.append(s + c)<br>        result = temp<br><br>    return result
