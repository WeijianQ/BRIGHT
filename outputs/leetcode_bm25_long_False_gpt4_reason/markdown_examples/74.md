# Query `74`

## Original Question

*You have an `inventory` of different colored balls, and there is a customer that wants `orders` balls of any color.

The customer weirdly values the colored balls. Each colored ball's value is the number of balls of that color you currently have in your `inventory`. For example, if you own `6` yellow balls, the customer would pay `6` for the first yellow ball. After the transaction, there are only `5` yellow balls left, so the next yellow ball is then valued at `5` (i.e., the value of the balls decreases as you sell more to the customer).

You are given an integer array, `inventory`, where `inventory[i]` represents the number of balls of the `ith` color that you initially own. You are also given an integer `orders`, which represents the total number of balls that the customer wants. You can sell the balls in any order.

Return _the maximum total value that you can attain after selling_ `orders` _colored balls_. As the answer may be too large, return it modulo `109 + 7`.

Example 1:

Input: inventory = \[2,5\], orders = 4
Output: 14
Explanation: Sell the 1st color 1 time (2) and the 2nd color 3 times (5 + 4 + 3).
The maximum total value is 2 + 5 + 4 + 3 = 14.

Example 2:

Input: inventory = \[3,5\], orders = 6
Output: 19
Explanation: Sell the 1st color 2 times (3 + 2) and the 2nd color 4 times (5 + 4 + 3 + 2).
The maximum total value is 3 + 2 + 5 + 4 + 3 + 2 = 19.

Constraints:

   `1 <= inventory.length <= 105`
   `1 <= inventory[i] <= 109`
   `1 <= orders <= min(sum(inventory[i]), 109)`*

## gpt4 Reasoning

```markdown
The essential problem here is to maximize the total value received from selling a certain number of colored balls, given that the value of balls of a particular color decreases as you sell more of them. The challenge lies in determining the order in which to sell the balls to maximize the total value, considering the dynamic pricing based on the remaining inventory of each color.

### Step-by-Step Solution:

1. **Sort the Inventory**: First, sort the inventory array in descending order. This allows us to start selling the balls from the colors with the highest inventory, ensuring we get the maximum value possible initially.

2. **Sell the Balls in Batches**: The key insight is to sell the balls in batches where each batch consists of balls of the same value. This means if we have colors with the same number of balls, we should sell one ball from each of those colors before moving on. This approach ensures we always sell the balls at the highest possible value.

3. **Calculate the Total Value**: To calculate the total value efficiently without simulating each sale:
    - Identify groups of balls with the same count and calculate the total value of selling down to the next unique count in the sorted inventory. This can be done using the formula for the sum of an arithmetic series, as the value of each ball decreases linearly as we sell them.
    - Continue this process until all orders are fulfilled. If the last batch to fulfill the order doesn't sell down to the next unique count completely, calculate the partial sum for this last batch accordingly.

4. **Handling the Last Partial Batch**: If you're left with a situation where you can't sell down to the next unique count because orders would be exceeded, you need to calculate the value of the partial batch. This involves finding the sum of the last few numbers in an arithmetic series, which can be done with a modified version of the sum formula.

5. **Return the Result Modulo \(10^9 + 7\)**: Given the potential for very large numbers, it's important to regularly apply the modulo operation (\(10^9 + 7\)) during the calculation to keep the numbers within manageable bounds.

### Relevant Formulas:

- **Sum of Arithmetic Series**: The sum of an arithmetic series can be calculated as \(S = \frac{n}{2} [2a + (n-1)d]\), where \(n\) is the number of terms, \(a\) is the first term, and \(d\) is the common difference. In this context, \(d = -1\) (since the value decreases by 1 with each sale), and \(a\) is the starting value (number of balls of the current color).

### Implementation Sketch:

1. Sort `inventory` in descending order.
2. Initialize a variable to keep track of the total value, say `totalValue = 0`.
3. Iterate over the sorted inventory, for each unique count:
    - Determine how many balls can be sold at the current value (taking into account multiple colors with the same count).
    - If selling all these balls doesn't exceed `orders`, calculate the total value for this batch and subtract the number of sold balls from `orders`.
    - If it does exceed `orders`, calculate the value for as many balls as can be sold to fulfill the `orders`.
    - Use modulo \(10^9 + 7\) at each step to keep the total value within bounds.
4. Return `totalValue` modulo \(10^9 + 7\).

This approach ensures that we are always selling the balls in a way that maximizes the total value, by always prioritizing the sale of balls from the colors with the highest inventory first and adjusting the strategy dynamically as the inventory changes.
```

### Metrics

```
recip_rank: 0.0000
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1801.txt
> from heapq import <br>    """You are given a 2D integer array `orders`, where each `orders[i] = [pricei, amounti, orderTypei]` denotes that `amounti` orders have been placed of type `orderTypei` at the price `pricei`. The `orderTypei` is:<br><br>   `0` if it is a batch of `buy` orders, or<br>   `1` if it is a batch of `sell` orders.<br><br>Note that `orders[i]` represents a batch of `amounti` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`.<br><br>There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:<br><br>   If the order is a `buy` order, you look at the `sell` order with the smallest price in the backlog. If that `sell` order's price is smaller than or equal to the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.<br>   Vice versa, if the order is a `sell` order, you look at the `buy` order with the largest price in the backlog. If that `buy` order's price is larger than or equal to the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.<br><br>Return _the total amount of orders in the backlog after placing all the orders from the input_. Since this number can be large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: orders = \[\[10,5,0\],\[15,2,1\],\[25,1,1\],\[30,4,0\]\]<br>Output: 6<br>Explanation: Here is what happens with the orders:<br>- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.<br>- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.<br>- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.<br>- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.<br>Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.<br><br>Example 2:<br><br>Input: orders = \[\[7,1000000000,1\],\[15,3,0\],\[5,999999995,0\],\[5,1,1\]\]<br>Output: 999999984<br>Explanation: Here is what happens with the orders:<br>- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.<br>- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.<br>- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.<br>- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.<br>Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).<br><br>Constraints:<br><br>   `1 <= orders.length <= 105`<br>   `orders[i].length == 3`<br>   `1 <= pricei, amounti <= 109`<br>   `orderTypei` is either `0` or `1`."""<br><br><br>def getNumberOfBacklogOrders(orders):<br>    buy_orders, sell_orders = [], []<br>    num_orders, mod = 0, int(1e9) + 7<br><br>    for price, amount, order_type in orders:<br>        if order_type == 0: # buy order<br>            while amount and sell_orders and sell_orders[0][0] <= price:<br>                x = min(amount, sell_orders[0][1])<br>                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x<br>                if sell_orders[0][1] == 0:<br>                    heappop(sell_orders)<br>            if amount:<br>                heappush(buy_orders, (-price, amount))<br>        else: # sell order<br>            while amount and buy_orders and -buy_orders[0][0] = price:<br>                x = min(amount, buy_orders[0][1])<br>                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x<br>                if buy_orders[0][1] == 0:<br>                    heappop(buy_orders)<br>            if amount:<br>                heappush(sell_orders, (price, amount))<br>    <br>    while buy_orders:<br>        num_orders = (num_orders + heappop(buy_orders)[1]) % mod<br><br>    while sell_orders:<br>        num_orders = (num_orders + heappop(sell_orders)[1]) % mod<br><br>    return num_orders

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_91903.txt
> def allocate(self, amount, update=True):<br>        """<br>        This allocates capital to the Security. This is the method used to<br>        buy/sell the security.<br><br>        A given amount of shares will be determined on the current price, a<br>        commission will be calculated based on the parent's commission fn, and<br>        any remaining capital will be passed back up  to parent as an<br>        adjustment.<br><br>        Args:<br>             amount (float): Amount of adjustment.<br>             update (bool): Force update?<br><br>        """<br><br>        # will need to update if this has been idle for a while...<br>        # update if needupdate or if now is stale<br>        # fetch parent's now since our now is stale<br>        if self._needupdate or self.now != self.parent.now:<br>            self.update(self.parent.now)<br><br>        # ignore 0 alloc<br>        # Note that if the price of security has dropped to zero, then it<br>        # should never be selected by SelectAll, SelectN etc. I.e. we should<br>        # not open the position at zero price. At the same time, we are able<br>        # to close it at zero price, because at that point amount=0.<br>        # Note also that we don't erase the position in an asset which price<br>        # has dropped to zero (though the weight will indeed be = 0)<br>        if amount == 0:<br>            return<br><br>        if self.parent is self or self.parent is None:<br>            raise Exception(<br>                'Cannot allocate capital to a parentless security')<br><br>        if self._price == 0 or np.isnan(self._price):<br>            raise Exception(<br>                'Cannot allocate capital to '<br>                '%s because price is %s as of %s'<br>                % (self.name, self._price, self.parent.now))<br><br>        # buy/sell<br>        # determine quantity - must also factor in commission<br>        # closing out?<br>        if amount == -self._value:<br>            q = -self._position<br>        else:<br>            q = amount / (self._price  self.multiplier)<br>            if self.integer_positions:<br>                if (self._position  0) or ((self._position == 0) and (<br>                        amount  0)):<br>                    # if we're going long or changing long position<br>                    q = math.floor(q)<br>                else:<br>                    # if we're going short or changing short position<br>                    q = math.ceil(q)<br><br>        # if q is 0 nothing to do<br>        if q == 0 or np.isnan(q):<br>            return<br><br>        # unless we are closing out a position (q == -position)<br>        # we want to ensure that<br>        #<br>        # - In the event of a positive amount, this indicates the maximum<br>        # amount a given security can use up for a purchase. Therefore, if<br>        # commissions push us above this amount, we cannot buy `q`, and must<br>        # decrease its value<br>        #<br>        # - In the event of a negative amount, we want to 'raise' at least the<br>        # amount indicated, no less. Therefore, if we have commission, we must<br>        # sell additional units to fund this requirement. As such, q must once<br>        # again decrease.<br>        #<br>        if not q == -self._position:<br>            full_outlay, _, _ = self.outlay(q)<br><br>            # if full outlay  amount, we must decrease the magnitude of `q`<br>            # this can potentially lead to an infinite loop if the commission<br>            # per share  price per share. However, we cannot really detect<br>            # that in advance since the function can be non-linear (say a fn<br>            # like max(1, abs(q)  0.01). Nevertheless, we want to avoid these<br>            # situations.<br>            # cap the maximum number of iterations to 1e4 and raise exception<br>            # if we get there<br>            # if integer positions then we know we are stuck if q doesn't change<br><br>            # if integer positions is false then we want full_outlay == amount<br>            # if integer positions is true then we want to be at the q where<br>            #   if we bought 1 more then we wouldn't have enough cash<br>            i = 0<br>            last_q = q<br>            last_amount_short = full_outlay - amount<br>            while not np.isclose(full_outlay, amount, rtol=0.) and q != 0:<br><br>                dq_wout_considering_tx_costs = (full_outlay - amount)/(self._price  self.multiplier)<br>                q = q - dq_wout_considering_tx_costs<br><br>                if self.integer_positions:<br>                    q = math.floor(q)<br><br>                full_outlay, _, _ = self.outlay(q)<br><br>                # if our q is too low and we have integer positions<br>                # then we know that the correct quantity is the one  where<br>                # the outlay of q + 1 < amount. i.e. if we bought one more<br>                # position then we wouldn't have enough cash<br>                if self.integer_positions:<br><br>                    full_outlay_of_1_more, _, _ = self.outlay(q + 1)<br><br>                    if full_outlay < amount and full_outlay_of_1_more  amount:<br>                        break<br><br>                # if not integer positions then we should keep going until<br>                # full_outlay == amount or is close enough<br><br>                i = i + 1<br>                if i  1e4:<br>                    raise Exception(<br>                        'Potentially infinite loop detected. This occurred '<br>                        'while trying to reduce the amount of shares purchased'<br>                        ' to respect the outlay <= amount rule. This is most '<br>                        'likely due to a commission function that outputs a '<br>                        'commission that is greater than the amount of cash '<br>                        'a short sale can raise.')<br><br>                if self.integer_positions and last_q == q:<br>                    raise Exception(<br>                        'Newton Method like root search for quantity is stuck!'<br>                        ' q did not change in iterations so it is probably a bug'<br>                        ' but we are not entirely sure it is wrong! Consider '<br>                        ' changing to warning.'<br>                    )<br>                last_q = q<br><br>                if np.abs(full_outlay - amount)  np.abs(last_amount_short):<br>                    raise Exception(<br>                        'The difference between what we have raised with q and'<br>                        ' the amount we are trying to raise has gotten bigger since'<br>                        ' last iteration! full_outlay should always be approaching'<br>                        ' amount! There may be a case where the commission fn is'<br>                        ' not smooth'<br>                    )<br>                last_amount_short = full_outlay - amount<br><br>        # if last step led to q == 0, then we can return just like above<br>        if q == 0:<br>            return<br><br>        # this security will need an update, even if pos is 0 (for example if<br>        # we close the positions, value and pos is 0, but still need to do that<br>        # last update)<br>        self._needupdate = True<br><br>        # adjust position & value<br>        self._position += q<br><br>        # calculate proper adjustment for parent<br>        # parent passed down amount so we want to pass<br>        # -outlay back up to parent to adjust for capital<br>        # used<br>        full_outlay, outlay, fee = self.outlay(q)<br><br>        # store outlay for future reference<br>        self._outlay += outlay<br><br>        # call parent<br>        self.parent.adjust(-full_outlay, update=update, flow=False, fee=fee)

### DOC[3] (IRRELEVANT) leetcode/leetcode_1467.txt
> from math import factorial<br>    """Given `2n` balls of `k` distinct colors. You will be given an integer array `balls` of size `k` where `balls[i]` is the number of balls of color `i`.<br><br>All the balls will be shuffled uniformly at random, then we will distribute the first `n` balls to the first box and the remaining `n` balls to the other box (Please read the explanation of the second example carefully).<br><br>Please note that the two boxes are considered different. For example, if we have two balls of colors `a` and `b`, and two boxes `[]` and `()`, then the distribution `[a] (b)` is considered different than the distribution `[b] (a)` (Please read the explanation of the first example carefully).<br><br>Return _the probability_ that the two boxes have the same number of distinct balls. Answers within `10-5` of the actual value will be accepted as correct.<br><br>Example 1:<br><br>Input: balls = \[1,1\]<br>Output: 1.00000<br>Explanation: Only 2 ways to divide the balls equally:<br>- A ball of color 1 to box 1 and a ball of color 2 to box 2<br>- A ball of color 2 to box 1 and a ball of color 1 to box 2<br>In both ways, the number of distinct colors in each box is equal. The probability is 2/2 = 1<br><br>Example 2:<br><br>Input: balls = \[2,1,1\]<br>Output: 0.66667<br>Explanation: We have the set of balls \[1, 1, 2, 3\]<br>This set of balls will be shuffled randomly and we may have one of the 12 distinct shuffles with equal probability (i.e. 1/12):<br>\[1,1 / 2,3\], \[1,1 / 3,2\], \[1,2 / 1,3\], \[1,2 / 3,1\], \[1,3 / 1,2\], \[1,3 / 2,1\], \[2,1 / 1,3\], \[2,1 / 3,1\], \[2,3 / 1,1\], \[3,1 / 1,2\], \[3,1 / 2,1\], \[3,2 / 1,1\]<br>After that, we add the first two balls to the first box and the second two balls to the second box.<br>We can see that 8 of these 12 possible random distributions have the same number of distinct colors of balls in each box.<br>Probability is 8/12 = 0.66667<br><br>Example 3:<br><br>Input: balls = \[1,2,1,2\]<br>Output: 0.60000<br>Explanation: The set of balls is \[1, 2, 2, 3, 4, 4\]. It is hard to display all the 180 possible random shuffles of this set but it is easy to check that 108 of them will have the same number of distinct colors in each box.<br>Probability = 108 / 180 = 0.6<br><br>Constraints:<br><br>   `1 <= balls.length <= 8`<br>   `1 <= balls[i] <= 6`<br>   `sum(balls)` is even."""<br><br><br>def count_combinations(balls, combinations, curr_ball):<br>    total_combinations = 1<br>    for i in range(curr_ball):<br>        total_combinations = factorial(balls[i] + combinations[i]) / (factorial(balls[i])  factorial(combinations[i]))<br><br>    return total_combinations<br><br>def dfs(balls, combinations, curr_ball):<br>    if curr_ball == len(balls):<br>        if combinations[-1] == combinations[0]:<br>            return count_combinations(balls, combinations, curr_ball)<br>        else:<br>            return 0<br><br>    result = 0<br>    for i in range(balls[curr_ball] + 1):<br>        combinations.append(i)<br>        result += dfs(balls, combinations, curr_ball + 1)<br>        combinations.pop()<br><br>    return result<br><br>def get_probability(balls):<br>    sum_balls = sum(balls)<br><br>    total_combinations = 1<br>    for ball in balls:<br>        total_combinations = factorial(ball)<br><br>    combinations = []<br>    return dfs(balls, combinations, 0) / total_combinations

### DOC[4] (IRRELEVANT) leetcode/leetcode_638.txt
> from typing import List<br>    """In LeetCode Store, there are `n` items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.<br><br>You are given an integer array `price` where `price[i]` is the price of the `ith` item, and an integer array `needs` where `needs[i]` is the number of pieces of the `ith` item you want to buy.<br><br>You are also given an array `special` where `special[i]` is of size `n + 1` where `special[i][j]` is the number of pieces of the `jth` item in the `ith` offer and `special[i][n]` (i.e., the last integer in the array) is the price of the `ith` offer.<br><br>Return _the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers_. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.<br><br>Example 1:<br><br>Input: price = \[2,5\], special = \[\[3,0,5\],\[1,2,10\]\], needs = \[3,2\]<br>Output: 14<br>Explanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. <br>In special offer 1, you can pay $5 for 3A and 0B<br>In special offer 2, you can pay $10 for 1A and 2B. <br>You need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.<br><br>Example 2:<br><br>Input: price = \[2,3,4\], special = \[\[1,1,0,4\],\[2,2,1,9\]\], needs = \[1,2,1\]<br>Output: 11<br>Explanation: The price of A is $2, and $3 for B, $4 for C. <br>You may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. <br>You need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. <br>You cannot add more items, though only $9 for 2A ,2B and 1C.<br><br>Constraints:<br><br>   `n == price.length == needs.length`<br>   `1 <= n <= 6`<br>   `0 <= price[i], needs[i] <= 10`<br>   `1 <= special.length <= 100`<br>   `special[i].length == n + 1`<br>   `0 <= special[i][j] <= 50`"""<br><br><br>def shoppingOffers(price: List[int], special: List[List[int]], needs: List[int]) - int:<br>    def helper(index):<br>        if index == len(special):<br>            return sum(needs[i]  price[i] for i in range(len(needs)))<br><br>        no_offer = helper(index + 1)<br>        can_apply_offer = True<br>        for i in range(len(needs)):<br>            needs[i] -= special[index][i]<br>            if needs[i] < 0:<br>                can_apply_offer = False<br><br>        with_offer = float('inf')<br>        if can_apply_offer:<br>            offer_cost = special[index][-1] + helper(index)<br>            with_offer = min(no_offer, offer_cost)<br><br>        for i in range(len(needs)):<br>            needs[i] += special[index][i]<br>        <br>        return with_offer if can_apply_offer else no_offer<br><br>    return helper(0)

### DOC[5] (IRRELEVANT) leetcode/leetcode_2312.txt
> def max_count_target(nums, key):<br>    """You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.<br><br>To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.<br><br>Return _the maximum money you can earn after cutting an_ `m x n` _piece of wood_.<br><br>Note that you can cut the piece of wood as many times as you want.<br><br>Example 1:<br><br>Input: m = 3, n = 5, prices = \[\[1,4,2\],\[2,2,7\],\[2,1,3\]\]<br>Output: 19<br>Explanation: The diagram above shows a possible scenario. It consists of:<br>- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \ 7 = 14.<br>- 1 piece of wood shaped 2 x 1, selling for a price of 1 \ 3 = 3.<br>- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.<br>This obtains a total of 14 + 3 + 2 = 19 money earned.<br>It can be shown that 19 is the maximum amount of money that can be earned.<br><br>Example 2:<br><br>Input: m = 4, n = 6, prices = \[\[3,2,10\],\[1,4,2\],\[4,1,3\]\]<br>Output: 32<br>Explanation: The diagram above shows a possible scenario. It consists of:<br>- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \ 10 = 30.<br>- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.<br>This obtains a total of 30 + 2 = 32 money earned.<br>It can be shown that 32 is the maximum amount of money that can be earned.<br>Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.<br><br>Constraints:<br><br>   `1 <= m, n <= 200`<br>   `1 <= prices.length <= 2  104`<br>   `prices[i].length == 3`<br>   `1 <= hi <= m`<br>   `1 <= wi <= n`<br>   `1 <= pricei <= 106`<br>   All the shapes of wood `(hi, wi)` are pairwise distinct."""<br><br>    count = {}<br>    max_count = 0<br>    max_target = -1<br>    for i in range(1, len(nums)):<br>        if nums[i - 1] == key:<br>            count[nums[i]] = count.get(nums[i], 0) + 1<br>            if count[nums[i]]  max_count:<br>                max_count = count[nums[i]]<br>                max_target = nums[i]<br>    return max_target


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_2141.txt
> def max_computer_runtime(n, batteries):<br>    """You have `n` computers. You are given the integer `n` and a 0-indexed integer array `batteries` where the `ith` battery can run a computer for `batteries[i]` minutes. You are interested in running all `n` computers simultaneously using the given batteries.<br><br>Initially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.<br><br>Note that the batteries cannot be recharged.<br><br>Return _the maximum number of minutes you can run all the_ `n` _computers simultaneously._<br><br>Example 1:<br><br>Input: n = 2, batteries = \[3,3,3\]<br>Output: 4<br>Explanation: <br>Initially, insert battery 0 into the first computer and battery 1 into the second computer.<br>After two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.<br>At the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.<br>By the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.<br>We can run the two computers simultaneously for at most 4 minutes, so we return 4.<br><br>Example 2:<br><br>Input: n = 2, batteries = \[1,1,1,1\]<br>Output: 2<br>Explanation: <br>Initially, insert battery 0 into the first computer and battery 2 into the second computer. <br>After one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. <br>After another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.<br>We can run the two computers simultaneously for at most 2 minutes, so we return 2.<br><br>Constraints:<br><br>   `1 <= n <= batteries.length <= 105`<br>   `1 <= batteries[i] <= 109`"""<br><br>    batteries.sort()<br>    result = 0<br>    for i in range(len(batteries)):<br>        result = max(result, min(n, len(batteries) - i)  batteries[i])<br>    return result
