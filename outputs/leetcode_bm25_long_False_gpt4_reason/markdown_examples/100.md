# Query `100`

## Original Question

*You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`.

The `ith` day is a good day to rob the bank if:

   There are at least `time` days before and after the `ith` day,
   The number of guards at the bank for the `time` days before `i` are non-increasing, and
   The number of guards at the bank for the `time` days after `i` are non-decreasing.

More formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] >= security[i - time + 1] >= ... >= security[i] <= ... <= security[i + time - 1] <= security[i + time]`.

Return _a list of all days (0-indexed) that are good days to rob the bank_. _The order that the days are returned in does not matter._

Example 1:

Input: security = \[5,3,3,3,5,6,2\], time = 2
Output: \[2,3\]
Explanation:
On day 2, we have security\[0\] >= security\[1\] >= security\[2\] <= security\[3\] <= security\[4\].
On day 3, we have security\[1\] >= security\[2\] >= security\[3\] <= security\[4\] <= security\[5\].
No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.

Example 2:

Input: security = \[1,1,1,1,1\], time = 0
Output: \[0,1,2,3,4\]
Explanation:
Since time equals 0, every day is a good day to rob the bank, so return every day.

Example 3:

Input: security = \[1,2,3,4,5,6\], time = 2
Output: \[\]
Explanation:
No day has 2 days before it that have a non-increasing number of guards.
Thus, no day is a good day to rob the bank, so return an empty list.

Constraints:

   `1 <= security.length <= 105`
   `0 <= security[i], time <= 105`*

## gpt4 Reasoning

```markdown
The essential problem is to find all the days in a given list (`security`) that meet specific criteria regarding the number of guards on duty, making those days optimal for a hypothetical bank robbery. These criteria depend on a given number of days (`time`) before and after each day being considered, with the number of guards needing to be non-increasing before and non-decreasing after that day.

To address this problem, we can follow these steps:

1. **Preprocessing:** For each day, calculate two pieces of information:
    - Whether the number of guards is non-increasing for `time` days before this day.
    - Whether the number of guards is non-decreasing for `time` days after this day.

2. **Checking Conditions:** For a day to be considered a good day to rob the bank, it must have at least `time` days before and after it in the array (to satisfy the condition related to having enough days on either side). Additionally, the preprocessed information must indicate that the number of guards is non-increasing before and non-decreasing after.

3. **Return Good Days:** Collect and return all days that meet these conditions.

### Step-by-Step Solution

**Preprocessing:**

- Initialize two arrays of the same length as `security`, say `left` and `right`, to track the non-increasing and non-decreasing sequences respectively.
- For `left`, starting from the second element, compare each element with its predecessor. If the current element is less than or equal to the previous, increment the value from the previous `left` index; otherwise, reset to 0. This tracks the length of the non-increasing sequence ending at each index.
- For `right`, starting from the second-last element, compare each element with its successor. If the current element is less than or equal to the next, increment the value from the next `right` index; otherwise, reset to 0. This tracks the length of the non-decreasing sequence starting at each index.

**Checking Conditions:**

- Iterate through the `security` array, starting from index `time` and ending `time` elements before the last element (to ensure there are `time` days before and after).
- For each day `i`, check if the values in `left[i]` and `right[i]` are both greater than or equal to `time`. If so, this day meets the criteria for a good day to rob the bank.

**Return Good Days:**

- Collect all days that meet the criteria into a list.
- Return this list as the final result.

### Example Walkthrough

Given `security = [5,3,3,3,5,6,2]` and `time = 2`, the preprocessing steps would yield something like this:

- `left = [0, 1, 2, 3, 0, 0, 0]` (indicating how many days before, including itself, have a non-increasing number of guards).
- `right = [3, 2, 1, 0, 0, 1, 0]` (indicating how many days after, including itself, have a non-decreasing number of guards).

Checking conditions, we see that for `i = 2` and `i = 3`, both `left[i]` and `right[i]` are greater than or equal to `2` (our `time` value). Thus, `[2, 3]` are good days to rob the bank, matching the expected output.

By following this approach, we can systematically determine all the days that are good for robbing the bank according to the given criteria.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.2000
recall_5: 0.2000
recall_10: 0.2000
recall_25: 0.2000
recall_50: 0.2000
recall_100: 0.2000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.3392
ndcg_cut_10: 0.3392
ndcg_cut_25: 0.3392
ndcg_cut_50: 0.3392
ndcg_cut_100: 0.3392
map_cut_1: 0.2000
map_cut_5: 0.2000
map_cut_10: 0.2000
map_cut_25: 0.2000
map_cut_50: 0.2000
map_cut_100: 0.2000
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_2420.txt
> def find_good_indices(nums, k):<br>    """You are given a 0-indexed integer array `nums` of size `n` and a positive integer `k`.<br><br>We call an index `i` in the range `k <= i < n - k` good if the following conditions are satisfied:<br><br>   The `k` elements that are just before the index `i` are in non-increasing order.<br>   The `k` elements that are just after the index `i` are in non-decreasing order.<br><br>Return _an array of all good indices sorted in increasing order_.<br><br>Example 1:<br><br>Input: nums = \[2,1,1,1,3,4,1\], k = 2<br>Output: \[2,3\]<br>Explanation: There are two good indices in the array:<br>- Index 2. The subarray \[2,1\] is in non-increasing order, and the subarray \[1,3\] is in non-decreasing order.<br>- Index 3. The subarray \[1,1\] is in non-increasing order, and the subarray \[3,4\] is in non-decreasing order.<br>Note that the index 4 is not good because \[4,1\] is not non-decreasing.<br><br>Example 2:<br><br>Input: nums = \[2,1,1,2\], k = 2<br>Output: \[\]<br>Explanation: There are no good indices in this array.<br><br>Constraints:<br><br>   `n == nums.length`<br>   `3 <= n <= 105`<br>   `1 <= nums[i] <= 106`<br>   `1 <= k <= n / 2`"""<br><br>    good_indices = []<br>    for i in range(k, len(nums) - k):<br>        left_non_inc = all(nums[i - j - 1] = nums[i - j - 2] for j in range(k - 1))<br>        right_non_dec = all(nums[i + j + 1] = nums[i + j + 2] for j in range(k - 1))<br><br>        if left_non_inc and right_non_dec:<br>            good_indices.append(i)<br><br>    return good_indices

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_213530.txt
> def _grow_overlaps(dna, melting_temp, require_even, length_max, overlap_min,<br>                   min_exception):<br>    '''Grows equidistant overlaps until they meet specified constraints.<br><br>    :param dna: Input sequence.<br>    :type dna: coral.DNA<br>    :param melting_temp: Ideal Tm of the overlaps, in degrees C.<br>    :type melting_temp: float<br>    :param require_even: Require that the number of oligonucleotides is even.<br>    :type require_even: bool<br>    :param length_max: Maximum oligo size (e.g. 60bp price point cutoff)<br>                       range.<br>    :type length_range: int<br>    :param overlap_min: Minimum overlap size.<br>    :type overlap_min: int<br>    :param min_exception: In order to meet melting_temp and overlap_min<br>                          settings, allow overlaps less than overlap_min to<br>                          continue growing above melting_temp.<br>    :type min_exception: bool<br>    :returns: Oligos, their overlapping regions, overlap Tms, and overlap<br>              indices.<br>    :rtype: tuple<br><br>    '''<br>    # TODO: prevent growing overlaps from bumping into each other -<br>    # should halt when it happens, give warning, let user decide if they still<br>    # want the current construct<br>    # Another option would be to start over, moving the starting positions<br>    # near the problem region a little farther from each other - this would<br>    # put the AT-rich region in the middle of the spanning oligo<br><br>    # Try bare minimum number of oligos<br>    oligo_n = len(dna) // length_max + 1<br><br>    # Adjust number of oligos if even number required<br>    if require_even:<br>        oligo_increment = 2<br>        if oligo_n % 2 == 1:<br>            oligo_n += 1<br>    else:<br>        oligo_increment = 1<br><br>    # Increase oligo number until the minimum oligo_len is less than length_max<br>    while float(len(dna)) / oligo_n  length_max:<br>        oligo_n += oligo_increment<br><br>    # Loop until all overlaps meet minimum Tm and length<br>    tm_met = False<br>    len_met = False<br><br>    while(not tm_met or not len_met):<br>        # Calculate initial number of overlaps<br>        overlap_n = oligo_n - 1<br><br>        # Place overlaps approximately equidistant over sequence length<br>        overlap_interval = float(len(dna)) / oligo_n<br>        starts = [int(overlap_interval  (i + 1)) for i in range(overlap_n)]<br>        ends = [index + 1 for index in starts]<br><br>        # Fencepost for while loop<br>        # Initial overlaps (1 base) and their tms<br>        overlaps = [dna[start:end] for start, end in zip(starts, ends)]<br>        overlap_tms = [coral.analysis.tm(overlap) for overlap in overlaps]<br>        index = overlap_tms.index(min(overlap_tms))<br>        # Initial oligos - includes the 1 base overlaps.<br>        # All the oligos are in the same direction - reverse<br>        # complementation of every other one happens later<br>        oligo_starts = [0] + starts<br>        oligo_ends = ends + [len(dna)]<br>        oligo_indices = [oligo_starts, oligo_ends]<br><br>        oligos = [dna[start:end] for start, end in zip(oligo_indices)]<br><br>        # Oligo won't be maxed in first pass. tm_met and len_met will be false<br>        maxed = False<br><br>        while not (tm_met and len_met) and not maxed:<br>            # Recalculate overlaps and their Tms<br>            overlaps = _recalculate_overlaps(dna, overlaps, oligo_indices)<br>            # Tm calculation is bottleneck - only recalculate changed overlap<br>            overlap_tms[index] = coral.analysis.tm(overlaps[index])<br>            # Find lowest-Tm overlap and its index.<br>            index = overlap_tms.index(min(overlap_tms))<br>            # Move overlap at that index<br>            oligos = _expand_overlap(dna, oligo_indices, index, oligos,<br>                                     length_max)<br>            # Regenerate conditions<br>            maxed = any([len(x) == length_max for x in oligos])<br>            tm_met = all([x = melting_temp for x in overlap_tms])<br>            if min_exception:<br>                len_met = True<br>            else:<br>                len_met = all([len(x) = overlap_min for x in overlaps])<br><br>        # TODO: add test for min_exception case (use rob's sequence from<br>        # 20130624 with 65C Tm)<br>        if min_exception:<br>            len_met = all([len(x) = overlap_min for x in overlaps])<br><br>            # See if len_met is true - if so do nothing<br>            if len_met:<br>                break<br>            else:<br>                while not len_met and not maxed:<br>                    # Recalculate overlaps and their Tms<br>                    overlaps = _recalculate_overlaps(dna, overlaps,<br>                                                     oligo_indices)<br>                    # Overlap to increase is the shortest one<br>                    overlap_lens = [len(overlap) for overlap in overlaps]<br>                    index = overlap_lens.index(min(overlap_lens))<br>                    # Increase left or right oligo<br>                    oligos = _expand_overlap(dna, oligo_indices, index, oligos,<br>                                             length_max)<br>                    # Recalculate conditions<br>                    maxed = any([len(x) == length_max for x in oligos])<br>                    len_met = all([len(x) = overlap_min for x in overlaps])<br><br>                # Recalculate tms to reflect any changes (some are redundant)<br>                overlap_tms[index] = coral.analysis.tm(overlaps[index])<br><br>                # Outcome could be that len_met happened or maxed out<br>                # length of one of the oligos. If len_met happened, should be<br>                # done so long as tm_met has been satisfied. If maxed happened,<br>                # len_met will not have been met, even if tm_met is satisfied,<br>                # and script will reattempt with more oligos<br><br>        oligo_n += oligo_increment<br><br>    # Calculate location of overlaps<br>    overlap_indices = [(oligo_indices[0][x + 1], oligo_indices[1][x]) for x in<br>                       range(overlap_n)]<br><br>    return oligos, overlaps, overlap_tms, overlap_indices

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_334934.txt
> def findpeak_multi(x, y, dy, N, Ntolerance, Nfit=None, curve='Lorentz', return_xfit=False, return_stat=False):<br>    """Find multiple peaks in the dataset given by vectors x and y.<br><br>    Points are searched for in the dataset where the N points before and<br>    after have strictly lower values than them. To get rid of false<br>    negatives caused by fluctuations, Ntolerance is introduced. It is the<br>    number of outlier points to be tolerated, i.e. points on the left-hand<br>    side of the peak where the growing tendency breaks or on the right-hand<br>    side where the diminishing tendency breaks. Increasing this number,<br>    however gives rise to false positives.<br><br>    Inputs:<br>        x, y, dy: vectors defining the data-set. dy can be None.<br>        N, Ntolerance: the parameters of the peak-finding routines<br>        Nfit: the number of points on the left and on the right of<br>            the peak to be used for least squares refinement of the<br>            peak positions.<br>        curve: the type of the curve to be fitted to the peaks. Can be<br>            'Lorentz' or 'Gauss'<br>        return_xfit: if the abscissa used for fitting is to be returned.<br>        return_stat: if the fitting statistics is to be returned for each<br>            peak.<br>            <br>    Outputs:<br>        position, hwhm, baseline, amplitude, (xfit): lists<br>        <br>    Notes:<br>        Peaks are identified where the curve grows N points before and <br>        decreases N points after. On noisy curves Ntolerance may improve<br>        the results, i.e. decreases the 2N above mentioned criteria.<br>    """<br>    if Nfit is None:<br>        Nfit = N<br>    # find points where the curve grows for N points before them and<br>    # decreases for N points after them. To accomplish this, we create<br>    # an indicator array of the sign of the first derivative.<br>    sgndiff = np.sign(np.diff(y))<br>    xdiff = x[:-1]  # associate difference values to the lower 'x' value.<br>    pix = np.arange(len(x) - 1)  # pixel coordinates create an indicator<br>    # array as the sum of sgndiff shifted left and right.  whenever an<br>    # element of this is 2N, it fulfills the criteria above.<br>    indicator = np.zeros(len(sgndiff) - 2  N)<br>    for i in range(2  N):<br>        indicator += np.sign(N - i)  sgndiff[i:-2  N + i]<br>    # add the last one, since the indexing is different (would be<br>    # [2N:0], which is not what we want)<br>    indicator += -sgndiff[2  N:]<br>    # find the positions (indices) of the peak. The strict criteria is<br>    # relaxed somewhat by using the Ntolerance value. Note the use of<br>    # 2Ntolerance, since each outlier point creates two outliers in<br>    # sgndiff (-1 insted of +1 and vice versa).<br>    peakpospix = pix[N:-N][indicator = 2  N - 2  Ntolerance]<br>    ypeak = y[peakpospix]<br>    # Now refine the found positions by least-squares fitting. But<br>    # first we have to sort out other non-peaks, i.e. found points<br>    # which have other found points with higher values in their [-N,N]<br>    # neighbourhood.<br>    pos = []; ampl = []; hwhm = []; baseline = []; xfit = []; stat = []<br>    dy1 = None<br>    for i in range(len(ypeak)):<br>        if not [j for j in list(range(i + 1, len(ypeak))) + list(range(0, i)) if abs(peakpospix[j] - peakpospix[i]) <= N and ypeak[i] < ypeak[j]]:<br>            # only leave maxima.<br>            idx = peakpospix[i]<br>            if dy is not None:<br>                dy1 = dy[(idx - Nfit):(idx + Nfit + 1)]<br>            xfit_ = x[(idx - Nfit):(idx + Nfit + 1)]<br>            pos_, hwhm_, baseline_, ampl_, stat_ = findpeak_single(xfit_, y[(idx - Nfit):(idx + Nfit + 1)], dy1, position=x[idx], return_stat=True)<br>            <br>            stat.append(stat_)<br>            xfit.append(xfit_)<br>            pos.append(pos_)<br>            ampl.append(ampl_)<br>            hwhm.append(hwhm_)<br>            baseline.append(baseline_)<br>    results = [pos, hwhm, baseline, ampl]<br>    if return_xfit:<br>        results.append(xfit)<br>    if return_stat:<br>        results.append(stat)<br>    return tuple(results)

### DOC[4] (IRRELEVANT) leetcode/leetcode_2532.txt
> from heapq import heappush, heappop<br>    """There are `k` workers who want to move `n` boxes from an old warehouse to a new one. You are given the two integers `n` and `k`, and a 2D integer array `time` of size `k x 4` where `time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi]`.<br><br>The warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all `k` workers are waiting on the left side of the bridge. To move the boxes, the `ith` worker (0-indexed) can :<br><br>   Cross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in `leftToRighti` minutes.<br>   Pick a box from the old warehouse and return to the bridge in `pickOldi` minutes. Different workers can pick up their boxes simultaneously.<br>   Cross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in `rightToLefti` minutes.<br>   Put the box in the new warehouse and return to the bridge in `putNewi` minutes. Different workers can put their boxes simultaneously.<br><br>A worker `i` is less efficient than a worker `j` if either condition is met:<br><br>   `leftToRighti + rightToLefti  leftToRightj + rightToLeftj`<br>   `leftToRighti + rightToLefti == leftToRightj + rightToLeftj` and `i  j`<br><br>The following rules regulate the movement of the workers through the bridge :<br><br>   If a worker `x` reaches the bridge while another worker `y` is crossing the bridge, `x` waits at their side of the bridge.<br>   If the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.<br>   If the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.<br><br>Return _the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse_.<br><br>Example 1:<br><br>Input: n = 1, k = 3, time = \[\[1,1,2,1\],\[1,1,3,1\],\[1,1,4,1\]\]<br>Output: 6<br>Explanation: <br>From 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.<br>From 1 to 2: worker 2 picks up a box from the old warehouse.<br>From 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.<br>From 6 to 7: worker 2 puts a box at the new warehouse.<br>The whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.<br><br>Example 2:<br><br>Input: n = 3, k = 2, time = \[\[1,9,1,8\],\[10,10,10,10\]\]<br>Output: 50<br>Explanation: <br>From 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.<br>From 10 to 20: worker 1 picks up a box from the old warehouse.<br>From 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.<br>From 11 to 20: worker 0 picks up a box from the old warehouse.<br>From 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.<br>From 30 to 40: worker 1 puts a box at the new warehouse.<br>From 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.<br>From 31 to 39: worker 0 puts a box at the new warehouse.<br>From 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.<br>From 40 to 49: worker 0 picks up a box from the old warehouse.<br>From 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.<br>From 50 to 58: worker 0 puts a box at the new warehouse.<br>The whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.<br><br>Constraints:<br><br>   `1 <= n, k <= 104`<br>   `time.length == k`<br>   `time[i].length == 4`<br>   `1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000`"""<br><br><br>def getLastMoment(n, k, time):<br>    left = [(time[j][0] + time[j][2], j) for j in range(k)]<br>    right = []<br><br>    while n:<br>        while right and right[0][0] <= left[0][0]:<br>            right_top = heappop(right)<br>            heappush(left, (right_top[0] + time[right_top[1]][0] + time[right_top[1]][2], right_top[1]))<br>        left_top = heappop(left)<br>        time[left_top[1]][2] += time[left_top[1]][3] + time[left_top[1]][0] + time[left_top[1]][1]<br>        heappush(right, (left_top[0] + time[left_top[1]][1], left_top[1]))<br>        n -= 1<br><br>    lastMoment = -1<br>    while right:<br>        right_top = heappop(right)<br>        lastMoment = max(lastMoment, time[right_top[1]][2])<br>    return lastMoment

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_313710.txt
> def load_rf(freq="M"):<br>    """Build a risk-free rate return series using 3-month US T-bill yields.<br><br>    The 3-Month Treasury Bill: Secondary Market Rate from the Federal Reserve<br>    (a yield) is convert to a total return.  See 'Methodology' for details.<br><br>    The time series should closely mimic returns of the BofA Merrill Lynch US<br>    Treasury Bill (3M) (Local Total Return) index.<br><br>    Parameters<br>    ----------<br>    freq : str, sequence, or set<br>        If a single-character string, return a single-column DataFrame with<br>        index frequency corresponding to `freq`.  If a sequence or set, return<br>        a dict of DataFrames with the keys corresponding to `freq`(s)<br><br>    Methodology<br>    -----------<br>    The Federal Reserve publishes a daily chart of Selected Interest Rates<br>    (release H.15; www.federalreserve.gov/releases/h15/).  As with a yield<br>    curve, some yields are interpolated from recent issues because Treasury<br>    auctions do not occur daily.<br><br>    While the de-annualized ex-ante yield itself is a fairly good tracker of<br>    the day's total return, it is not perfect and can exhibit non-neglible<br>    error in periods of volatile short rates.  The purpose of this function<br>    is to convert yields to total returns for 3-month T-bills.  It is a<br>    straightforward process given that these are discount (zero-coupon)<br>    securities.  It consists of buying a 3-month bond at the beginning of each<br>    month, then amortizing that bond throughout the month to back into the<br>    price of a <3-month tenor bond.<br><br>    The source data (pulled from fred.stlouisfed.org) is quoted on a discount<br>    basis.  (See footnote 4 from release H.15.)  This is converted to a<br>    bond-equivlanet yield (BEY) and then translated to a hypothetical daily<br>    total return.<br><br>    The process largely follows Morningstar's published Return Calculation of<br>    U.S. Treasury Constant Maturity Indices, and is as follows:<br>    - At the beginning of each month a bill is purchased at the prior month-end<br>      price, and daily returns in the month reflect the change in daily<br>      valuation of this bill<br>    - If t is not a business day, its yield is the yield of the prior<br>      business day.<br>    - At each day during the month, the price of a 3-month bill purchased on<br>      the final calendar day of the previous month is computed.<br>    - Month-end pricing is unique.  At each month-end date, there are<br>      effectively two bonds and two prices.  The first is the bond<br>      hypothetically purchased on the final day of the prior month with 2m<br>      remaining to maturity, and the second is a new-issue bond purchased that<br>      day with 3m to maturity.  The former is used as the numerator to compute<br>      that day's total return, while the latter is used as the denominator<br>      to compute the next day's (1st day of next month) total return.<br><br>    Description of the BofA Merrill Lynch US 3-Month Treasury Bill Index:<br>    The BofA Merrill Lynch US 3-Month Treasury Bill Index is comprised of a<br>    single issue purchased at the beginning of the month and held for a full<br>    month. At the end of the month that issue is sold and rolled into a newly<br>    selected issue. The     issue selected at each month-end rebalancing is the<br>    outstanding Treasury Bill that matures closest to, but not beyond, three<br>    months from the rebalancing date. To qualify for selection, an issue must<br>    have settled on or before the month-end rebalancing date.<br>        (Source: Bank of America Merrill Lynch)<br><br>    See also<br>    --------<br>    FRED: 3-Month Treasury Bill: Secondary Market Rate (DTB3)<br>      https://fred.stlouisfed.org/series/DTB3<br>    McGraw-Hill/Irwin, Interest Rates, 2008.<br>      https://people.ucsc.edu/~lbaum/econ80h/LS-Chap009.pdf<br>    Morningstar, Return Calculation of U.S. Treasury Constant Maturity Indices,<br>      September 2008.<br>    """<br><br>    freqs = "DWMQA"<br>    freq = freq.upper()<br>    if freq not in freqs:<br>        raise ValueError(<br>            "`freq` must be either a single element or subset"<br>            " from %s, case-insensitive" % freqs<br>        )<br><br>    # Load daily 3-Month Treasury Bill: Secondary Market Rate.<br>    # Note that this is on discount basis and will be converted to BEY.<br>    # Periodicity is daily.<br>    rates = (<br>        pdr.DataReader("DTB3", "fred", DSTART)<br>        .mul(0.01)<br>        .asfreq("D", method="ffill")<br>        .fillna(method="ffill")<br>        .squeeze()<br>    )<br><br>    # Algebra doesn't 'work' on DateOffsets, don't simplify here!<br>    minus_one_month = offsets.MonthEnd(-1)<br>    plus_three_months = offsets.MonthEnd(3)<br>    trigger = rates.index.is_month_end<br>    dtm_old = rates.index + minus_one_month + plus_three_months - rates.index<br>    dtm_new = (<br>        rates.index.where(trigger, rates.index + minus_one_month)<br>        + plus_three_months<br>        - rates.index<br>    )<br><br>    # This does 2 things in one step:<br>    # (1) convert discount yield to BEY<br>    # (2) get the price at that BEY and days to maturity<br>    # The two equations are simplified<br>    # See https://people.ucsc.edu/~lbaum/econ80h/LS-Chap009.pdf<br>    p_old = (100 / 360)  (360 - rates  dtm_old.days)<br>    p_new = (100 / 360)  (360 - rates  dtm_new.days)<br><br>    res = p_old.pct_change().where(trigger, p_new.pct_change()).dropna()<br>    # TODO: For purpose of using in TSeries, we should drop upsampled<br>    #       periods where we don't have the full period constituents.<br>    return res.add(1.0).resample(freq).prod().sub(1.0)


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_665.txt
> def checkPossibility(nums):<br>    """Given an array `nums` with `n` integers, your task is to check if it could become non-decreasing by modifying at most one element.<br><br>We define an array is non-decreasing if `nums[i] <= nums[i + 1]` holds for every `i` (0-based) such that (`0 <= i <= n - 2`).<br><br>Example 1:<br><br>Input: nums = \[4,2,3\]<br>Output: true<br>Explanation: You could modify the first 4 to 1 to get a non-decreasing array.<br><br>Example 2:<br><br>Input: nums = \[4,2,1\]<br>Output: false<br>Explanation: You cannot get a non-decreasing array by modifying at most one element.<br><br>Constraints:<br><br>   `n == nums.length`<br>   `1 <= n <= 104`<br>   `-105 <= nums[i] <= 105`"""<br><br>    cnt = 0<br>    for i in range(1, len(nums)):<br>        if nums[i] < nums[i - 1]:<br>            cnt += 1<br>            if i == 1 or nums[i] = nums[i - 2]:<br>                nums[i-1] = nums[i]<br>            else:<br>                nums[i] = nums[i - 1]<br>            if cnt  1:<br>                return False<br>    return True

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_845.txt
> def longestMountain(arr):<br>    """You may recall that an array `arr` is a mountain array if and only if:<br><br>   `arr.length = 3`<br>   There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that:<br>       `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`<br>       `arr[i]  arr[i + 1]  ...  arr[arr.length - 1]`<br><br>Given an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.<br><br>Example 1:<br><br>Input: arr = \[2,1,4,7,3,2,5\]<br>Output: 5<br>Explanation: The largest mountain is \[1,4,7,3,2\] which has length 5.<br><br>Example 2:<br><br>Input: arr = \[2,2,2\]<br>Output: 0<br>Explanation: There is no mountain.<br><br>Constraints:<br><br>   `1 <= arr.length <= 104`<br>   `0 <= arr[i] <= 104`<br><br>Follow up:<br><br>   Can you solve it using only one pass?<br>   Can you solve it in `O(1)` space?"""<br><br>    n = len(arr)<br>    res = up = down = 0<br><br>    for i in range(1, n):<br>        if (down and arr[i - 1] < arr[i]) or arr[i - 1] == arr[i]:<br>            up = down = 0<br><br>        up += arr[i - 1] < arr[i]<br>        down += arr[i - 1]  arr[i]<br><br>        if up and down:<br>            res = max(res, up + down + 1)<br><br>    return res

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_1095.txt
> def twoCitySchedCost(costs):<br>    """_(This problem is an interactive problem.)_<br><br>You may recall that an array `arr` is a mountain array if and only if:<br><br>   `arr.length = 3`<br>   There exists some `i` with `0 < i < arr.length - 1` such that:<br>       `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`<br>       `arr[i]  arr[i + 1]  ...  arr[arr.length - 1]`<br><br>Given a mountain array `mountainArr`, return the minimum `index` such that `mountainArr.get(index) == target`. If such an `index` does not exist, return `-1`.<br><br>You cannot access the mountain array directly. You may only access the array using a `MountainArray` interface:<br><br>   `MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).<br>   `MountainArray.length()` returns the length of the array.<br><br>Submissions making more than `100` calls to `MountainArray.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.<br><br>Example 1:<br><br>Input: array = \[1,2,3,4,5,3,1\], target = 3<br>Output: 2<br>Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.<br><br>Example 2:<br><br>Input: array = \[0,1,2,4,2,1\], target = 3<br>Output: -1<br>Explanation: 3 does not exist in `the array,` so we return -1.<br><br>Constraints:<br><br>   `3 <= mountain_arr.length() <= 104`<br>   `0 <= target <= 109`<br>   `0 <= mountain_arr.get(index) <= 109`"""<br><br>    costs.sort(key=lambda x: x[0] - x[1])<br><br>    totalCost = 0<br>    n = len(costs) // 2<br><br>    for i in range(n):<br>        totalCost += costs[i][0] + costs[i + n][1]<br><br>    return totalCost

### GROUND TRUTH 3, ranked not in top 100, leetcode/leetcode_1800.txt
> def concatenated_binary(n: int) - int:<br>    """Given an array of positive integers `nums`, return the _maximum possible sum of an ascending subarray in_ `nums`.<br><br>A subarray is defined as a contiguous sequence of numbers in an array.<br><br>A subarray `[numsl, numsl+1, ..., numsr-1, numsr]` is ascending if for all `i` where `l <= i < r`, `numsi < numsi+1`. Note that a subarray of size `1` is ascending.<br><br>Example 1:<br><br>Input: nums = \[10,20,30,5,10,50\]<br>Output: 65<br>Explanation: \[5,10,50\] is the ascending subarray with the maximum sum of 65.<br><br>Example 2:<br><br>Input: nums = \[10,20,30,40,50\]<br>Output: 150<br>Explanation: \[10,20,30,40,50\] is the ascending subarray with the maximum sum of 150.<br><br>Example 3:<br><br>Input: nums = \[12,17,15,13,10,11,12\]<br>Output: 33<br>Explanation: \[10,11,12\] is the ascending subarray with the maximum sum of 33.<br><br>Constraints:<br><br>   `1 <= nums.length <= 100`<br>   `1 <= nums[i] <= 100`"""<br><br>    result = 0<br>    mod = 1000000007<br>    for i in range(1, n + 1):<br>        length = len(bin(i)) - 2<br>        result = ((result << length) % mod + i) % mod<br>    return result

### GROUND TRUTH 4, ranked 0, leetcode/leetcode_2420.txt
> def find_good_indices(nums, k):<br>    """You are given a 0-indexed integer array `nums` of size `n` and a positive integer `k`.<br><br>We call an index `i` in the range `k <= i < n - k` good if the following conditions are satisfied:<br><br>   The `k` elements that are just before the index `i` are in non-increasing order.<br>   The `k` elements that are just after the index `i` are in non-decreasing order.<br><br>Return _an array of all good indices sorted in increasing order_.<br><br>Example 1:<br><br>Input: nums = \[2,1,1,1,3,4,1\], k = 2<br>Output: \[2,3\]<br>Explanation: There are two good indices in the array:<br>- Index 2. The subarray \[2,1\] is in non-increasing order, and the subarray \[1,3\] is in non-decreasing order.<br>- Index 3. The subarray \[1,1\] is in non-increasing order, and the subarray \[3,4\] is in non-decreasing order.<br>Note that the index 4 is not good because \[4,1\] is not non-decreasing.<br><br>Example 2:<br><br>Input: nums = \[2,1,1,2\], k = 2<br>Output: \[\]<br>Explanation: There are no good indices in this array.<br><br>Constraints:<br><br>   `n == nums.length`<br>   `3 <= n <= 105`<br>   `1 <= nums[i] <= 106`<br>   `1 <= k <= n / 2`"""<br><br>    good_indices = []<br>    for i in range(k, len(nums) - k):<br>        left_non_inc = all(nums[i - j - 1] = nums[i - j - 2] for j in range(k - 1))<br>        right_non_dec = all(nums[i + j + 1] = nums[i + j + 2] for j in range(k - 1))<br><br>        if left_non_inc and right_non_dec:<br>            good_indices.append(i)<br><br>    return good_indices
