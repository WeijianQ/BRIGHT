# Query `124`

## Original Question

*You are given two integers `m` and `n` that represent the height and width of a rectangular piece of wood. You are also given a 2D integer array `prices`, where `prices[i] = [hi, wi, pricei]` indicates you can sell a rectangular piece of wood of height `hi` and width `wi` for `pricei` dollars.

To cut a piece of wood, you must make a vertical or horizontal cut across the entire height or width of the piece to split it into two smaller pieces. After cutting a piece of wood into some number of smaller pieces, you can sell pieces according to `prices`. You may sell multiple pieces of the same shape, and you do not have to sell all the shapes. The grain of the wood makes a difference, so you cannot rotate a piece to swap its height and width.

Return _the maximum money you can earn after cutting an_ `m x n` _piece of wood_.

Note that you can cut the piece of wood as many times as you want.

Example 1:

Input: m = 3, n = 5, prices = \[\[1,4,2\],\[2,2,7\],\[2,1,3\]\]
Output: 19
Explanation: The diagram above shows a possible scenario. It consists of:
- 2 pieces of wood shaped 2 x 2, selling for a price of 2 \ 7 = 14.
- 1 piece of wood shaped 2 x 1, selling for a price of 1 \ 3 = 3.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.
This obtains a total of 14 + 3 + 2 = 19 money earned.
It can be shown that 19 is the maximum amount of money that can be earned.

Example 2:

Input: m = 4, n = 6, prices = \[\[3,2,10\],\[1,4,2\],\[4,1,3\]\]
Output: 32
Explanation: The diagram above shows a possible scenario. It consists of:
- 3 pieces of wood shaped 3 x 2, selling for a price of 3 \ 10 = 30.
- 1 piece of wood shaped 1 x 4, selling for a price of 1 \ 2 = 2.
This obtains a total of 30 + 2 = 32 money earned.
It can be shown that 32 is the maximum amount of money that can be earned.
Notice that we cannot rotate the 1 x 4 piece of wood to obtain a 4 x 1 piece of wood.

Constraints:

   `1 <= m, n <= 200`
   `1 <= prices.length <= 2  104`
   `prices[i].length == 3`
   `1 <= hi <= m`
   `1 <= wi <= n`
   `1 <= pricei <= 106`
   All the shapes of wood `(hi, wi)` are pairwise distinct.*

## gpt4 Reasoning

```markdown
The essential problem here is to maximize the profit obtained from cutting and selling pieces of a given `m x n` piece of wood, based on the prices provided for specific shapes. This is a dynamic programming problem, where the goal is to find the optimal way to split the wood into pieces that can be sold for the highest total price. The problem involves making decisions at each step (whether to cut or not, and where to cut) that affect the outcome, and the solution requires considering all possible ways to cut the wood to maximize profit.

### Step 1: Understanding the Problem
First, it's important to fully understand the constraints and limitations:
- You can only sell pieces of wood in the dimensions provided in the `prices` array. 
- You cannot rotate pieces to swap their height and width.
- You can make any number of vertical or horizontal cuts, but each cut must span the entire width or height of the piece being cut.
- You aim to maximize the total selling price of the pieces.

### Step 2: Dynamic Programming Approach
A dynamic programming (DP) approach can be used to solve this problem by breaking it down into smaller subproblems. The idea is to use a 2D DP table where `dp[i][j]` represents the maximum money that can be earned from a piece of wood with dimensions `i x j`.

#### Initialization
Initialize a 2D array `dp` with dimensions `(m+1) x (n+1)` filled with zeros. This is because the maximum profit that can be earned from a piece of wood with either dimension equal to 0 is 0.

#### Populating the DP Table
For each piece of wood (subproblem) of dimensions `i x j`, iterate through all possible cuts:
- Horizontal cuts: For a horizontal cut at height `h`, the problem is divided into two subproblems of sizes `h x j` and `(i-h) x j`. The value for `dp[i][j]` should be updated if the sum of the profits from these two subproblems is greater than its current value.
- Vertical cuts: Similarly, for a vertical cut at width `w`, the problem is divided into two subproblems of sizes `i x w` and `i x (j-w)`. Update `dp[i][j]` if the sum of profits from these subproblems exceeds its current value.

Additionally, check if selling the whole piece `i x j` as is (without any cuts) is more profitable based on the prices given. This means for each price entry `[hi, wi, pricei]`, if `hi <= i` and `wi <= j`, consider updating `dp[i][j]` to `pricei` if it's higher than the current value of `dp[i][j]`.

#### Recursive Relation
The recursive relation for updating the DP table is:
```
dp[i][j] = max(dp[i][j], dp[h][j] + dp[i-h][j], dp[i][w] + dp[i][j-w], price for i x j (if applicable))
```
where `h` ranges from 1 to `i-1` and `w` ranges from 1 to `j-1`.

### Step 3: Implement and Optimize
The implementation of this DP approach involves nested loops to fill in the DP table based on the recursive relation described. Optimization techniques, such as memoization or bottom-up DP, can be used to reduce the time complexity.

### Step 4: Return the Result
After populating the DP table, the value at `dp[m][n]` represents the maximum money that can be earned from the original `m x n` piece of wood.

### Complexity Analysis
The time complexity of this approach can be quite high due to the nested loops required to fill the DP table, especially for larger values of `m` and `n`. Each cell in the DP table requires considering every possible cut, leading to a time complexity that could approach O(m^2 * n^2) in the worst case. Optimizations and pruning of unnecessary computations can help reduce the effective runtime.
```

### Metrics

```
recip_rank: 0.1429
P_1: 0.0000
P_5: 0.0000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.2044
ndcg_cut_25: 0.2044
ndcg_cut_50: 0.2044
ndcg_cut_100: 0.2044
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0714
map_cut_25: 0.0714
map_cut_50: 0.0714
map_cut_100: 0.0714
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_1465.txt
> class TreeNode:<br>    """You are given a rectangular cake of size `h x w` and two arrays of integers `horizontalCuts` and `verticalCuts` where:<br><br>   `horizontalCuts[i]` is the distance from the top of the rectangular cake to the `ith` horizontal cut and similarly, and<br>   `verticalCuts[j]` is the distance from the left of the rectangular cake to the `jth` vertical cut.<br><br>Return _the maximum area of a piece of cake after you cut at each horizontal and vertical position provided in the arrays_ `horizontalCuts` _and_ `verticalCuts`. Since the answer can be a large number, return this modulo `109 + 7`.<br><br>Example 1:<br><br>Input: h = 5, w = 4, horizontalCuts = \[1,2,4\], verticalCuts = \[1,3\]<br>Output: 4 <br>Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green piece of cake has the maximum area.<br><br>Example 2:<br><br>Input: h = 5, w = 4, horizontalCuts = \[3,1\], verticalCuts = \[1\]<br>Output: 6<br>Explanation: The figure above represents the given rectangular cake. Red lines are the horizontal and vertical cuts. After you cut the cake, the green and yellow pieces of cake have the maximum area.<br><br>Example 3:<br><br>Input: h = 5, w = 4, horizontalCuts = \[3\], verticalCuts = \[3\]<br>Output: 9<br><br>Constraints:<br><br>   `2 <= h, w <= 109`<br>   `1 <= horizontalCuts.length <= min(h - 1, 105)`<br>   `1 <= verticalCuts.length <= min(w - 1, 105)`<br>   `1 <= horizontalCuts[i] < h`<br>   `1 <= verticalCuts[i] < w`<br>   All the elements in `horizontalCuts` are distinct.<br>   All the elements in `verticalCuts` are distinct."""<br><br>    def __init__(self, x):<br>        self.val = x<br>        self.left = None<br>        self.right = None<br><br>class Solution:<br>    def maxProduct(self, root: TreeNode) - int:<br>        def dfs(node):<br>            if not node:<br>                return 0<br>            return node.val + dfs(node.left) + dfs(node.right)<br><br>        def dfs2(node, half):<br>            nonlocal result<br><br>            if not node:<br>                return 0<br>            cur_sum = node.val + dfs2(node.left, half) + dfs2(node.right, half)<br>            result = max(result, (total - cur_sum)  cur_sum)<br>            return cur_sum<br><br>        total = dfs(root)<br>        result = 0<br>        dfs2(root, total / 2)<br>        return result % (109 + 7)

### DOC[2] (IRRELEVANT) leetcode/leetcode_502.txt
> import heapq<br>    """Suppose LeetCode will start its IPO soon. In order to sell a good price of its shares to Venture Capital, LeetCode would like to work on some projects to increase its capital before the IPO. Since it has limited resources, it can only finish at most `k` distinct projects before the IPO. Help LeetCode design the best way to maximize its total capital after finishing at most `k` distinct projects.<br><br>You are given `n` projects where the `ith` project has a pure profit `profits[i]` and a minimum capital of `capital[i]` is needed to start it.<br><br>Initially, you have `w` capital. When you finish a project, you will obtain its pure profit and the profit will be added to your total capital.<br><br>Pick a list of at most `k` distinct projects from given projects to maximize your final capital, and return _the final maximized capital_.<br><br>The answer is guaranteed to fit in a 32-bit signed integer.<br><br>Example 1:<br><br>Input: k = 2, w = 0, profits = \[1,2,3\], capital = \[0,1,1\]<br>Output: 4<br>Explanation: Since your initial capital is 0, you can only start the project indexed 0.<br>After finishing it you will obtain profit 1 and your capital becomes 1.<br>With capital 1, you can either start the project indexed 1 or the project indexed 2.<br>Since you can choose at most 2 projects, you need to finish the project indexed 2 to get the maximum capital.<br>Therefore, output the final maximized capital, which is 0 + 1 + 3 = 4.<br><br>Example 2:<br><br>Input: k = 3, w = 0, profits = \[1,2,3\], capital = \[0,1,2\]<br>Output: 6<br><br>Constraints:<br><br>   `1 <= k <= 105`<br>   `0 <= w <= 109`<br>   `n == profits.length`<br>   `n == capital.length`<br>   `1 <= n <= 105`<br>   `0 <= profits[i] <= 104`<br>   `0 <= capital[i] <= 109`"""<br><br><br>def findMaximizedCapital(k: int, w: int, profits, capital) - int:<br>    project_pool = list(zip(capital, profits))<br>    project_pool.sort(reverse=True)<br>    <br>    profit_pool = []<br>    <br>    while k:<br>        while project_pool and project_pool[-1][0] <= w:<br>            heapq.heappush(profit_pool, -project_pool.pop()[1])<br>        <br>        if not profit_pool:<br>            break<br>        <br>        w -= heapq.heappop(profit_pool)<br>        k -= 1<br>        <br>    return w

### DOC[3] (IRRELEVANT) leetcode/leetcode_1801.txt
> from heapq import <br>    """You are given a 2D integer array `orders`, where each `orders[i] = [pricei, amounti, orderTypei]` denotes that `amounti` orders have been placed of type `orderTypei` at the price `pricei`. The `orderTypei` is:<br><br>   `0` if it is a batch of `buy` orders, or<br>   `1` if it is a batch of `sell` orders.<br><br>Note that `orders[i]` represents a batch of `amounti` independent orders with the same price and order type. All orders represented by `orders[i]` will be placed before all orders represented by `orders[i+1]` for all valid `i`.<br><br>There is a backlog that consists of orders that have not been executed. The backlog is initially empty. When an order is placed, the following happens:<br><br>   If the order is a `buy` order, you look at the `sell` order with the smallest price in the backlog. If that `sell` order's price is smaller than or equal to the current `buy` order's price, they will match and be executed, and that `sell` order will be removed from the backlog. Else, the `buy` order is added to the backlog.<br>   Vice versa, if the order is a `sell` order, you look at the `buy` order with the largest price in the backlog. If that `buy` order's price is larger than or equal to the current `sell` order's price, they will match and be executed, and that `buy` order will be removed from the backlog. Else, the `sell` order is added to the backlog.<br><br>Return _the total amount of orders in the backlog after placing all the orders from the input_. Since this number can be large, return it modulo `109 + 7`.<br><br>Example 1:<br><br>Input: orders = \[\[10,5,0\],\[15,2,1\],\[25,1,1\],\[30,4,0\]\]<br>Output: 6<br>Explanation: Here is what happens with the orders:<br>- 5 orders of type buy with price 10 are placed. There are no sell orders, so the 5 orders are added to the backlog.<br>- 2 orders of type sell with price 15 are placed. There are no buy orders with prices larger than or equal to 15, so the 2 orders are added to the backlog.<br>- 1 order of type sell with price 25 is placed. There are no buy orders with prices larger than or equal to 25 in the backlog, so this order is added to the backlog.<br>- 4 orders of type buy with price 30 are placed. The first 2 orders are matched with the 2 sell orders of the least price, which is 15 and these 2 sell orders are removed from the backlog. The 3rd order is matched with the sell order of the least price, which is 25 and this sell order is removed from the backlog. Then, there are no more sell orders in the backlog, so the 4th order is added to the backlog.<br>Finally, the backlog has 5 buy orders with price 10, and 1 buy order with price 30. So the total number of orders in the backlog is 6.<br><br>Example 2:<br><br>Input: orders = \[\[7,1000000000,1\],\[15,3,0\],\[5,999999995,0\],\[5,1,1\]\]<br>Output: 999999984<br>Explanation: Here is what happens with the orders:<br>- 109 orders of type sell with price 7 are placed. There are no buy orders, so the 109 orders are added to the backlog.<br>- 3 orders of type buy with price 15 are placed. They are matched with the 3 sell orders with the least price which is 7, and those 3 sell orders are removed from the backlog.<br>- 999999995 orders of type buy with price 5 are placed. The least price of a sell order is 7, so the 999999995 orders are added to the backlog.<br>- 1 order of type sell with price 5 is placed. It is matched with the buy order of the highest price, which is 5, and that buy order is removed from the backlog.<br>Finally, the backlog has (1000000000-3) sell orders with price 7, and (999999995-1) buy orders with price 5. So the total number of orders = 1999999991, which is equal to 999999984 % (109 + 7).<br><br>Constraints:<br><br>   `1 <= orders.length <= 105`<br>   `orders[i].length == 3`<br>   `1 <= pricei, amounti <= 109`<br>   `orderTypei` is either `0` or `1`."""<br><br><br>def getNumberOfBacklogOrders(orders):<br>    buy_orders, sell_orders = [], []<br>    num_orders, mod = 0, int(1e9) + 7<br><br>    for price, amount, order_type in orders:<br>        if order_type == 0: # buy order<br>            while amount and sell_orders and sell_orders[0][0] <= price:<br>                x = min(amount, sell_orders[0][1])<br>                amount, sell_orders[0][1] = amount - x, sell_orders[0][1] - x<br>                if sell_orders[0][1] == 0:<br>                    heappop(sell_orders)<br>            if amount:<br>                heappush(buy_orders, (-price, amount))<br>        else: # sell order<br>            while amount and buy_orders and -buy_orders[0][0] = price:<br>                x = min(amount, buy_orders[0][1])<br>                amount, buy_orders[0][1] = amount - x, buy_orders[0][1] - x<br>                if buy_orders[0][1] == 0:<br>                    heappop(buy_orders)<br>            if amount:<br>                heappush(sell_orders, (price, amount))<br>    <br>    while buy_orders:<br>        num_orders = (num_orders + heappop(buy_orders)[1]) % mod<br><br>    while sell_orders:<br>        num_orders = (num_orders + heappop(sell_orders)[1]) % mod<br><br>    return num_orders

### DOC[4] (IRRELEVANT) leetcode/leetcode_1725.txt
> def numberOfSets(n, k):<br>    """You are given an array `rectangles` where `rectangles[i] = [li, wi]` represents the `ith` rectangle of length `li` and width `wi`.<br><br>You can cut the `ith` rectangle to form a square with a side length of `k` if both `k <= li` and `k <= wi`. For example, if you have a rectangle `[4,6]`, you can cut it to get a square with a side length of at most `4`.<br><br>Let `maxLen` be the side length of the largest square you can obtain from any of the given rectangles.<br><br>Return _the number of rectangles that can make a square with a side length of_ `maxLen`.<br><br>Example 1:<br><br>Input: rectangles = \[\[5,8\],\[3,9\],\[5,12\],\[16,5\]\]<br>Output: 3<br>Explanation: The largest squares you can get from each rectangle are of lengths \[5,3,5,5\].<br>The largest possible square is of length 5, and you can get it out of 3 rectangles.<br><br>Example 2:<br><br>Input: rectangles = \[\[2,3\],\[3,7\],\[4,3\],\[3,7\]\]<br>Output: 3<br><br>Constraints:<br><br>   `1 <= rectangles.length <= 1000`<br>   `rectangles[i].length == 2`<br>   `1 <= li, wi <= 109`<br>   `li != wi`"""<br><br>    mod = 109 + 7<br>    dp = [[0]  (k + 1) for _ in range(n)]<br>    presum = [1]  n<br>    <br>    for j in range(1, k + 1):<br>        for i in range(n):<br>            dp[i][j] = presum[i]<br>            if i  0:<br>                dp[i][j] += dp[i - 1][j]<br>            dp[i][j] %= mod<br>            presum[i] = (presum[i] + dp[i][j - 1]) % mod<br>    <br>    return dp[n - 1][k]

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_144360.txt
> def place(vertices_resources, nets, machine, constraints,<br>          effort=1.0, random=default_random, on_temperature_change=None,<br>          kernel=default_kernel, kernel_kwargs={}):<br>    """A flat Simulated Annealing based placement algorithm.<br><br>    This placement algorithm uses simulated annealing directly on the supplied<br>    problem graph with the objective of reducing wire lengths (and thus,<br>    indirectly, the potential for congestion). Though computationally<br>    expensive, this placer produces relatively good placement solutions.<br><br>    The annealing temperature schedule used by this algorithm is taken from<br>    "VPR: A New Packing, Placement and Routing Tool for FPGA Research" by<br>    Vaughn Betz and Jonathan Rose from the "1997 International Workshop on<br>    Field Programmable Logic and Applications".<br><br>    Two implementations of the algorithm's kernel are available:<br><br>     :py:class:`~rig.place_and_route.place.sa.python_kernel.PythonKernel` A<br>      pure Python implementation which is available on all platforms supported<br>      by Rig.<br>     :py:class:`~rig.place_and_route.place.sa.c_kernel.CKernel` A C<br>      implementation which is typically 50-150x faster than the basic Python<br>      kernel. Since this implementation requires a C compiler during<br>      installation, it is an optional feature of Rig. See the<br>      :py:class:`CKernel's documentation<br>      <rig.place_and_route.place.sa.c_kernel.CKernel` for details.<br><br>    The fastest kernel installed is used by default and can be manually chosen<br>    using the ``kernel`` argument.<br><br>    This algorithm produces INFO level logging information describing the<br>    progress made by the algorithm.<br><br>    .. warning:<br>        This algorithm does not attempt to produce good solutions to the<br>        bin-packing problem of optimally fitting vertices into chips and it may<br>        fail if a good placement requires good bin packing.<br><br>    Parameters<br>    ----------<br>    effort : float<br>        A scaling factor for the number of iterations the algorithm should run<br>        for. 1.0 is probably about as low as you'll want to go in practice and<br>        runtime increases linearly as you increase this parameter.<br>    random : :py:class:`random.Random`<br>        A Python random number generator. Defaults to ``import random`` but can<br>        be set to your own instance of :py:class:`random.Random` to allow you<br>        to control the seed and produce deterministic results. For results to<br>        be deterministic, vertices_resources must be supplied as an<br>        :py:class:`collections.OrderedDict`.<br>    on_temperature_change : callback_function or None<br>        An (optional) callback function which is called every time the<br>        temperature is changed. This callback can be used to provide status<br>        updates<br><br>        The callback function is passed the following arguments:<br><br>         ``iteration_count``: the number of iterations the placer has<br>          attempted (integer)<br>         ``placements``: The current placement solution.<br>         ``cost``: the weighted sum over all nets of bounding-box size.<br>          (float)<br>         ``acceptance_rate``: the proportion of iterations which have resulted<br>          in an accepted change since the last callback call. (float between<br>          0.0 and 1.0)<br>         ``temperature``: The current annealing temperature. (float)<br>         ``distance_limit``: The maximum distance any swap may be made over.<br>          (integer)<br><br>        If the callback returns False, the anneal is terminated immediately and<br>        the current solution is returned.<br>    kernel : :py:class:`~rig.place_and_route.place.sa.kernel.Kernel`<br>        A simulated annealing placement kernel. A sensible default will be<br>        chosen based on the available kernels on this machine. The kernel may<br>        not be used if the placement problem has a trivial solution.<br>    kernel_kwargs : dict<br>        Optional kernel-specific keyword arguments to pass to the kernel<br>        constructor.<br>    """<br>    # Special case: just return immediately when there's nothing to place<br>    if len(vertices_resources) == 0:<br>        return {}<br><br>    # Within the algorithm we modify the resource availability values in the<br>    # machine to account for the effects of the current placement. As a result,<br>    # an internal copy of the structure must be made.<br>    machine = machine.copy()<br><br>    # {vertex: (x, y), ...} gives the location of all vertices whose position<br>    # is fixed by a LocationConstraint.<br>    fixed_vertices = {}<br><br>    # Handle constraints<br>    vertices_resources, nets, constraints, substitutions = \<br>        apply_same_chip_constraints(vertices_resources, nets, constraints)<br>    for constraint in constraints:<br>        if isinstance(constraint, LocationConstraint):<br>            # Location constraints are handled by recording the set of fixed<br>            # vertex locations and subtracting their resources from the chips<br>            # they're allocated to. These vertices will then not be added to<br>            # the internal placement data structure to prevent annealing from<br>            # moving them. They will be re-introduced at the last possible<br>            # moment.<br>            location = constraint.location<br>            if location not in machine:<br>                raise InvalidConstraintError(<br>                    "Chip requested by {} unavailable".format(machine))<br>            vertex = constraint.vertex<br><br>            # Record the constrained vertex's location<br>            fixed_vertices[vertex] = location<br><br>            # Make sure the vertex fits at the requested location (updating the<br>            # resource availability after placement)<br>            resources = vertices_resources[vertex]<br>            machine[location] = subtract_resources(machine[location],<br>                                                   resources)<br>            if overallocated(machine[location]):<br>                raise InsufficientResourceError(<br>                    "Cannot meet {}".format(constraint))<br>        elif isinstance(constraint,  # pragma: no branch<br>                        ReserveResourceConstraint):<br>            apply_reserve_resource_constraint(machine, constraint)<br><br>    # Initially randomly place the movable vertices<br>    movable_vertices = {v for v in vertices_resources<br>                        if v not in fixed_vertices}<br>    initial_placements = _initial_placement(movable_vertices,<br>                                            vertices_resources,<br>                                            machine, random)<br><br>    # Include the fixed vertices in initial placement<br>    initial_placements.update(fixed_vertices)<br><br>    # Filter out empty or singleton nets and those weighted as zero since they<br>    # cannot influence placement.<br>    nets = [n for n in nets if len(set(n))  1 and n.weight  0.0]<br><br>    # Special cases where no placement effort is required:<br>    #  There is only one chip<br>    #  There are no resource types to be consumed<br>    #  No effort is to be made<br>    #  No movable vertices<br>    #  There are no nets (and moving things has no effect)<br>    trivial = ((machine.width, machine.height) == (1, 1) or<br>               len(machine.chip_resources) == 0 or<br>               effort == 0.0 or<br>               len(movable_vertices) == 0 or<br>               len(nets) == 0)<br>    if trivial:<br>        logger.info("Placement has trivial solution. SA not used.")<br>        finalise_same_chip_constraints(substitutions, initial_placements)<br>        return initial_placements<br><br>    # Intialise the algorithm kernel<br>    k = kernel(vertices_resources, movable_vertices, set(fixed_vertices),<br>               initial_placements, nets, machine, random, kernel_kwargs)<br><br>    logger.info("SA placement kernel: %s", kernel.__name__)<br><br>    # Specifies the maximum distance any swap can span. Initially consider<br>    # swaps that span the entire machine.<br>    distance_limit = max(machine.width, machine.height)<br><br>    # Determine initial temperature according to the heuristic used by VPR: 20<br>    # times the standard deviation of len(movable_vertices) random swap costs.<br>    # The arbitrary very-high temperature is used to cause "all" swaps to be<br>    # accepted.<br>    _0, _1, cost_delta_sd = k.run_steps(len(movable_vertices),<br>                                        distance_limit,<br>                                        1e100)<br>    temperature = 20.0  cost_delta_sd<br><br>    # The number of swap-attempts between temperature changes is selected by<br>    # the heuristic used by VPR. This value is scaled linearly by the effort<br>    # parameter.<br>    num_steps = max(1, int(effort  len(vertices_resources)1.33))<br><br>    logger.info("Initial placement temperature: %0.1f", temperature)<br><br>    # Counter for the number of swap attempts made (used for diagnostic<br>    # purposes)<br>    iteration_count = 0<br><br>    # Holds the total cost of the current placement. This default value chosen<br>    # to ensure the loop below iterates at least once.<br>    current_cost = 0.0<br><br>    # The annealing algorithm runs until a heuristic termination condition<br>    # (taken from VPR) is hit. The heuristic waits until the temperature falls<br>    # below a small fraction of the average net cost.<br>    while temperature  (0.005  current_cost) / len(nets):<br>        # Run an iteration at the current temperature<br>        num_accepted, current_cost, _ = k.run_steps(<br>            num_steps, int(math.ceil(distance_limit)), temperature)<br><br>        # The ratio of accepted-to-not-accepted changes<br>        r_accept = num_accepted / float(num_steps)<br><br>        # Special case: Can't do better than 0 cost! This is a special case<br>        # since the normal termination condition will not terminate if the cost<br>        # doesn't drop below 0.<br>        if current_cost == 0:<br>            break<br><br>        # The temperature is reduced by a factor heuristically based on the<br>        # acceptance rate. The schedule below attempts to maximise the time<br>        # spent at temperatures where a large portion (but not all) of changes<br>        # are being accepted. If lots of changes are being accepted (e.g.<br>        # during high-temperature periods) then most of them are likely not to<br>        # be beneficial. If few changes are being accepted, we're probably<br>        # pretty close to the optimal placement.<br>        if r_accept  0.96:<br>            alpha = 0.5<br>        elif r_accept  0.8:<br>            alpha = 0.9<br>        elif r_accept  0.15:<br>            alpha = 0.95<br>        else:<br>            alpha = 0.8<br>        temperature = alpha  temperature<br><br>        # According to:<br>        #  M. Huang, F. Romeo, and A. Sangiovanni-Vincentelli, "An Efficient<br>        #   General Cooling Schedule for Simulated Annealing" ICCAD, 1986, pp.<br>        #   381 - 384 and J. Lam<br>        #  J. Delosme, "Performance of a New Annealing Schedule" DAC, 1988,<br>        #   pp. 306 - 311.<br>        # It is desirable to keep the acceptance ratio as close to 0.44 for as<br>        # long as possible. As a result, when r_accept falls below this we can<br>        # help increase the acceptance rate by reducing the set of possible<br>        # swap candidates based on the observation that near the end of<br>        # placement, most things are near their optimal location and thus long<br>        # distance swaps are unlikely to be useful.<br>        distance_limit = 1.0 - 0.44 + r_accept<br>        distance_limit = min(max(distance_limit, 1.0),<br>                             max(machine.width, machine.height))<br><br>        iteration_count += num_steps<br>        logger.debug("Iteration: %d, "<br>                     "Cost: %0.1f, "<br>                     "Kept: %0.1f%%, "<br>                     "Temp: %0.3f, "<br>                     "Dist: %d.",<br>                     iteration_count, current_cost,<br>                     r_accept100, temperature, math.ceil(distance_limit))<br><br>        # Call the user callback before the next iteration, terminating if<br>        # requested.<br>        if on_temperature_change is not None:<br>            placements = k.get_placements().copy()<br>            finalise_same_chip_constraints(substitutions, placements)<br>            ret_val = on_temperature_change(iteration_count,<br>                                            placements,<br>                                            current_cost,<br>                                            r_accept,<br>                                            temperature,<br>                                            distance_limit)<br>            if ret_val is False:<br>                break<br><br>    logger.info("Anneal terminated after %d iterations.", iteration_count)<br><br>    placements = k.get_placements()<br>    finalise_same_chip_constraints(substitutions, placements)<br><br>    return placements


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_1240.txt
> from functools import lru_cache<br>    """Given a rectangle of size `n` x `m`, return _the minimum number of integer-sided squares that tile the rectangle_.<br><br>Example 1:<br><br>Input: n = 2, m = 3<br>Output: 3<br>Explanation: `3` squares are necessary to cover the rectangle.<br>`2` (squares of `1x1`)<br>`1` (square of `2x2`)<br><br>Example 2:<br><br>Input: n = 5, m = 8<br>Output: 5<br><br>Example 3:<br><br>Input: n = 11, m = 13<br>Output: 6<br><br>Constraints:<br><br>   `1 <= n, m <= 13`"""<br><br><br>def stoneGameII(piles):<br>    n = len(piles)<br>    for i in range(n - 2, -1, -1):<br>        piles[i] += piles[i + 1]<br><br>    @lru_cache(None)<br>    def search(idx, M):<br>        if idx + 2  M = n:<br>            return piles[idx]<br>        return max(piles[idx] - search(idx + x, max(M, x)) for x in range(1, 2  M + 1))<br><br>    return search(0, 1)

### GROUND TRUTH 1, ranked 6, leetcode/leetcode_1444.txt
> def number_of_steps(num):<br>    """Given a rectangular pizza represented as a `rows x cols` matrix containing the following characters: `'A'` (an apple) and `'.'` (empty cell) and given the integer `k`. You have to cut the pizza into `k` pieces using `k-1` cuts.<br><br>For each cut you choose the direction: vertical or horizontal, then you choose a cut position at the cell boundary and cut the pizza into two pieces. If you cut the pizza vertically, give the left part of the pizza to a person. If you cut the pizza horizontally, give the upper part of the pizza to a person. Give the last piece of pizza to the last person.<br><br>_Return the number of ways of cutting the pizza such that each piece contains at least one apple._ Since the answer can be a huge number, return this modulo 10^9 + 7.<br><br>Example 1:<br><br>Input: pizza = \[ "A.. ", "AAA ", "... "\], k = 3<br>Output: 3 <br>Explanation: The figure above shows the three ways to cut the pizza. Note that pieces must contain at least one apple.<br><br>Example 2:<br><br>Input: pizza = \[ "A.. ", "AA. ", "... "\], k = 3<br>Output: 1<br><br>Example 3:<br><br>Input: pizza = \[ "A.. ", "A.. ", "... "\], k = 1<br>Output: 1<br><br>Constraints:<br><br>   `1 <= rows, cols <= 50`<br>   `rows == pizza.length`<br>   `cols == pizza[i].length`<br>   `1 <= k <= 10`<br>   `pizza` consists of characters `'A'` and `'.'` only."""<br><br>    steps = 0<br>    while num:<br>        steps += 1 if num % 2 == 0 else 2<br>        num = 1<br>    return steps - 1
