# Query `2`

## Original Question

*The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.

Given an integer `n`, return _the number of distinct solutions to the n-queens puzzle_.

Example 1:

Input: n = 4
Output: 2
Explanation: There are two distinct solutions to the 4-queens puzzle as shown.

Example 2:

Input: n = 1
Output: 1

Constraints:

   `1 <= n <= 9`*

## gpt4 Reasoning

```markdown
The essential problem here is to find out how many distinct ways there are to place `n` queens on an `n x n` chessboard without any of them being in a position to attack each other. A queen in chess can move any number of squares along the row, column, or diagonals. This means no two queens can share the same row, column, or diagonal.

### Steps to Solve the Problem

1. **Understanding Constraints and Possibilities**: 
    - Given that a queen can attack in rows, columns, and diagonals, the placement of each queen must be such that it does not share these with any other queen.
    - Since there are `n` queens and an `n x n` board, it logically follows that there must be exactly one queen per row and one per column.

2. **Approach**:
    - **Backtracking** is a common approach to solving this problem. It involves placing a queen in a valid spot and then moving on to place the next queen. If at any point it becomes impossible to place a queen without an attack possibility, the algorithm backtracks to the previous queen and tries a different position.
    - **Bitmasking** can optimize the backtracking approach by using bits to represent columns, left diagonals, and right diagonals that are under attack, thus making checks faster.

3. **Implementing the Solution**:
    - Start with the first row and try placing a queen in each column one by one.
    - For each placement, check if it leads to a conflict (same column, or same diagonals). This can be done by keeping track of the columns and diagonals already occupied.
    - If a placement does not lead to a conflict, move to the next row and repeat the process.
    - If all `n` queens are placed successfully, you have found a distinct solution. Increment your solution counter.
    - If at any row, there is no valid column to place a queen, backtrack to the previous row and try a new position for the queen in that row.

4. **Optimization**:
    - The problem can be optimized by observing that the board is symmetrical. Thus, you can solve for half the board and then double the count (except for when `n` is small, where symmetrical solutions might overlap).

5. **Edge Cases**:
    - When `n = 1`, there's only one square for the queen to go, so the answer is 1.
    - When `n = 2` or `n = 3`, it's impossible to place queens without them attacking each other due to the limited space, so the answer is 0.

### Relevant Information

- The maximum value of `n` is 9 due to the constraints, which means the problem is computationally feasible to solve with backtracking within a reasonable time frame.
- The number of solutions increases with `n`, but not in a simple pattern. For example, there are 2 solutions for `n = 4` and 92 solutions for `n = 8`.
- The problem is a classic example of using backtracking to explore all possible configurations and using pruning (eliminating branches of the search tree) to avoid exploring invalid configurations.

In conclusion, solving the n-queens puzzle requires a careful consideration of the rules governing queen movements, an efficient strategy for exploring the space of possible board configurations (like backtracking with optimizations such as bitmasking), and handling edge cases appropriately. The output is the count of distinct configurations where `n` queens can be placed on an `n x n` board without attacking each other.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 1.0000
recall_5: 1.0000
recall_10: 1.0000
recall_25: 1.0000
recall_50: 1.0000
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 1.0000
ndcg_cut_10: 1.0000
ndcg_cut_25: 1.0000
ndcg_cut_50: 1.0000
ndcg_cut_100: 1.0000
map_cut_1: 1.0000
map_cut_5: 1.0000
map_cut_10: 1.0000
map_cut_25: 1.0000
map_cut_50: 1.0000
map_cut_100: 1.0000
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_51.txt
> def solveNQueens(n):<br>    """The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.<br><br>Given an integer `n`, return _all distinct solutions to the n-queens puzzle_. You may return the answer in any order.<br><br>Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.<br><br>Example 1:<br><br>Input: n = 4<br>Output: \[\[ ".Q.. ", "...Q ", "Q... ", "..Q. "\],\[ "..Q. ", "Q... ", "...Q ", ".Q.. "\]\]<br>Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above<br><br>Example 2:<br><br>Input: n = 1<br>Output: \[\[ "Q "\]\]<br><br>Constraints:<br><br>   `1 <= n <= 9`"""<br><br>    def isSafe(board, row, col):<br>        for i in range(col):<br>            if board[row][i] == 'Q': return False<br>        i, j = row, col<br>        while i = 0 and j = 0:<br>            if board[i][j] == 'Q': return False<br>            i, j = i - 1, j - 1<br>        i, j = row, col<br>        while i < n and j = 0:<br>            if board[i][j] == 'Q': return False<br>            i, j = i + 1, j - 1<br>        return True<br><br>    def solve(result, board, n, col):<br>        if col == n:<br>            result.append(board.copy())<br>            return<br>        for row in range(n):<br>            if isSafe(board, row, col):<br>                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]<br>                solve(result, board, n, col + 1)<br>                board[row] = board[row][:col] + '.' + board[row][col + 1:]<br><br>    result, board = [], ['.'  n for _ in range(n)]<br>    solve(result, board, n, 0)<br>    return result

### DOC[2] (IRRELEVANT) leetcode/leetcode_1222.txt
> def remove_covered_intervals(intervals):<br>    """On a 0-indexed `8 x 8` chessboard, there can be multiple black queens ad one white king.<br><br>You are given a 2D integer array `queens` where `queens[i] = [xQueeni, yQueeni]` represents the position of the `ith` black queen on the chessboard. You are also given an integer array `king` of length `2` where `king = [xKing, yKing]` represents the position of the white king.<br><br>Return _the coordinates of the black queens that can directly attack the king_. You may return the answer in any order.<br><br>Example 1:<br><br>Input: queens = \[\[0,1\],\[1,0\],\[4,0\],\[0,4\],\[3,3\],\[2,4\]\], king = \[0,0\]<br>Output: \[\[0,1\],\[1,0\],\[3,3\]\]<br>Explanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).<br><br>Example 2:<br><br>Input: queens = \[\[0,0\],\[1,1\],\[2,2\],\[3,4\],\[3,5\],\[4,4\],\[4,5\]\], king = \[3,3\]<br>Output: \[\[2,2\],\[3,4\],\[4,4\]\]<br>Explanation: The diagram above shows the three queens that can directly attack the king and the three queens that cannot attack the king (i.e., marked with red dashes).<br><br>Constraints:<br><br>   `1 <= queens.length < 64`<br>   `queens[i].length == king.length == 2`<br>   `0 <= xQueeni, yQueeni, xKing, yKing < 8`<br>   All the given positions are unique."""<br><br>    intervals.sort(key=lambda x: (x[0], -x[1]))<br>    <br>    count = 0<br>    end = 0<br>    for i in intervals:<br>        if i[1]  end:<br>            count += 1<br>            end = i[1]<br>    return count

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_119698.txt
> def n_queens(queen_count):<br>    """N-Queens solver.<br><br>    Args:<br>        queen_count: the number of queens to solve for. This is also the<br>            board size.<br><br>    Yields:<br>        Solutions to the problem. Each yielded value is looks like<br>        (3, 8, 2, 1, 4, ..., 6) where each number is the column position for the<br>        queen, and the index into the tuple indicates the row.<br>    """<br>    out =list()<br>    cols = range(queen_count)<br>    #for vec in permutations(cols):<br>    for vec in permutations(cols,None):<br>        if (queen_count == len(set(vec[i]+i for i in cols))<br>                        == len(set(vec[i]-i for i in cols))):<br>            #yield vec<br>            out.append(vec)<br>    return out

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_144360.txt
> def place(vertices_resources, nets, machine, constraints,<br>          effort=1.0, random=default_random, on_temperature_change=None,<br>          kernel=default_kernel, kernel_kwargs={}):<br>    """A flat Simulated Annealing based placement algorithm.<br><br>    This placement algorithm uses simulated annealing directly on the supplied<br>    problem graph with the objective of reducing wire lengths (and thus,<br>    indirectly, the potential for congestion). Though computationally<br>    expensive, this placer produces relatively good placement solutions.<br><br>    The annealing temperature schedule used by this algorithm is taken from<br>    "VPR: A New Packing, Placement and Routing Tool for FPGA Research" by<br>    Vaughn Betz and Jonathan Rose from the "1997 International Workshop on<br>    Field Programmable Logic and Applications".<br><br>    Two implementations of the algorithm's kernel are available:<br><br>     :py:class:`~rig.place_and_route.place.sa.python_kernel.PythonKernel` A<br>      pure Python implementation which is available on all platforms supported<br>      by Rig.<br>     :py:class:`~rig.place_and_route.place.sa.c_kernel.CKernel` A C<br>      implementation which is typically 50-150x faster than the basic Python<br>      kernel. Since this implementation requires a C compiler during<br>      installation, it is an optional feature of Rig. See the<br>      :py:class:`CKernel's documentation<br>      <rig.place_and_route.place.sa.c_kernel.CKernel` for details.<br><br>    The fastest kernel installed is used by default and can be manually chosen<br>    using the ``kernel`` argument.<br><br>    This algorithm produces INFO level logging information describing the<br>    progress made by the algorithm.<br><br>    .. warning:<br>        This algorithm does not attempt to produce good solutions to the<br>        bin-packing problem of optimally fitting vertices into chips and it may<br>        fail if a good placement requires good bin packing.<br><br>    Parameters<br>    ----------<br>    effort : float<br>        A scaling factor for the number of iterations the algorithm should run<br>        for. 1.0 is probably about as low as you'll want to go in practice and<br>        runtime increases linearly as you increase this parameter.<br>    random : :py:class:`random.Random`<br>        A Python random number generator. Defaults to ``import random`` but can<br>        be set to your own instance of :py:class:`random.Random` to allow you<br>        to control the seed and produce deterministic results. For results to<br>        be deterministic, vertices_resources must be supplied as an<br>        :py:class:`collections.OrderedDict`.<br>    on_temperature_change : callback_function or None<br>        An (optional) callback function which is called every time the<br>        temperature is changed. This callback can be used to provide status<br>        updates<br><br>        The callback function is passed the following arguments:<br><br>         ``iteration_count``: the number of iterations the placer has<br>          attempted (integer)<br>         ``placements``: The current placement solution.<br>         ``cost``: the weighted sum over all nets of bounding-box size.<br>          (float)<br>         ``acceptance_rate``: the proportion of iterations which have resulted<br>          in an accepted change since the last callback call. (float between<br>          0.0 and 1.0)<br>         ``temperature``: The current annealing temperature. (float)<br>         ``distance_limit``: The maximum distance any swap may be made over.<br>          (integer)<br><br>        If the callback returns False, the anneal is terminated immediately and<br>        the current solution is returned.<br>    kernel : :py:class:`~rig.place_and_route.place.sa.kernel.Kernel`<br>        A simulated annealing placement kernel. A sensible default will be<br>        chosen based on the available kernels on this machine. The kernel may<br>        not be used if the placement problem has a trivial solution.<br>    kernel_kwargs : dict<br>        Optional kernel-specific keyword arguments to pass to the kernel<br>        constructor.<br>    """<br>    # Special case: just return immediately when there's nothing to place<br>    if len(vertices_resources) == 0:<br>        return {}<br><br>    # Within the algorithm we modify the resource availability values in the<br>    # machine to account for the effects of the current placement. As a result,<br>    # an internal copy of the structure must be made.<br>    machine = machine.copy()<br><br>    # {vertex: (x, y), ...} gives the location of all vertices whose position<br>    # is fixed by a LocationConstraint.<br>    fixed_vertices = {}<br><br>    # Handle constraints<br>    vertices_resources, nets, constraints, substitutions = \<br>        apply_same_chip_constraints(vertices_resources, nets, constraints)<br>    for constraint in constraints:<br>        if isinstance(constraint, LocationConstraint):<br>            # Location constraints are handled by recording the set of fixed<br>            # vertex locations and subtracting their resources from the chips<br>            # they're allocated to. These vertices will then not be added to<br>            # the internal placement data structure to prevent annealing from<br>            # moving them. They will be re-introduced at the last possible<br>            # moment.<br>            location = constraint.location<br>            if location not in machine:<br>                raise InvalidConstraintError(<br>                    "Chip requested by {} unavailable".format(machine))<br>            vertex = constraint.vertex<br><br>            # Record the constrained vertex's location<br>            fixed_vertices[vertex] = location<br><br>            # Make sure the vertex fits at the requested location (updating the<br>            # resource availability after placement)<br>            resources = vertices_resources[vertex]<br>            machine[location] = subtract_resources(machine[location],<br>                                                   resources)<br>            if overallocated(machine[location]):<br>                raise InsufficientResourceError(<br>                    "Cannot meet {}".format(constraint))<br>        elif isinstance(constraint,  # pragma: no branch<br>                        ReserveResourceConstraint):<br>            apply_reserve_resource_constraint(machine, constraint)<br><br>    # Initially randomly place the movable vertices<br>    movable_vertices = {v for v in vertices_resources<br>                        if v not in fixed_vertices}<br>    initial_placements = _initial_placement(movable_vertices,<br>                                            vertices_resources,<br>                                            machine, random)<br><br>    # Include the fixed vertices in initial placement<br>    initial_placements.update(fixed_vertices)<br><br>    # Filter out empty or singleton nets and those weighted as zero since they<br>    # cannot influence placement.<br>    nets = [n for n in nets if len(set(n))  1 and n.weight  0.0]<br><br>    # Special cases where no placement effort is required:<br>    #  There is only one chip<br>    #  There are no resource types to be consumed<br>    #  No effort is to be made<br>    #  No movable vertices<br>    #  There are no nets (and moving things has no effect)<br>    trivial = ((machine.width, machine.height) == (1, 1) or<br>               len(machine.chip_resources) == 0 or<br>               effort == 0.0 or<br>               len(movable_vertices) == 0 or<br>               len(nets) == 0)<br>    if trivial:<br>        logger.info("Placement has trivial solution. SA not used.")<br>        finalise_same_chip_constraints(substitutions, initial_placements)<br>        return initial_placements<br><br>    # Intialise the algorithm kernel<br>    k = kernel(vertices_resources, movable_vertices, set(fixed_vertices),<br>               initial_placements, nets, machine, random, kernel_kwargs)<br><br>    logger.info("SA placement kernel: %s", kernel.__name__)<br><br>    # Specifies the maximum distance any swap can span. Initially consider<br>    # swaps that span the entire machine.<br>    distance_limit = max(machine.width, machine.height)<br><br>    # Determine initial temperature according to the heuristic used by VPR: 20<br>    # times the standard deviation of len(movable_vertices) random swap costs.<br>    # The arbitrary very-high temperature is used to cause "all" swaps to be<br>    # accepted.<br>    _0, _1, cost_delta_sd = k.run_steps(len(movable_vertices),<br>                                        distance_limit,<br>                                        1e100)<br>    temperature = 20.0  cost_delta_sd<br><br>    # The number of swap-attempts between temperature changes is selected by<br>    # the heuristic used by VPR. This value is scaled linearly by the effort<br>    # parameter.<br>    num_steps = max(1, int(effort  len(vertices_resources)1.33))<br><br>    logger.info("Initial placement temperature: %0.1f", temperature)<br><br>    # Counter for the number of swap attempts made (used for diagnostic<br>    # purposes)<br>    iteration_count = 0<br><br>    # Holds the total cost of the current placement. This default value chosen<br>    # to ensure the loop below iterates at least once.<br>    current_cost = 0.0<br><br>    # The annealing algorithm runs until a heuristic termination condition<br>    # (taken from VPR) is hit. The heuristic waits until the temperature falls<br>    # below a small fraction of the average net cost.<br>    while temperature  (0.005  current_cost) / len(nets):<br>        # Run an iteration at the current temperature<br>        num_accepted, current_cost, _ = k.run_steps(<br>            num_steps, int(math.ceil(distance_limit)), temperature)<br><br>        # The ratio of accepted-to-not-accepted changes<br>        r_accept = num_accepted / float(num_steps)<br><br>        # Special case: Can't do better than 0 cost! This is a special case<br>        # since the normal termination condition will not terminate if the cost<br>        # doesn't drop below 0.<br>        if current_cost == 0:<br>            break<br><br>        # The temperature is reduced by a factor heuristically based on the<br>        # acceptance rate. The schedule below attempts to maximise the time<br>        # spent at temperatures where a large portion (but not all) of changes<br>        # are being accepted. If lots of changes are being accepted (e.g.<br>        # during high-temperature periods) then most of them are likely not to<br>        # be beneficial. If few changes are being accepted, we're probably<br>        # pretty close to the optimal placement.<br>        if r_accept  0.96:<br>            alpha = 0.5<br>        elif r_accept  0.8:<br>            alpha = 0.9<br>        elif r_accept  0.15:<br>            alpha = 0.95<br>        else:<br>            alpha = 0.8<br>        temperature = alpha  temperature<br><br>        # According to:<br>        #  M. Huang, F. Romeo, and A. Sangiovanni-Vincentelli, "An Efficient<br>        #   General Cooling Schedule for Simulated Annealing" ICCAD, 1986, pp.<br>        #   381 - 384 and J. Lam<br>        #  J. Delosme, "Performance of a New Annealing Schedule" DAC, 1988,<br>        #   pp. 306 - 311.<br>        # It is desirable to keep the acceptance ratio as close to 0.44 for as<br>        # long as possible. As a result, when r_accept falls below this we can<br>        # help increase the acceptance rate by reducing the set of possible<br>        # swap candidates based on the observation that near the end of<br>        # placement, most things are near their optimal location and thus long<br>        # distance swaps are unlikely to be useful.<br>        distance_limit = 1.0 - 0.44 + r_accept<br>        distance_limit = min(max(distance_limit, 1.0),<br>                             max(machine.width, machine.height))<br><br>        iteration_count += num_steps<br>        logger.debug("Iteration: %d, "<br>                     "Cost: %0.1f, "<br>                     "Kept: %0.1f%%, "<br>                     "Temp: %0.3f, "<br>                     "Dist: %d.",<br>                     iteration_count, current_cost,<br>                     r_accept100, temperature, math.ceil(distance_limit))<br><br>        # Call the user callback before the next iteration, terminating if<br>        # requested.<br>        if on_temperature_change is not None:<br>            placements = k.get_placements().copy()<br>            finalise_same_chip_constraints(substitutions, placements)<br>            ret_val = on_temperature_change(iteration_count,<br>                                            placements,<br>                                            current_cost,<br>                                            r_accept,<br>                                            temperature,<br>                                            distance_limit)<br>            if ret_val is False:<br>                break<br><br>    logger.info("Anneal terminated after %d iterations.", iteration_count)<br><br>    placements = k.get_placements()<br>    finalise_same_chip_constraints(substitutions, placements)<br><br>    return placements

### DOC[5] (IRRELEVANT) leetcode/leetcode_782.txt
> def numJewelsInStones(jewels, stones):<br>    """You are given an `n x n` binary grid `board`. In each move, you can swap any two rows with each other, or any two columns with each other.<br><br>Return _the minimum number of moves to transform the board into a chessboard board_. If the task is impossible, return `-1`.<br><br>A chessboard board is a board where no `0`'s and no `1`'s are 4-directionally adjacent.<br><br>Example 1:<br><br>Input: board = \[\[0,1,1,0\],\[0,1,1,0\],\[1,0,0,1\],\[1,0,0,1\]\]<br>Output: 2<br>Explanation: One potential sequence of moves is shown.<br>The first move swaps the first and second column.<br>The second move swaps the second and third row.<br><br>Example 2:<br><br>Input: board = \[\[0,1\],\[1,0\]\]<br>Output: 0<br>Explanation: Also note that the board with 0 in the top left corner, is also a valid chessboard.<br><br>Example 3:<br><br>Input: board = \[\[1,0\],\[1,0\]\]<br>Output: -1<br>Explanation: No matter what sequence of moves you make, you cannot end with a valid chessboard.<br><br>Constraints:<br><br>   `n == board.length`<br>   `n == board[i].length`<br>   `2 <= n <= 30`<br>   `board[i][j]` is either `0` or `1`."""<br><br>    count = 0<br>    for s in stones:<br>        if s in jewels:<br>            count += 1<br>    return count


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_51.txt
> def solveNQueens(n):<br>    """The n-queens puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.<br><br>Given an integer `n`, return _all distinct solutions to the n-queens puzzle_. You may return the answer in any order.<br><br>Each solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.<br><br>Example 1:<br><br>Input: n = 4<br>Output: \[\[ ".Q.. ", "...Q ", "Q... ", "..Q. "\],\[ "..Q. ", "Q... ", "...Q ", ".Q.. "\]\]<br>Explanation: There exist two distinct solutions to the 4-queens puzzle as shown above<br><br>Example 2:<br><br>Input: n = 1<br>Output: \[\[ "Q "\]\]<br><br>Constraints:<br><br>   `1 <= n <= 9`"""<br><br>    def isSafe(board, row, col):<br>        for i in range(col):<br>            if board[row][i] == 'Q': return False<br>        i, j = row, col<br>        while i = 0 and j = 0:<br>            if board[i][j] == 'Q': return False<br>            i, j = i - 1, j - 1<br>        i, j = row, col<br>        while i < n and j = 0:<br>            if board[i][j] == 'Q': return False<br>            i, j = i + 1, j - 1<br>        return True<br><br>    def solve(result, board, n, col):<br>        if col == n:<br>            result.append(board.copy())<br>            return<br>        for row in range(n):<br>            if isSafe(board, row, col):<br>                board[row] = board[row][:col] + 'Q' + board[row][col + 1:]<br>                solve(result, board, n, col + 1)<br>                board[row] = board[row][:col] + '.' + board[row][col + 1:]<br><br>    result, board = [], ['.'  n for _ in range(n)]<br>    solve(result, board, n, 0)<br>    return result
