# Query `8`

## Original Question

*Convert a non-negative integer `num` to its English words representation.

Example 1:

Input: num = 123
Output:  "One Hundred Twenty Three "

Example 2:

Input: num = 12345
Output:  "Twelve Thousand Three Hundred Forty Five "

Example 3:

Input: num = 1234567
Output:  "One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven "

Constraints:

   `0 <= num <= 231 - 1`*

## gpt4 Reasoning

```markdown
The essential problem here is converting a non-negative integer to its English words representation, adhering to the grammatical rules of English number naming. This task involves breaking down the number into understandable chunks, mapping those chunks to their English word equivalents, and then assembling those words in a grammatically correct order that represents the original number.

### Step-by-Step Solution:

#### 1. Understanding the Number System:
- English words for numbers are based on a combination of unique names for numbers less than 20, tens (20, 30, 40, etc.), and powers of a thousand (thousand, million, billion, etc.).
- Numbers are grouped in sets of three digits (thousands, millions, billions) when converting them to words, reflecting the use of commas in the numeric representation (e.g., 1,234,567).

#### 2. Breaking Down the Problem:
- **Chunking the Number**: Divide the number into chunks of three digits, starting from the right (e.g., 1234567 -> 1,234,567 -> ['567', '234', '1']).
- **Mapping to Words**: For each chunk, convert it to words as if it were an independent number, keeping in mind:
  - Numbers 0-19 have unique names.
  - Tens (20, 30, etc.) have specific names.
  - Hundreds are represented by prefixing the number 1-9 names with "hundred" (e.g., "One Hundred").
- **Adding Scale**: After converting a chunk to words, append the appropriate scale name (thousand, million, etc.) unless the chunk is the last (rightmost) or its value is 0.

#### 3. Considerations:
- **Zero**: Special case where the input is 0, the output should be "Zero".
- **Joining Words**: Words within a chunk should be joined with spaces, and there should be a space before the scale name (if any).
- **Recursive or Iterative Approach**: This problem can be approached either way. A recursive approach might convert each chunk to words and then append the appropriate scale name, calling itself with the remaining number. An iterative approach would loop through each chunk, converting and assembling the word representation.

#### 4. Implementation Notes:
- **Data Structures**: Utilizing dictionaries or arrays for mapping numbers to words and scales to their names can simplify the conversion process.
- **Function Design**: A helper function can manage the conversion of each three-digit chunk to words, while the main function handles chunking the number, calling the helper for each chunk, and assembling the final string.

#### 5. Example Walkthrough (12345):
- Chunking: 12,345 -> ['345', '12'].
- Convert '345': "Three Hundred Forty Five".
- Convert '12': "Twelve".
- Assemble: "Twelve Thousand Three Hundred Forty Five".

By carefully structuring the approach to handle each part of the problem—chunking the number, mapping chunks to words, handling special cases like zero and scales, and finally assembling the full string representation—we can effectively convert any non-negative integer into its English words representation within the given constraints.
```

### Metrics

```
recip_rank: 0.0056
P_1: 0.0000
P_5: 0.0000
P_10: 0.0000
P_25: 0.0000
P_50: 0.0000
P_100: 0.0000
recall_1: 0.0000
recall_5: 0.0000
recall_10: 0.0000
recall_25: 0.0000
recall_50: 0.0000
recall_100: 0.0000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.0000
ndcg_cut_10: 0.0000
ndcg_cut_25: 0.0000
ndcg_cut_50: 0.0000
ndcg_cut_100: 0.0000
map_cut_1: 0.0000
map_cut_5: 0.0000
map_cut_10: 0.0000
map_cut_25: 0.0000
map_cut_50: 0.0000
map_cut_100: 0.0000
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/csn_python_train_58076.txt
> def phone_text_subs():<br>  """<br>  Gets a dictionary of dictionaries that each contain alphabetic number manifestations mapped to their actual<br>  Number value.<br><br>  Returns:<br>    dictionary of dictionaries containing Strings mapped to Numbers<br><br>  """<br><br>  Small = {<br>    'zero': 0,<br>    'zer0': 0,<br>    'one': 1,<br>    'two': 2,<br>    'three': 3,<br>    'four': 4,<br>    'fuor': 4,<br>    'five': 5,<br>    'fith': 5,<br>    'six': 6,<br>    'seven': 7,<br>    'sven': 7,<br>    'eight': 8,<br>    'nine': 9,<br>    'ten': 10,<br>    'eleven': 11,<br>    'twelve': 12,<br>    'thirteen': 13,<br>    'fourteen': 14,<br>    'fifteen': 15,<br>    'sixteen': 16,<br>    'seventeen': 17,<br>    'eighteen': 18,<br>    'nineteen': 19,<br>    'twenty': 20,<br>    'thirty': 30,<br>    'forty': 40,<br>    'fifty': 50,<br>    'sixty': 60,<br>    'seventy': 70,<br>    'eighty': 80,<br>    'ninety': 90,<br>    'oh': 0<br>  }<br><br>  Magnitude = {<br>    'thousand': 000,<br>    'million': 000000,<br>  }<br><br>  Others = {<br>    '!': 1,<br>    'o': 0,<br>    'l': 1,<br>    'i': 1<br>  }<br><br>  output = {}<br>  output['Small'] = Small<br>  output['Magnitude'] = Magnitude<br>  output['Others'] = Others<br><br>  return output

### DOC[2] (IRRELEVANT) leetcode/csn_python_train_342755.txt
> def int_to_words(number, european=False):<br>    """<br>    Converts an integer or float to words.<br><br>    .. code: python<br><br>        reusables.int_to_number(445)<br>        # 'four hundred forty-five'<br><br>        reusables.int_to_number(1.45)<br>        # 'one and forty-five hundredths'<br><br>    :param number: String, integer, or float to convert to words. The decimal<br>        can only be up to three places long, and max number allowed is 999<br>        decillion.<br>    :param european: If the string uses the european style formatting, i.e.<br>        decimal points instead of commas and commas instead of decimal points,<br>        set this parameter to True<br>    :return: The translated string<br>    """<br>    def ones(n):<br>        return "" if n == 0 else _numbers[n]<br><br>    def tens(n):<br>        teen = int("{0}{1}".format(n[0], n[1]))<br><br>        if n[0] == 0:<br>            return ones(n[1])<br>        if teen in _numbers:<br>            return _numbers[teen]<br>        else:<br>            ten = _numbers[int("{0}0".format(n[0]))]<br>            one = _numbers[n[1]]<br>            return "{0}-{1}".format(ten, one)<br><br>    def hundreds(n):<br>        if n[0] == 0:<br>            return tens(n[1:])<br>        else:<br>            t = tens(n[1:])<br>            return "{0} hundred {1}".format(_numbers[n[0]], "" if not t else t)<br><br>    def comma_separated(list_of_strings):<br>        if len(list_of_strings)  1:<br>            return "{0} ".format("" if len(list_of_strings) == 2<br>                                 else ",").join(list_of_strings)<br>        else:<br>            return list_of_strings[0]<br><br>    def while_loop(list_of_numbers, final_list):<br>        index = 0<br>        group_set = int(len(list_of_numbers) / 3)<br>        while group_set != 0:<br>            value = hundreds(list_of_numbers[index:index + 3])<br>            if value:<br>                final_list.append("{0} {1}".format(value, _places[group_set])<br>                                  if _places[group_set] else value)<br>            group_set -= 1<br>            index += 3<br><br>    number_list = []<br>    decimal_list = []<br><br>    decimal = ''<br>    number = str(number)<br>    group_delimiter, point_delimiter = (",", ".") \<br>        if not european else (".", ",")<br><br>    if point_delimiter in number:<br>        decimal = number.split(point_delimiter)[1]<br>        number = number.split(point_delimiter)[0].replace(<br>            group_delimiter, "")<br>    elif group_delimiter in number:<br>        number = number.replace(group_delimiter, "")<br><br>    if not number.isdigit():<br>        raise ValueError("Number is not numeric")<br><br>    if decimal and not decimal.isdigit():<br>        raise ValueError("Decimal is not numeric")<br><br>    if int(number) == 0:<br>        number_list.append("zero")<br><br>    r = len(number) % 3<br>    d_r = len(decimal) % 3<br>    number = number.zfill(len(number) + 3 - r if r else 0)<br>    f_decimal = decimal.zfill(len(decimal) + 3 - d_r if d_r else 0)<br><br>    d = [int(x) for x in f_decimal]<br>    n = [int(x) for x in number]<br><br>    while_loop(n, number_list)<br><br>    if decimal and int(decimal) != 0:<br>        while_loop(d, decimal_list)<br><br>        if decimal_list:<br>            name = ''<br>            if len(decimal) % 3 == 1:<br>                name = 'ten'<br>            elif len(decimal) % 3 == 2:<br>                name = 'hundred'<br><br>            place = int((str(len(decimal) / 3).split(".")[0]))<br>            number_list.append("and {0} {1}{2}{3}ths".format(<br>                comma_separated(decimal_list), name,<br>                "-" if name and _places[place+1] else "", _places[place+1]))<br><br>    return comma_separated(number_list)

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_223125.txt
> def num2tamilstr_american( args ):<br>    number = args[0]<br>    """ work till 1000 trillion  - 1 - i.e  = 1e121e3 - 1.<br>        turn number into a numeral, American style. Fractions upto 1e-30. """<br><br>    if not any( filter( lambda T: isinstance( number, T), [int, str, unicode, long, float]) ) or isinstance(number,complex):<br>        raise Exception('num2tamilstr_american input has to be long or integer')<br>    if float(number) = long(1e15):<br>        raise Exception('num2tamilstr input is too large')<br>    if float(number) < 0:<br>        return u"- "+num2tamilstr_american( -float(number) )<br><br>    units = (u'பூஜ்ஜியம்', u'ஒன்று', u'இரண்டு', u'மூன்று', u'நான்கு', u'ஐந்து', u'ஆறு', u'ஏழு', u'எட்டு', u'ஒன்பது', u'பத்து') # 0-10<br>    hundreds = ( u'நூறு', u'இருநூறு', u'முன்னூறு', u'நாநூறு',u'ஐநூறு', u'அறுநூறு', u'எழுநூறு', u'எண்ணூறு', u'தொள்ளாயிரம்') #100 - 900<br><br>    one_thousand_prefix = u'ஓர்'<br>    thousands = (u'ஆயிரம்',u'ஆயிரத்து')<br><br>    one_prefix = u'ஒரு'<br>    mil = u'மில்லியன்'<br>    million = (mil,mil)<br><br>    bil = u'பில்லியன்'<br>    billion = (bil,bil)<br><br>    tril = u'டிரில்லியன்'<br>    trillion = (tril,tril)<br><br>    n_one = 1<br>    n_ten = 10<br>    n_hundred = 100<br>    n_thousand = 1000<br>    n_million = 1000n_thousand<br>    n_billion = long(1000n_million)<br>    n_trillion = long(1000n_billion)<br><br>    suffix_base = { n_trillion: trillion,<br>                    n_billion : billion,<br>                    n_million : million,<br>                    n_thousand : thousands}<br><br>    num_map = {n_trillion : [one_prefix,trillion[0]],<br>               n_billion : [one_prefix,billion[0]],<br>               n_million  : [one_prefix,million[0]],<br>               n_thousand : [one_thousand_prefix, thousands[0]],<br>               n_hundred : [hundreds[0]], #special<br>               n_ten : [units[10]],<br>               n_one : [units[1]]}<br><br>    all_bases = [n_trillion,n_billion, n_million, n_thousand, n_hundred, n_ten,n_one]<br>    allowed_bases = list(filter( lambda base: float(number) = base, all_bases ))<br><br>    # handle fractional parts<br>    if float(number)  0.0 and float(number) <= 1000.0:<br>        return num2tamilstr(number)<br><br>    if isinstance(number,str) or isinstance(number,unicode):<br>        result = u""<br>        number = number.strip()<br>        assert(len(args) == 1)<br>        assert(len(number)  0)<br>        is_negative = number[0] == "-"<br>        if  is_negative:<br>            number = number[1:]<br>        frac_part = u""<br>        if number.find(".") = 0:<br>            rat_part,frac_part = number.split(".")<br>            frac_part = num2tamilstr_american(u"0."+frac_part)<br>        else:<br>            rat_part = number<br>        if len(rat_part)  0:<br>            result = num2tamilstr_american(float(rat_part))<br>        result = result +u" "+ frac_part<br>        return result.strip()<br><br>    if len(allowed_bases) = 1:<br>        n_base = allowed_bases[0]<br>        if number == n_base:<br>            return u" ".join(num_map[n_base])<br>        quotient_number = long( number/n_base )<br>        residue_number = number - n_basequotient_number<br><br>        if n_base < n_thousand:<br>            raise Exception("This can never happen")<br>        else:<br>            if ( quotient_number == 1 ):<br>                if n_base == n_thousand:<br>                    numeral = one_thousand_prefix+u' '<br>                else:<br>                    numeral = one_prefix+u' '<br>            else:<br>                numeral = num2tamilstr( quotient_number )<br>        if n_base = n_thousand:<br>            suffix = suffix_base[n_base][long(residue_number = 1)]<br>            if residue_number == 0:<br>                return numeral + u' ' + suffix<br>            numeral = numeral + u' ' + suffix<br>        residue_numeral = num2tamilstr_american( residue_number )<br>        return numeral+u' '+residue_numeral<br><br>    # number has to be zero<br>    return units[0]

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_281413.txt
> def NumbersToWords(number):<br>    """<br>    little function that converts numbers to words. This could be more efficient,<br>    and won't work if the number is bigger than 999 but it's for stave names,<br>    and I doubt any part would have more than 10 staves let alone 999.<br>    """<br><br>    units = [<br>        'one',<br>        'two',<br>        'three',<br>        'four',<br>        'five',<br>        'six',<br>        'seven',<br>        'eight',<br>        'nine']<br>    tens = [<br>        'ten',<br>        'twenty',<br>        'thirty',<br>        'forty',<br>        'fifty',<br>        'sixty',<br>        'seventy',<br>        'eighty',<br>        'ninety']<br>    output = ""<br>    if number != 0:<br>        str_val = str(number)<br>        if 4  len(str_val)  2:<br>            output += units[int(str_val[0]) - 1]<br>            output += "hundred"<br>            if str_val[1] != 0:<br>                output += "and" + tens[int(str_val[1]) - 1]<br>                if str_val[2] != 0:<br>                    output += units[int(str_val[2]) - 1]<br>        if 3  len(str_val)  1:<br>            output += tens[int(str_val[0]) - 1]<br>            if str_val[1] != 0:<br>                output += units[int(str_val[1]) - 1]<br>        if 2  len(str_val) == 1:<br>            output += units[int(str_val[0]) - 1]<br>    else:<br>        output = "zero"<br>    return output

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_223124.txt
> def num2tamilstr( args ):<br>    """ work till one lakh crore - i.e 1e51e7 = 1e12.<br>        turn number into a numeral, Indian style. Fractions upto 1e-30"""<br>    number = args[0]<br>    if len(args) < 2:<br>        filenames = []<br>    else:<br>        filenames = args[1]<br>    if len(args) ==3:<br>        tensSpecial = args[2]<br>    else:<br>        tensSpecial='BASIC'<br>    if not any( filter( lambda T: isinstance( number, T), [str,unicode,int, long, float]) ) or isinstance(number,complex):<br>        raise Exception('num2tamilstr input has to be a long or integer or float')<br>    if float(number)  long(1e12):<br>        raise Exception('num2tamilstr input is too large')<br>    if float(number) < 0:<br>        return u"- "+num2tamilstr( -number )<br><br>    units = (u'பூஜ்ஜியம்', u'ஒன்று', u'இரண்டு', u'மூன்று', u'நான்கு', u'ஐந்து', u'ஆறு', u'ஏழு', u'எட்டு', u'ஒன்பது', u'பத்து') # 0-10<br>    units_suffix = (u'பூஜ்ஜியம்', u'தொன்று', u'திரண்டு', u'மூன்று', u'நான்கு', u'தைந்து', u'தாறு', u'தேழு', u'தெட்டு', u'தொன்பது', u'பத்து') # 0-10<br>    units_suffix_nine = (u'பூஜ்ஜியம்', u'றொன்று', u'றிரண்டு', u'மூன்று', u'நான்கு', u'றைந்து', u'றாறு', u'றேழு', u'றெட்டு', u'றொன்பது', u'பத்து') # 0-10<br>    tween = [1.0,2.0,5.0,6.0,7.0,8.0,9.0]<br>    teens = (u'பதினொன்று', u'பனிரண்டு', u'பதிமூன்று', u'பதினான்கு', u'பதினைந்து',u'பதினாறு', u'பதினேழு', u'பதினெட்டு', u'பத்தொன்பது') # 11-19<br>    tens = (u'பத்து', u'இருபது', u'முப்பது', u'நாற்பது', u'ஐம்பது',u'அறுபது', u'எழுபது', u'எண்பது', u'தொன்னூறு') # 10-90<br>    tens_full_prefix = (u'இருபத்து', u'முப்பத்து', u'நாற்பத்து', u'ஐம்பத்து', u'அறுபத்து', u'எழுபத்து', u'எண்பத்து', u'தொன்னூற்று') # 10+-90+<br>    tens_prefix = (u'இருபத்', u'முப்பத்', u'நாற்பத்', u'ஐம்பத்', u'அறுபத்', u'எழுபத்', u'எண்பத்', u'தொன்னூற்') # 10+-90+<br>    hundreds = ( u'நூறு', u'இருநூறு', u'முன்னூறு', u'நாநூறு',u'ஐநூறு', u'அறுநூறு', u'எழுநூறு', u'எண்ணூறு', u'தொள்ளாயிரம்') #100 - 900<br>    hundreds_suffix = (u'நூற்றி', u'இருநூற்று', u'முன்னூற்று', u'நாநூற்று', u'ஐநூற்று', u'அறுநூற்று', u'எழுநூற்று', u'எண்ணூற்று',u'தொள்ளாயிரத்து') #100+ - 900+<br><br>    one_thousand_prefix = u'ஓர்'<br>    thousands = (u'ஆயிரம்',u'ஆயிரத்து')<br><br>    one_prefix = u'ஒரு'<br>    lakh = (u'இலட்சம்',u'இலட்சத்து')<br>    crore = (u'கோடி',u'கோடியே')<br><br>    pulli = u'புள்ளி'<br>    n_one = 1.0<br>    n_ten = 10.0<br>    n_hundred = 100.0<br>    n_thousand = 1000.0<br>    n_lakh = 100.0n_thousand<br>    n_crore = (100.0n_lakh)<br>    # handle fractional parts<br>    if float(number)  0.0 and float(number) < 1.0:<br>        rval = []<br>        rval.append(pulli)<br>        filenames.append( 'pulli' )<br>        number_str = str(number).replace('0.','')<br>        for digit in number_str:<br>            filenames.append( "units_%d"%int(digit))<br>            rval.append( units[int(digit)] )<br>        return u' '.join(rval)<br><br>    if isinstance(number,str) or isinstance(number,unicode):<br>        result = u""<br>        number = number.strip()<br>        assert(len(args) == 1)<br>        assert(len(number)  0)<br>        is_negative = number[0] == "-"<br>        if  is_negative:<br>            number = number[1:]<br>        frac_part = u""<br>        if number.find(".") = 0:<br>            rat_part,frac_part = number.split(".")<br>            frac_part = num2tamilstr(u"0."+frac_part)<br>        else:<br>            rat_part = number<br>        if len(rat_part)  0:<br>            result = num2tamilstr(float(rat_part))<br>        result = result +u" "+ frac_part<br>        return is_negative and "-" + result.strip() or result.strip()<br><br>    suffix_base = { n_crore: crore, n_lakh : lakh, n_thousand : thousands}<br>    suffix_file_map = {n_crore: "crore", n_lakh : "lakh", n_thousand : "thousands"}<br><br>    file_map = {n_crore :["one_prefix","crore_0"],<br>                n_lakh : ["one_prefix","lakh_0"],<br>                n_thousand :  ["one_thousand_prefix", "thousands_0"],<br>               n_hundred : ["hundreds_0"], #special<br>               n_ten : ["units_10"],<br>               n_one : ["units_1"]}<br><br>    num_map = {n_crore : [one_prefix,crore[0]],<br>               n_lakh  : [one_prefix,lakh[0]],<br>               n_thousand : [one_thousand_prefix, thousands[0]],<br>               n_hundred : [hundreds[0]], #special<br>               n_ten : [units[10]],<br>               n_one : [units[1]]}<br><br>    all_bases = [n_crore, n_lakh, n_thousand, n_hundred, n_ten,n_one]<br>    allowed_bases = list(filter( lambda base: number = base, all_bases ))<br>    if len(allowed_bases) = 1:<br>        n_base = allowed_bases[0]<br>        if number == n_base:<br>            if tensSpecial=='BASIC':<br>                filenames.extend(file_map[n_base])<br>                return u" ".join(num_map[n_base])<br>            elif tensSpecial=='NINES':<br>                filenames.extend(file_map[n_base])<br>                return units_suffix_nine[long(number%10)]<br>            else:<br>                filenames.extend(file_map[n_base])<br>                return units_suffix[long(number%10)]<br>        quotient_number = long( number/n_base )<br>        residue_number = number - n_basequotient_number<br>        #print number, n_base, quotient_number, residue_number, tensSpecial<br>        if n_base == n_one:<br>            if isinstance(number,float):<br>                int_part = long(number%10)<br>                frac = number - float(int_part)<br>                filenames.append("units_%d"%int_part)<br>                if abs(frac)  1e-30:<br>                    if tensSpecial=='BASIC':<br>                        return units[int_part]+u' ' + num2tamilstr(frac,filenames)<br>                    elif tensSpecial=='NINES':<br>                        return units_suffix_nine[int_part]+u' ' + num2tamilstr(frac,filenames)<br>                    else:<br>                        return units_suffix[int_part]+u' ' + num2tamilstr(frac,filenames)<br><br>                else:<br>                    if tensSpecial=='BASIC':<br>                        return units[int_part]<br>                    elif tensSpecial=='NINES':<br>                        return units_suffix_nine[int_part]<br>                    else:<br>                        return units_suffix[int_part]<br>            else:<br>                if tensSpecial=='BASIC':<br>                    filenames.append("units_%d"%number)<br>                    return units[number]<br>                elif tensSpecial=='NINES':<br>                    filenames.append("units_%d"%number)<br>                    return units_suffix_nine[number]<br>                else:<br>                    filenames.append("units_%d"%number)<br>                    return units_suffix[number]<br><br>        elif n_base == n_ten:<br>            if residue_number < 1.0:<br>                filenames.append("tens_%d"%(quotient_number-1))<br>                if residue_number == 0.0:<br>                    return tens[quotient_number-1]<br>                #else: //seems not reachable.<br>                #    numeral = tens[quotient_number-1]<br>            elif number < 20:<br>                filenames.append("teens_%d"%(number-10))<br>                residue_number = math.fmod(number,1)<br>                teen_number = int(math.floor(number - 10))<br>                if residue_number  1e-30:<br>                    return teens[teen_number-1] +u' ' + num2tamilstr(residue_number,filenames)<br>                else:<br>                    return teens[teen_number-1]+u' '<br>            if residue_number < 1.0:<br>                filenames.append( "tens_%d"%(quotient_number-1) )<br>                numeral = tens[quotient_number-1]+u' '<br>            else:<br>                if residue_number in tween:<br>                    filenames.append( "tens_prefix_%d"%(quotient_number-2) )<br>                    numeral = tens_prefix[quotient_number-2]<br>                    tensSpecial='SPECIAL'<br>                    if (quotient_number==9):<br>                        tensSpecial = 'NINES'<br>                else:<br>                    filenames.append( "tens_prefix_%d"%(quotient_number-2) )<br>                    numeral = tens_full_prefix[quotient_number-2]+u' '<br>        elif n_base == n_hundred:<br>            if residue_number == 0:<br>                filenames.append("hundreds_%d"%(quotient_number-1))<br>                return hundreds[quotient_number-1]+u' '<br>            if residue_number < 1.0:<br>                filenames.append( "hundreds_%d"%(quotient_number-1) )<br>                numeral = hundreds[quotient_number-1]+u' '<br>            else:<br>                filenames.append("hundreds_suffix_%d"%(quotient_number-1))<br>                numeral = hundreds_suffix[quotient_number-1]+u' '<br>        else:<br>            if ( quotient_number == 1 ):<br>                if n_base == n_thousand:<br>                    filenames.append("one_thousand_prefix")<br>                    numeral = one_thousand_prefix<br>                else:<br>                    filenames.append("one_prefix")<br>                    numeral = one_prefix<br>            else:<br>                numeral = num2tamilstr( quotient_number, filenames )<br>        if n_base = n_thousand:<br>            suffix = suffix_base[n_base][long(residue_number = 1)]<br>            suffix_filename = "%s_%d"%(suffix_file_map[n_base],long(residue_number = 1))<br>            if residue_number == 0:<br>                filenames.append(suffix_filename)<br>                return numeral + u' ' + suffix+u' '<br>            filenames.append(suffix_filename)<br>            numeral = numeral + u' ' + suffix+u' '<br>        residue_numeral = num2tamilstr( residue_number, filenames, tensSpecial)<br>        #return numeral+u' '+residue_numeral<br>        return numeral+residue_numeral<br>    # number has to be zero<br>    filenames.append("units_0")<br>    return units[0]


## Ground Truth

### GROUND TRUTH 0, ranked not in top 100, leetcode/leetcode_12.txt
> def int_to_roman(num):<br>    """Roman numerals are represented by seven different symbols: `I`, `V`, `X`, `L`, `C`, `D` and `M`.<br><br>Symbol       Value<br>I             1<br>V             5<br>X             10<br>L             50<br>C             100<br>D             500<br>M             1000<br><br>For example, `2` is written as `II` in Roman numeral, just two one's added together. `12` is written as `XII`, which is simply `X + II`. The number `27` is written as `XXVII`, which is `XX + V + II`.<br><br>Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. There are six instances where subtraction is used:<br><br>   `I` can be placed before `V` (5) and `X` (10) to make 4 and 9.<br>   `X` can be placed before `L` (50) and `C` (100) to make 40 and 90.<br>   `C` can be placed before `D` (500) and `M` (1000) to make 400 and 900.<br><br>Given an integer, convert it to a roman numeral.<br><br>Example 1:<br><br>Input: num = 3<br>Output:  "III "<br>Explanation: 3 is represented as 3 ones.<br><br>Example 2:<br><br>Input: num = 58<br>Output:  "LVIII "<br>Explanation: L = 50, V = 5, III = 3.<br><br>Example 3:<br><br>Input: num = 1994<br>Output:  "MCMXCIV "<br>Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.<br><br>Constraints:<br><br>   `1 <= num <= 3999`"""<br><br>    romans = [<br>        (1000, "M"), (900, "CM"), (500, "D"),<br>        (400, "CD"), (100, "C"), (90, "XC"),<br>        (50, "L"), (40, "XL"), (10, "X"), <br>        (9, "IX"), (5, "V"), (4, "IV"), (1, "I")<br>    ]<br>    roman = ""<br>    for value, symbol in romans:<br>        while num = value:<br>            roman += symbol<br>            num -= value<br>    return roman
