# Query `42`

## Original Question

*You may recall that an array `arr` is a mountain array if and only if:

   `arr.length >= 3`
   There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that:
       `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`
       `arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`

Given an integer array `arr`, return _the length of the longest subarray, which is a mountain_. Return `0` if there is no mountain subarray.

Example 1:

Input: arr = \[2,1,4,7,3,2,5\]
Output: 5
Explanation: The largest mountain is \[1,4,7,3,2\] which has length 5.

Example 2:

Input: arr = \[2,2,2\]
Output: 0
Explanation: There is no mountain.

Constraints:

   `1 <= arr.length <= 104`
   `0 <= arr[i] <= 104`

Follow up:

   Can you solve it using only one pass?
   Can you solve it in `O(1)` space?*

## gpt4 Reasoning

```markdown
The essential problem here is to identify the length of the longest subarray within a given array `arr` that forms a mountain. A mountain subarray is defined by a sequence of strictly increasing elements followed by a sequence of strictly decreasing elements, with at least one element in each sequence, making the minimum length of a mountain subarray 3. The task involves not only identifying such subarrays but also determining the longest among them, if any exist.

To address this problem, especially under the constraints of doing so in a single pass (iterating through the array just once) and ideally using `O(1)` extra space (not using additional space that grows with the input size), we can break down the solution into the following steps:

### Step 1: Initialization
- Initialize variables to keep track of the current subarray's length, the longest mountain's length found so far, and the state of the current subarray (increasing, decreasing, or neither).

### Step 2: Iterate Through the Array
- As we iterate through the array, we need to identify when we start ascending a mountain, reach the peak, and then start descending. This can be tracked by comparing each element with its predecessor.

### Step 3: Identifying States
- **Start of a Mountain (Ascending)**: We identify we're ascending if the current element is greater than the previous one, and we were not already ascending. If we were already ascending, we just continue.
- **Peak of a Mountain**: We know we've reached the peak when the current element is less than the previous one, and we were ascending before. This marks the transition from ascending to descending.
- **Descending a Mountain**: We're descending if the current element is less than the previous one, and we've previously identified a peak. If we continue to descend, we keep updating the length of the current mountain.
- **End of a Mountain/Reset**: If we encounter an element equal to or greater than the previous one while descending, the current mountain ends. We update our longest mountain length if the current mountain was longer and reset our tracking variables.

### Step 4: Edge Cases and Final Check
- If we reach the end of the array while descending a mountain, we need to do a final check to update the longest mountain length with the length of the last mountain, if applicable.
- We need to handle edge cases, such as arrays with fewer than 3 elements, where a mountain subarray cannot exist, or arrays that do not form any mountain.

### O(1) Space Consideration
- The space complexity is `O(1)` because we only use a fixed number of variables that do not grow with the input size, regardless of the array's length.

### Final Thoughts
Implementing this logic allows us to efficiently find the longest mountain in one pass through the array, adhering to the constraints of `O(1)` space and not requiring multiple passes through the data. This approach is efficient and effective for solving the problem as described.
```

### Metrics

```
recip_rank: 0.2500
P_1: 0.0000
P_5: 0.2000
P_10: 0.1000
P_25: 0.0400
P_50: 0.0200
P_100: 0.0100
recall_1: 0.0000
recall_5: 0.5000
recall_10: 0.5000
recall_25: 0.5000
recall_50: 0.5000
recall_100: 0.5000
ndcg_cut_1: 0.0000
ndcg_cut_5: 0.2641
ndcg_cut_10: 0.2641
ndcg_cut_25: 0.2641
ndcg_cut_50: 0.2641
ndcg_cut_100: 0.2641
map_cut_1: 0.0000
map_cut_5: 0.1250
map_cut_10: 0.1250
map_cut_25: 0.1250
map_cut_50: 0.1250
map_cut_100: 0.1250
```

## Retrieval Results

### DOC[1] (IRRELEVANT) leetcode/leetcode_2607.txt
> def minOperations(arr: List[int], k: int) - int:<br>    """You are given a 0-indexed integer array `arr` and an integer `k`. The array `arr` is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.<br><br>You can do the following operation any number of times:<br><br>   Pick any element from `arr` and increase or decrease it by `1`.<br><br>Return _the minimum number of operations such that the sum of each subarray of length_ `k` _is equal_.<br><br>A subarray is a contiguous part of the array.<br><br>Example 1:<br><br>Input: arr = \[1,4,1,3\], k = 2<br>Output: 1<br>Explanation: we can do one operation on index 1 to make its value equal to 3.<br>The array after the operation is \[1,3,1,3\]<br>- Subarray starts at index 0 is \[1, 3\], and its sum is 4 <br>- Subarray starts at index 1 is \[3, 1\], and its sum is 4 <br>- Subarray starts at index 2 is \[1, 3\], and its sum is 4 <br>- Subarray starts at index 3 is \[3, 1\], and its sum is 4 <br><br>Example 2:<br><br>Input: arr = \[2,5,5,7\], k = 3<br>Output: 5<br>Explanation: we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.<br>The array after the operations is \[5,5,5,5\]<br>- Subarray starts at index 0 is \[5, 5, 5\], and its sum is 15<br>- Subarray starts at index 1 is \[5, 5, 5\], and its sum is 15<br>- Subarray starts at index 2 is \[5, 5, 5\], and its sum is 15<br>- Subarray starts at index 3 is \[5, 5, 5\], and its sum is 15 <br><br>Constraints:<br><br>   `1 <= k <= arr.length <= 105`<br>   `1 <= arr[i] <= 109`"""<br><br>    n = len(arr)<br>    res = float('inf')<br>    prefix = [0]  (n + 1)<br><br>    for i in range(1, n + 1):<br>        prefix[i] = prefix[i - 1] + arr[i - 1]<br><br>    for i in range(1, n - k + 2):<br>        target = (prefix[i - 1] + prefix[n] - prefix[i + k - 1] + n // k - 1) // (n // k)<br>        curr_cost = 0<br>        for j in range(i, i + k):<br>            curr_cost += abs(arr[j - 1] - target)<br>        res = min(res, curr_cost)<br><br>    return res

### DOC[2] (IRRELEVANT) leetcode/leetcode_1095.txt
> def twoCitySchedCost(costs):<br>    """_(This problem is an interactive problem.)_<br><br>You may recall that an array `arr` is a mountain array if and only if:<br><br>   `arr.length = 3`<br>   There exists some `i` with `0 < i < arr.length - 1` such that:<br>       `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`<br>       `arr[i]  arr[i + 1]  ...  arr[arr.length - 1]`<br><br>Given a mountain array `mountainArr`, return the minimum `index` such that `mountainArr.get(index) == target`. If such an `index` does not exist, return `-1`.<br><br>You cannot access the mountain array directly. You may only access the array using a `MountainArray` interface:<br><br>   `MountainArray.get(k)` returns the element of the array at index `k` (0-indexed).<br>   `MountainArray.length()` returns the length of the array.<br><br>Submissions making more than `100` calls to `MountainArray.get` will be judged _Wrong Answer_. Also, any solutions that attempt to circumvent the judge will result in disqualification.<br><br>Example 1:<br><br>Input: array = \[1,2,3,4,5,3,1\], target = 3<br>Output: 2<br>Explanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.<br><br>Example 2:<br><br>Input: array = \[0,1,2,4,2,1\], target = 3<br>Output: -1<br>Explanation: 3 does not exist in `the array,` so we return -1.<br><br>Constraints:<br><br>   `3 <= mountain_arr.length() <= 104`<br>   `0 <= target <= 109`<br>   `0 <= mountain_arr.get(index) <= 109`"""<br><br>    costs.sort(key=lambda x: x[0] - x[1])<br><br>    totalCost = 0<br>    n = len(costs) // 2<br><br>    for i in range(n):<br>        totalCost += costs[i][0] + costs[i + n][1]<br><br>    return totalCost

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_256844.txt
> def fit_image(self, sma0=None, minsma=0., maxsma=None, step=0.1,<br>                  conver=DEFAULT_CONVERGENCE, minit=DEFAULT_MINIT,<br>                  maxit=DEFAULT_MAXIT, fflag=DEFAULT_FFLAG,<br>                  maxgerr=DEFAULT_MAXGERR, sclip=3., nclip=0,<br>                  integrmode=BILINEAR, linear=False, maxrit=None):<br>        # This parameter list is quite large and should in principle be<br>        # simplified by re-distributing these controls to somewhere else.<br>        # We keep this design though because it better mimics the flat<br>        # architecture used in the original STSDAS task `ellipse`.<br>        """<br>        Fit multiple isophotes to the image array.<br><br>        This method loops over each value of the semimajor axis (sma)<br>        length (constructed from the input parameters), fitting a single<br>        isophote at each sma.  The entire set of isophotes is returned<br>        in an `~photutils.isophote.IsophoteList` instance.<br><br>        Parameters<br>        ----------<br>        sma0 : float, optional<br>            The starting value for the semimajor axis length (pixels).<br>            This value must not be the minimum or maximum semimajor axis<br>            length, but something in between. The algorithm can't start<br>            from the very center of the galaxy image because the<br>            modelling of elliptical isophotes on that region is poor and<br>            it will diverge very easily if not tied to other previously<br>            fit isophotes. It can't start from the maximum value either<br>            because the maximum is not known beforehand, depending on<br>            signal-to-noise. The ``sma0`` value should be selected such<br>            that the corresponding isophote has a good signal-to-noise<br>            ratio and a clearly defined geometry. If set to `None` (the<br>            default), one of two actions will be taken:  if a<br>            `~photutils.isophote.EllipseGeometry` instance was input to<br>            the `~photutils.isophote.Ellipse` constructor, its ``sma``<br>            value will be used.  Otherwise, a default value of 10. will<br>            be used.<br>        minsma : float, optional<br>            The minimum value for the semimajor axis length (pixels).<br>            The default is 0.<br>        maxsma : float or `None`, optional<br>            The maximum value for the semimajor axis length (pixels).<br>            When set to `None` (default), the algorithm will increase<br>            the semimajor axis until one of several conditions will<br>            cause it to stop and revert to fit ellipses with sma <<br>            ``sma0``.<br>        step : float, optional<br>            The step value used to grow/shrink the semimajor axis length<br>            (pixels if ``linear=True``, or a relative value if<br>            ``linear=False``). See the ``linear`` parameter.  The<br>            default is 0.1.<br>        conver : float, optional<br>            The main convergence criterion. Iterations stop when the<br>            largest harmonic amplitude becomes smaller (in absolute<br>            value) than ``conver`` times the harmonic fit rms.  The<br>            default is 0.05.<br>        minit : int, optional<br>            The minimum number of iterations to perform. A minimum of 10<br>            (the default) iterations guarantees that, on average, 2<br>            iterations will be available for fitting each independent<br>            parameter (the four harmonic amplitudes and the intensity<br>            level). For the first isophote, the minimum number of<br>            iterations is 2  ``minit`` to ensure that, even departing<br>            from not-so-good initial values, the algorithm has a better<br>            chance to converge to a sensible solution.<br>        maxit : int, optional<br>            The maximum number of iterations to perform.  The default is<br>            50.<br>        fflag : float, optional<br>            The acceptable fraction of flagged data points in the<br>            sample.  If the actual fraction of valid data points is<br>            smaller than this, the iterations will stop and the current<br>            `~photutils.isophote.Isophote` will be returned.  Flagged<br>            data points are points that either lie outside the image<br>            frame, are masked, or were rejected by sigma-clipping.  The<br>            default is 0.7.<br>        maxgerr : float, optional<br>            The maximum acceptable relative error in the local radial<br>            intensity gradient. This is the main control for preventing<br>            ellipses to grow to regions of too low signal-to-noise<br>            ratio.  It specifies the maximum acceptable relative error<br>            in the local radial intensity gradient.  `Busko (1996; ASPC<br>            101, 139)<br>            <http://adsabs.harvard.edu/abs/1996ASPC..101..139B`_ showed<br>            that the fitting precision relates to that relative error.<br>            The usual behavior of the gradient relative error is to<br>            increase with semimajor axis, being larger in outer, fainter<br>            regions of a galaxy image.  In the current implementation,<br>            the ``maxgerr`` criterion is triggered only when two<br>            consecutive isophotes exceed the value specified by the<br>            parameter. This prevents premature stopping caused by<br>            contamination such as stars and HII regions.<br><br>            A number of actions may happen when the gradient error<br>            exceeds ``maxgerr`` (or becomes non-significant and is set<br>            to `None`).  If the maximum semimajor axis specified by<br>            ``maxsma`` is set to `None`, semimajor axis growth is<br>            stopped and the algorithm proceeds inwards to the galaxy<br>            center. If ``maxsma`` is set to some finite value, and this<br>            value is larger than the current semimajor axis length, the<br>            algorithm enters non-iterative mode and proceeds outwards<br>            until reaching ``maxsma``.  The default is 0.5.<br>        sclip : float, optional<br>            The sigma-clip sigma value.  The default is 3.0.<br>        nclip : int, optional<br>            The number of sigma-clip interations.  The default is 0,<br>            which means sigma-clipping is skipped.<br>        integrmode : {'bilinear', 'nearest_neighbor', 'mean', 'median'}, optional<br>            The area integration mode.  The default is 'bilinear'.<br>        linear : bool, optional<br>            The semimajor axis growing/shrinking mode. If `False`<br>            (default), the geometric growing mode is chosen, thus the<br>            semimajor axis length is increased by a factor of (1. +<br>            ``step``), and the process is repeated until either the<br>            semimajor axis value reaches the value of parameter<br>            ``maxsma``, or the last fitted ellipse has more than a given<br>            fraction of its sampled points flagged out (see ``fflag``).<br>            The process then resumes from the first fitted ellipse (at<br>            ``sma0``) inwards, in steps of (1./(1. + ``step``)), until<br>            the semimajor axis length reaches the value ``minsma``. In<br>            case of linear growing, the increment or decrement value is<br>            given directly by ``step`` in pixels.  If ``maxsma`` is set<br>            to `None`, the semimajor axis will grow until a low<br>            signal-to-noise criterion is met. See ``maxgerr``.<br>        maxrit : float or `None`, optional<br>            The maximum value of semimajor axis to perform an actual<br>            fit.  Whenever the current semimajor axis length is larger<br>            than ``maxrit``, the isophotes will be extracted using the<br>            current geometry, without being fitted.  This non-iterative<br>            mode may be useful for sampling regions of very low surface<br>            brightness, where the algorithm may become unstable and<br>            unable to recover reliable geometry information.<br>            Non-iterative mode can also be entered automatically<br>            whenever the ellipticity exceeds 1.0 or the ellipse center<br>            crosses the image boundaries.  If `None` (default), then no<br>            maximum value is used.<br><br>        Returns<br>        -------<br>        result : `~photutils.isophote.IsophoteList` instance<br>            A list-like object of `~photutils.isophote.Isophote`<br>            instances, sorted by increasing semimajor axis length.<br>        """<br><br>        # multiple fitted isophotes will be stored here<br>        isophote_list = []<br><br>        # get starting sma from appropriate source: keyword parameter,<br>        # internal EllipseGeometry instance, or fixed default value.<br>        if not sma0:<br>            if self._geometry:<br>                sma = self._geometry.sma<br>            else:<br>                sma = 10.<br>        else:<br>            sma = sma0<br><br>        # first, go from initial sma outwards until<br>        # hitting one of several stopping criteria.<br>        noiter = False<br>        first_isophote = True<br>        while True:<br>            # first isophote runs longer<br>            minit_a = 2  minit if first_isophote else minit<br>            first_isophote = False<br><br>            isophote = self.fit_isophote(sma, step, conver, minit_a, maxit,<br>                                         fflag, maxgerr, sclip, nclip,<br>                                         integrmode, linear, maxrit,<br>                                         noniterate=noiter,<br>                                         isophote_list=isophote_list)<br><br>            # check for failed fit.<br>            if (isophote.stop_code < 0 or isophote.stop_code == 1):<br>                # in case the fit failed right at the outset, return an<br>                # empty list. This is the usual case when the user<br>                # provides initial guesses that are too way off to enable<br>                # the fitting algorithm to find any meaningful solution.<br><br>                if len(isophote_list) == 1:<br>                    warnings.warn('No meaningful fit was possible.',<br>                                  AstropyUserWarning)<br>                    return IsophoteList([])<br><br>                self._fix_last_isophote(isophote_list, -1)<br><br>                # get last isophote from the actual list, since the last<br>                # `isophote` instance in this context may no longer be OK.<br>                isophote = isophote_list[-1]<br><br>                # if two consecutive isophotes failed to fit,<br>                # shut off iterative mode. Or, bail out and<br>                # change to go inwards.<br>                if len(isophote_list)  2:<br>                    if ((isophote.stop_code == 5 and<br>                         isophote_list[-2].stop_code == 5)<br>                            or isophote.stop_code == 1):<br>                        if maxsma and maxsma  isophote.sma:<br>                            # if a maximum sma value was provided by<br>                            # user, and the current sma is smaller than<br>                            # maxsma, keep growing sma in non-iterative<br>                            # mode until reaching it.<br>                            noiter = True<br>                        else:<br>                            # if no maximum sma, stop growing and change<br>                            # to go inwards.<br>                            break<br><br>            # reset variable from the actual list, since the last<br>            # `isophote` instance may no longer be OK.<br>            isophote = isophote_list[-1]<br><br>            # update sma. If exceeded user-defined<br>            # maximum, bail out from this loop.<br>            sma = isophote.sample.geometry.update_sma(step)<br>            if maxsma and sma = maxsma:<br>                break<br><br>        # reset sma so as to go inwards.<br>        first_isophote = isophote_list[0]<br>        sma, step = first_isophote.sample.geometry.reset_sma(step)<br><br>        # now, go from initial sma inwards towards center.<br>        while True:<br>            isophote = self.fit_isophote(sma, step, conver, minit, maxit,<br>                                         fflag, maxgerr, sclip, nclip,<br>                                         integrmode, linear, maxrit,<br>                                         going_inwards=True,<br>                                         isophote_list=isophote_list)<br><br>            # if abnormal condition, fix isophote but keep going.<br>            if isophote.stop_code < 0:<br>                self._fix_last_isophote(isophote_list, 0)<br><br>            # reset variable from the actual list, since the last<br>            # `isophote` instance may no longer be OK.<br>            isophote = isophote_list[-1]<br><br>            # figure out next sma; if exceeded user-defined<br>            # minimum, or too small, bail out from this loop<br>            sma = isophote.sample.geometry.update_sma(step)<br>            if sma <= max(minsma, 0.5):<br>                break<br><br>        # if user asked for minsma=0, extract special isophote there<br>        if minsma == 0.0:<br>            isophote = self.fit_isophote(0.0, isophote_list=isophote_list)<br><br>        # sort list of isophotes according to sma<br>        isophote_list.sort()<br><br>        return IsophoteList(isophote_list)

### DOC[4] (GROUND TRUTH) leetcode/leetcode_1671.txt
> def minimumMountainRemovals(nums):<br>    """You may recall that an array `arr` is a mountain array if and only if:<br><br>   `arr.length = 3`<br>   There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that:<br>       `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`<br>       `arr[i]  arr[i + 1]  ...  arr[arr.length - 1]`<br><br>Given an integer array `nums`​​​, return _the minimum number of elements to remove to make_ `nums_​​​_` _a mountain array._<br><br>Example 1:<br><br>Input: nums = \[1,3,1\]<br>Output: 0<br>Explanation: The array itself is a mountain array so we do not need to remove any elements.<br><br>Example 2:<br><br>Input: nums = \[2,1,1,5,6,2,3,1\]<br>Output: 3<br>Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \[1,5,6,3,1\].<br><br>Constraints:<br><br>   `3 <= nums.length <= 1000`<br>   `1 <= nums[i] <= 109`<br>   It is guaranteed that you can make a mountain array out of `nums`."""<br><br>    n = len(nums)<br>    left, right = [0]  n, [0]  n<br>    for i in range(1, n):<br>        left[i] = left[i - 1] + int(nums[i]  nums[i - 1])<br>        right[n - i - 1] = right[n - i] + int(nums[n - i - 1]  nums[n - i])<br>    ans = n - 3<br>    for i in range(1, n - 1):<br>        ans = min(ans, n - 1 - left[i] - right[i])<br>    return ans

### DOC[5] (IRRELEVANT) leetcode/leetcode_2612.txt
> def reach_position(n, p, banned, k):<br>    """You are given an integer `n` and an integer `p` in the range `[0, n - 1]`. Representing a 0-indexed array `arr` of length `n` where all positions are set to `0`'s, except position `p` which is set to `1`.<br><br>You are also given an integer array `banned` containing some positions from the array. For the ith position in `banned`, `arr[banned[i]] = 0`, and `banned[i] != p`.<br><br>You can perform multiple operations on `arr`. In an operation, you can choose a subarray with size `k` and reverse the subarray. However, the `1` in `arr` should never go to any of the positions in `banned`. In other words, after each operation `arr[banned[i]]` remains `0`.<br><br>_Return an array_ `ans` _where_ _for each_ `i` _from_ `[0, n - 1]`, `ans[i]` _is the minimum number of reverse operations needed to bring the_ `1` _to position_ `i` _in arr_, _or_ `-1` _if it is impossible_.<br><br>   A subarray is a contiguous non-empty sequence of elements within an array.<br>   The values of `ans[i]` are independent for all `i`'s.<br>   The reverse of an array is an array containing the values in reverse order.<br><br>Example 1:<br><br>Input: n = 4, p = 0, banned = \[1,2\], k = 4<br>Output: \[0,-1,-1,1\]<br>Explanation: In this case `k = 4` so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is `0`. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is `-1`. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is `1`. <br><br>Example 2:<br><br>Input: n = 5, p = 0, banned = \[2,4\], k = 3<br>Output: \[0,-1,-1,-1,-1\]<br>Explanation: In this case the 1 is initially at position 0, so the answer for that position is `0`. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray `[0, 2]` for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions `-1`. <br><br>Example 3:<br><br>Input: n = 4, p = 2, banned = \[0,1,3\], k = 1<br>Output: \[-1,-1,0,-1\]<br>Explanation: In this case we can only perform reverse operations of size 1. So the 1 never changes its position.<br><br>Constraints:<br><br>   `1 <= n <= 105`<br>   `0 <= p <= n - 1`<br>   `0 <= banned.length <= n - 1`<br>   `0 <= banned[i] <= n - 1`<br>   `1 <= k <= n`<br>   `banned[i] != p`<br>   all values in `banned` are unique"""<br><br>    banned_positions = set(banned)<br>    ans = [0]  n<br><br>    for i in range(n):<br>        if i in banned_positions or i == p:<br>            ans[i] = -1<br>            continue<br><br>        an = abs(p - i) // k<br>        if abs(p - i) % k == 0 and (an & 1) == (((n - 1) & 1) ^ (k & 1)):<br>            steps = an<br>        else:<br>            steps = -1<br><br>        ans[i] = steps<br><br>    ans[p] = 0<br>    return ans


## Ground Truth

### GROUND TRUTH 0, ranked 3, leetcode/leetcode_1671.txt
> def minimumMountainRemovals(nums):<br>    """You may recall that an array `arr` is a mountain array if and only if:<br><br>   `arr.length = 3`<br>   There exists some index `i` (0-indexed) with `0 < i < arr.length - 1` such that:<br>       `arr[0] < arr[1] < ... < arr[i - 1] < arr[i]`<br>       `arr[i]  arr[i + 1]  ...  arr[arr.length - 1]`<br><br>Given an integer array `nums`​​​, return _the minimum number of elements to remove to make_ `nums_​​​_` _a mountain array._<br><br>Example 1:<br><br>Input: nums = \[1,3,1\]<br>Output: 0<br>Explanation: The array itself is a mountain array so we do not need to remove any elements.<br><br>Example 2:<br><br>Input: nums = \[2,1,1,5,6,2,3,1\]<br>Output: 3<br>Explanation: One solution is to remove the elements at indices 0, 1, and 5, making the array nums = \[1,5,6,3,1\].<br><br>Constraints:<br><br>   `3 <= nums.length <= 1000`<br>   `1 <= nums[i] <= 109`<br>   It is guaranteed that you can make a mountain array out of `nums`."""<br><br>    n = len(nums)<br>    left, right = [0]  n, [0]  n<br>    for i in range(1, n):<br>        left[i] = left[i - 1] + int(nums[i]  nums[i - 1])<br>        right[n - i - 1] = right[n - i] + int(nums[n - i - 1]  nums[n - i])<br>    ans = n - 3<br>    for i in range(1, n - 1):<br>        ans = min(ans, n - 1 - left[i] - right[i])<br>    return ans

### GROUND TRUTH 1, ranked not in top 100, leetcode/leetcode_2100.txt
> def minNonZeroProduct(p):<br>    """You and a gang of thieves are planning on robbing a bank. You are given a 0-indexed integer array `security`, where `security[i]` is the number of guards on duty on the `ith` day. The days are numbered starting from `0`. You are also given an integer `time`.<br><br>The `ith` day is a good day to rob the bank if:<br><br>   There are at least `time` days before and after the `ith` day,<br>   The number of guards at the bank for the `time` days before `i` are non-increasing, and<br>   The number of guards at the bank for the `time` days after `i` are non-decreasing.<br><br>More formally, this means day `i` is a good day to rob the bank if and only if `security[i - time] = security[i - time + 1] = ... = security[i] <= ... <= security[i + time - 1] <= security[i + time]`.<br><br>Return _a list of all days (0-indexed) that are good days to rob the bank_. _The order that the days are returned in does not matter._<br><br>Example 1:<br><br>Input: security = \[5,3,3,3,5,6,2\], time = 2<br>Output: \[2,3\]<br>Explanation:<br>On day 2, we have security\[0\] = security\[1\] = security\[2\] <= security\[3\] <= security\[4\].<br>On day 3, we have security\[1\] = security\[2\] = security\[3\] <= security\[4\] <= security\[5\].<br>No other days satisfy this condition, so days 2 and 3 are the only good days to rob the bank.<br><br>Example 2:<br><br>Input: security = \[1,1,1,1,1\], time = 0<br>Output: \[0,1,2,3,4\]<br>Explanation:<br>Since time equals 0, every day is a good day to rob the bank, so return every day.<br><br>Example 3:<br><br>Input: security = \[1,2,3,4,5,6\], time = 2<br>Output: \[\]<br>Explanation:<br>No day has 2 days before it that have a non-increasing number of guards.<br>Thus, no day is a good day to rob the bank, so return an empty list.<br><br>Constraints:<br><br>   `1 <= security.length <= 105`<br>   `0 <= security[i], time <= 105`"""<br><br>    MOD = 109 + 7<br>    prod = 1<br>    a = (1 << p) - 2<br>    b = ((1 << p) - 1) % MOD<br>       <br>    while a  0:<br>        if a % 2:<br>            prod = (prod  b) % MOD<br>        b = (b  b) % MOD<br>        a //= 2<br>    return prod
