# Query `10`

## Original Question

*You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API `bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

Example 1:

Input: n = 5, bad = 4
Output: 4
Explanation:
call isBadVersion(3) -> false
call isBadVersion(5) -> true
call isBadVersion(4) -> true
Then 4 is the first bad version.

Example 2:

Input: n = 1, bad = 1
Output: 1

Constraints:

   `1 <= bad <= n <= 231 - 1`*

## gpt4 Reasoning

```markdown
The essential problem here is to efficiently identify the first version of the product that fails the quality check, given that all subsequent versions after a bad version are also bad. This is a classic example of a binary search problem where the goal is to minimize the number of API calls made to `isBadVersion(version)` to find the first bad version in a sorted list of versions `[1, 2, ..., n]`.

### Step-by-Step Solution

1. **Define the Search Space**: The search space is the range of versions from 1 to `n`. Initially, the start of the search space is 1 (`left = 1`), and the end (`right = n`) is the number of versions `n`.

2. **Binary Search Algorithm**:
    - While the search space is valid (`left <= right`), find the midpoint (`mid`) of the current search space. This is done by calculating `(left + right) / 2`. To avoid potential overflow, it's safer to use `left + (right - left) / 2`.
    - Use the `isBadVersion(mid)` API to check if the version at `mid` is bad.
    - If `isBadVersion(mid)` returns `true`, this means that the first bad version is at `mid` or before it. Hence, we adjust the search space to the left half by setting `right = mid - 1`.
    - If `isBadVersion(mid)` returns `false`, this means that the first bad version is after `mid`. Therefore, we adjust the search space to the right half by setting `left = mid + 1`.
    - Continue this process until `left` exceeds `right`, indicating that the search space has been narrowed down to the point where `left` points to the first bad version.

3. **Return the First Bad Version**: At the end of the binary search, `left` will point to the first bad version. This is because when `isBadVersion(mid)` is `true`, we keep adjusting `right` to narrow down the search space towards the start of the bad versions. Conversely, when `isBadVersion(mid)` is `false`, we adjust `left` to skip all the good versions. Eventually, `left` and `right` converge to the point where the first bad version is found.

### Example Implementation in Python

```python
# The isBadVersion API is already defined for you.
# @param version, an integer
# @return a bool
# def isBadVersion(version):

def firstBadVersion(n):
    left, right = 1, n
    while left <= right:
        mid = left + (right - left) // 2
        if isBadVersion(mid):
            right = mid - 1
        else:
            left = mid + 1
    return left
```

This implementation ensures that the number of calls to `isBadVersion` is minimized, adhering to the binary search methodology which has a time complexity of O(log n), making it efficient for large values of `n`.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.4000
P_10: 0.2000
P_25: 0.0800
P_50: 0.0400
P_100: 0.0200
recall_1: 0.3333
recall_5: 0.6667
recall_10: 0.6667
recall_25: 0.6667
recall_50: 0.6667
recall_100: 0.6667
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.7654
ndcg_cut_10: 0.7654
ndcg_cut_25: 0.7654
ndcg_cut_50: 0.7654
ndcg_cut_100: 0.7654
map_cut_1: 0.3333
map_cut_5: 0.6667
map_cut_10: 0.6667
map_cut_25: 0.6667
map_cut_50: 0.6667
map_cut_100: 0.6667
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_34.txt
> def searchRange(nums, target):<br>    """Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.<br><br>If `target` is not found in the array, return `[-1, -1]`.<br><br>You must write an algorithm with `O(log n)` runtime complexity.<br><br>Example 1:<br><br>Input: nums = \[5,7,7,8,8,10\], target = 8<br>Output: \[3,4\]<br><br>Example 2:<br><br>Input: nums = \[5,7,7,8,8,10\], target = 6<br>Output: \[-1,-1\]<br><br>Example 3:<br><br>Input: nums = \[\], target = 0<br>Output: \[-1,-1\]<br><br>Constraints:<br><br>   `0 <= nums.length <= 105`<br>   `-109 <= nums[i] <= 109`<br>   `nums` is a non-decreasing array.<br>   `-109 <= target <= 109`"""<br><br>    start, end = -1, -1<br>    left, right = 0, len(nums) - 1<br>    <br>    while left <= right:<br>        mid = left + (right - left) // 2<br>        if nums[mid] < target:<br>            left = mid + 1<br>        else:<br>            right = mid - 1<br>            if nums[mid] == target:<br>                start = mid<br><br>    left, right = 0, len(nums) - 1<br>    <br>    while left <= right:<br>        mid = left + (right - left) // 2<br>        if nums[mid]  target:right = mid - 1<br>        else:<br>            left = mid + 1<br>            if nums[mid] == target:<br>                end = mid<br>    <br>    return [start, end]

### DOC[2] (GROUND TRUTH) leetcode/leetcode_35.txt
> def searchInsert(nums, target):<br>    """Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br><br>You must write an algorithm with `O(log n)` runtime complexity.<br><br>Example 1:<br><br>Input: nums = \[1,3,5,6\], target = 5<br>Output: 2<br><br>Example 2:<br><br>Input: nums = \[1,3,5,6\], target = 2<br>Output: 1<br><br>Example 3:<br><br>Input: nums = \[1,3,5,6\], target = 7<br>Output: 4<br><br>Constraints:<br><br>   `1 <= nums.length <= 104`<br>   `-104 <= nums[i] <= 104`<br>   `nums` contains distinct values sorted in ascending order.<br>   `-104 <= target <= 104`"""<br><br>    left, right = 0, len(nums) - 1<br>    while left <= right:<br>        mid = left + (right - left) // 2<br>        if nums[mid] == target:<br>            return mid<br>        if nums[mid] < target:<br>            left = mid + 1<br>        else:<br>            right = mid - 1<br>    return left

### DOC[3] (IRRELEVANT) leetcode/csn_python_train_396404.txt
> def exam_reliability(x_axis, x_axis_new, reliable_distance, precision=0.0001):<br>    """When we do linear interpolation on x_axis and derive value for <br>    x_axis_new, we also evaluate how can we trust those interpolated <br>    data points. This is how it works:<br><br>    For each new x_axis point in x_axis new, let's say xi. Find the closest <br>    point in x_axis, suppose the distance is #dist. Compare this to <br>    #reliable_distance. If #dist < #reliable_distance, then we can trust it, <br>    otherwise, we can't.<br><br>    The precision is to handle decimal value's precision problem. Because <br>    1.0 may actually is 1.00000000001 or 0.999999999999 in computer system. <br>    So we define that: if ``dist`` + ``precision`` <= ``reliable_distance``, then we <br>    can trust it, else, we can't.<br><br>    Here is an O(n) algorithm implementation. A lots of improvement than <br>    classic binary search one, which is O(n^2).<br>    """<br>    x_axis = x_axis[::-1]<br>    x_axis.append(-232)<br><br>    distance_to_closest_point = list()<br>    for t in x_axis_new:<br>        while 1:<br>            try:<br>                x = x_axis.pop()<br>                if x <= t:<br>                    left = x<br>                else:<br>                    right = x<br>                    x_axis.append(right)<br>                    x_axis.append(left)<br>                    left_dist, right_dist = (t - left), (right - t)<br>                    if left_dist <= right_dist:<br>                        distance_to_closest_point.append(left_dist)<br>                    else:<br>                        distance_to_closest_point.append(right_dist)<br>                    break<br>            except:<br>                distance_to_closest_point.append(t - left)<br>                break<br><br>    reliable_flag = list()<br>    for dist in distance_to_closest_point:<br>        if dist - precision - reliable_distance <= 0:<br>            reliable_flag.append(True)<br>        else:<br>            reliable_flag.append(False)<br><br>    return reliable_flag

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_1066.txt
> def _parse_float_vec(vec):<br>    """<br>    Parse a vector of float values representing IBM 8 byte floats into<br>    native 8 byte floats.<br>    """<br><br>    dtype = np.dtype('u4,u4')<br>    vec1 = vec.view(dtype=dtype)<br>    xport1 = vec1['f0']<br>    xport2 = vec1['f1']<br><br>    # Start by setting first half of ieee number to first half of IBM<br>    # number sans exponent<br>    ieee1 = xport1 & 0x00ffffff<br><br>    # The fraction bit to the left of the binary point in the ieee<br>    # format was set and the number was shifted 0, 1, 2, or 3<br>    # places. This will tell us how to adjust the ibm exponent to be a<br>    # power of 2 ieee exponent and how to shift the fraction bits to<br>    # restore the correct magnitude.<br>    shift = np.zeros(len(vec), dtype=np.uint8)<br>    shift[np.where(xport1 & 0x00200000)] = 1<br>    shift[np.where(xport1 & 0x00400000)] = 2<br>    shift[np.where(xport1 & 0x00800000)] = 3<br><br>    # shift the ieee number down the correct number of places then<br>    # set the second half of the ieee number to be the second half<br>    # of the ibm number shifted appropriately, ored with the bits<br>    # from the first half that would have been shifted in if we<br>    # could shift a double. All we are worried about are the low<br>    # order 3 bits of the first half since we're only shifting by<br>    # 1, 2, or 3.<br>    ieee1 = shift<br>    ieee2 = (xport2  shift) | ((xport1 & 0x00000007) << (29 + (3 - shift)))<br><br>    # clear the 1 bit to the left of the binary point<br>    ieee1 &= 0xffefffff<br><br>    # set the exponent of the ieee number to be the actual exponent<br>    # plus the shift count + 1023. Or this into the first half of the<br>    # ieee number. The ibm exponent is excess 64 but is adjusted by 65<br>    # since during conversion to ibm format the exponent is<br>    # incremented by 1 and the fraction bits left 4 positions to the<br>    # right of the radix point.  (had to add  24 because C treats &<br>    # 0x7f as 0x7f000000 and Python doesn't)<br>    ieee1 |= ((((((xport1  24) & 0x7f) - 65) << 2) +<br>               shift + 1023) << 20) | (xport1 & 0x80000000)<br><br>    ieee = np.empty((len(ieee1),), dtype='u4,u4')<br>    ieee['f0'] = ieee1<br>    ieee['f1'] = ieee2<br>    ieee = ieee.view(dtype='f8')<br>    ieee = ieee.astype('f8')<br><br>    return ieee

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_256844.txt
> def fit_image(self, sma0=None, minsma=0., maxsma=None, step=0.1,<br>                  conver=DEFAULT_CONVERGENCE, minit=DEFAULT_MINIT,<br>                  maxit=DEFAULT_MAXIT, fflag=DEFAULT_FFLAG,<br>                  maxgerr=DEFAULT_MAXGERR, sclip=3., nclip=0,<br>                  integrmode=BILINEAR, linear=False, maxrit=None):<br>        # This parameter list is quite large and should in principle be<br>        # simplified by re-distributing these controls to somewhere else.<br>        # We keep this design though because it better mimics the flat<br>        # architecture used in the original STSDAS task `ellipse`.<br>        """<br>        Fit multiple isophotes to the image array.<br><br>        This method loops over each value of the semimajor axis (sma)<br>        length (constructed from the input parameters), fitting a single<br>        isophote at each sma.  The entire set of isophotes is returned<br>        in an `~photutils.isophote.IsophoteList` instance.<br><br>        Parameters<br>        ----------<br>        sma0 : float, optional<br>            The starting value for the semimajor axis length (pixels).<br>            This value must not be the minimum or maximum semimajor axis<br>            length, but something in between. The algorithm can't start<br>            from the very center of the galaxy image because the<br>            modelling of elliptical isophotes on that region is poor and<br>            it will diverge very easily if not tied to other previously<br>            fit isophotes. It can't start from the maximum value either<br>            because the maximum is not known beforehand, depending on<br>            signal-to-noise. The ``sma0`` value should be selected such<br>            that the corresponding isophote has a good signal-to-noise<br>            ratio and a clearly defined geometry. If set to `None` (the<br>            default), one of two actions will be taken:  if a<br>            `~photutils.isophote.EllipseGeometry` instance was input to<br>            the `~photutils.isophote.Ellipse` constructor, its ``sma``<br>            value will be used.  Otherwise, a default value of 10. will<br>            be used.<br>        minsma : float, optional<br>            The minimum value for the semimajor axis length (pixels).<br>            The default is 0.<br>        maxsma : float or `None`, optional<br>            The maximum value for the semimajor axis length (pixels).<br>            When set to `None` (default), the algorithm will increase<br>            the semimajor axis until one of several conditions will<br>            cause it to stop and revert to fit ellipses with sma <<br>            ``sma0``.<br>        step : float, optional<br>            The step value used to grow/shrink the semimajor axis length<br>            (pixels if ``linear=True``, or a relative value if<br>            ``linear=False``). See the ``linear`` parameter.  The<br>            default is 0.1.<br>        conver : float, optional<br>            The main convergence criterion. Iterations stop when the<br>            largest harmonic amplitude becomes smaller (in absolute<br>            value) than ``conver`` times the harmonic fit rms.  The<br>            default is 0.05.<br>        minit : int, optional<br>            The minimum number of iterations to perform. A minimum of 10<br>            (the default) iterations guarantees that, on average, 2<br>            iterations will be available for fitting each independent<br>            parameter (the four harmonic amplitudes and the intensity<br>            level). For the first isophote, the minimum number of<br>            iterations is 2  ``minit`` to ensure that, even departing<br>            from not-so-good initial values, the algorithm has a better<br>            chance to converge to a sensible solution.<br>        maxit : int, optional<br>            The maximum number of iterations to perform.  The default is<br>            50.<br>        fflag : float, optional<br>            The acceptable fraction of flagged data points in the<br>            sample.  If the actual fraction of valid data points is<br>            smaller than this, the iterations will stop and the current<br>            `~photutils.isophote.Isophote` will be returned.  Flagged<br>            data points are points that either lie outside the image<br>            frame, are masked, or were rejected by sigma-clipping.  The<br>            default is 0.7.<br>        maxgerr : float, optional<br>            The maximum acceptable relative error in the local radial<br>            intensity gradient. This is the main control for preventing<br>            ellipses to grow to regions of too low signal-to-noise<br>            ratio.  It specifies the maximum acceptable relative error<br>            in the local radial intensity gradient.  `Busko (1996; ASPC<br>            101, 139)<br>            <http://adsabs.harvard.edu/abs/1996ASPC..101..139B`_ showed<br>            that the fitting precision relates to that relative error.<br>            The usual behavior of the gradient relative error is to<br>            increase with semimajor axis, being larger in outer, fainter<br>            regions of a galaxy image.  In the current implementation,<br>            the ``maxgerr`` criterion is triggered only when two<br>            consecutive isophotes exceed the value specified by the<br>            parameter. This prevents premature stopping caused by<br>            contamination such as stars and HII regions.<br><br>            A number of actions may happen when the gradient error<br>            exceeds ``maxgerr`` (or becomes non-significant and is set<br>            to `None`).  If the maximum semimajor axis specified by<br>            ``maxsma`` is set to `None`, semimajor axis growth is<br>            stopped and the algorithm proceeds inwards to the galaxy<br>            center. If ``maxsma`` is set to some finite value, and this<br>            value is larger than the current semimajor axis length, the<br>            algorithm enters non-iterative mode and proceeds outwards<br>            until reaching ``maxsma``.  The default is 0.5.<br>        sclip : float, optional<br>            The sigma-clip sigma value.  The default is 3.0.<br>        nclip : int, optional<br>            The number of sigma-clip interations.  The default is 0,<br>            which means sigma-clipping is skipped.<br>        integrmode : {'bilinear', 'nearest_neighbor', 'mean', 'median'}, optional<br>            The area integration mode.  The default is 'bilinear'.<br>        linear : bool, optional<br>            The semimajor axis growing/shrinking mode. If `False`<br>            (default), the geometric growing mode is chosen, thus the<br>            semimajor axis length is increased by a factor of (1. +<br>            ``step``), and the process is repeated until either the<br>            semimajor axis value reaches the value of parameter<br>            ``maxsma``, or the last fitted ellipse has more than a given<br>            fraction of its sampled points flagged out (see ``fflag``).<br>            The process then resumes from the first fitted ellipse (at<br>            ``sma0``) inwards, in steps of (1./(1. + ``step``)), until<br>            the semimajor axis length reaches the value ``minsma``. In<br>            case of linear growing, the increment or decrement value is<br>            given directly by ``step`` in pixels.  If ``maxsma`` is set<br>            to `None`, the semimajor axis will grow until a low<br>            signal-to-noise criterion is met. See ``maxgerr``.<br>        maxrit : float or `None`, optional<br>            The maximum value of semimajor axis to perform an actual<br>            fit.  Whenever the current semimajor axis length is larger<br>            than ``maxrit``, the isophotes will be extracted using the<br>            current geometry, without being fitted.  This non-iterative<br>            mode may be useful for sampling regions of very low surface<br>            brightness, where the algorithm may become unstable and<br>            unable to recover reliable geometry information.<br>            Non-iterative mode can also be entered automatically<br>            whenever the ellipticity exceeds 1.0 or the ellipse center<br>            crosses the image boundaries.  If `None` (default), then no<br>            maximum value is used.<br><br>        Returns<br>        -------<br>        result : `~photutils.isophote.IsophoteList` instance<br>            A list-like object of `~photutils.isophote.Isophote`<br>            instances, sorted by increasing semimajor axis length.<br>        """<br><br>        # multiple fitted isophotes will be stored here<br>        isophote_list = []<br><br>        # get starting sma from appropriate source: keyword parameter,<br>        # internal EllipseGeometry instance, or fixed default value.<br>        if not sma0:<br>            if self._geometry:<br>                sma = self._geometry.sma<br>            else:<br>                sma = 10.<br>        else:<br>            sma = sma0<br><br>        # first, go from initial sma outwards until<br>        # hitting one of several stopping criteria.<br>        noiter = False<br>        first_isophote = True<br>        while True:<br>            # first isophote runs longer<br>            minit_a = 2  minit if first_isophote else minit<br>            first_isophote = False<br><br>            isophote = self.fit_isophote(sma, step, conver, minit_a, maxit,<br>                                         fflag, maxgerr, sclip, nclip,<br>                                         integrmode, linear, maxrit,<br>                                         noniterate=noiter,<br>                                         isophote_list=isophote_list)<br><br>            # check for failed fit.<br>            if (isophote.stop_code < 0 or isophote.stop_code == 1):<br>                # in case the fit failed right at the outset, return an<br>                # empty list. This is the usual case when the user<br>                # provides initial guesses that are too way off to enable<br>                # the fitting algorithm to find any meaningful solution.<br><br>                if len(isophote_list) == 1:<br>                    warnings.warn('No meaningful fit was possible.',<br>                                  AstropyUserWarning)<br>                    return IsophoteList([])<br><br>                self._fix_last_isophote(isophote_list, -1)<br><br>                # get last isophote from the actual list, since the last<br>                # `isophote` instance in this context may no longer be OK.<br>                isophote = isophote_list[-1]<br><br>                # if two consecutive isophotes failed to fit,<br>                # shut off iterative mode. Or, bail out and<br>                # change to go inwards.<br>                if len(isophote_list)  2:<br>                    if ((isophote.stop_code == 5 and<br>                         isophote_list[-2].stop_code == 5)<br>                            or isophote.stop_code == 1):<br>                        if maxsma and maxsma  isophote.sma:<br>                            # if a maximum sma value was provided by<br>                            # user, and the current sma is smaller than<br>                            # maxsma, keep growing sma in non-iterative<br>                            # mode until reaching it.<br>                            noiter = True<br>                        else:<br>                            # if no maximum sma, stop growing and change<br>                            # to go inwards.<br>                            break<br><br>            # reset variable from the actual list, since the last<br>            # `isophote` instance may no longer be OK.<br>            isophote = isophote_list[-1]<br><br>            # update sma. If exceeded user-defined<br>            # maximum, bail out from this loop.<br>            sma = isophote.sample.geometry.update_sma(step)<br>            if maxsma and sma = maxsma:<br>                break<br><br>        # reset sma so as to go inwards.<br>        first_isophote = isophote_list[0]<br>        sma, step = first_isophote.sample.geometry.reset_sma(step)<br><br>        # now, go from initial sma inwards towards center.<br>        while True:<br>            isophote = self.fit_isophote(sma, step, conver, minit, maxit,<br>                                         fflag, maxgerr, sclip, nclip,<br>                                         integrmode, linear, maxrit,<br>                                         going_inwards=True,<br>                                         isophote_list=isophote_list)<br><br>            # if abnormal condition, fix isophote but keep going.<br>            if isophote.stop_code < 0:<br>                self._fix_last_isophote(isophote_list, 0)<br><br>            # reset variable from the actual list, since the last<br>            # `isophote` instance may no longer be OK.<br>            isophote = isophote_list[-1]<br><br>            # figure out next sma; if exceeded user-defined<br>            # minimum, or too small, bail out from this loop<br>            sma = isophote.sample.geometry.update_sma(step)<br>            if sma <= max(minsma, 0.5):<br>                break<br><br>        # if user asked for minsma=0, extract special isophote there<br>        if minsma == 0.0:<br>            isophote = self.fit_isophote(0.0, isophote_list=isophote_list)<br><br>        # sort list of isophotes according to sma<br>        isophote_list.sort()<br><br>        return IsophoteList(isophote_list)


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_34.txt
> def searchRange(nums, target):<br>    """Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value.<br><br>If `target` is not found in the array, return `[-1, -1]`.<br><br>You must write an algorithm with `O(log n)` runtime complexity.<br><br>Example 1:<br><br>Input: nums = \[5,7,7,8,8,10\], target = 8<br>Output: \[3,4\]<br><br>Example 2:<br><br>Input: nums = \[5,7,7,8,8,10\], target = 6<br>Output: \[-1,-1\]<br><br>Example 3:<br><br>Input: nums = \[\], target = 0<br>Output: \[-1,-1\]<br><br>Constraints:<br><br>   `0 <= nums.length <= 105`<br>   `-109 <= nums[i] <= 109`<br>   `nums` is a non-decreasing array.<br>   `-109 <= target <= 109`"""<br><br>    start, end = -1, -1<br>    left, right = 0, len(nums) - 1<br>    <br>    while left <= right:<br>        mid = left + (right - left) // 2<br>        if nums[mid] < target:<br>            left = mid + 1<br>        else:<br>            right = mid - 1<br>            if nums[mid] == target:<br>                start = mid<br><br>    left, right = 0, len(nums) - 1<br>    <br>    while left <= right:<br>        mid = left + (right - left) // 2<br>        if nums[mid]  target:right = mid - 1<br>        else:<br>            left = mid + 1<br>            if nums[mid] == target:<br>                end = mid<br>    <br>    return [start, end]

### GROUND TRUTH 1, ranked 1, leetcode/leetcode_35.txt
> def searchInsert(nums, target):<br>    """Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.<br><br>You must write an algorithm with `O(log n)` runtime complexity.<br><br>Example 1:<br><br>Input: nums = \[1,3,5,6\], target = 5<br>Output: 2<br><br>Example 2:<br><br>Input: nums = \[1,3,5,6\], target = 2<br>Output: 1<br><br>Example 3:<br><br>Input: nums = \[1,3,5,6\], target = 7<br>Output: 4<br><br>Constraints:<br><br>   `1 <= nums.length <= 104`<br>   `-104 <= nums[i] <= 104`<br>   `nums` contains distinct values sorted in ascending order.<br>   `-104 <= target <= 104`"""<br><br>    left, right = 0, len(nums) - 1<br>    while left <= right:<br>        mid = left + (right - left) // 2<br>        if nums[mid] == target:<br>            return mid<br>        if nums[mid] < target:<br>            left = mid + 1<br>        else:<br>            right = mid - 1<br>    return left

### GROUND TRUTH 2, ranked not in top 100, leetcode/leetcode_374.txt
> def guessNumber(n):<br>    """We are playing the Guess Game. The game is as follows:<br><br>I pick a number from `1` to `n`. You have to guess which number I picked.<br><br>Every time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.<br><br>You call a pre-defined API `int guess(int num)`, which returns three possible results:<br><br>   `-1`: Your guess is higher than the number I picked (i.e. `num  pick`).<br>   `1`: Your guess is lower than the number I picked (i.e. `num < pick`).<br>   `0`: your guess is equal to the number I picked (i.e. `num == pick`).<br><br>Return _the number that I picked_.<br><br>Example 1:<br><br>Input: n = 10, pick = 6<br>Output: 6<br><br>Example 2:<br><br>Input: n = 1, pick = 1<br>Output: 1<br><br>Example 3:<br><br>Input: n = 2, pick = 1<br>Output: 1<br><br>Constraints:<br><br>   `1 <= n <= 231 - 1`<br>   `1 <= pick <= n`"""<br><br>    low, high = 1, n<br>    while low <= high:<br>        mid = low + (high - low) // 2<br>        result = guess(mid)<br>        if result == 0:<br>            return mid<br>        elif result < 0:<br>            high = mid - 1<br>        else:<br>            low = mid + 1<br>    return -1
