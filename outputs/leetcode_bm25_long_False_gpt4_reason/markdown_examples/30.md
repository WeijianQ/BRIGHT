# Query `30`

## Original Question

*Nearly everyone has used the [Multiplication Table](https://en.wikipedia.org/wiki/Multiplication_table). The multiplication table of size `m x n` is an integer matrix `mat` where `mat[i][j] == i  j` (1-indexed).

Given three integers `m`, `n`, and `k`, return _the_ `kth` _smallest element in the_ `m x n` _multiplication table_.

Example 1:

Input: m = 3, n = 3, k = 5
Output: 3
Explanation: The 5th smallest number is 3.

Example 2:

Input: m = 2, n = 3, k = 6
Output: 6
Explanation: The 6th smallest number is 6.

Constraints:

   `1 <= m, n <= 3  104`
   `1 <= k <= m  n`*

## gpt4 Reasoning

```markdown
The essential problem here is to find the `kth` smallest element in the multiplication table of size `m x n`, where each cell `(i, j)` in the table contains the product of `i` and `j`, with both `i` and `j` being 1-indexed. 

To address this problem, we need to understand the structure of the multiplication table and how the elements are distributed within it. The key points to consider are:

1. **Ordered Structure**: The multiplication table is inherently ordered. For any fixed row `i`, the elements in that row follow the sequence `i, 2i, 3i, ..., ni`. Similarly, for any fixed column `j`, the elements follow the sequence `j, 2j, 3j, ..., mj`. This ordering suggests that the table's elements increase both across rows and down columns.

2. **Binary Search**: Given the ordered nature of the multiplication table and the problem's constraints, a direct approach (e.g., generating the entire table and sorting it to find the `kth` smallest element) would be inefficient, especially for large values of `m` and `n`. A more efficient method involves binary search, exploiting the table's ordered structure.

3. **Counting Elements**: To apply binary search, we need a way to count how many elements in the table are less than or equal to a given value `x`. This count can help us determine if our current `x` is too large or too small relative to the `kth` smallest element we're searching for.

Here's a step-by-step strategy to solve the problem:

### Step 1: Initialize Binary Search
- Define the search space's lower and upper bounds. The smallest element in the table is `1` (product of 1x1), and the largest is `m*n` (product of `m` and `n`).
- Initialize variables for the lower bound (`low`) as 1 and the upper bound (`high`) as `m*n`.

### Step 2: Binary Search Loop
- While `low` is less than `high`, do the following:
  - Calculate the midpoint `mid` as `(low + high) / 2`.
  - Count how many elements in the table are less than or equal to `mid`. This involves iterating over rows or columns and summing how many times `mid` is divisible by each row or column index, capped by `n` or `m` respectively.
  - If the count is less than `k`, we know the `kth` smallest element is greater than `mid`, so we adjust `low` to `mid + 1`.
  - Otherwise, adjust `high` to `mid`.

### Step 3: Conclusion
- After exiting the loop, `low` will have converged to the `kth` smallest element in the multiplication table, so we return `low`.

### Example
Let's briefly consider how this approach works for Example 1 (`m = 3, n = 3, k = 5`):
- The search space is from 1 to 9.
- Suppose we start with `mid = 5`. We count the elements in the table less than or equal to 5, which are `[1, 2, 3, 4, 2, 4, 3]`, totaling 7 elements.
- Since our count (7) is greater than `k` (5), we know the `kth` smallest element is less than or equal to 5. We adjust our search space accordingly.
- By continuing this process with binary search logic, we eventually narrow down to the `kth` smallest element, which is `3`.

This approach is efficient, leveraging the multiplication table's properties and binary search to avoid generating and sorting the entire table, which would be impractical for large `m` and `n` values.
```

### Metrics

```
recip_rank: 1.0000
P_1: 1.0000
P_5: 0.4000
P_10: 0.2000
P_25: 0.0800
P_50: 0.0400
P_100: 0.0300
recall_1: 0.3333
recall_5: 0.6667
recall_10: 0.6667
recall_25: 0.6667
recall_50: 0.6667
recall_100: 1.0000
ndcg_cut_1: 1.0000
ndcg_cut_5: 0.7039
ndcg_cut_10: 0.7039
ndcg_cut_25: 0.7039
ndcg_cut_50: 0.7039
ndcg_cut_100: 0.7851
map_cut_1: 0.3333
map_cut_5: 0.5556
map_cut_10: 0.5556
map_cut_25: 0.5556
map_cut_50: 0.5556
map_cut_100: 0.5741
```

## Retrieval Results

### DOC[1] (GROUND TRUTH) leetcode/leetcode_378.txt
> import heapq<br>    """Given an `n x n` `matrix` where each of the rows and columns is sorted in ascending order, return _the_ `kth` _smallest element in the matrix_.<br><br>Note that it is the `kth` smallest element in the sorted order, not the `kth` distinct element.<br><br>You must find a solution with a memory complexity better than `O(n2)`.<br><br>Example 1:<br><br>Input: matrix = \[\[1,5,9\],\[10,11,13\],\[12,13,15\]\], k = 8<br>Output: 13<br>Explanation: The elements in the matrix are \[1,5,9,10,11,12,13,13,15\], and the 8th smallest number is 13<br><br>Example 2:<br><br>Input: matrix = \[\[-5\]\], k = 1<br>Output: -5<br><br>Constraints:<br><br>   `n == matrix.length == matrix[i].length`<br>   `1 <= n <= 300`<br>   `-109 <= matrix[i][j] <= 109`<br>   All the rows and columns of `matrix` are guaranteed to be sorted in non-decreasing order.<br>   `1 <= k <= n2`<br><br>Follow up:<br><br>   Could you solve the problem with a constant memory (i.e., `O(1)` memory complexity)?<br>   Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) fun."""<br><br><br>def kthSmallest(matrix, k):<br>    n = len(matrix)<br>    min_heap = []<br><br>    for i in range(n):<br>        heapq.heappush(min_heap, (matrix[i][0], i, 0))<br><br>    while k  1:<br>        val, row, col = heapq.heappop(min_heap)<br><br>        if col + 1 < n:<br>            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))<br><br>        k -= 1<br><br>    return min_heap[0][0]

### DOC[2] (IRRELEVANT) leetcode/leetcode_975.txt
> def rangeSumBST(self, root: TreeNode, low: int, high: int) - int:<br>    """You are given an integer array `arr`. From some starting index, you can make a series of jumps. The (1st, 3rd, 5th, ...) jumps in the series are called odd-numbered jumps, and the (2nd, 4th, 6th, ...) jumps in the series are called even-numbered jumps. Note that the jumps are numbered, not the indices.<br><br>You may jump forward from index `i` to index `j` (with `i < j`) in the following way:<br><br>   During odd-numbered jumps (i.e., jumps 1, 3, 5, ...), you jump to the index `j` such that `arr[i] <= arr[j]` and `arr[j]` is the smallest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.<br>   During even-numbered jumps (i.e., jumps 2, 4, 6, ...), you jump to the index `j` such that `arr[i] = arr[j]` and `arr[j]` is the largest possible value. If there are multiple such indices `j`, you can only jump to the smallest such index `j`.<br>   It may be the case that for some index `i`, there are no legal jumps.<br><br>A starting index is good if, starting from that index, you can reach the end of the array (index `arr.length - 1`) by jumping some number of times (possibly 0 or more than once).<br><br>Return _the number of good starting indices_.<br><br>Example 1:<br><br>Input: arr = \[10,13,12,14,15\]<br>Output: 2<br>Explanation: <br>From starting index i = 0, we can make our 1st jump to i = 2 (since arr\[2\] is the smallest among arr\[1\], arr\[2\], arr\[3\], arr\[4\] that is greater or equal to arr\[0\]), then we cannot jump any more.<br>From starting index i = 1 and i = 2, we can make our 1st jump to i = 3, then we cannot jump any more.<br>From starting index i = 3, we can make our 1st jump to i = 4, so we have reached the end.<br>From starting index i = 4, we have reached the end already.<br>In total, there are 2 different starting indices i = 3 and i = 4, where we can reach the end with some number of<br>jumps.<br><br>Example 2:<br><br>Input: arr = \[2,3,1,1,4\]<br>Output: 3<br>Explanation: <br>From starting index i = 0, we make jumps to i = 1, i = 2, i = 3:<br>During our 1st jump (odd-numbered), we first jump to i = 1 because arr\[1\] is the smallest value in \[arr\[1\], arr\[2\], arr\[3\], arr\[4\]\] that is greater than or equal to arr\[0\].<br>During our 2nd jump (even-numbered), we jump from i = 1 to i = 2 because arr\[2\] is the largest value in \[arr\[2\], arr\[3\], arr\[4\]\] that is less than or equal to arr\[1\]. arr\[3\] is also the largest value, but 2 is a smaller index, so we can only jump to i = 2 and not i = 3<br>During our 3rd jump (odd-numbered), we jump from i = 2 to i = 3 because arr\[3\] is the smallest value in \[arr\[3\], arr\[4\]\] that is greater than or equal to arr\[2\].<br>We can't jump from i = 3 to i = 4, so the starting index i = 0 is not good.<br>In a similar manner, we can deduce that:<br>From starting index i = 1, we jump to i = 4, so we reach the end.<br>From starting index i = 2, we jump to i = 3, and then we can't jump anymore.<br>From starting index i = 3, we jump to i = 4, so we reach the end.<br>From starting index i = 4, we are already at the end.<br>In total, there are 3 different starting indices i = 1, i = 3, and i = 4, where we can reach the end with some<br>number of jumps.<br><br>Example 3:<br><br>Input: arr = \[5,1,3,4,2\]<br>Output: 3<br>Explanation: We can reach the end from starting indices 1, 2, and 4.<br><br>Constraints:<br><br>   `1 <= arr.length <= 2  104`<br>   `0 <= arr[i] < 105`"""<br><br>    if not root:<br>        return 0<br>    if root.val < low:<br>        return self.rangeSumBST(root.right, low, high)<br>    if root.val  high:<br>        return self.rangeSumBST(root.left, low, high)<br>    return root.val + self.rangeSumBST(root.left, low, high) + self.rangeSumBST(root.right, low, high)

### DOC[3] (GROUND TRUTH) leetcode/leetcode_719.txt
> def smallestDistancePair(nums, k):<br>    """The distance of a pair of integers `a` and `b` is defined as the absolute difference between `a` and `b`.<br><br>Given an integer array `nums` and an integer `k`, return _the_ `kth` _smallest distance among all the pairs_ `nums[i]` _and_ `nums[j]` _where_ `0 <= i < j < nums.length`.<br><br>Example 1:<br><br>Input: nums = \[1,3,1\], k = 1<br>Output: 0<br>Explanation: Here are all the pairs:<br>(1,3) - 2<br>(1,1) - 0<br>(3,1) - 2<br>Then the 1st smallest distance pair is (1,1), and its distance is 0.<br><br>Example 2:<br><br>Input: nums = \[1,1,1\], k = 2<br>Output: 0<br><br>Example 3:<br><br>Input: nums = \[1,6,1\], k = 3<br>Output: 5<br><br>Constraints:<br><br>   `n == nums.length`<br>   `2 <= n <= 104`<br>   `0 <= nums[i] <= 106`<br>   `1 <= k <= n  (n - 1) / 2`"""<br><br>    nums.sort()<br>    low, high = 0, nums[-1] - nums[0]<br>    <br>    while low < high:<br>        mid = (low + high) // 2<br>        count, left = 0, 0<br><br>        for right in range(len(nums)):<br>            while nums[right] - nums[left]  mid:<br>                left += 1<br>            count += (right - left)<br><br>        if count < k:<br>            low = mid + 1<br>        else:<br>            high = mid<br>    <br>    return low

### DOC[4] (IRRELEVANT) leetcode/csn_python_train_106574.txt
> def FormattedTable(self, width=80, force_display=False, ml_delimiter=True,<br>                     color=True, display_header=True, columns=None):<br>    """Returns whole table, with whitespace padding and row delimiters.<br><br>    Args:<br>      width: An int, the max width we want the table to fit in.<br>      force_display: A bool, if set to True will display table when the table<br>          can't be made to fit to the width.<br>      ml_delimiter: A bool, if set to False will not display the multi-line<br>          delimiter.<br>      color: A bool. If true, display any colours in row.colour.<br>      display_header: A bool. If true, display header.<br>      columns: A list of str, show only columns with these names.<br><br>    Returns:<br>      A string.  The tabled output.<br><br>    Raises:<br>      TableError: Width too narrow to display table.<br>    """<br><br>    def _FilteredCols():<br>      """Returns list of column names to display."""<br>      if not columns:<br>        return self._Header().values<br>      return [col for col in self._Header().values if col in columns]<br><br>    # Largest is the biggest data entry in a column.<br>    largest = {}<br>    # Smallest is the same as above but with linewrap i.e. largest unbroken<br>    # word in the data stream.<br>    smallest = {}<br>    # largest == smallest for a column with a single word of data.<br>    # Initialise largest and smallest for all columns.<br>    for key in _FilteredCols():<br>      largest[key] = 0<br>      smallest[key] = 0<br><br>    # Find the largest and smallest values.<br>    # Include Title line in equation.<br>    # pylint: disable=E1103<br>    for row in self._table:<br>      for key, value in row.items():<br>        if key not in _FilteredCols():<br>          continue<br>        # Convert lists into a string.<br>        if isinstance(value, list):<br>          value = ', '.join(value)<br>        value = terminal.StripAnsiText(value)<br>        largest[key] = max(len(value), largest[key])<br>        smallest[key] = max(self._SmallestColSize(value), smallest[key])<br>    # pylint: enable=E1103<br><br>    min_total_width = 0<br>    multi_word = []<br>    # Bump up the size of each column to include minimum pad.<br>    # Find all columns that can be wrapped (multi-line).<br>    # And the minimum width needed to display all columns (even if wrapped).<br>    for key in _FilteredCols():<br>      # Each column is bracketed by a space on both sides.<br>      # So increase size required accordingly.<br>      largest[key] += 2<br>      smallest[key] += 2<br>      min_total_width += smallest[key]<br>      # If column contains data that 'could' be split over multiple lines.<br>      if largest[key] != smallest[key]:<br>        multi_word.append(key)<br><br>    # Check if we have enough space to display the table.<br>    if min_total_width  width and not force_display:<br>      raise TableError('Width too narrow to display table.')<br><br>    # We have some columns that may need wrapping over several lines.<br>    if multi_word:<br>      # Find how much space is left over for the wrapped columns to use.<br>      # Also find how much space we would need if they were not wrapped.<br>      # These are 'spare_width' and 'desired_width' respectively.<br>      desired_width = 0<br>      spare_width = width - min_total_width<br>      for key in multi_word:<br>        spare_width += smallest[key]<br>        desired_width += largest[key]<br><br>      # Scale up the space we give each wrapped column.<br>      # Proportional to its size relative to 'desired_width' for all columns.<br>      # Rinse and repeat if we changed the wrap list in this iteration.<br>      # Once done we will have a list of columns that definitely need wrapping.<br>      done = False<br>      while not done:<br>        done = True<br>        for key in multi_word:<br>          # If we scale past the desired width for this particular column,<br>          # then give it its desired width and remove it from the wrapped list.<br>          if (largest[key] <=<br>              round((largest[key] / float(desired_width))  spare_width)):<br>            smallest[key] = largest[key]<br>            multi_word.remove(key)<br>            spare_width -= smallest[key]<br>            desired_width -= largest[key]<br>            done = False<br>          # If we scale below the minimum width for this particular column,<br>          # then leave it at its minimum and remove it from the wrapped list.<br>          elif (smallest[key] =<br>                round((largest[key] / float(desired_width))  spare_width)):<br>            multi_word.remove(key)<br>            spare_width -= smallest[key]<br>            desired_width -= largest[key]<br>            done = False<br><br>      # Repeat the scaling algorithm with the final wrap list.<br>      # This time we assign the extra column space by increasing 'smallest'.<br>      for key in multi_word:<br>        smallest[key] = int(round((largest[key] / float(desired_width))<br>                                   spare_width))<br><br>    total_width = 0<br>    row_count = 0<br>    result_dict = {}<br>    # Format the header lines and add to result_dict.<br>    # Find what the total width will be and use this for the ruled lines.<br>    # Find how many rows are needed for the most wrapped line (row_count).<br>    for key in _FilteredCols():<br>      result_dict[key] = self._TextJustify(key, smallest[key])<br>      if len(result_dict[key])  row_count:<br>        row_count = len(result_dict[key])<br>      total_width += smallest[key]<br><br>    # Store header in header_list, working down the wrapped rows.<br>    header_list = []<br>    for row_idx in range(row_count):<br>      for key in _FilteredCols():<br>        try:<br>          header_list.append(result_dict[key][row_idx])<br>        except IndexError:<br>          # If no value than use whitespace of equal size.<br>          header_list.append(' 'smallest[key])<br>      header_list.append('\n')<br><br>    # Format and store the body lines<br>    result_dict = {}<br>    body_list = []<br>    # We separate multi line rows with a single line delimiter.<br>    prev_muli_line = False<br>    # Unless it is the first line in which there is already the header line.<br>    first_line = True<br>    for row in self:<br>      row_count = 0<br>      for key, value in row.items():<br>        if key not in _FilteredCols():<br>          continue<br>        # Convert field contents to a string.<br>        if isinstance(value, list):<br>          value = ', '.join(value)<br>        # Store results in result_dict and take note of wrapped line count.<br>        result_dict[key] = self._TextJustify(value, smallest[key])<br>        if len(result_dict[key])  row_count:<br>          row_count = len(result_dict[key])<br><br>      if row_count  1:<br>        prev_muli_line = True<br>      # If current or prior line was multi-line then include delimiter.<br>      if not first_line and prev_muli_line and ml_delimiter:<br>        body_list.append('-'total_width + '\n')<br>        if row_count == 1:<br>          # Our current line was not wrapped, so clear flag.<br>          prev_muli_line = False<br><br>      row_list = []<br>      for row_idx in range(row_count):<br>        for key in _FilteredCols():<br>          try:<br>            row_list.append(result_dict[key][row_idx])<br>          except IndexError:<br>            # If no value than use whitespace of equal size.<br>            row_list.append(' 'smallest[key])<br>        row_list.append('\n')<br><br>      if color and row.color is not None:<br>        body_list.append(<br>            terminal.AnsiText(''.join(row_list)[:-1],<br>                              command_list=row.color))<br>        body_list.append('\n')<br>      else:<br>        body_list.append(''.join(row_list))<br><br>      first_line = False<br><br>    header = ''.join(header_list) + '='total_width<br>    if color and self._Header().color is not None:<br>      header = terminal.AnsiText(header, command_list=self._Header().color)<br>    # Add double line delimiter between header and main body.<br>    if display_header:<br>      return '%s\n%s' % (header, ''.join(body_list))<br>    return '%s' % ''.join(body_list)

### DOC[5] (IRRELEVANT) leetcode/csn_python_train_107218.txt
> def find_span_binsearch(degree, knot_vector, num_ctrlpts, knot, kwargs):<br>    """ Finds the span of the knot over the input knot vector using binary search.<br><br>    Implementation of Algorithm A2.1 from The NURBS Book by Piegl & Tiller.<br><br>    The NURBS Book states that the knot span index always starts from zero, i.e. for a knot vector [0, 0, 1, 1];<br>    if FindSpan returns 1, then the knot is between the interval [0, 1).<br><br>    :param degree: degree, :math:`p`<br>    :type degree: int<br>    :param knot_vector: knot vector, :math:`U`<br>    :type knot_vector: list, tuple<br>    :param num_ctrlpts: number of control points, :math:`n + 1`<br>    :type num_ctrlpts: int<br>    :param knot: knot or parameter, :math:`u`<br>    :type knot: float<br>    :return: knot span<br>    :rtype: int<br>    """<br>    # Get tolerance value<br>    tol = kwargs.get('tol', 10e-6)<br><br>    # In The NURBS Book; number of knots = m + 1, number of control points = n + 1, p = degree<br>    # All knot vectors should follow the rule: m = p + n + 1<br>    n = num_ctrlpts - 1<br>    if abs(knot_vector[n + 1] - knot) <= tol:<br>        return n<br><br>    # Set max and min positions of the array to be searched<br>    low = degree<br>    high = num_ctrlpts<br><br>    # The division could return a float value which makes it impossible to use as an array index<br>    mid = (low + high) / 2<br>    # Direct int casting would cause numerical errors due to discarding the significand figures (digits after the dot)<br>    # The round function could return unexpected results, so we add the floating point with some small number<br>    # This addition would solve the issues caused by the division operation and how Python stores float numbers.<br>    # E.g. round(13/2) = 6 (expected to see 7)<br>    mid = int(round(mid + tol))<br><br>    # Search for the span<br>    while (knot < knot_vector[mid]) or (knot = knot_vector[mid + 1]):<br>        if knot < knot_vector[mid]:<br>            high = mid<br>        else:<br>            low = mid<br>        mid = int((low + high) / 2)<br><br>    return mid


## Ground Truth

### GROUND TRUTH 0, ranked 0, leetcode/leetcode_378.txt
> import heapq<br>    """Given an `n x n` `matrix` where each of the rows and columns is sorted in ascending order, return _the_ `kth` _smallest element in the matrix_.<br><br>Note that it is the `kth` smallest element in the sorted order, not the `kth` distinct element.<br><br>You must find a solution with a memory complexity better than `O(n2)`.<br><br>Example 1:<br><br>Input: matrix = \[\[1,5,9\],\[10,11,13\],\[12,13,15\]\], k = 8<br>Output: 13<br>Explanation: The elements in the matrix are \[1,5,9,10,11,12,13,13,15\], and the 8th smallest number is 13<br><br>Example 2:<br><br>Input: matrix = \[\[-5\]\], k = 1<br>Output: -5<br><br>Constraints:<br><br>   `n == matrix.length == matrix[i].length`<br>   `1 <= n <= 300`<br>   `-109 <= matrix[i][j] <= 109`<br>   All the rows and columns of `matrix` are guaranteed to be sorted in non-decreasing order.<br>   `1 <= k <= n2`<br><br>Follow up:<br><br>   Could you solve the problem with a constant memory (i.e., `O(1)` memory complexity)?<br>   Could you solve the problem in `O(n)` time complexity? The solution may be too advanced for an interview but you may find reading [this paper](http://www.cse.yorku.ca/~andy/pubs/X+Y.pdf) fun."""<br><br><br>def kthSmallest(matrix, k):<br>    n = len(matrix)<br>    min_heap = []<br><br>    for i in range(n):<br>        heapq.heappush(min_heap, (matrix[i][0], i, 0))<br><br>    while k  1:<br>        val, row, col = heapq.heappop(min_heap)<br><br>        if col + 1 < n:<br>            heapq.heappush(min_heap, (matrix[row][col + 1], row, col + 1))<br><br>        k -= 1<br><br>    return min_heap[0][0]

### GROUND TRUTH 1, ranked 2, leetcode/leetcode_719.txt
> def smallestDistancePair(nums, k):<br>    """The distance of a pair of integers `a` and `b` is defined as the absolute difference between `a` and `b`.<br><br>Given an integer array `nums` and an integer `k`, return _the_ `kth` _smallest distance among all the pairs_ `nums[i]` _and_ `nums[j]` _where_ `0 <= i < j < nums.length`.<br><br>Example 1:<br><br>Input: nums = \[1,3,1\], k = 1<br>Output: 0<br>Explanation: Here are all the pairs:<br>(1,3) - 2<br>(1,1) - 0<br>(3,1) - 2<br>Then the 1st smallest distance pair is (1,1), and its distance is 0.<br><br>Example 2:<br><br>Input: nums = \[1,1,1\], k = 2<br>Output: 0<br><br>Example 3:<br><br>Input: nums = \[1,6,1\], k = 3<br>Output: 5<br><br>Constraints:<br><br>   `n == nums.length`<br>   `2 <= n <= 104`<br>   `0 <= nums[i] <= 106`<br>   `1 <= k <= n  (n - 1) / 2`"""<br><br>    nums.sort()<br>    low, high = 0, nums[-1] - nums[0]<br>    <br>    while low < high:<br>        mid = (low + high) // 2<br>        count, left = 0, 0<br><br>        for right in range(len(nums)):<br>            while nums[right] - nums[left]  mid:<br>                left += 1<br>            count += (right - left)<br><br>        if count < k:<br>            low = mid + 1<br>        else:<br>            high = mid<br>    <br>    return low

### GROUND TRUTH 2, ranked 53, leetcode/leetcode_786.txt
> import heapq<br>    """You are given a sorted integer array `arr` containing `1` and prime numbers, where all the integers of `arr` are unique. You are also given an integer `k`.<br><br>For every `i` and `j` where `0 <= i < j < arr.length`, we consider the fraction `arr[i] / arr[j]`.<br><br>Return _the_ `kth` _smallest fraction considered_. Return your answer as an array of integers of size `2`, where `answer[0] == arr[i]` and `answer[1] == arr[j]`.<br><br>Example 1:<br><br>Input: arr = \[1,2,3,5\], k = 3<br>Output: \[2,5\]<br>Explanation: The fractions to be considered in sorted order are:<br>1/5, 1/3, 2/5, 1/2, 3/5, and 2/3.<br>The third fraction is 2/5.<br><br>Example 2:<br><br>Input: arr = \[1,7\], k = 1<br>Output: \[1,7\]<br><br>Constraints:<br><br>   `2 <= arr.length <= 1000`<br>   `1 <= arr[i] <= 3  104`<br>   `arr[0] == 1`<br>   `arr[i]` is a prime number for `i  0`.<br>   All the numbers of `arr` are unique and sorted in strictly increasing order.<br>   `1 <= k <= arr.length  (arr.length - 1) / 2`<br><br>Follow up: Can you solve the problem with better than `O(n2)` complexity?"""<br><br>from typing import List<br><br>def kthSmallestPrimeFraction(arr: List[int], k: int) - List[int]:<br>    pq = [(arr[i] / arr[j], i, j) for j in range(len(arr) - 1, 0, -1)]<br>    heapq.heapify(pq)<br>    for _ in range(k - 1):<br>        _, i, j = heapq.heappop(pq)<br>        if j != i + 1:<br>            heapq.heappush(pq, (arr[i] / arr[j - 1], i, j - 1))<br>    return [arr[pq[0][1]], arr[pq[0][2]]]
